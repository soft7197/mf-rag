{
    "Gson-7": {
        "function_num": 2,
        "functions": [
            {
                "path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
                "start_loc": 939,
                "end_loc": 980,
                "buggy_function": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                "fixed_function": "  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                "comment": "  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n",
                "normalized_body": [
                    "public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\\\"Expected a long but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(\\\"Expected a long but was \\\" + peekedString + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\\\"Expected a long but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(\\\"Expected a long but was \\\" + peekedString + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                    ],
                    [
                        0.9943128824234009,
                        "public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(\\\"Expected a double but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(\\\"JSON forbids NaN and infinities: \\\" + result + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                    ],
                    [
                        0.9853337407112122,
                        "private static Date parse(String date, ParsePosition pos) throws ParseException { Exception fail = null; try { int offset = pos.getIndex(); int year = parseInt(date, offset, offset += 4); if (checkOffset(date, offset, '-')) { offset += 1; } int month = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '-')) { offset += 1; } int day = parseInt(date, offset, offset += 2); int hour = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; if (checkOffset(date, offset, 'T')) { hour = parseInt(date, offset += 1, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } minutes = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } if (date.length() > offset) { char c = date.charAt(offset); if (c != 'Z' && c != '+' && c != '-') { seconds = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '.')) { milliseconds = parseInt(date, offset += 1, offset += 3); } } } } String timezoneId; if (date.length() <= offset) { throw new IllegalArgumentException(\\\"No time zone indicator\\\"); } char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset); timezoneId = GMT_ID + timezoneOffset; offset += timezoneOffset.length(); } else if (timezoneIndicator == 'Z') { timezoneId = GMT_ID; offset += 1; } else { throw new IndexOutOfBoundsException(\\\"Invalid time zone indicator \\\" + timezoneIndicator); } TimeZone timezone = TimeZone.getTimeZone(timezoneId); if (!timezone.getID().equals(timezoneId)) { throw new IndexOutOfBoundsException(); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); pos.setIndex(offset); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { fail = e; } catch (NumberFormatException e) { fail = e; } catch (IllegalArgumentException e) { fail = e; } String input = (date == null) ? null : ('\\\"' + date + \\\"'\\\"); throw new ParseException(\\\"Failed to parse date [\\\" + input + \\\"]: \\\" + fail.getMessage(), pos.getIndex()); }"
                    ],
                    [
                        0.9849224090576172,
                        "public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(\\\"Expected an int but was \\\" + peekedLong + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\\\"Expected an int but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(\\\"Expected an int but was \\\" + peekedString + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                    ],
                    [
                        0.9822618365287781,
                        "public void testNullSafe() { TypeAdapter<Person> typeAdapter = new TypeAdapter<Person>() { @Override public Person read(JsonReader in) throws IOException { String[] values = in.nextString().split(\\\",\\\"); return new Person(values[0], Integer.parseInt(values[1])); } public void write(JsonWriter out, Person person) throws IOException { out.value(person.name + \\\",\\\" + person.age); } }; Gson gson = new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter).create(); Truck truck = new Truck(); truck.horsePower = 1.0D; truck.passengers = new ArrayList<Person>(); truck.passengers.add(null); truck.passengers.add(new Person(\\\"jesse\\\", 30)); try { gson.toJson(truck, Truck.class); fail(); } catch (NullPointerException expected) { } String json = \\\"{horsePower:1.0,passengers:[null,'jesse,30']}\\\"; try { gson.fromJson(json, Truck.class); fail(); } catch (JsonSyntaxException expected) { } gson = new GsonBuilder().registerTypeAdapter(Person.class, typeAdapter.nullSafe()).create(); assertEquals(\\\"{\\\\\"horsePower\\\\\":1.0,\\\\\"passengers\\\\\":[null,\\\\\"jesse,30\\\\\"]}\\\", gson.toJson(truck, Truck.class)); truck = gson.fromJson(json, Truck.class); assertEquals(1.0D, truck.horsePower); assertNull(truck.passengers.get(0)); assertEquals(\\\"jesse\\\", truck.passengers.get(1).name); }"
                    ],
                    [
                        0.9800980687141418,
                        "@Override public void write(JsonWriter out, Map<K, V> map) throws IOException { if (map == null) { out.nullValue(); return; } if (!complexMapKeySerialization) { out.beginObject(); for (Map.Entry<K, V> entry : map.entrySet()) { out.name(String.valueOf(entry.getKey())); valueTypeAdapter.write(out, entry.getValue()); } out.endObject(); return; } boolean hasComplexKeys = false; List<JsonElement> keys = new ArrayList<JsonElement>(map.size()); List<V> values = new ArrayList<V>(map.size()); for (Map.Entry<K, V> entry : map.entrySet()) { JsonElement keyElement = keyTypeAdapter.toJsonTree(entry.getKey()); keys.add(keyElement); values.add(entry.getValue()); hasComplexKeys |= keyElement.isJsonArray() || keyElement.isJsonObject(); } if (hasComplexKeys) { out.beginArray(); for (int i = 0; i < keys.size(); i++) { out.beginArray(); Streams.write(keys.get(i), out); valueTypeAdapter.write(out, values.get(i)); out.endArray(); } out.endArray(); } else { out.beginObject(); for (int i = 0; i < keys.size(); i++) { JsonElement keyElement = keys.get(i); out.name(keyToString(keyElement)); valueTypeAdapter.write(out, values.get(i)); } out.endObject(); } }"
                    ],
                    [
                        0.9795671105384827,
                        "public static Date parse(String date, ParsePosition pos) throws ParseException { Exception fail = null; try { int offset = pos.getIndex(); int year = parseInt(date, offset, offset += 4); if (checkOffset(date, offset, '-')) { offset += 1; } int month = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '-')) { offset += 1; } int day = parseInt(date, offset, offset += 2); int hour = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; boolean hasT = checkOffset(date, offset, 'T'); if (!hasT && (date.length() <= offset)) { Calendar calendar = new GregorianCalendar(year, month - 1, day); pos.setIndex(offset); return calendar.getTime(); } if (hasT) { hour = parseInt(date, offset += 1, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } minutes = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } if (date.length() > offset) { char c = date.charAt(offset); if (c != 'Z' && c != '+' && c != '-') { seconds = parseInt(date, offset, offset += 2); if (seconds > 59 && seconds < 63) seconds = 59; if (checkOffset(date, offset, '.')) { offset += 1; int endOffset = indexOfNonDigit(date, offset + 1); int parseEndOffset = Math.min(endOffset, offset + 3); int fraction = parseInt(date, offset, parseEndOffset); switch(parseEndOffset - offset) { case 2: milliseconds = fraction * 10; break; case 1: milliseconds = fraction * 100; break; default: milliseconds = fraction; } offset = endOffset; } } } } if (date.length() <= offset) { throw new IllegalArgumentException(\\\"No time zone indicator\\\"); } TimeZone timezone = null; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == 'Z') { timezone = TIMEZONE_UTC; offset += 1; } else if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset); timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \\\"00\\\"; offset += timezoneOffset.length(); if (\\\"+0000\\\".equals(timezoneOffset) || \\\"+00:00\\\".equals(timezoneOffset)) { timezone = TIMEZONE_UTC; } else { String timezoneId = \\\"GMT\\\" + timezoneOffset; timezone = TimeZone.getTimeZone(timezoneId); String act = timezone.getID(); if (!act.equals(timezoneId)) { String cleaned = act.replace(\\\":\\\", \\\"\\\"); if (!cleaned.equals(timezoneId)) { throw new IndexOutOfBoundsException(\\\"Mismatching time zone indicator: \\\" + timezoneId + \\\" given, resolves to \\\" + timezone.getID()); } } } } else { throw new IndexOutOfBoundsException(\\\"Invalid time zone indicator '\\\" + timezoneIndicator + \\\"'\\\"); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); pos.setIndex(offset); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { fail = e; } catch (NumberFormatException e) { fail = e; } catch (IllegalArgumentException e) { fail = e; } String input = (date == null) ? null : ('\\\"' + date + \\\"'\\\"); String msg = fail.getMessage(); if (msg == null || msg.isEmpty()) { msg = \\\"(\\\" + fail.getClass().getName() + \\\")\\\"; } ParseException ex = new ParseException(\\\"Failed to parse date [\\\" + input + \\\"]: \\\" + msg, pos.getIndex()); ex.initCause(fail); throw ex; }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedLongKeys"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMapDeserializationWithUnquotedLongKeys() {\n    long longKey = 9876543210L;\n    String json = String.format(\"{%d:\\\"456\\\"}\", longKey);\n    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();\n    Map<Long, String> map = gson.fromJson(json, typeOfMap);\n    assertEquals(1, map.size());\n    assertTrue(map.containsKey(longKey));\n    assertEquals(\"456\", map.get(longKey));\n  }\n```\n#Error message: com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tat com.google.gson.Gson.fromJson(Gson.java:892)  throw new JsonSyntaxException(e);\n\tat com.google.gson.Gson.fromJson(Gson.java:845)  T object = (T) fromJson(jsonReader, typeOfT);\n\tat com.google.gson.Gson.fromJson(Gson.java:794)  T target = (T) fromJson(reader, typeOfT);\n\tat com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedLongKeys(MapTest.java:192)  Map<Long, String> map = gson.fromJson(json, typeOfMap);\nCaused by: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tat com.google.gson.stream.JsonReader.nextLong(JsonReader.java:965)  throw new IllegalStateException(\"Expected a long but was \" + peek()          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n\tat com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)  return delegate.read(in);\n\tat com.google.gson.Gson.fromJson(Gson.java:880)  T object = typeAdapter.read(reader);\n\t... 37 more\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        } else {\n            peekedString = nextUnquotedValue();\n        }\n        try {\n            long result = Long.parseLong(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a long but was \" + peek()\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            long result = Long.parseLong(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a long but was \" + peek()\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString);\n    long result = (long) asDouble;\n    if (result != asDouble) { \n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\npublic long nextLong() throws IOException {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  }\n\n  if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      peekedString = nextUnquotedValue();\n    }\n    \n    try {\n      long result = Long.parseLong(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a double below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a long but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  long result = (long) asDouble;\n  if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n    throw new NumberFormatException(\"Expected a long but was \" + peekedString\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}\n",
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n\n        try {\n            long result = Long.parseLong(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    }\n\n    if (p == PEEKED_BUFFERED) {\n        double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n        long result = (long) asDouble;\n        if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n            throw new NumberFormatException(\"Expected a long but was \" + peekedString\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peekedString = null;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    throw new IllegalStateException(\"Expected a long but was \" + peek()\n        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}\n",
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        \n        try {\n            long result = Long.parseLong(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\n  public long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        long result = Long.parseLong(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a long but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n"
                        ],
                        "plausible_patches": [
                            "\npublic long nextLong() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        } else {\n            peekedString = nextUnquotedValue();\n        }\n        try {\n            long result = Long.parseLong(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a long but was \" + peek()\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n        throw new NumberFormatException(\"Expected a long but was \" + peekedString\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
                "start_loc": 1161,
                "end_loc": 1208,
                "buggy_function": "  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                "fixed_function": "  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                "comment": "  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n",
                "normalized_body": [
                    "public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(\\\"Expected an int but was \\\" + peekedLong + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\\\"Expected an int but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(\\\"Expected an int but was \\\" + peekedString + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException(\\\"Expected an int but was \\\" + peekedLong + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\\\"Expected an int but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException(\\\"Expected an int but was \\\" + peekedString + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                    ],
                    [
                        0.9893195629119873,
                        "int doPeek() throws IOException { int peekStack = stack[stackSize - 1]; if (peekStack == JsonScope.EMPTY_ARRAY) { stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY; } else if (peekStack == JsonScope.NONEMPTY_ARRAY) { int c = nextNonWhitespace(true); switch(c) { case ']': return peeked = PEEKED_END_ARRAY; case ';': checkLenient(); case ',': break; default: throw syntaxError(\\\"Unterminated array\\\"); } } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) { stack[stackSize - 1] = JsonScope.DANGLING_NAME; if (peekStack == JsonScope.NONEMPTY_OBJECT) { int c = nextNonWhitespace(true); switch(c) { case '}': return peeked = PEEKED_END_OBJECT; case ';': checkLenient(); case ',': break; default: throw syntaxError(\\\"Unterminated object\\\"); } } int c = nextNonWhitespace(true); switch(c) { case '\\\"': return peeked = PEEKED_DOUBLE_QUOTED_NAME; case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED_NAME; case '}': if (peekStack != JsonScope.NONEMPTY_OBJECT) { return peeked = PEEKED_END_OBJECT; } else { throw syntaxError(\\\"Expected name\\\"); } default: checkLenient(); pos--; if (isLiteral((char) c)) { return peeked = PEEKED_UNQUOTED_NAME; } else { throw syntaxError(\\\"Expected name\\\"); } } } else if (peekStack == JsonScope.DANGLING_NAME) { stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT; int c = nextNonWhitespace(true); switch(c) { case ':': break; case '=': checkLenient(); if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { pos++; } break; default: throw syntaxError(\\\"Expected ':'\\\"); } } else if (peekStack == JsonScope.EMPTY_DOCUMENT) { if (lenient) { consumeNonExecutePrefix(); } stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT; } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) { int c = nextNonWhitespace(false); if (c == -1) { return peeked = PEEKED_EOF; } else { checkLenient(); pos--; } } else if (peekStack == JsonScope.CLOSED) { throw new IllegalStateException(\\\"JsonReader is closed\\\"); } int c = nextNonWhitespace(true); switch(c) { case ']': if (peekStack == JsonScope.EMPTY_ARRAY) { return peeked = PEEKED_END_ARRAY; } case ';': case ',': if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) { checkLenient(); pos--; return peeked = PEEKED_NULL; } else { throw syntaxError(\\\"Unexpected value\\\"); } case '\\'': checkLenient(); return peeked = PEEKED_SINGLE_QUOTED; case '\\\"': return peeked = PEEKED_DOUBLE_QUOTED; case '[': return peeked = PEEKED_BEGIN_ARRAY; case '{': return peeked = PEEKED_BEGIN_OBJECT; default: pos--; } int result = peekKeyword(); if (result != PEEKED_NONE) { return result; } result = peekNumber(); if (result != PEEKED_NONE) { return result; } if (!isLiteral(buffer[pos])) { throw syntaxError(\\\"Expected value\\\"); } checkLenient(); return peeked = PEEKED_UNQUOTED; }"
                    ],
                    [
                        0.9854849576950073,
                        "private static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); int capacity = \\\"yyyy-MM-ddThh:mm:ss\\\".length(); capacity += millis ? \\\".sss\\\".length() : 0; capacity += tz.getRawOffset() == 0 ? \\\"Z\\\".length() : \\\"+hh:mm\\\".length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), \\\"yyyy\\\".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.MONTH) + 1, \\\"MM\\\".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \\\"dd\\\".length()); formatted.append('T'); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \\\"hh\\\".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.MINUTE), \\\"mm\\\".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.SECOND), \\\"ss\\\".length()); if (millis) { formatted.append('.'); padInt(formatted, calendar.get(Calendar.MILLISECOND), \\\"sss\\\".length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset < 0 ? '-' : '+'); padInt(formatted, hours, \\\"hh\\\".length()); formatted.append(':'); padInt(formatted, minutes, \\\"mm\\\".length()); } else { formatted.append('Z'); } return formatted.toString(); }"
                    ],
                    [
                        0.9853624701499939,
                        "public static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); int capacity = \\\"yyyy-MM-ddThh:mm:ss\\\".length(); capacity += millis ? \\\".sss\\\".length() : 0; capacity += tz.getRawOffset() == 0 ? \\\"Z\\\".length() : \\\"+hh:mm\\\".length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), \\\"yyyy\\\".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.MONTH) + 1, \\\"MM\\\".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \\\"dd\\\".length()); formatted.append('T'); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \\\"hh\\\".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.MINUTE), \\\"mm\\\".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.SECOND), \\\"ss\\\".length()); if (millis) { formatted.append('.'); padInt(formatted, calendar.get(Calendar.MILLISECOND), \\\"sss\\\".length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset < 0 ? '-' : '+'); padInt(formatted, hours, \\\"hh\\\".length()); formatted.append(':'); padInt(formatted, minutes, \\\"mm\\\".length()); } else { formatted.append('Z'); } return formatted.toString(); }"
                    ],
                    [
                        0.9849374890327454,
                        "public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException(\\\"Expected a double but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException(\\\"JSON forbids NaN and infinities: \\\" + result + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                    ],
                    [
                        0.9849224090576172,
                        "public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\\\"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException(\\\"Expected a long but was \\\" + peek() + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException(\\\"Expected a long but was \\\" + peekedString + \\\" at line \\\" + getLineNumber() + \\\" column \\\" + getColumnNumber() + \\\" path \\\" + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; }"
                    ],
                    [
                        0.9786162972450256,
                        "public static UnsafeAllocator create() { try { Class<?> unsafeClass = Class.forName(\\\"sun.misc.Unsafe\\\"); Field f = unsafeClass.getDeclaredField(\\\"theUnsafe\\\"); f.setAccessible(true); final Object unsafe = f.get(null); final Method allocateInstance = unsafeClass.getMethod(\\\"allocateInstance\\\", Class.class); return new UnsafeAllocator() { @Override @SuppressWarnings(\\\"unchecked\\\") public <T> T newInstance(Class<T> c) throws Exception { return (T) allocateInstance.invoke(unsafe, c); } }; } catch (Exception ignored) { } try { Method getConstructorId = ObjectStreamClass.class.getDeclaredMethod(\\\"getConstructorId\\\", Class.class); getConstructorId.setAccessible(true); final int constructorId = (Integer) getConstructorId.invoke(null, Object.class); final Method newInstance = ObjectStreamClass.class.getDeclaredMethod(\\\"newInstance\\\", Class.class, int.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(\\\"unchecked\\\") public <T> T newInstance(Class<T> c) throws Exception { return (T) newInstance.invoke(null, c, constructorId); } }; } catch (Exception ignored) { } try { final Method newInstance = ObjectInputStream.class.getDeclaredMethod(\\\"newInstance\\\", Class.class, Class.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings(\\\"unchecked\\\") public <T> T newInstance(Class<T> c) throws Exception { return (T) newInstance.invoke(null, c, Object.class); } }; } catch (Exception ignored) { } return new UnsafeAllocator() { @Override public <T> T newInstance(Class<T> c) { throw new UnsupportedOperationException(\\\"Cannot allocate \\\" + c); } }; }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedIntegerKeys",
                    "com.google.gson.stream.JsonReaderTest::testPeekingUnquotedStringsPrefixedWithIntegers"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMapDeserializationWithUnquotedIntegerKeys() {\n    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();\n    Map<Integer, String> map = gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\n    assertEquals(1, map.size());\n    assertTrue(map.containsKey(123));\n    assertEquals(\"456\", map.get(123));\n  }\n```\n#Error message: com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $.\n\tat com.google.gson.Gson.fromJson(Gson.java:892)  throw new JsonSyntaxException(e);\n\tat com.google.gson.Gson.fromJson(Gson.java:845)  T object = (T) fromJson(jsonReader, typeOfT);\n\tat com.google.gson.Gson.fromJson(Gson.java:794)  T target = (T) fromJson(reader, typeOfT);\n\tat com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedIntegerKeys(MapTest.java:172)  Map<Integer, String> map = gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\nCaused by: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $.\n\tat com.google.gson.stream.JsonReader.nextInt(JsonReader.java:1193)  throw new IllegalStateException(\"Expected an int but was \" + peek()          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n\tat com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)  return delegate.read(in);\n\tat com.google.gson.Gson.fromJson(Gson.java:880)  T object = typeAdapter.read(reader);\n\t... 37 more\n \n#Test method 2:\n```java\n  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\n    JsonReader reader = new JsonReader(reader(\"[12.34e5x]\"));\n    reader.setLenient(true);\n    reader.beginArray();\n    assertEquals(STRING, reader.peek());\n    try {\n      reader.nextInt();\n      fail();\n    } catch (NumberFormatException expected) {\n    }\n    assertEquals(\"12.34e5x\", reader.nextString());\n  }\n```\n#Error message: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $[0]\n\tat com.google.gson.stream.JsonReader.nextInt(JsonReader.java:1193)  throw new IllegalStateException(\"Expected an int but was \" + peek()          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n\tat com.google.gson.stream.JsonReaderTest.testPeekingUnquotedStringsPrefixedWithIntegers(JsonReaderTest.java:502)  reader.nextInt();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG || p == PEEKED_NUMBER) {\n        result = (int) peekedLong;\n        if (peekedLong != result) {\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : (p == PEEKED_DOUBLE_QUOTED ? '\"' : ' '));\n        try {\n            result = Integer.parseInt(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected an int but was \" + peek()\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString);\n    result = (int) asDouble;\n    if (result != asDouble) {\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n        result = (int) peekedLong;\n        if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n                    + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Integer.parseInt(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else if (p != PEEKED_BUFFERED) {\n        throw new IllegalStateException(\"Expected an int but was \" + peek()\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : (p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\0'));\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      } else {\n        peekedString = nextUnquotedValue();\n      }\n      \n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n        result = (int) peekedLong;\n        if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        } else if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        }\n        try {\n            result = Integer.parseInt(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected an int but was \" + peek()\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) {\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      p = PEEKED_BUFFERED;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      p = PEEKED_BUFFERED;\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n      p = PEEKED_BUFFERED;\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    try {\n      result = Integer.parseInt(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n    }\n\n    double asDouble = Double.parseDouble(peekedString);\n    result = (int) asDouble;\n    if (result != asDouble) {\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_UNQUOTED) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n        result = (int) peekedLong;\n        if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n                    + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        } else {\n            peekedString = nextUnquotedValue();\n        }\n        try {\n            result = Integer.parseInt(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected an int but was \" + peek()\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n        result = (int) peekedLong;\n        if (peekedLong != result) {\n            throw new NumberFormatException(\n                \"Expected an int but was \" + peekedLong \n                + \" at line \" + getLineNumber() + \" column \" \n                + getColumnNumber() + \" path \" + getPath()\n            );\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Integer.parseInt(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n        }\n    } else if (p == PEEKED_BUFFERED) {\n        peekedString = nextUnquotedValue();\n    } else {\n        throw new IllegalStateException(\n            \"Expected an int but was \" + peek() \n            + \" at line \" + getLineNumber() + \" column \" \n            + getColumnNumber() + \" path \" + getPath()\n        );\n    }\n\n    double asDouble = Double.parseDouble(peekedString);\n    result = (int) asDouble;\n    if (result != asDouble) {\n        throw new NumberFormatException(\n            \"Expected an int but was \" + peekedString \n            + \" at line \" + getLineNumber() + \" column \" \n            + getColumnNumber() + \" path \" + getPath()\n        );\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n        result = (int) peekedLong;\n        if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_UNQUOTED) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n        throw new IllegalStateException(\"Expected an int but was \" + peek()\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } catch (NumberFormatException ignored) {\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n"
                        ],
                        "plausible_patches": [
                            "\n  public int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n      result = (int) peekedLong;\n      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      } else {\n        peekedString = nextUnquotedValue();\n      }\n      \n      try {\n        result = Integer.parseInt(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a double below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected an int but was \" + peek()\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n",
                            "\npublic int nextInt() throws IOException {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    int result;\n    if (p == PEEKED_LONG) {\n        result = (int) peekedLong;\n        if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n            throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n                + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER || p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_NUMBER) {\n            peekedString = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        } else if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        }\n        try {\n            result = Integer.parseInt(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected an int but was \" + peek()\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n        throw new NumberFormatException(\"Expected an int but was \" + peekedString\n            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedLongKeys": {
                "path": "gson/src/test/java/com/google/gson/functional/MapTest.java",
                "function_name": "testMapDeserializationWithUnquotedLongKeys",
                "src": "  public void testMapDeserializationWithUnquotedLongKeys() {\n    long longKey = 9876543210L;\n    String json = String.format(\"{%d:\\\"456\\\"}\", longKey);\n    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();\n    Map<Long, String> map = gson.fromJson(json, typeOfMap);\n    assertEquals(1, map.size());\n    assertTrue(map.containsKey(longKey));\n    assertEquals(\"456\", map.get(longKey));\n  }",
                "error_msg": "com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tat com.google.gson.Gson.fromJson(Gson.java:892)\n\tat com.google.gson.Gson.fromJson(Gson.java:845)\n\tat com.google.gson.Gson.fromJson(Gson.java:794)\n\tat com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedLongKeys(MapTest.java:192)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tat com.google.gson.stream.JsonReader.nextLong(JsonReader.java:965)\n\tat com.google.gson.internal.bind.TypeAdapters$12.read(TypeAdapters.java:325)\n\tat com.google.gson.internal.bind.TypeAdapters$12.read(TypeAdapters.java:317)\n\tat com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)\n\tat com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter.read(MapTypeAdapterFactory.java:186)\n\tat com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter.read(MapTypeAdapterFactory.java:145)\n\tat com.google.gson.Gson.fromJson(Gson.java:880)\n\t... 37 more",
                "clean_error_msg": "com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tat com.google.gson.Gson.fromJson(Gson.java:892)  throw new JsonSyntaxException(e);\n\tat com.google.gson.Gson.fromJson(Gson.java:845)  T object = (T) fromJson(jsonReader, typeOfT);\n\tat com.google.gson.Gson.fromJson(Gson.java:794)  T target = (T) fromJson(reader, typeOfT);\n\tat com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedLongKeys(MapTest.java:192)  Map<Long, String> map = gson.fromJson(json, typeOfMap);\nCaused by: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tat com.google.gson.stream.JsonReader.nextLong(JsonReader.java:965)  throw new IllegalStateException(\"Expected a long but was \" + peek()          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n\tat com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)  return delegate.read(in);\n\tat com.google.gson.Gson.fromJson(Gson.java:880)  T object = typeAdapter.read(reader);\n\t... 37 more"
            },
            "com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedIntegerKeys": {
                "path": "gson/src/test/java/com/google/gson/functional/MapTest.java",
                "function_name": "testMapDeserializationWithUnquotedIntegerKeys",
                "src": "  public void testMapDeserializationWithUnquotedIntegerKeys() {\n    Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();\n    Map<Integer, String> map = gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\n    assertEquals(1, map.size());\n    assertTrue(map.containsKey(123));\n    assertEquals(\"456\", map.get(123));\n  }",
                "error_msg": "com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $.\n\tat com.google.gson.Gson.fromJson(Gson.java:892)\n\tat com.google.gson.Gson.fromJson(Gson.java:845)\n\tat com.google.gson.Gson.fromJson(Gson.java:794)\n\tat com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedIntegerKeys(MapTest.java:172)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $.\n\tat com.google.gson.stream.JsonReader.nextInt(JsonReader.java:1193)\n\tat com.google.gson.internal.bind.TypeAdapters$11.read(TypeAdapters.java:247)\n\tat com.google.gson.internal.bind.TypeAdapters$11.read(TypeAdapters.java:239)\n\tat com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)\n\tat com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter.read(MapTypeAdapterFactory.java:186)\n\tat com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter.read(MapTypeAdapterFactory.java:145)\n\tat com.google.gson.Gson.fromJson(Gson.java:880)\n\t... 37 more",
                "clean_error_msg": "com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $.\n\tat com.google.gson.Gson.fromJson(Gson.java:892)  throw new JsonSyntaxException(e);\n\tat com.google.gson.Gson.fromJson(Gson.java:845)  T object = (T) fromJson(jsonReader, typeOfT);\n\tat com.google.gson.Gson.fromJson(Gson.java:794)  T target = (T) fromJson(reader, typeOfT);\n\tat com.google.gson.functional.MapTest.testMapDeserializationWithUnquotedIntegerKeys(MapTest.java:172)  Map<Integer, String> map = gson.fromJson(\"{123:\\\"456\\\"}\", typeOfMap);\nCaused by: java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $.\n\tat com.google.gson.stream.JsonReader.nextInt(JsonReader.java:1193)  throw new IllegalStateException(\"Expected an int but was \" + peek()          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n\tat com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)  return delegate.read(in);\n\tat com.google.gson.Gson.fromJson(Gson.java:880)  T object = typeAdapter.read(reader);\n\t... 37 more"
            },
            "com.google.gson.stream.JsonReaderTest::testPeekingUnquotedStringsPrefixedWithIntegers": {
                "path": "gson/src/test/java/com/google/gson/stream/JsonReaderTest.java",
                "function_name": "testPeekingUnquotedStringsPrefixedWithIntegers",
                "src": "  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\n    JsonReader reader = new JsonReader(reader(\"[12.34e5x]\"));\n    reader.setLenient(true);\n    reader.beginArray();\n    assertEquals(STRING, reader.peek());\n    try {\n      reader.nextInt();\n      fail();\n    } catch (NumberFormatException expected) {\n    }\n    assertEquals(\"12.34e5x\", reader.nextString());\n  }",
                "error_msg": "java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $[0]\n\tat com.google.gson.stream.JsonReader.nextInt(JsonReader.java:1193)\n\tat com.google.gson.stream.JsonReaderTest.testPeekingUnquotedStringsPrefixedWithIntegers(JsonReaderTest.java:502)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.IllegalStateException: Expected an int but was STRING at line 1 column 2 path $[0]\n\tat com.google.gson.stream.JsonReader.nextInt(JsonReader.java:1193)  throw new IllegalStateException(\"Expected an int but was \" + peek()          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n\tat com.google.gson.stream.JsonReaderTest.testPeekingUnquotedStringsPrefixedWithIntegers(JsonReaderTest.java:502)  reader.nextInt();"
            }
        },
        "evaluation_done": true
    }
}