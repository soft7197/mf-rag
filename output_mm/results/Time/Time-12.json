{
    "Time-12": {
        "function_num": 4,
        "functions": [
            {
                "path": "src/main/java/org/joda/time/LocalDate.java",
                "start_loc": 206,
                "end_loc": 216,
                "buggy_function": "    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                "fixed_function": "    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                "comment": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n",
                "normalized_body": [
                    "public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\\\"The calendar must not be null\\\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate(yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public static LocalDate fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\\\"The calendar must not be null\\\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDate(yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH)); }"
                    ],
                    [
                        0.9460967183113098,
                        "public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\\\"The calendar must not be null\\\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime(yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); }"
                    ],
                    [
                        0.944290041923523,
                        "int[] isoFromFixed(long date) { int weekyear = gjYearFromFixed(date - 3); if (date >= fixedFromISO(weekyear + 1, 1, 1)) { weekyear += 1; } int weekOfWeekyear = (int) (div(date - fixedFromISO(weekyear, 1, 1), 7) + 1); int dayOfWeek = (int) amod(date, 7); return new int[] { weekyear, weekOfWeekyear, dayOfWeek }; }"
                    ],
                    [
                        0.934650182723999,
                        "long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) { long year_m1 = year - 1; long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100) + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth; if (monthOfYear > 2) { f += isLeapYear(year) ? -1 : -2; } return f; }"
                    ],
                    [
                        0.933952808380127,
                        "public void testDOW() { aDateTime = getADate(\\\"2002-04-12T00:00:00\\\"); bDateTime = getADate(\\\"2002-04-13T00:00:00\\\"); assertEquals(\\\"DOWM1a\\\", -1, cDayOfWeek.compare(aDateTime, bDateTime)); assertEquals(\\\"DOWP1a\\\", 1, cDayOfWeek.compare(bDateTime, aDateTime)); }"
                    ],
                    [
                        0.9191834330558777,
                        "public int getOffset(long instant) { long[] transitions = iTransitions; int i = Arrays.binarySearch(transitions, instant); if (i >= 0) { return iWallOffsets[i]; } i = ~i; if (i < transitions.length) { if (i > 0) { return iWallOffsets[i - 1]; } return 0; } if (iTailZone == null) { return iWallOffsets[i - 1]; } return iTailZone.getOffset(instant); }"
                    ],
                    [
                        0.9176622033119202,
                        "long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) { if (year == 0) { throw new IllegalArgumentException(\\\"Illegal year: \\\" + year); } int y = (year < 0) ? year + 1 : year; long y_m1 = y - 1; long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4) + div(367 * monthOfYear - 362, 12) + dayOfMonth; if (monthOfYear > 2) { f += isLeapYear(year) ? -1 : -2; } return f; }"
                    ],
                    [
                        0.9155000448226929,
                        "public boolean isSupported(DateTimeFieldType type) { if (type == null) { return false; } DurationFieldType durType = type.getDurationType(); if (DATE_DURATION_TYPES.contains(durType) || durType.getField(getChronology()).getUnitMillis() >= getChronology().days().getUnitMillis()) { return type.getField(getChronology()).isSupported(); } return false; }"
                    ],
                    [
                        0.9133590459823608,
                        "public int getStandardOffset(long instant) { long[] transitions = iTransitions; int i = Arrays.binarySearch(transitions, instant); if (i >= 0) { return iStandardOffsets[i]; } i = ~i; if (i < transitions.length) { if (i > 0) { return iStandardOffsets[i - 1]; } return 0; } if (iTailZone == null) { return iStandardOffsets[i - 1]; } return iTailZone.getStandardOffset(instant); }"
                    ]
                ],
                "directly_related_tests": [
                    "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero1",
                    "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero3"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero1(TestLocalDate_Constructors.java:109)  assertEquals(expected, LocalDate.fromCalendarFields(cal));\n \n#Test method 2:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero3(TestLocalDate_Constructors.java:117)  assertEquals(expected, LocalDate.fromCalendarFields(cal));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int year = calendar.get(Calendar.YEAR);\n        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDate(\n            year,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int year = calendar.get(Calendar.YEAR);\n        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDate(\n            year,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Convert to ISO 8601 standard for representing BC dates\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int year = calendar.get(Calendar.YEAR);\n    if (era == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n",
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int year = calendar.get(Calendar.YEAR);\n        int yearOfEra = (era == GregorianCalendar.BC) ? -(year - 1) : year;\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int year = calendar.get(Calendar.YEAR);\n    if (era == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n",
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n            yearOfEra = -yearOfEra + 1; // Convert BC year to negative, noting BC year is inclusive of 1\n        }\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -year + 1; // Convert BC year to negative\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n"
                        ],
                        "plausible_patches": [
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int year = calendar.get(Calendar.YEAR);\n        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDate(\n            year,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int year = calendar.get(Calendar.YEAR);\n    if (era == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n",
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int year = calendar.get(Calendar.YEAR);\n        int yearOfEra = (era == GregorianCalendar.BC) ? -(year - 1) : year;\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n            yearOfEra = -yearOfEra + 1; // Convert BC year to negative, noting BC year is inclusive of 1\n        }\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }\n",
                            "\npublic static LocalDate fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = -year + 1; // Convert BC year to negative\n    }\n    return new LocalDate(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH)\n    );\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/org/joda/time/LocalDate.java",
                "start_loc": 238,
                "end_loc": 249,
                "buggy_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n",
                "fixed_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            // handle years in era BC\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n",
                "comment": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n",
                "normalized_body": [
                    "@SuppressWarnings(\\\"deprecation\\\") public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\\\"The date must not be null\\\"); } return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@SuppressWarnings(\\\"deprecation\\\") public static LocalDate fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\\\"The date must not be null\\\"); } return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); }"
                    ],
                    [
                        0.9932919144630432,
                        "@SuppressWarnings(\\\"deprecation\\\") public static MonthDay fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\\\"The date must not be null\\\"); } return new MonthDay(date.getMonth() + 1, date.getDate()); }"
                    ],
                    [
                        0.9853010177612305,
                        "public static DateTimeFormatter dateHourMinuteSecondMillis() { if (dhmsl == null) { dhmsl = new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecondMillis()).toFormatter(); } return dhmsl; }"
                    ],
                    [
                        0.9849140048027039,
                        "public static DateTimeFormatter dateHourMinuteSecondFraction() { if (dhmsf == null) { dhmsf = new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecondFraction()).toFormatter(); } return dhmsf; }"
                    ],
                    [
                        0.9848156571388245,
                        "public static DateTimeFormatter dateParser() { if (dp == null) { DateTimeParser tOffset = new DateTimeFormatterBuilder().appendLiteral('T').append(offsetElement()).toParser(); dp = new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(tOffset).toFormatter(); } return dp; }"
                    ],
                    [
                        0.9833667874336243,
                        "public static DateTimeFormatter ordinalDateTimeNoMillis() { if (odtx == null) { odtx = new DateTimeFormatterBuilder().append(ordinalDate()).append(tTimeNoMillis()).toFormatter(); } return odtx; }"
                    ],
                    [
                        0.9830113053321838,
                        "public static DateTimeFormatter hourMinuteSecondFraction() { if (hmsf == null) { hmsf = new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).append(fractionElement()).toFormatter(); } return hmsf; }"
                    ],
                    [
                        0.9808202981948853,
                        "public static DateTimeFormatter basicDate() { if (bd == null) { bd = new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2).toFormatter(); } return bd; }"
                    ],
                    [
                        0.9806799292564392,
                        "public static String patternForStyle(String style, Locale locale) { DateTimeFormatter formatter = createFormatterForStyle(style); if (locale == null) { locale = Locale.getDefault(); } return ((StyleFormatter) formatter.getPrinter()).getPattern(locale); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n```\n\n```java\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n \n#Test method 2:\n```java\n    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 2: junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n \n#Test method 3:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n \n#Test method 4:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 4: junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n \n#Test method 5:\n```java\n    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 5: junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n \n#Test method 6:\n```java\n    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 6: junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n \n#Test method 7:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 7: junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n \n#Test method 8:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 8: junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n\n        int year = date.getYear() + 1900;\n        if (date.getYear() < 0) { // handle BC era dates\n            year = -(year - 1);\n        }\n        \n        // handle years in era BC\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (date.getYear() < 0) { // BC era\n            year = -(year - 1);\n        }\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (year <= 0) {\n            year -= 1;  // Adjust year for BC era\n        }\n        return new LocalDate(year, date.getMonth() + 1, date.getDate());\n    }\n",
                            "\n@SuppressWarnings(\"deprecation\")\npublic static LocalDate fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    int year = date.getYear() + 1900;\n    if (date instanceof GregorianCalendar) {\n        GregorianCalendar cal = (GregorianCalendar) date;\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = -(year - 1);\n        }\n    }\n    return new LocalDate(\n        year,\n        date.getMonth() + 1,\n        date.getDate()\n    );\n}\n\n@SuppressWarnings(\"deprecation\")\npublic static LocalDateTime fromDateFields(Date date) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    int year = date.getYear() + 1900;\n    if (date instanceof GregorianCalendar) {\n        GregorianCalendar cal = (GregorianCalendar) date;\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = -(year - 1);\n        }\n    }\n    return new LocalDateTime(\n        year,\n        date.getMonth() + 1,\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        (((int) (date.getTime() % 1000)) + 1000) % 1000\n    );\n}\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        int year = cal.get(Calendar.YEAR);\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year; // adjust for BC dates\n        }\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (year <= 0) {\n            year = -(year - 1);\n        }\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        \n        if (year <= 0) {\n            year--; // Adjust for the fact that there is no year zero in the ISO calendar\n        }\n\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n\n        int year = date.getYear() + 1900;\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDate(year, date.getMonth() + 1, date.getDate());\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (year <= 0 && date instanceof GregorianCalendar && ((GregorianCalendar)date).get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year; // Convert to ISO 8601 year representation\n        }\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (year <= 0 && date instanceof GregorianCalendar && ((GregorianCalendar)date).get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year; // Convert to ISO 8601 year representation\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n\n        int year = date.getYear() + 1900;\n        if (date.getYear() < 0) { // handle BC era dates\n            year = -(year - 1);\n        }\n        \n        // handle years in era BC\n        return new LocalDate(\n            year,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/joda/time/LocalDateTime.java",
                "start_loc": 195,
                "end_loc": 209,
                "buggy_function": "    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n",
                "fixed_function": "    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n",
                "comment": "    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n",
                "normalized_body": [
                    "public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\\\"The calendar must not be null\\\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime(yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "public static LocalDateTime fromCalendarFields(Calendar calendar) { if (calendar == null) { throw new IllegalArgumentException(\\\"The calendar must not be null\\\"); } int yearOfEra = calendar.get(Calendar.YEAR); return new LocalDateTime(yearOfEra, calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); }"
                    ],
                    [
                        0.9615322351455688,
                        "int[] isoFromFixed(long date) { int weekyear = gjYearFromFixed(date - 3); if (date >= fixedFromISO(weekyear + 1, 1, 1)) { weekyear += 1; } int weekOfWeekyear = (int) (div(date - fixedFromISO(weekyear, 1, 1), 7) + 1); int dayOfWeek = (int) amod(date, 7); return new int[] { weekyear, weekOfWeekyear, dayOfWeek }; }"
                    ],
                    [
                        0.9610733985900879,
                        "long fixedFromGJ(int year, int monthOfYear, int dayOfMonth) { if (year == 0) { throw new IllegalArgumentException(\\\"Illegal year: \\\" + year); } int y = (year < 0) ? year + 1 : year; long y_m1 = y - 1; long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4) + div(367 * monthOfYear - 362, 12) + dayOfMonth; if (monthOfYear > 2) { f += isLeapYear(year) ? -1 : -2; } return f; }"
                    ],
                    [
                        0.9606462717056274,
                        "public DateTimeZoneBuilder addCutover(int year, char mode, int monthOfYear, int dayOfMonth, int dayOfWeek, boolean advanceDayOfWeek, int millisOfDay) { if (iRuleSets.size() > 0) { OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay); RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1); lastRuleSet.setUpperLimit(year, ofYear); } iRuleSets.add(new RuleSet()); return this; }"
                    ],
                    [
                        0.9604352116584778,
                        "public long set(long millis, int value) { int[] wwd = iChronology.isoFromMillis(millis); millis = iChronology.getTimeOnlyMillis(millis) + iChronology.millisFromISO(value, wwd[1], wwd[2]); if (wwd[1] == 53) { int[] wwd2 = iChronology.isoFromMillis(millis); if (wwd2[0] != value) { millis = iChronology.dayOfYear().add(millis, -7); } } return millis; }"
                    ],
                    [
                        0.9579296708106995,
                        "public void testWOYY() { aDateTime = getADate(\\\"1998-12-31T23:59:59\\\"); bDateTime = getADate(\\\"1999-01-01T00:00:00\\\"); assertEquals(\\\"YOYYZ\\\", 0, cWeekyear.compare(aDateTime, bDateTime)); bDateTime = getADate(\\\"1999-01-04T00:00:00\\\"); assertEquals(\\\"YOYYM1\\\", -1, cWeekyear.compare(aDateTime, bDateTime)); assertEquals(\\\"YOYYP1\\\", 1, cWeekyear.compare(bDateTime, aDateTime)); }"
                    ],
                    [
                        0.9578443169593811,
                        "public long add(long millis, long value) { int newYear = iChronology.year().get(millis) + (int) TestGJChronology.div(value, 12); int newMonth = get(millis) + (int) TestGJChronology.mod(value, 12); if (newMonth > 12) { newYear++; newMonth -= 12; } int newDay = iChronology.dayOfMonth().get(millis); millis = iChronology.getTimeOnlyMillis(millis) + iChronology.millisFromGJ(newYear, newMonth, newDay); while (get(millis) != newMonth) { millis = iChronology.dayOfYear().add(millis, -1); } return millis; }"
                    ],
                    [
                        0.9575868844985962,
                        "public void testIsLessThan() { assertEquals(false, Years.THREE.isLessThan(Years.TWO)); assertEquals(false, Years.THREE.isLessThan(Years.THREE)); assertEquals(true, Years.TWO.isLessThan(Years.THREE)); assertEquals(false, Years.ONE.isLessThan(null)); assertEquals(true, Years.years(-1).isLessThan(null)); }"
                    ],
                    [
                        0.9572628736495972,
                        "int getWeekyear(long instant) { int year = getYear(instant); int week = getWeekOfWeekyear(instant, year); if (week == 1) { return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); } else if (week > 51) { return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); } else { return year; } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero1",
                    "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero3"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero1(TestLocalDateTime_Constructors.java:117)  assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n \n#Test method 2:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero3(TestLocalDateTime_Constructors.java:125)  assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        yearOfEra = 1 - yearOfEra;  // Adjust for BC era\n    }\n    return new LocalDateTime(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int adjustedYear = (era == GregorianCalendar.AD) ? yearOfEra : 1 - yearOfEra;\n    return new LocalDateTime(\n        adjustedYear,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int year = calendar.get(Calendar.YEAR);\n        int yearOfEra = (era == GregorianCalendar.BC) ? 1 - year : year;\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        yearOfEra = 1 - yearOfEra; // Convert BC era into negative years\n    }\n    return new LocalDateTime(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Convert to ISO proleptic years\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int year = calendar.get(Calendar.YEAR);\n        if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDateTime(\n            year,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int year = (era == GregorianCalendar.BC) ? 1 - yearOfEra : yearOfEra;\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int year = calendar.get(Calendar.YEAR);\n    if (era == GregorianCalendar.BC) {\n        year = 1 - year; // Convert BC years to negative\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year; // Convert year to ISO format where BC dates are negative\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n"
                        ],
                        "plausible_patches": [
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int year = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        year = 1 - year;\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    if (calendar.get(Calendar.ERA) == GregorianCalendar.BC) {\n        yearOfEra = 1 - yearOfEra;  // Adjust for BC era\n    }\n    return new LocalDateTime(\n        yearOfEra,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int adjustedYear = (era == GregorianCalendar.AD) ? yearOfEra : 1 - yearOfEra;\n    return new LocalDateTime(\n        adjustedYear,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int era = calendar.get(Calendar.ERA);\n        int year = calendar.get(Calendar.YEAR);\n        int yearOfEra = (era == GregorianCalendar.BC) ? 1 - year : year;\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    int era = calendar.get(Calendar.ERA);\n    int year = (era == GregorianCalendar.BC) ? 1 - yearOfEra : yearOfEra;\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n",
                            "\npublic static LocalDateTime fromCalendarFields(Calendar calendar) {\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int year = calendar.get(Calendar.YEAR);\n    if (era == GregorianCalendar.BC) {\n        year = 1 - year; // Convert BC years to negative\n    }\n    return new LocalDateTime(\n        year,\n        calendar.get(Calendar.MONTH) + 1,\n        calendar.get(Calendar.DAY_OF_MONTH),\n        calendar.get(Calendar.HOUR_OF_DAY),\n        calendar.get(Calendar.MINUTE),\n        calendar.get(Calendar.SECOND),\n        calendar.get(Calendar.MILLISECOND)\n    );\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/org/joda/time/LocalDateTime.java",
                "start_loc": 231,
                "end_loc": 246,
                "buggy_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                "fixed_function": "    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        if (date.getTime() < 0) {\n            // handle years in era BC\n            GregorianCalendar cal = new GregorianCalendar();\n            cal.setTime(date);\n            return fromCalendarFields(cal);\n        }\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                "comment": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n",
                "normalized_body": [
                    "@SuppressWarnings(\\\"deprecation\\\") public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\\\"The date must not be null\\\"); } return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "@SuppressWarnings(\\\"deprecation\\\") public static LocalDateTime fromDateFields(Date date) { if (date == null) { throw new IllegalArgumentException(\\\"The date must not be null\\\"); } return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); }"
                    ],
                    [
                        0.964889645576477,
                        "public static Days daysBetween(ReadablePartial start, ReadablePartial end) { if (start instanceof LocalDate && end instanceof LocalDate) { Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); int days = chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); return Days.days(days); } int amount = BaseSingleFieldPeriod.between(start, end, ZERO); return Days.days(amount); }"
                    ],
                    [
                        0.9632078409194946,
                        "int getWeekyear(long instant) { int year = getYear(instant); int week = getWeekOfWeekyear(instant, year); if (week == 1) { return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); } else if (week > 51) { return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); } else { return year; } }"
                    ],
                    [
                        0.962964653968811,
                        "@SuppressWarnings(\\\"deprecation\\\") public void testConstructor_ObjectYearMonthDay() throws Throwable { YearMonthDay date = new YearMonthDay(1970, 4, 6, BUDDHIST_UTC); LocalDate test = new LocalDate(date); assertEquals(BUDDHIST_UTC, test.getChronology()); assertEquals(1970, test.getYear()); assertEquals(4, test.getMonthOfYear()); assertEquals(6, test.getDayOfMonth()); }"
                    ],
                    [
                        0.9628207683563232,
                        "public void testSetZoneRetainFields_DateTimeZone3() { MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance(PARIS)); test.setZoneRetainFields(null); assertEquals(TEST_TIME1 + DateTimeConstants.MILLIS_PER_HOUR, test.getMillis()); assertEquals(GregorianChronology.getInstance(), test.getChronology()); }"
                    ],
                    [
                        0.9626744389533997,
                        "public void testMinusDays_int() { LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON); LocalDateTime result = test.minusDays(1); LocalDateTime expected = new LocalDateTime(2002, 5, 2, 10, 20, 30, 40, BUDDHIST_LONDON); assertEquals(expected, result); result = test.minusDays(0); assertSame(test, result); }"
                    ],
                    [
                        0.9626338481903076,
                        "public void testPropertyWithMaxMinValueMilli() { LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40); check(test.millisOfSecond().withMaximumValue(), 2005, 6, 9, 10, 20, 30, 999); check(test.millisOfSecond().withMinimumValue(), 2005, 6, 9, 10, 20, 30, 0); }"
                    ],
                    [
                        0.9612705707550049,
                        "int getWeekOfWeekyear(long instant, int year) { long firstWeekMillis1 = getFirstWeekOfYearMillis(year); if (instant < firstWeekMillis1) { return getWeeksInYear(year - 1); } long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); if (instant >= firstWeekMillis2) { return 1; } return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; }"
                    ],
                    [
                        0.9612475633621216,
                        "long getFirstWeekOfYearMillis(int year) { long jan1millis = getYearMillis(year); int jan1dayOfWeek = getDayOfWeek(jan1millis); if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) { return jan1millis + (8 - jan1dayOfWeek) * (long) DateTimeConstants.MILLIS_PER_DAY; } else { return jan1millis - (jan1dayOfWeek - 1) * (long) DateTimeConstants.MILLIS_PER_DAY; } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }\n\n```\n\n```java\n    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n \n#Test method 2:\n```java\n    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 2: junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n \n#Test method 3:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n \n#Test method 4:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 4: junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n \n#Test method 5:\n```java\n    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 5: junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n \n#Test method 6:\n```java\n    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }\n```\n#Error message from the test method 6: junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n \n#Test method 7:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 7: junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n \n#Test method 8:\n```java\n    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }\n```\n#Error message from the test method 8: junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n\n        int year = date.getYear() + 1900;\n        if (date.getYear() < 0) { // handle BC era dates\n            year = -(year - 1);\n        }\n        \n        // handle years in era BC\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (date.getYear() < 0) { // BC era\n            year = -(year - 1);\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (year <= 0) {\n            year -= 1;  // Adjust year for BC era\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        int year = cal.get(Calendar.YEAR);\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year; // adjust for BC dates\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        if (year <= 0) {\n            year = -(year - 1);\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n        int year = date.getYear() + 1900;\n        \n        if (year <= 0) {\n            year--; // Adjust for the fact that there is no year zero in the ISO calendar\n        }\n\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n",
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n\n        int year = date.getYear() + 1900;\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        if (cal.get(Calendar.ERA) == GregorianCalendar.BC) {\n            year = 1 - year;\n        }\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n\n        int year = date.getYear() + 1900;\n        if (date.getYear() < 0) { // handle BC era dates\n            year = -(year - 1);\n        }\n        \n        // handle years in era BC\n        return new LocalDateTime(\n            year,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }\n\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero1": {
                "path": "src/test/java/org/joda/time/TestLocalDateTime_Constructors.java",
                "function_name": "testFactory_fromDateFields_beforeYearZero1",
                "src": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero1(TestLocalDateTime_Constructors.java:155)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero1(TestLocalDateTime_Constructors.java:155)  assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));"
            },
            "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero3": {
                "path": "src/test/java/org/joda/time/TestLocalDateTime_Constructors.java",
                "function_name": "testFactory_fromDateFields_beforeYearZero3",
                "src": "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero3(TestLocalDateTime_Constructors.java:163)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero3(TestLocalDateTime_Constructors.java:163)  assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));"
            },
            "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero1": {
                "path": "src/test/java/org/joda/time/TestLocalDateTime_Constructors.java",
                "function_name": "testFactory_fromCalendarFields_beforeYearZero1",
                "src": "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero1(TestLocalDateTime_Constructors.java:117)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero1(TestLocalDateTime_Constructors.java:117)  assertEquals(expected, LocalDateTime.fromCalendarFields(cal));"
            },
            "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromCalendarFields_beforeYearZero3": {
                "path": "src/test/java/org/joda/time/TestLocalDateTime_Constructors.java",
                "function_name": "testFactory_fromCalendarFields_beforeYearZero3",
                "src": "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero3(TestLocalDateTime_Constructors.java:125)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>\n\tat org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero3(TestLocalDateTime_Constructors.java:125)  assertEquals(expected, LocalDateTime.fromCalendarFields(cal));"
            },
            "org.joda.time.TestLocalDate_Constructors::testFactory_fromDateFields_beforeYearZero1": {
                "path": "src/test/java/org/joda/time/TestLocalDate_Constructors.java",
                "function_name": "testFactory_fromDateFields_beforeYearZero1",
                "src": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero1(TestLocalDate_Constructors.java:147)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero1(TestLocalDate_Constructors.java:147)  assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));"
            },
            "org.joda.time.TestLocalDate_Constructors::testFactory_fromDateFields_beforeYearZero3": {
                "path": "src/test/java/org/joda/time/TestLocalDate_Constructors.java",
                "function_name": "testFactory_fromDateFields_beforeYearZero3",
                "src": "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero3(TestLocalDate_Constructors.java:155)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero3(TestLocalDate_Constructors.java:155)  assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));"
            },
            "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero1": {
                "path": "src/test/java/org/joda/time/TestLocalDate_Constructors.java",
                "function_name": "testFactory_fromCalendarFields_beforeYearZero1",
                "src": "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero1(TestLocalDate_Constructors.java:109)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0000-02-03> but was:<0001-02-03>\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero1(TestLocalDate_Constructors.java:109)  assertEquals(expected, LocalDate.fromCalendarFields(cal));"
            },
            "org.joda.time.TestLocalDate_Constructors::testFactory_fromCalendarFields_beforeYearZero3": {
                "path": "src/test/java/org/joda/time/TestLocalDate_Constructors.java",
                "function_name": "testFactory_fromCalendarFields_beforeYearZero3",
                "src": "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero3(TestLocalDate_Constructors.java:117)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<-0002-02-03> but was:<0003-02-03>\n\tat org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero3(TestLocalDate_Constructors.java:117)  assertEquals(expected, LocalDate.fromCalendarFields(cal));"
            }
        },
        "evaluation_done": true
    }
}