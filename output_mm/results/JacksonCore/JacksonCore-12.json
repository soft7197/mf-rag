{
    "JacksonCore-12": {
        "function_num": 7,
        "functions": [
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
                "start_loc": 573,
                "end_loc": 705,
                "buggy_function": "    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n",
                "fixed_function": "    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n",
                "comment": "    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n",
                "normalized_body": [
                    "@Override public final JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); boolean inObject = _parsingContext.inObject(); if (inObject) { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } JsonToken t; switch(i) { case '\\\"': _tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \\\"expected a value\\\"); case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; } _currToken = t; return t; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000000596046448,
                        "@Override public final JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); boolean inObject = _parsingContext.inObject(); if (inObject) { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } JsonToken t; switch(i) { case '\\\"': _tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \\\"expected a value\\\"); case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; } _currToken = t; return t; }"
                    ],
                    [
                        0.9900487661361694,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); final String nameStr = _parseName(i); _parsingContext.setCurrentName(nameStr); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; }"
                    ],
                    [
                        0.9840598702430725,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return name; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return name; }"
                    ],
                    [
                        0.9822111129760742,
                        "@Override public JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); return _nextTokenNotInObject(i); } _updateNameLocation(); String n = _parseName(i); _parsingContext.setCurrentName(n); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; }"
                    ],
                    [
                        0.973996639251709,
                        "private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException { String n = _parseName(i); _parsingContext.setCurrentName(n); final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch(i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; }"
                    ],
                    [
                        0.9734972715377808,
                        "@Override public JsonToken nextToken() throws IOException { TokenFilterContext ctxt = _exposedContext; if (ctxt != null) { while (true) { JsonToken t = ctxt.nextTokenToRead(); if (t != null) { _currToken = t; return t; } if (ctxt == _headContext) { _exposedContext = null; if (ctxt.inArray()) { t = delegate.getCurrentToken(); _currToken = t; return t; } break; } ctxt = _headContext.findChildOf(ctxt); _exposedContext = ctxt; if (ctxt == null) { throw _constructError(\\\"Unexpected problem: chain of filtered context broken\\\"); } } } JsonToken t = delegate.nextToken(); if (t == null) { return (_currToken = t); } TokenFilter f; switch(t.id()) { case ID_START_ARRAY: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); break; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); break; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartArray(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildArrayContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; case ID_START_OBJECT: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); break; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); break; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartObject(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildObjectContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; case ID_END_ARRAY: case ID_END_OBJECT: { boolean returnEnd = _headContext.isStartHandled(); f = _headContext.getFilter(); if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) { f.filterFinishArray(); } _headContext = _headContext.getParent(); _itemFilter = _headContext.getFilter(); if (returnEnd) { return (_currToken = t); } } break; case ID_FIELD_NAME: { final String name = delegate.getCurrentName(); f = _headContext.setFieldName(name); if (f == TokenFilter.INCLUDE_ALL) { _itemFilter = f; if (!_includePath) { if (_includeImmediateParent && !_headContext.isStartHandled()) { t = _headContext.nextTokenToRead(); _exposedContext = _headContext; } } return (_currToken = t); } if (f == null) { delegate.nextToken(); delegate.skipChildren(); break; } f = f.includeProperty(name); if (f == null) { delegate.nextToken(); delegate.skipChildren(); break; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } } if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } break; } default: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { return (_currToken = t); } if (f != null) { f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } break; } return _nextToken2(); }"
                    ],
                    [
                        0.9714995324611664,
                        "@SuppressWarnings(\\\"resource\\\") private void _testCommentsBetweenArrayValues(JsonFactory f, boolean useStream, String comment) throws Exception { for (String tmpl : new String[] { \\\"%s,\\\", \\\" %s,\\\", \\\"\\t%s,\\\", \\\"%s ,\\\", \\\"%s\\t,\\\", \\\" %s ,\\\", \\\"\\t%s\\t,\\\", \\\"\\n%s,\\\", \\\"%s\\n,\\\" }) { String commented = String.format(tmpl, comment); final String DOC = \\\"[1\\\" + commented + \\\"2]\\\"; JsonParser jp = useStream ? f.createParser(DOC.getBytes(\\\"UTF-8\\\")) : f.createParser(DOC); assertEquals(JsonToken.START_ARRAY, jp.nextToken()); JsonToken t = null; try { t = jp.nextToken(); } catch (Exception e) { throw new RuntimeException(\\\"Failed on '\\\" + DOC + \\\"' due to \\\" + e, e); } assertEquals(JsonToken.VALUE_NUMBER_INT, t); assertEquals(1, jp.getIntValue()); try { t = jp.nextToken(); } catch (Exception e) { throw new RuntimeException(\\\"Failed on '\\\" + DOC + \\\"' due to \\\" + e, e); } assertEquals(JsonToken.VALUE_NUMBER_INT, t); assertEquals(2, jp.getIntValue()); assertEquals(JsonToken.END_ARRAY, jp.nextToken()); jp.close(); } }"
                    ],
                    [
                        0.9699667096138,
                        "@SuppressWarnings(\\\"resource\\\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\\\"') { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } }"
                    ],
                    [
                        0.969948798418045,
                        "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameToMatch.equals(name); } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return nameToMatch.equals(name); }"
                    ],
                    [
                        0.9692864716053009,
                        "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException { _inputPtr = neg ? (startPtr + 1) : startPtr; char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); int outPtr = 0; if (neg) { outBuf[outPtr++] = '-'; } int intLen = 0; char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\\\"No digit following minus sign\\\"); if (c == '0') { c = _verifyNoLeadingZeroes(); } boolean eof = false; int_loop: while (c >= '0' && c <= '9') { ++intLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { c = CHAR_NULL; eof = true; break int_loop; } c = _inputBuffer[_inputPtr++]; } if (intLen == 0) { return _handleInvalidNumberStart(c, neg); } int fractLen = 0; if (c == '.') { outBuf[outPtr++] = c; fract_loop: while (true) { if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break fract_loop; } c = _inputBuffer[_inputPtr++]; if (c < INT_0 || c > INT_9) { break fract_loop; } ++fractLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; } if (fractLen == 0) { reportUnexpectedNumberChar(c, \\\"Decimal point not followed by a digit\\\"); } } int expLen = 0; if (c == 'e' || c == 'E') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\\\"expected a digit for number exponent\\\"); if (c == '-' || c == '+') { if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\\\"expected a digit for number exponent\\\"); } exp_loop: while (c <= INT_9 && c >= INT_0) { ++expLen; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } outBuf[outPtr++] = c; if (_inputPtr >= _inputEnd && !loadMore()) { eof = true; break exp_loop; } c = _inputBuffer[_inputPtr++]; } if (expLen == 0) { reportUnexpectedNumberChar(c, \\\"Exponent indicator not followed by a digit\\\"); } } if (!eof) { --_inputPtr; if (_parsingContext.inRoot()) { _verifyRootSpace(c); } } _textBuffer.setCurrentLength(outPtr); return reset(neg, intLen, fractLen, expLen); }"
                    ],
                    [
                        0.9688964784145355,
                        "private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\\\": was expecting closing '\\\" + ((char) endChar) + \\\"' for name\\\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \\\"name\\\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }"
                    ],
                    [
                        0.968758225440979,
                        "private void _prependOrWriteCharacterEscape(char ch, int escCode) throws IOException, JsonGenerationException { if (escCode >= 0) { if (_outputTail >= 2) { int ptr = _outputTail - 2; _outputHead = ptr; _outputBuffer[ptr++] = '\\\\'; _outputBuffer[ptr] = (char) escCode; return; } char[] buf = _entityBuffer; if (buf == null) { buf = _allocateEntityBuffer(); } _outputHead = _outputTail; buf[1] = (char) escCode; _writer.write(buf, 0, 2); return; } if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { if (_outputTail >= 6) { char[] buf = _outputBuffer; int ptr = _outputTail - 6; _outputHead = ptr; buf[ptr] = '\\\\'; buf[++ptr] = 'u'; if (ch > 0xFF) { int hi = (ch >> 8) & 0xFF; buf[++ptr] = HEX_CHARS[hi >> 4]; buf[++ptr] = HEX_CHARS[hi & 0xF]; ch &= 0xFF; } else { buf[++ptr] = '0'; buf[++ptr] = '0'; } buf[++ptr] = HEX_CHARS[ch >> 4]; buf[++ptr] = HEX_CHARS[ch & 0xF]; return; } char[] buf = _entityBuffer; if (buf == null) { buf = _allocateEntityBuffer(); } _outputHead = _outputTail; if (ch > 0xFF) { int hi = (ch >> 8) & 0xFF; int lo = ch & 0xFF; buf[10] = HEX_CHARS[hi >> 4]; buf[11] = HEX_CHARS[hi & 0xF]; buf[12] = HEX_CHARS[lo >> 4]; buf[13] = HEX_CHARS[lo & 0xF]; _writer.write(buf, 8, 6); } else { buf[6] = HEX_CHARS[ch >> 4]; buf[7] = HEX_CHARS[ch & 0xF]; _writer.write(buf, 2, 6); } return; } String escape; if (_currentEscape == null) { escape = _characterEscapes.getEscapeSequence(ch).getValue(); } else { escape = _currentEscape.getValue(); _currentEscape = null; } int len = escape.length(); if (_outputTail >= len) { int ptr = _outputTail - len; _outputHead = ptr; escape.getChars(0, len, _outputBuffer, ptr); return; } _outputHead = _outputTail; _writer.write(escape); }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n```\n\n```java\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n```\n\n```java\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                -1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(1L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(6L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f2\", p.nextFieldName());\n        assertEquals(11L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n        assertEquals(16L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f3\", p.nextFieldName());\n        assertEquals(17L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n        assertEquals(22L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(\"f4\", p.nextFieldName());\n        assertEquals(28L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n        assertEquals(33L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n        assertEquals(34L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n        assertEquals(39L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n\n        assertEquals(\"f5\", p.nextFieldName());\n        assertEquals(46L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(51L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<6> but was:<1>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic final JsonToken nextToken() throws IOException\n{\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        return (_currToken = null);\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return _currToken;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return _currToken;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n\n    JsonToken t;\n\n    switch (i) {\n    case '\"':\n        _tokenIncomplete = true;\n        t = JsonToken.VALUE_STRING;\n        break;\n    case '[':\n        if (!inObject) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        }\n        t = JsonToken.START_ARRAY;\n        break;\n    case '{':\n        if (!inObject) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        t = JsonToken.START_OBJECT;\n        break;\n    case ']':\n    case '}':\n        _reportUnexpectedChar(i, \"expected a value\");\n        break;\n    case 't':\n        _matchTrue();\n        t = JsonToken.VALUE_TRUE;\n        break;\n    case 'f':\n        _matchFalse();\n        t = JsonToken.VALUE_FALSE;\n        break;\n    case 'n':\n        _matchNull();\n        t = JsonToken.VALUE_NULL;\n        break;\n    case '-':\n        t = _parseNegNumber();\n        break;\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        t = _parsePosNumber(i);\n        break;\n    default:\n        t = _handleOddValue(i);\n        break;\n    }\n\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}\n",
                            "\n@Override\npublic final JsonToken nextToken() throws IOException\n{\n    // First: field names are special -- we will always tokenize\n    // (part of) value along with field name to simplify\n    // state handling. If so, can and need to use secondary token:\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        _skipString(); // only strings can be partial\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) { // end-of-input\n        // 19-Feb-2009, tatu: Should actually close/release things\n        // like input source, symbol table and recyclable buffers now.\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n\n    // And should we now have a name? Always true for Object contexts, since\n    // the intermediate 'expect-value' state is never retained.\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n\n    // Ok: we must have a value... what is it?\n\n    JsonToken t;\n\n    switch (i) {\n    case '\"':\n        _tokenIncomplete = true;\n        t = JsonToken.VALUE_STRING;\n        break;\n    case '[':\n        _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        t = JsonToken.START_ARRAY;\n        break;\n    case '{':\n        _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        t = JsonToken.START_OBJECT;\n        break;\n    case ']':\n    case '}':\n        // Error: neither is valid at this point; valid closers have\n        // been handled earlier\n        _reportUnexpectedChar(i, \"expected a value\");\n    case 't':\n        _matchTrue();\n        t = JsonToken.VALUE_TRUE;\n        break;\n    case 'f':\n        _matchFalse();\n        t = JsonToken.VALUE_FALSE;\n        break;\n    case 'n':\n        _matchNull();\n        t = JsonToken.VALUE_NULL;\n        break;\n    case '-':\n        t = _parseNegNumber();\n        break;\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        t = _parsePosNumber(i);\n        break;\n    default:\n        t = _handleOddValue(i);\n        break;\n    }\n\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            close();\n            return (_currToken = null);\n        }\n\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        JsonToken t;\n        long tokenCharOffset = _inputPtr;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        _tokenInputTotal = tokenCharOffset;\n        return t;\n    }\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return _currToken;\n        }\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); \n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { \n            close();\n            return (_currToken = null);\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return _currToken;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return _currToken;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        JsonToken t;\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _currToken = _nextToken;\n            _nextToken = null;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildContext(_tokenInputRow, _tokenInputCol, _currToken);\n            }\n            return _currToken;\n        }\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n        _binaryValue = null;\n\n        _updateLocation();\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return _currToken;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return _currToken;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        boolean inObject = _parsingContext.inObject();\n\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n            if (i == INT_QUOTE) {\n                _tokenIncomplete = true;\n                _nextToken = JsonToken.VALUE_STRING;\n                return _currToken;\n            }\n            JsonToken t;\n            switch (i) {\n                case '-':\n                    t = _parseNegNumber();\n                    break;\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                    t = _parsePosNumber(i);\n                    break;\n                case 'f':\n                    _matchFalse();\n                    t = JsonToken.VALUE_FALSE;\n                    break;\n                case 'n':\n                    _matchNull();\n                    t = JsonToken.VALUE_NULL;\n                    break;\n                case 't':\n                    _matchTrue();\n                    t = JsonToken.VALUE_TRUE;\n                    break;\n                case '[':\n                    t = JsonToken.START_ARRAY;\n                    _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n                    break;\n                case '{':\n                    t = JsonToken.START_OBJECT;\n                    _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n                    break;\n                default:\n                    t = _handleOddValue(i);\n            }\n            _nextToken = t;\n            return _currToken;\n        }\n\n        JsonToken t;\n        switch (i) {\n            case '\"':\n                _tokenIncomplete = true;\n                t = JsonToken.VALUE_STRING;\n                break;\n            case '[':\n                t = JsonToken.START_ARRAY;\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n                break;\n            case '{':\n                t = JsonToken.START_OBJECT;\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n                break;\n            case ']':\n            case '}':\n                _reportUnexpectedChar(i, \"expected a value\");\n            case 't':\n                _matchTrue();\n                t = JsonToken.VALUE_TRUE;\n                break;\n            case 'f':\n                _matchFalse();\n                t = JsonToken.VALUE_FALSE;\n                break;\n            case 'n':\n                _matchNull();\n                t = JsonToken.VALUE_NULL;\n                break;\n            case '-':\n                t = _parseNegNumber();\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                t = _parsePosNumber(i);\n                break;\n            default:\n                t = _handleOddValue(i);\n                break;\n        }\n        _currToken = t;\n        return t;\n    }\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                getTokenCharacterOffset() - 1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                            "\n@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        _currToken = _nextToken;\n        _nextToken = null;\n        return _currToken;\n    }\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        return (_currToken = null);\n    }\n    _binaryValue = null;\n    _updateLocation();\n    if (i == INT_RBRACKET) {\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    JsonToken t;\n    switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}\n\n@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        _currToken = _nextToken;\n        _nextToken = null;\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    _updateLocation();\n    if (i == INT_RBRACKET) {\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n\n    JsonToken t;\n    switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}\n\n@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    return new JsonLocation(src,\n            getTokenCharacterOffset(),\n            -1L, getTokenLineNr(),\n            getTokenColumnNr());\n}\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n        _binaryValue = null;\n        _updateLocation(); // Moved up to fix location issue\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n",
                            "\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
                "start_loc": 731,
                "end_loc": 808,
                "buggy_function": "    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n",
                "fixed_function": "    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return false;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return false;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n",
                "comment": "    // Implemented since 2.7\n",
                "normalized_body": [
                    "@Override public boolean nextFieldName(SerializableString sstr) throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return false; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { char[] nameChars = sstr.asQuotedChars(); final int len = nameChars.length; if ((_inputPtr + len + 4) < _inputEnd) { final int end = _inputPtr + len; if (_inputBuffer[end] == '\\\"') { int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { _parsingContext.setCurrentName(sstr.getValue()); _isNextTokenNameYes(_skipColonFast(ptr + 1)); return true; } if (nameChars[offset] != _inputBuffer[ptr]) { break; } ++offset; ++ptr; } } } } return _isNextTokenNameMaybe(i, sstr.getValue()); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "@Override public boolean nextFieldName(SerializableString sstr) throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return false; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return false; } if (i == INT_QUOTE) { char[] nameChars = sstr.asQuotedChars(); final int len = nameChars.length; if ((_inputPtr + len + 4) < _inputEnd) { final int end = _inputPtr + len; if (_inputBuffer[end] == '\\\"') { int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { _parsingContext.setCurrentName(sstr.getValue()); _isNextTokenNameYes(_skipColonFast(ptr + 1)); return true; } if (nameChars[offset] != _inputBuffer[ptr]) { break; } ++offset; ++ptr; } } } } return _isNextTokenNameMaybe(i, sstr.getValue()); }"
                    ],
                    [
                        0.9942691326141357,
                        "protected final JsonToken _nextToken2() throws IOException { main_loop: while (true) { JsonToken t = delegate.nextToken(); if (t == null) { return (_currToken = t); } TokenFilter f; switch(t.id()) { case ID_START_ARRAY: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); continue main_loop; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); continue main_loop; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartArray(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildArrayContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildArrayContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } continue main_loop; case ID_START_OBJECT: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } if (f == null) { delegate.skipChildren(); continue main_loop; } f = _headContext.checkValue(f); if (f == null) { delegate.skipChildren(); continue main_loop; } if (f != TokenFilter.INCLUDE_ALL) { f = f.filterStartObject(); } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { _headContext = _headContext.createChildObjectContext(f, true); return (_currToken = t); } _headContext = _headContext.createChildObjectContext(f, false); if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } continue main_loop; case ID_END_ARRAY: case ID_END_OBJECT: { boolean returnEnd = _headContext.isStartHandled(); f = _headContext.getFilter(); if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) { f.filterFinishArray(); } _headContext = _headContext.getParent(); _itemFilter = _headContext.getFilter(); if (returnEnd) { return (_currToken = t); } } continue main_loop; case ID_FIELD_NAME: { final String name = delegate.getCurrentName(); f = _headContext.setFieldName(name); if (f == TokenFilter.INCLUDE_ALL) { _itemFilter = f; return (_currToken = t); } if (f == null) { delegate.nextToken(); delegate.skipChildren(); continue main_loop; } f = f.includeProperty(name); if (f == null) { delegate.nextToken(); delegate.skipChildren(); continue main_loop; } _itemFilter = f; if (f == TokenFilter.INCLUDE_ALL) { if (_includePath) { return (_currToken = t); } continue main_loop; } if (_includePath) { t = _nextTokenWithBuffering(_headContext); if (t != null) { _currToken = t; return t; } } } continue main_loop; default: f = _itemFilter; if (f == TokenFilter.INCLUDE_ALL) { return (_currToken = t); } if (f != null) { f = _headContext.checkValue(f); if ((f == TokenFilter.INCLUDE_ALL) || ((f != null) && f.includeValue(delegate))) { return (_currToken = t); } } break; } } }"
                    ],
                    [
                        0.9920141696929932,
                        "protected String _handleOddName(int ch) throws IOException { if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { char c = (char) _decodeCharForError(ch); _reportUnexpectedChar(c, \\\"was expecting double-quote to start field name\\\"); } final int[] codes = CharTypes.getInputCodeUtf8JsNames(); if (codes[ch] != 0) { _reportUnexpectedChar(ch, \\\"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\\\"); } int[] quads = _quadBuffer; int qlen = 0; int currQuad = 0; int currQuadBytes = 0; while (true) { if (currQuadBytes < 4) { ++currQuadBytes; currQuad = (currQuad << 8) | ch; } else { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; currQuad = ch; currQuadBytes = 1; } if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\\\" in field name\\\"); } } ch = _inputBuffer[_inputPtr] & 0xFF; if (codes[ch] != 0) { break; } ++_inputPtr; } if (currQuadBytes > 0) { if (qlen >= quads.length) { _quadBuffer = quads = growArrayBy(quads, quads.length); } quads[qlen++] = currQuad; } String name = _symbols.findName(quads, qlen); if (name == null) { name = addName(quads, qlen, currQuadBytes); } return name; }"
                    ],
                    [
                        0.9918981194496155,
                        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { int ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = (int) _inputBuffer[_inputPtr++] & 0xFF; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == INT_QUOTE) { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++] & 0xFF; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; }"
                    ],
                    [
                        0.9912158250808716,
                        "protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException { int outputPtr = 0; final int outputEnd = buffer.length - 3; int outputCount = 0; while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\\\"') { break; } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { continue; } } if (outputPtr > outputEnd) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); outputPtr = 0; } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); } decodedData >>= 4; buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; break; } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; continue; } } decodedData = (decodedData << 6) | bits; buffer[outputPtr++] = (byte) (decodedData >> 16); buffer[outputPtr++] = (byte) (decodedData >> 8); buffer[outputPtr++] = (byte) decodedData; } _tokenIncomplete = false; if (outputPtr > 0) { outputCount += outputPtr; out.write(buffer, 0, outputPtr); } return outputCount; }"
                    ],
                    [
                        0.9905344843864441,
                        "protected final int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { break; } lastFullOffset = inputEnd - 3; } if (_outputTail > safeOutputEnd) { _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { if (_outputTail > safeOutputEnd) { _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; }"
                    ],
                    [
                        0.9898566603660583,
                        "protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException { int inputPtr = 0; int inputEnd = 0; int lastFullOffset = -3; int bytesDone = 0; int safeOutputEnd = _outputEnd - 6; int chunksBeforeLF = b64variant.getMaxLineLength() >> 2; while (true) { if (inputPtr > lastFullOffset) { inputEnd = _readMore(data, readBuffer, inputPtr, inputEnd, readBuffer.length); inputPtr = 0; if (inputEnd < 3) { break; } lastFullOffset = inputEnd - 3; } if (_outputTail > safeOutputEnd) { _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 8; b24 |= ((int) readBuffer[inputPtr++]) & 0xFF; b24 = (b24 << 8) | (((int) readBuffer[inputPtr++]) & 0xFF); bytesDone += 3; _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail); if (--chunksBeforeLF <= 0) { _outputBuffer[_outputTail++] = '\\\\'; _outputBuffer[_outputTail++] = 'n'; chunksBeforeLF = b64variant.getMaxLineLength() >> 2; } } if (inputPtr < inputEnd) { if (_outputTail > safeOutputEnd) { _flushBuffer(); } int b24 = ((int) readBuffer[inputPtr++]) << 16; int amount = 1; if (inputPtr < inputEnd) { b24 |= (((int) readBuffer[inputPtr]) & 0xFF) << 8; amount = 2; } bytesDone += amount; _outputTail = b64variant.encodeBase64Partial(b24, amount, _outputBuffer, _outputTail); } return bytesDone; }"
                    ],
                    [
                        0.989445686340332,
                        "private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen) throws IOException { final int inputLen = _inputEnd; int fractLen = 0; if (ch == '.') { fract_loop: while (true) { if (ptr >= inputLen) { return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch < INT_0 || ch > INT_9) { break fract_loop; } ++fractLen; } if (fractLen == 0) { reportUnexpectedNumberChar(ch, \\\"Decimal point not followed by a digit\\\"); } } int expLen = 0; if (ch == 'e' || ch == 'E') { if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; if (ch == INT_MINUS || ch == INT_PLUS) { if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; } while (ch <= INT_9 && ch >= INT_0) { ++expLen; if (ptr >= inputLen) { _inputPtr = startPtr; return _parseNumber2(neg, startPtr); } ch = (int) _inputBuffer[ptr++]; } if (expLen == 0) { reportUnexpectedNumberChar(ch, \\\"Exponent indicator not followed by a digit\\\"); } } --ptr; _inputPtr = ptr; if (_parsingContext.inRoot()) { _verifyRootSpace(ch); } int len = ptr - startPtr; _textBuffer.resetWithShared(_inputBuffer, startPtr, len); return resetFloat(neg, intLen, fractLen, expLen); }"
                    ],
                    [
                        0.9886441826820374,
                        "public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { if (!acc.hasMoreBytes()) { return MatchStrength.INCONCLUSIVE; } byte b = acc.nextByte(); if (b == UTF8_BOM_1) { if (!acc.hasMoreBytes()) { return MatchStrength.INCONCLUSIVE; } if (acc.nextByte() != UTF8_BOM_2) { return MatchStrength.NO_MATCH; } if (!acc.hasMoreBytes()) { return MatchStrength.INCONCLUSIVE; } if (acc.nextByte() != UTF8_BOM_3) { return MatchStrength.NO_MATCH; } if (!acc.hasMoreBytes()) { return MatchStrength.INCONCLUSIVE; } b = acc.nextByte(); } int ch = skipSpace(acc, b); if (ch < 0) { return MatchStrength.INCONCLUSIVE; } if (ch == '{') { ch = skipSpace(acc); if (ch < 0) { return MatchStrength.INCONCLUSIVE; } if (ch == '\\\"' || ch == '}') { return MatchStrength.SOLID_MATCH; } return MatchStrength.NO_MATCH; } MatchStrength strength; if (ch == '[') { ch = skipSpace(acc); if (ch < 0) { return MatchStrength.INCONCLUSIVE; } if (ch == ']' || ch == '[') { return MatchStrength.SOLID_MATCH; } return MatchStrength.SOLID_MATCH; } else { strength = MatchStrength.WEAK_MATCH; } if (ch == '\\\"') { return strength; } if (ch <= '9' && ch >= '0') { return strength; } if (ch == '-') { ch = skipSpace(acc); if (ch < 0) { return MatchStrength.INCONCLUSIVE; } return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; } if (ch == 'n') { return tryMatch(acc, \\\"ull\\\", strength); } if (ch == 't') { return tryMatch(acc, \\\"rue\\\", strength); } if (ch == 'f') { return tryMatch(acc, \\\"alse\\\", strength); } return MatchStrength.NO_MATCH; }"
                    ],
                    [
                        0.9879864454269409,
                        "public void testSimpleDouble() throws Exception { final String[] INPUTS = new String[] { \\\"1234.00\\\", \\\"2.1101567E-16\\\", \\\"1.0e5\\\", \\\"0.0\\\", \\\"1.0\\\", \\\"-1.0\\\", \\\"-0.5\\\", \\\"-12.9\\\", \\\"-999.0\\\", \\\"2.5e+5\\\", \\\"9e4\\\", \\\"-12e-3\\\", \\\"0.25\\\" }; for (int input = 0; input < 2; ++input) { for (int i = 0; i < INPUTS.length; ++i) { String STR = INPUTS[i]; double EXP_D = Double.parseDouble(STR); String DOC = \\\"[\\\" + STR + \\\"]\\\"; JsonParser jp; if (input == 0) { jp = createParserUsingStream(DOC, \\\"UTF-8\\\"); } else { jp = FACTORY.createParser(DOC); } assertToken(JsonToken.START_ARRAY, jp.nextToken()); assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken()); assertEquals(STR, jp.getText()); assertEquals(EXP_D, jp.getDoubleValue()); assertToken(JsonToken.END_ARRAY, jp.nextToken()); assertNull(jp.nextToken()); jp.close(); if (input == 0) { jp = createParserUsingStream(STR, \\\"UTF-8\\\"); } else { jp = FACTORY.createParser(STR); } JsonToken t = null; try { t = jp.nextToken(); } catch (Exception e) { throw new Exception(\\\"Failed to parse input '\\\" + STR + \\\"' (parser of type \\\" + jp.getClass().getSimpleName() + \\\")\\\", e); } assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); assertEquals(STR, jp.getText()); assertNull(jp.nextToken()); jp.close(); } } }"
                    ],
                    [
                        0.9868717789649963,
                        "protected String _handleOddName(int i) throws IOException { if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { return _parseAposName(); } if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { _reportUnexpectedChar(i, \\\"was expecting double-quote to start field name\\\"); } final int[] codes = CharTypes.getInputCodeLatin1JsNames(); final int maxCode = codes.length; boolean firstOk; if (i < maxCode) { firstOk = (codes[i] == 0); } else { firstOk = Character.isJavaIdentifierPart((char) i); } if (!firstOk) { _reportUnexpectedChar(i, \\\"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\\\"); } int ptr = _inputPtr; int hash = _hashSeed; final int inputLen = _inputEnd; if (ptr < inputLen) { do { int ch = _inputBuffer[ptr]; if (ch < maxCode) { if (codes[ch] != 0) { int start = _inputPtr - 1; _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } } else if (!Character.isJavaIdentifierPart((char) ch)) { int start = _inputPtr - 1; _inputPtr = ptr; return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; ++ptr; } while (ptr < inputLen); } int start = _inputPtr - 1; _inputPtr = ptr; return _handleOddName2(start, hash, codes); }"
                    ],
                    [
                        0.9859728813171387,
                        "@Override public int read(char[] cbuf, int start, int len) throws IOException { if (_buffer == null) { return -1; } if (len < 1) { return len; } if (start < 0 || (start + len) > cbuf.length) { reportBounds(cbuf, start, len); } len += start; int outPtr = start; if (_surrogate != NC) { cbuf[outPtr++] = _surrogate; _surrogate = NC; } else { int left = (_length - _ptr); if (left < 4) { if (!loadMore(left)) { return -1; } } } main_loop: while (outPtr < len) { int ptr = _ptr; int ch; if (_bigEndian) { ch = (_buffer[ptr] << 24) | ((_buffer[ptr + 1] & 0xFF) << 16) | ((_buffer[ptr + 2] & 0xFF) << 8) | (_buffer[ptr + 3] & 0xFF); } else { ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr + 1] & 0xFF) << 8) | ((_buffer[ptr + 2] & 0xFF) << 16) | (_buffer[ptr + 3] << 24); } _ptr += 4; if (ch > 0xFFFF) { if (ch > LAST_VALID_UNICODE_CHAR) { reportInvalid(ch, outPtr - start, \\\"(above \\\" + Integer.toHexString(LAST_VALID_UNICODE_CHAR) + \\\") \\\"); } ch -= 0x10000; cbuf[outPtr++] = (char) (0xD800 + (ch >> 10)); ch = (0xDC00 | (ch & 0x03FF)); if (outPtr >= len) { _surrogate = (char) ch; break main_loop; } } cbuf[outPtr++] = (char) ch; if (_ptr >= _length) { break main_loop; } } len = outPtr - start; _charCount += len; return len; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
                "start_loc": 810,
                "end_loc": 912,
                "buggy_function": "    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n",
                "fixed_function": "    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return name; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return name; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001788139343,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return name; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return name; }"
                    ],
                    [
                        0.9887076914310455,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); final String nameStr = _parseName(i); _parsingContext.setCurrentName(nameStr); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; }"
                    ],
                    [
                        0.9840598404407501,
                        "@Override public final JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); boolean inObject = _parsingContext.inObject(); if (inObject) { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } JsonToken t; switch(i) { case '\\\"': _tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \\\"expected a value\\\"); case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; } _currToken = t; return t; }"
                    ],
                    [
                        0.9805243611335754,
                        "@Override public JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); return _nextTokenNotInObject(i); } _updateNameLocation(); String n = _parseName(i); _parsingContext.setCurrentName(n); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; }"
                    ],
                    [
                        0.9763936102390289,
                        "private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException { String n = _parseName(i); _parsingContext.setCurrentName(n); final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch(i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; }"
                    ],
                    [
                        0.9744697511196136,
                        "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameToMatch.equals(name); } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return nameToMatch.equals(name); }"
                    ],
                    [
                        0.9702841639518738,
                        "@Override public boolean nextFieldName(SerializableString str) throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return false; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return false; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return false; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return false; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return false; } _updateNameLocation(); if (i == INT_QUOTE) { byte[] nameBytes = str.asQuotedUTF8(); final int len = nameBytes.length; if ((_inputPtr + len + 4) < _inputEnd) { final int end = _inputPtr + len; if (_inputBuffer[end] == INT_QUOTE) { int offset = 0; int ptr = _inputPtr; while (true) { if (ptr == end) { _parsingContext.setCurrentName(str.getValue()); i = _skipColonFast(ptr + 1); _isNextTokenNameYes(i); return true; } if (nameBytes[offset] != _inputBuffer[ptr]) { break; } ++offset; ++ptr; } } } } return _isNextTokenNameMaybe(i, str); }"
                    ],
                    [
                        0.9686894714832306,
                        "@SuppressWarnings(\\\"resource\\\") private void _testLongText(int LEN) throws Exception { StringBuilder sb = new StringBuilder(LEN + 100); Random r = new Random(99); while (sb.length() < LEN) { sb.append(r.nextInt()); sb.append(\\\" xyz foo\\\"); if (r.nextBoolean()) { sb.append(\\\" and \\\\\"bar\\\\\"\\\"); } else if (r.nextBoolean()) { sb.append(\\\" [whatever].... \\\"); } else { sb.append(\\\" UTF-8-fu: try this {\\u00E2/\\u0BF8/\\uA123!} (look funny?)\\\"); } if (r.nextBoolean()) { if (r.nextBoolean()) { sb.append('\\n'); } else if (r.nextBoolean()) { sb.append('\\r'); } else { sb.append(\\\"\\r\\n\\\"); } } } final String VALUE = sb.toString(); StringWriter sw = new StringWriter(LEN + (LEN >> 2)); JsonGenerator jg = JSON_FACTORY.createGenerator(sw); jg.writeStartObject(); jg.writeFieldName(\\\"doc\\\"); jg.writeString(VALUE); jg.writeEndObject(); jg.close(); final String DOC = sw.toString(); for (int type = 0; type < 3; ++type) { JsonParser jp; switch(type) { default: jp = JSON_FACTORY.createParser(DOC.getBytes(\\\"UTF-8\\\")); break; case 1: jp = JSON_FACTORY.createParser(DOC); break; case 2: jp = JSON_FACTORY.createParser(encodeInUTF32BE(DOC)); break; } assertToken(JsonToken.START_OBJECT, jp.nextToken()); assertToken(JsonToken.FIELD_NAME, jp.nextToken()); assertEquals(\\\"doc\\\", jp.getCurrentName()); assertToken(JsonToken.VALUE_STRING, jp.nextToken()); String act = getAndVerifyText(jp); if (act.length() != VALUE.length()) { fail(\\\"Expected length \\\" + VALUE.length() + \\\", got \\\" + act.length()); } if (!act.equals(VALUE)) { fail(\\\"Long text differs\\\"); } assertEquals(\\\"doc\\\", jp.getCurrentName()); assertToken(JsonToken.END_OBJECT, jp.nextToken()); assertNull(jp.nextToken()); jp.close(); } }"
                    ],
                    [
                        0.9684649705886841,
                        "public void testThousandsOfSymbolsWithNew() throws IOException { final int SEED = 33333; ByteQuadsCanonicalizer symbolsBRoot = ByteQuadsCanonicalizer.createRoot(SEED); final Charset utf8 = Charset.forName(\\\"UTF-8\\\"); int exp = 0; ByteQuadsCanonicalizer symbolsB = null; for (int doc = 0; doc < 100; ++doc) { symbolsB = symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults()); for (int i = 0; i < 250; ++i) { String name = \\\"f_\\\" + doc + \\\"_\\\" + i; int[] quads = calcQuads(name.getBytes(utf8)); symbolsB.addName(name, quads, quads.length); String n = symbolsB.findName(quads, quads.length); assertEquals(name, n); } symbolsB.release(); exp += 250; if (exp > ByteQuadsCanonicalizer.MAX_ENTRIES_FOR_REUSE) { exp = 0; } assertEquals(exp, symbolsBRoot.size()); } assertEquals(6250, symbolsB.size()); assertEquals(4761, symbolsB.primaryCount()); assertEquals(1190, symbolsB.secondaryCount()); assertEquals(299, symbolsB.tertiaryCount()); assertEquals(0, symbolsB.spilloverCount()); }"
                    ],
                    [
                        0.9681381583213806,
                        "private void doTestInvalidKeyword1(boolean useStream, String value) throws IOException { final String doc = \\\"{ \\\\\"key1\\\\\" : \\\" + value + \\\" }\\\"; JsonParser jp = useStream ? createParserUsingStream(doc, \\\"UTF-8\\\") : createParserUsingReader(doc); assertToken(JsonToken.START_OBJECT, jp.nextToken()); try { assertToken(JsonToken.FIELD_NAME, jp.nextToken()); jp.nextToken(); fail(\\\"Expected an exception for malformed value keyword\\\"); } catch (JsonParseException jex) { verifyException(jex, \\\"Unrecognized token\\\"); verifyException(jex, value); } finally { jp.close(); } jp = useStream ? createParserUsingStream(value, \\\"UTF-8\\\") : createParserUsingReader(value); try { jp.nextToken(); fail(\\\"Expected an exception for malformed value keyword\\\"); } catch (JsonParseException jex) { verifyException(jex, \\\"Unrecognized token\\\"); verifyException(jex, value); } finally { jp.close(); } }"
                    ],
                    [
                        0.9679140448570251,
                        "protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch(codes[c]) { case 1: _decodeEscaped(); break; case 2: _skipUtf8_2(c); break; case 3: _skipUtf8_3(c); break; case 4: _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \\\"string value\\\"); } else { _reportInvalidChar(c); } } } }"
                    ],
                    [
                        0.9676403105258942,
                        "private String _parseName2(int startPtr, int hash, int endChar) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); while (true) { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOF(\\\": was expecting closing '\\\" + ((char) endChar) + \\\"' for name\\\"); } } char c = _inputBuffer[_inputPtr++]; int i = (int) c; if (i <= INT_BACKSLASH) { if (i == INT_BACKSLASH) { c = _decodeEscaped(); } else if (i <= endChar) { if (i == endChar) { break; } if (i < INT_SPACE) { _throwUnquotedSpace(i, \\\"name\\\"); } } } hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n```\n\n```java\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n```\n\n```java\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                -1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(1L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(6L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f2\", p.nextFieldName());\n        assertEquals(11L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n        assertEquals(16L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f3\", p.nextFieldName());\n        assertEquals(17L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n        assertEquals(22L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(\"f4\", p.nextFieldName());\n        assertEquals(28L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n        assertEquals(33L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n        assertEquals(34L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n        assertEquals(39L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n\n        assertEquals(\"f5\", p.nextFieldName());\n        assertEquals(46L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(51L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<6> but was:<1>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic String nextFieldName() throws IOException\n{\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n\n    JsonToken t;\n\n    switch (i) {\n    case '-':\n        t = _parseNegNumber();\n        break;\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        t = _parsePosNumber(i);\n        break;\n    case 'f':\n        _matchFalse();\n        t = JsonToken.VALUE_FALSE;\n        break;\n    case 'n':\n        _matchNull();\n        t = JsonToken.VALUE_NULL;\n        break;\n    case 't':\n        _matchTrue();\n        t = JsonToken.VALUE_TRUE;\n        break;\n    case '[':\n        t = JsonToken.START_ARRAY;\n        break;\n    case '{':\n        t = JsonToken.START_OBJECT;\n        break;\n    default:\n        t = _handleOddValue(i);\n        break;\n    }\n    _nextToken = t;\n    return name;\n}\n",
                            "\n@Override\npublic String nextFieldName() throws IOException\n{\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n\n    JsonToken t;\n\n    switch (i) {\n    case '-':\n        t = _parseNegNumber();\n        break;\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n        t = _parsePosNumber(i);\n        break;\n    case 'f':\n        _matchFalse();\n        t = JsonToken.VALUE_FALSE;\n        break;\n    case 'n':\n        _matchNull();\n        t = JsonToken.VALUE_NULL;\n        break;\n    case 't':\n        _matchTrue();\n        t = JsonToken.VALUE_TRUE;\n        break;\n    case '[':\n        t = JsonToken.START_ARRAY;\n        break;\n    case '{':\n        t = JsonToken.START_OBJECT;\n        break;\n    default:\n        t = _handleOddValue(i);\n        break;\n    }\n    _nextToken = t;\n    return name;\n}\n",
                            "\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        long tokenCharOffset = _inputPtr;\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            _tokenInputTotal = tokenCharOffset;\n            return name;\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        _tokenInputTotal = tokenCharOffset;\n        return name;\n    }\n",
                            "\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n",
                            "\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n\n        JsonToken t;\n\n        switch (i) {\n            case '-':\n                t = _parseNegNumber();\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                t = _parsePosNumber(i);\n                break;\n            case 'f':\n                _matchFalse();\n                t = JsonToken.VALUE_FALSE;\n                break;\n            case 'n':\n                _matchNull();\n                t = JsonToken.VALUE_NULL;\n                break;\n            case 't':\n                _matchTrue();\n                t = JsonToken.VALUE_TRUE;\n                break;\n            case '[':\n                t = JsonToken.START_ARRAY;\n                break;\n            case '{':\n                t = JsonToken.START_OBJECT;\n                break;\n            default:\n                t = _handleOddValue(i);\n                break;\n        }\n        _nextToken = t;\n        return name;\n    }\n",
                            "\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n",
                            "\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        _updateLocation();  // Moved up to fix location issue\n\n        if (i == INT_RBRACKET) {\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n",
                            "\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
                "start_loc": 914,
                "end_loc": 958,
                "buggy_function": "    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n",
                "fixed_function": "    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; switch(i) { case '\\\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\\\"true\\\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\\\"false\\\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\\\"null\\\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleOddValue(i); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; switch(i) { case '\\\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\\\"true\\\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\\\"false\\\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\\\"null\\\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleOddValue(i); }"
                    ],
                    [
                        0.9722148180007935,
                        "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameToMatch.equals(name); } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return nameToMatch.equals(name); }"
                    ],
                    [
                        0.9693151116371155,
                        "@Override public JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); return _nextTokenNotInObject(i); } _updateNameLocation(); String n = _parseName(i); _parsingContext.setCurrentName(n); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; }"
                    ],
                    [
                        0.9662649631500244,
                        "private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation(); switch(i) { case '\\\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\\\"true\\\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\\\"false\\\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\\\"null\\\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleUnexpectedValue(i); }"
                    ],
                    [
                        0.9636877179145813,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return name; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return name; }"
                    ],
                    [
                        0.9606013298034668,
                        "private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException { String n = _parseName(i); _parsingContext.setCurrentName(n); final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch(i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; }"
                    ],
                    [
                        0.9537840485572815,
                        "@Override public final JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); boolean inObject = _parsingContext.inObject(); if (inObject) { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); } JsonToken t; switch(i) { case '\\\"': _tokenIncomplete = true; t = JsonToken.VALUE_STRING; break; case '[': if (!inObject) { _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_ARRAY; break; case '{': if (!inObject) { _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); } t = JsonToken.START_OBJECT; break; case ']': case '}': _reportUnexpectedChar(i, \\\"expected a value\\\"); case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleOddValue(i); break; } if (inObject) { _nextToken = t; return _currToken; } _currToken = t; return t; }"
                    ],
                    [
                        0.9521719813346863,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); final String nameStr = _parseName(i); _parsingContext.setCurrentName(nameStr); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; }"
                    ],
                    [
                        0.948830783367157,
                        "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \\\"-INF\\\" : \\\"+INF\\\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\\\"Non-standard token '\\\" + match + \\\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\\\"); } else if (ch == 'n') { String match = negative ? \\\"-Infinity\\\" : \\\"+Infinity\\\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\\\"Non-standard token '\\\" + match + \\\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\\\"); } } reportUnexpectedNumberChar(ch, \\\"expected digit (0-9) to follow minus sign, for valid numeric value\\\"); return null; }"
                    ],
                    [
                        0.9481629133224487,
                        "public void testLongerObjects() throws Exception { JsonFactory jf = new JsonFactory(); for (int i = 0; i < 2; ++i) { boolean useChars = (i == 0); JsonGenerator jgen; ByteArrayOutputStream bout = new ByteArrayOutputStream(200); if (useChars) { jgen = jf.createGenerator(new OutputStreamWriter(bout, \\\"UTF-8\\\")); } else { jgen = jf.createGenerator(bout, JsonEncoding.UTF8); } jgen.writeStartObject(); for (int rounds = 0; rounds < 1500; ++rounds) { for (int letter = 'a'; letter <= 'z'; ++letter) { for (int index = 0; index < 20; ++index) { String name; if (letter > 'f') { name = \\\"X\\\" + letter + index; } else if (letter > 'p') { name = \\\"\\\" + letter + index; } else { name = \\\"__\\\" + index + letter; } jgen.writeFieldName(name); jgen.writeNumber(index - 1); } jgen.writeRaw('\\n'); } } jgen.writeEndObject(); jgen.close(); byte[] json = bout.toByteArray(); JsonParser jp = jf.createParser(json); assertToken(JsonToken.START_OBJECT, jp.nextToken()); for (int rounds = 0; rounds < 1500; ++rounds) { for (int letter = 'a'; letter <= 'z'; ++letter) { for (int index = 0; index < 20; ++index) { assertToken(JsonToken.FIELD_NAME, jp.nextToken()); String name; if (letter > 'f') { name = \\\"X\\\" + letter + index; } else if (letter > 'p') { name = \\\"\\\" + letter + index; } else { name = \\\"__\\\" + index + letter; } assertEquals(name, jp.getCurrentName()); assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); assertEquals(index - 1, jp.getIntValue()); } } } assertToken(JsonToken.END_OBJECT, jp.nextToken()); jp.close(); } }"
                    ],
                    [
                        0.9480839371681213,
                        "protected void _skipString() throws IOException { _tokenIncomplete = false; final int[] codes = _icUTF8; final byte[] inputBuffer = _inputBuffer; main_loop: while (true) { int c; ascii_loop: while (true) { int ptr = _inputPtr; int max = _inputEnd; if (ptr >= max) { loadMoreGuaranteed(); ptr = _inputPtr; max = _inputEnd; } while (ptr < max) { c = (int) inputBuffer[ptr++] & 0xFF; if (codes[c] != 0) { _inputPtr = ptr; break ascii_loop; } } _inputPtr = ptr; } if (c == INT_QUOTE) { break main_loop; } switch(codes[c]) { case 1: _decodeEscaped(); break; case 2: _skipUtf8_2(c); break; case 3: _skipUtf8_3(c); break; case 4: _skipUtf8_4(c); break; default: if (c < INT_SPACE) { _throwUnquotedSpace(c, \\\"string value\\\"); } else { _reportInvalidChar(c); } } } }"
                    ],
                    [
                        0.948046088218689,
                        "private final int _skipColon() throws IOException { if ((_inputPtr + 4) >= _inputEnd) { return _skipColon2(false); } char c = _inputBuffer[_inputPtr]; if (c == ':') { int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); } if (c == ' ' || c == '\\t') { c = _inputBuffer[++_inputPtr]; } if (c == ':') { int i = _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } if (i == INT_SPACE || i == INT_TAB) { i = (int) _inputBuffer[++_inputPtr]; if (i > INT_SPACE) { if (i == INT_SLASH || i == INT_HASH) { return _skipColon2(true); } ++_inputPtr; return i; } } return _skipColon2(true); } return _skipColon2(false); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
                "start_loc": 960,
                "end_loc": 1014,
                "buggy_function": "    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n",
                "fixed_function": "    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n",
                "comment": "",
                "normalized_body": [
                    "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameToMatch.equals(name); } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return nameToMatch.equals(name); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException { String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameToMatch.equals(name); } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return nameToMatch.equals(name); }"
                    ],
                    [
                        0.987352192401886,
                        "@Override public JsonToken nextToken() throws IOException { if (_currToken == JsonToken.FIELD_NAME) { return _nextAfterName(); } _numTypesValid = NR_UNKNOWN; if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); return (_currToken = null); } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_ARRAY); } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); return (_currToken = JsonToken.END_OBJECT); } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); return _nextTokenNotInObject(i); } _updateNameLocation(); String n = _parseName(i); _parsingContext.setCurrentName(n); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return _currToken; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return _currToken; }"
                    ],
                    [
                        0.986850380897522,
                        "private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException { String n = _parseName(i); _parsingContext.setCurrentName(n); final boolean match = n.equals(str.getValue()); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return match; } JsonToken t; switch(i) { case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return match; }"
                    ],
                    [
                        0.9865748882293701,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { i = _skipComma(i); } _updateLocation(); if (!_parsingContext.inObject()) { _nextTokenNotInObject(i); return null; } String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i); _parsingContext.setCurrentName(name); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return name; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchFalse(); t = JsonToken.VALUE_FALSE; break; case 'n': _matchNull(); t = JsonToken.VALUE_NULL; break; case 't': _matchTrue(); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleOddValue(i); break; } _nextToken = t; return name; }"
                    ],
                    [
                        0.9775093793869019,
                        "private final void _isNextTokenNameYes(int i) throws IOException { _currToken = JsonToken.FIELD_NAME; _updateLocation(); switch(i) { case '\\\"': _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return; case '[': _nextToken = JsonToken.START_ARRAY; return; case '{': _nextToken = JsonToken.START_OBJECT; return; case 't': _matchToken(\\\"true\\\", 1); _nextToken = JsonToken.VALUE_TRUE; return; case 'f': _matchToken(\\\"false\\\", 1); _nextToken = JsonToken.VALUE_FALSE; return; case 'n': _matchToken(\\\"null\\\", 1); _nextToken = JsonToken.VALUE_NULL; return; case '-': _nextToken = _parseNegNumber(); return; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': _nextToken = _parsePosNumber(i); return; } _nextToken = _handleUnexpectedValue(i); }"
                    ],
                    [
                        0.9763486385345459,
                        "@SuppressWarnings(\\\"resource\\\") protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException { ByteArrayBuilder builder = _getByteArrayBuilder(); while (true) { char ch; do { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; } while (ch <= INT_SPACE); int bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (ch == '\\\"') { return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 0); if (bits < 0) { continue; } } int decodedData = bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { bits = _decodeBase64Escape(b64variant, ch, 1); } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 4; builder.append(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 2); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; if (!b64variant.usesPaddingChar(ch)) { throw reportInvalidBase64Char(b64variant, ch, 3, \\\"expected padding character '\\\" + b64variant.getPaddingChar() + \\\"'\\\"); } decodedData >>= 4; builder.append(decodedData); continue; } } decodedData = (decodedData << 6) | bits; if (_inputPtr >= _inputEnd) { loadMoreGuaranteed(); } ch = _inputBuffer[_inputPtr++]; bits = b64variant.decodeBase64Char(ch); if (bits < 0) { if (bits != Base64Variant.BASE64_VALUE_PADDING) { if (ch == '\\\"' && !b64variant.usesPadding()) { decodedData >>= 2; builder.appendTwoBytes(decodedData); return builder.toByteArray(); } bits = _decodeBase64Escape(b64variant, ch, 3); } if (bits == Base64Variant.BASE64_VALUE_PADDING) { decodedData >>= 2; builder.appendTwoBytes(decodedData); continue; } } decodedData = (decodedData << 6) | bits; builder.appendThreeBytes(decodedData); } }"
                    ],
                    [
                        0.9763140082359314,
                        "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException { if (ch == 'I') { if (_inputPtr >= _inputEnd) { if (!loadMore()) { _reportInvalidEOFInValue(); } } ch = _inputBuffer[_inputPtr++]; if (ch == 'N') { String match = negative ? \\\"-INF\\\" : \\\"+INF\\\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\\\"Non-standard token '\\\" + match + \\\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\\\"); } else if (ch == 'n') { String match = negative ? \\\"-Infinity\\\" : \\\"+Infinity\\\"; _matchToken(match, 3); if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY); } _reportError(\\\"Non-standard token '\\\" + match + \\\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\\\"); } } reportUnexpectedNumberChar(ch, \\\"expected digit (0-9) to follow minus sign, for valid numeric value\\\"); return null; }"
                    ],
                    [
                        0.9762457013130188,
                        "public void testThousandsOfSymbolsWithNew() throws IOException { final int SEED = 33333; ByteQuadsCanonicalizer symbolsBRoot = ByteQuadsCanonicalizer.createRoot(SEED); final Charset utf8 = Charset.forName(\\\"UTF-8\\\"); int exp = 0; ByteQuadsCanonicalizer symbolsB = null; for (int doc = 0; doc < 100; ++doc) { symbolsB = symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults()); for (int i = 0; i < 250; ++i) { String name = \\\"f_\\\" + doc + \\\"_\\\" + i; int[] quads = calcQuads(name.getBytes(utf8)); symbolsB.addName(name, quads, quads.length); String n = symbolsB.findName(quads, quads.length); assertEquals(name, n); } symbolsB.release(); exp += 250; if (exp > ByteQuadsCanonicalizer.MAX_ENTRIES_FOR_REUSE) { exp = 0; } assertEquals(exp, symbolsBRoot.size()); } assertEquals(6250, symbolsB.size()); assertEquals(4761, symbolsB.primaryCount()); assertEquals(1190, symbolsB.secondaryCount()); assertEquals(299, symbolsB.tertiaryCount()); assertEquals(0, symbolsB.spilloverCount()); }"
                    ],
                    [
                        0.9755940437316895,
                        "@SuppressWarnings(\\\"resource\\\") private void _testCommentsBetweenArrayValues(JsonFactory f, boolean useStream, String comment) throws Exception { for (String tmpl : new String[] { \\\"%s,\\\", \\\" %s,\\\", \\\"\\t%s,\\\", \\\"%s ,\\\", \\\"%s\\t,\\\", \\\" %s ,\\\", \\\"\\t%s\\t,\\\", \\\"\\n%s,\\\", \\\"%s\\n,\\\" }) { String commented = String.format(tmpl, comment); final String DOC = \\\"[1\\\" + commented + \\\"2]\\\"; JsonParser jp = useStream ? f.createParser(DOC.getBytes(\\\"UTF-8\\\")) : f.createParser(DOC); assertEquals(JsonToken.START_ARRAY, jp.nextToken()); JsonToken t = null; try { t = jp.nextToken(); } catch (Exception e) { throw new RuntimeException(\\\"Failed on '\\\" + DOC + \\\"' due to \\\" + e, e); } assertEquals(JsonToken.VALUE_NUMBER_INT, t); assertEquals(1, jp.getIntValue()); try { t = jp.nextToken(); } catch (Exception e) { throw new RuntimeException(\\\"Failed on '\\\" + DOC + \\\"' due to \\\" + e, e); } assertEquals(JsonToken.VALUE_NUMBER_INT, t); assertEquals(2, jp.getIntValue()); assertEquals(JsonToken.END_ARRAY, jp.nextToken()); jp.close(); } }"
                    ],
                    [
                        0.975116491317749,
                        "@SuppressWarnings(\\\"resource\\\") private void _testLongText(int LEN) throws Exception { StringBuilder sb = new StringBuilder(LEN + 100); Random r = new Random(99); while (sb.length() < LEN) { sb.append(r.nextInt()); sb.append(\\\" xyz foo\\\"); if (r.nextBoolean()) { sb.append(\\\" and \\\\\"bar\\\\\"\\\"); } else if (r.nextBoolean()) { sb.append(\\\" [whatever].... \\\"); } else { sb.append(\\\" UTF-8-fu: try this {\\u00E2/\\u0BF8/\\uA123!} (look funny?)\\\"); } if (r.nextBoolean()) { if (r.nextBoolean()) { sb.append('\\n'); } else if (r.nextBoolean()) { sb.append('\\r'); } else { sb.append(\\\"\\r\\n\\\"); } } } final String VALUE = sb.toString(); StringWriter sw = new StringWriter(LEN + (LEN >> 2)); JsonGenerator jg = JSON_FACTORY.createGenerator(sw); jg.writeStartObject(); jg.writeFieldName(\\\"doc\\\"); jg.writeString(VALUE); jg.writeEndObject(); jg.close(); final String DOC = sw.toString(); for (int type = 0; type < 3; ++type) { JsonParser jp; switch(type) { default: jp = JSON_FACTORY.createParser(DOC.getBytes(\\\"UTF-8\\\")); break; case 1: jp = JSON_FACTORY.createParser(DOC); break; case 2: jp = JSON_FACTORY.createParser(encodeInUTF32BE(DOC)); break; } assertToken(JsonToken.START_OBJECT, jp.nextToken()); assertToken(JsonToken.FIELD_NAME, jp.nextToken()); assertEquals(\\\"doc\\\", jp.getCurrentName()); assertToken(JsonToken.VALUE_STRING, jp.nextToken()); String act = getAndVerifyText(jp); if (act.length() != VALUE.length()) { fail(\\\"Expected length \\\" + VALUE.length() + \\\", got \\\" + act.length()); } if (!act.equals(VALUE)) { fail(\\\"Long text differs\\\"); } assertEquals(\\\"doc\\\", jp.getCurrentName()); assertToken(JsonToken.END_OBJECT, jp.nextToken()); assertNull(jp.nextToken()); jp.close(); } }"
                    ],
                    [
                        0.9750461578369141,
                        "public JsonEncoding detectEncoding() throws IOException { boolean foundEncoding = false; if (ensureLoaded(4)) { int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); if (handleBOM(quad)) { foundEncoding = true; } else { if (checkUTF32(quad)) { foundEncoding = true; } else if (checkUTF16(quad >>> 16)) { foundEncoding = true; } } } else if (ensureLoaded(2)) { int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); if (checkUTF16(i16)) { foundEncoding = true; } } JsonEncoding enc; if (!foundEncoding) { enc = JsonEncoding.UTF8; } else { switch(_bytesPerChar) { case 1: enc = JsonEncoding.UTF8; break; case 2: enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; break; case 4: enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; break; default: throw new RuntimeException(\\\"Internal error\\\"); } } _context.setEncoding(enc); return enc; }"
                    ],
                    [
                        0.9750280380249023,
                        "@Override public String nextFieldName() throws IOException { _numTypesValid = NR_UNKNOWN; if (_currToken == JsonToken.FIELD_NAME) { _nextAfterName(); return null; } if (_tokenIncomplete) { _skipString(); } int i = _skipWSOrEnd(); if (i < 0) { close(); _currToken = null; return null; } _binaryValue = null; if (i == INT_RBRACKET) { _updateLocation(); if (!_parsingContext.inArray()) { _reportMismatchedEndMarker(i, '}'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_ARRAY; return null; } if (i == INT_RCURLY) { _updateLocation(); if (!_parsingContext.inObject()) { _reportMismatchedEndMarker(i, ']'); } _parsingContext = _parsingContext.getParent(); _currToken = JsonToken.END_OBJECT; return null; } if (_parsingContext.expectComma()) { if (i != INT_COMMA) { _reportUnexpectedChar(i, \\\"was expecting comma to separate \\\" + _parsingContext.getTypeDesc() + \\\" entries\\\"); } i = _skipWS(); } if (!_parsingContext.inObject()) { _updateLocation(); _nextTokenNotInObject(i); return null; } _updateNameLocation(); final String nameStr = _parseName(i); _parsingContext.setCurrentName(nameStr); _currToken = JsonToken.FIELD_NAME; i = _skipColon(); _updateLocation(); if (i == INT_QUOTE) { _tokenIncomplete = true; _nextToken = JsonToken.VALUE_STRING; return nameStr; } JsonToken t; switch(i) { case '-': t = _parseNegNumber(); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': t = _parsePosNumber(i); break; case 'f': _matchToken(\\\"false\\\", 1); t = JsonToken.VALUE_FALSE; break; case 'n': _matchToken(\\\"null\\\", 1); t = JsonToken.VALUE_NULL; break; case 't': _matchToken(\\\"true\\\", 1); t = JsonToken.VALUE_TRUE; break; case '[': t = JsonToken.START_ARRAY; break; case '{': t = JsonToken.START_OBJECT; break; default: t = _handleUnexpectedValue(i); } _nextToken = t; return nameStr; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java",
                "start_loc": 2667,
                "end_loc": 2675,
                "buggy_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                -1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                "fixed_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    -1L, _nameInputTotal, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                -1L, _tokenInputTotal, _tokenInputRow,\n                getTokenColumnNr());\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr()); }"
                    ],
                    [
                        0.9679077863693237,
                        "@Override public int read() throws IOException { if (_b != null) { int c = _b[_ptr++] & 0xFF; if (_ptr >= _end) { _free(); } return c; } return _in.read(); }"
                    ],
                    [
                        0.9667924642562866,
                        "@Override public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { jg.writeRaw(\\\"(\\\" + nrOfEntries + \\\")}\\\"); }"
                    ],
                    [
                        0.9631932973861694,
                        "@Override public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { jg.writeRaw(\\\"(\\\" + nrOfValues + \\\")]\\\"); }"
                    ],
                    [
                        0.9629842042922974,
                        "@Override public void flush() throws IOException { if (_out != null) { if (_outPtr > 0) { _out.write(_outBuffer, 0, _outPtr); _outPtr = 0; } _out.flush(); } }"
                    ],
                    [
                        0.9620677828788757,
                        "@Override public BigInteger getBigIntegerValue() throws IOException { if ((_numTypesValid & NR_BIGINT) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_BIGINT); } if ((_numTypesValid & NR_BIGINT) == 0) { convertNumberToBigInteger(); } } return _numberBigInt; }"
                    ],
                    [
                        0.9577662348747253,
                        "@Override public void run() { try { while (true) { parse(jf, INPUT); count.addAndGet(1); } } catch (IOException e) { System.err.println(\\\"PROBLEM: \\\" + e); } }"
                    ],
                    [
                        0.9577605724334717,
                        "@Override public void writeEndArray(JsonGenerator jg, int nrOfValues) throws IOException, JsonGenerationException { jg.writeRaw(']'); }"
                    ],
                    [
                        0.9574965834617615,
                        "@Override public int available() throws IOException { if (_b != null) { return _end - _ptr; } return _in.available(); }"
                    ],
                    [
                        0.9574171304702759,
                        "@Override public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException, JsonGenerationException { jg.writeRaw('}'); }"
                    ],
                    [
                        0.9567098617553711,
                        "@Override public void writeRawValue(String text) throws IOException { if (_checkRawValueWrite()) { delegate.writeRaw(text); } }"
                    ],
                    [
                        0.9566344022750854,
                        "@Override public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException { _reportUnsupportedOperation(); return 0; }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            /* 19-Feb-2009, tatu: Should actually close/release things\n             *    like input source, symbol table and recyclable buffers now.\n             */\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_ARRAY);\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            return (_currToken = JsonToken.END_OBJECT);\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n```\n\n```java\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return null;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n        }\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n```\n\n```java\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                -1L, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(1L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(6L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f2\", p.nextFieldName());\n        assertEquals(11L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n        assertEquals(16L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f3\", p.nextFieldName());\n        assertEquals(17L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n        assertEquals(22L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(\"f4\", p.nextFieldName());\n        assertEquals(28L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n        assertEquals(33L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n        assertEquals(34L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n        assertEquals(39L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n\n        assertEquals(\"f5\", p.nextFieldName());\n        assertEquals(46L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(51L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<6> but was:<1>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic JsonLocation getTokenLocation()\n{\n    final Object src = _ioContext.getSourceReference();\n    return new JsonLocation(src,\n            (_tokenInputPtr >= 0) ? _tokenInputPtr : -1L,\n            getTokenCharacterOffset(),\n            getTokenLineNr(),\n            getTokenColumnNr());\n}\n",
                            "\n@Override\npublic JsonLocation getTokenLocation()\n{\n    final Object src = _ioContext.getSourceReference();\n    return new JsonLocation(src,\n            getTokenCharacterOffset(), -1L,\n            getTokenLineNr(),\n            getTokenColumnNr());\n}\n",
                            "\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                _tokenInputTotal, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                            "\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        long offset = _tokenInputTotal - 1; // adjust offset to match expectations\n        return new JsonLocation(src,\n                offset, getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n",
                            "\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                getTokenCharacterOffset(),\n                -1L, getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                            "\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                getTokenCharacterOffset(), getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                            "\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                getTokenCharacterOffset(),  // Changed from -1L to correct offset\n                getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                            "\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        return new JsonLocation(src,\n                getTokenCharacterOffset(), getTokenCharacterOffset(),\n                getTokenLineNr(),\n                getTokenColumnNr());\n    }\n\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java",
                "start_loc": 3613,
                "end_loc": 3624,
                "buggy_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                getTokenCharacterOffset(), -1L, getTokenLineNr(),\n                getTokenColumnNr());\n    }\n",
                "fixed_function": "    @Override\n    public JsonLocation getTokenLocation()\n    {\n        final Object src = _ioContext.getSourceReference();\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return new JsonLocation(src,\n                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n        }\n        return new JsonLocation(src,\n                _tokenInputTotal, -1L, _tokenInputRow,\n                getTokenColumnNr());\n    }\n",
                "comment": "    // As per [core#108], must ensure we call the right method\n",
                "normalized_body": [
                    "@Override public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr()); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public JsonLocation getTokenLocation() { final Object src = _ioContext.getSourceReference(); if (_currToken == JsonToken.FIELD_NAME) { return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol); } return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr()); }"
                    ],
                    [
                        0.9501259326934814,
                        "@Override public String getValueAsString() throws IOException { if (_currToken == JsonToken.VALUE_STRING) { if (_tokenIncomplete) { _tokenIncomplete = false; return _finishAndReturnString(); } return _textBuffer.contentsAsString(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } return super.getValueAsString(null); }"
                    ],
                    [
                        0.9466924667358398,
                        "public static JsonPointer compile(String input) throws IllegalArgumentException { if ((input == null) || input.length() == 0) { return EMPTY; } if (input.charAt(0) != '/') { throw new IllegalArgumentException(\\\"Invalid input: JSON Pointer expression must start with '/': \\\" + \\\"\\\\\"\\\" + input + \\\"\\\\\"\\\"); } return _parseTail(input); }"
                    ],
                    [
                        0.9452360272407532,
                        "@Override public BigDecimal getDecimalValue() throws IOException { if ((_numTypesValid & NR_BIGDECIMAL) == 0) { if (_numTypesValid == NR_UNKNOWN) { _parseNumericValue(NR_BIGDECIMAL); } if ((_numTypesValid & NR_BIGDECIMAL) == 0) { convertNumberToBigDecimal(); } } return _numberBigDecimal; }"
                    ],
                    [
                        0.9431251287460327,
                        "@Override public JsonParser enable(Feature f) { _features |= f.getMask(); if (f == Feature.STRICT_DUPLICATE_DETECTION) { if (_parsingContext.getDupDetector() == null) { _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this)); } } return this; }"
                    ],
                    [
                        0.943023681640625,
                        "@Override public String getValueAsString(String defaultValue) throws IOException { if (_currToken == JsonToken.VALUE_STRING) { return getText(); } if (_currToken == JsonToken.FIELD_NAME) { return getCurrentName(); } if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) { return defaultValue; } return getText(); }"
                    ],
                    [
                        0.9415155053138733,
                        "@Override public void writeEndObject() throws IOException, JsonGenerationException { if (!_writeContext.inObject()) { _reportError(\\\"Current context not an object but \\\" + _writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = '}'; } _writeContext = _writeContext.getParent(); }"
                    ],
                    [
                        0.9401888251304626,
                        "protected JsonPointer _constructHead(int suffixLength, JsonPointer last) { if (this == last) { return EMPTY; } JsonPointer next = _nextSegment; String str = _asString; return new JsonPointer(str.substring(0, str.length() - suffixLength), _matchingPropertyName, _matchingElementIndex, next._constructHead(suffixLength, last)); }"
                    ],
                    [
                        0.9397240877151489,
                        "@Override public void writeEndArray() throws IOException, JsonGenerationException { if (!_writeContext.inArray()) { _reportError(\\\"Current context not an ARRAY but \\\" + _writeContext.getTypeDesc()); } if (_cfgPrettyPrinter != null) { _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount()); } else { if (_outputTail >= _outputEnd) { _flushBuffer(); } _outputBuffer[_outputTail++] = ']'; } _writeContext = _writeContext.getParent(); }"
                    ],
                    [
                        0.9383863806724548,
                        "public void testSimpleDupsChars() throws Exception { JsonFactory nonDupF = new JsonFactory(); JsonFactory dupF = new JsonFactory(); dupF.enable(JsonParser.Feature.STRICT_DUPLICATE_DETECTION); for (String doc : DUP_DOCS) { _testSimpleDupsFail(doc, dupF, false, \\\"a\\\", false); _testSimpleDupsFail(doc, nonDupF, false, \\\"a\\\", true); } }"
                    ],
                    [
                        0.937989354133606,
                        "protected String getAndVerifyText(JsonParser jp) throws IOException { int actLen = jp.getTextLength(); char[] ch = jp.getTextCharacters(); String str2 = new String(ch, jp.getTextOffset(), actLen); String str = jp.getText(); if (str.length() != actLen) { fail(\\\"Internal problem (jp.token == \\\" + jp.getCurrentToken() + \\\"): jp.getText().length() ['\\\" + str + \\\"'] == \\\" + str.length() + \\\"; jp.getTextLength() == \\\" + actLen); } assertEquals(\\\"String access via getText(), getTextXxx() must be the same\\\", str, str2); return str; }"
                    ],
                    [
                        0.9369644522666931,
                        "private char _verifyNLZ2() throws IOException { if (_inputPtr >= _inputEnd && !loadMore()) { return '0'; } char ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { reportInvalidNumber(\\\"Leading zeroes not allowed\\\"); } ++_inputPtr; if (ch == INT_0) { while (_inputPtr < _inputEnd || loadMore()) { ch = _inputBuffer[_inputPtr]; if (ch < '0' || ch > '9') { return '0'; } ++_inputPtr; if (ch != '0') { break; } } } return ch; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            }
        ],
        "trigger_test": {
            "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader": {
                "path": "src/test/java/com/fasterxml/jackson/core/json/LocationInObjectTest.java",
                "function_name": "testOffsetWithObjectFieldsUsingReader",
                "src": "    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n\n        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n        assertEquals(1L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n        assertEquals(6L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f2\", p.nextFieldName());\n        assertEquals(11L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n        assertEquals(16L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(\"f3\", p.nextFieldName());\n        assertEquals(17L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n        assertEquals(22L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        assertEquals(\"f4\", p.nextFieldName());\n        assertEquals(28L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n        assertEquals(33L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n        assertEquals(34L, p.getTokenLocation().getCharOffset());\n\n        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n        assertEquals(39L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n\n        assertEquals(\"f5\", p.nextFieldName());\n        assertEquals(46L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n        assertEquals(51L, p.getTokenLocation().getCharOffset());\n        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<6> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:159)\n\tat junit.framework.Assert.assertEquals(Assert.java:166)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:324)\n\tat com.fasterxml.jackson.core.json.LocationInObjectTest.testOffsetWithObjectFieldsUsingReader(LocationInObjectTest.java:66)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<6> but was:<1>\n\tat com.fasterxml.jackson.core.json.LocationInObjectTest.testOffsetWithObjectFieldsUsingReader(LocationInObjectTest.java:66)  assertEquals(6L, p.getTokenLocation().getCharOffset());"
            }
        },
        "evaluation_done": true
    }
}