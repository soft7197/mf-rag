{
    "JxPath-16": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java",
                "start_loc": 117,
                "end_loc": 167,
                "buggy_function": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                "fixed_function": "    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                "comment": "    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n",
                "normalized_body": [
                    "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType() != Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch(((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE: return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT: return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT: return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI: return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType() != Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch(((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE: return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT: return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT: return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI: return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }"
                    ],
                    [
                        0.9892241358757019,
                        "private static NodePointer doPredicateName(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { Expression predicate = predicates[currentPredicate]; String key = keyFromPredicate(context, predicate); NodePointer child = valuePointer(parent); if (child instanceof PropertyOwnerPointer) { PropertyPointer pointer = ((PropertyOwnerPointer) child).getPropertyPointer(); pointer.setPropertyName(key); if (pointer.isActual()) { return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); } } else if (child.isCollection()) { NodePointer bestMatch = null; int bestQuality = 0; child = (NodePointer) child.clone(); int count = child.getLength(); for (int i = 0; i < count; i++) { child.setIndex(i); NodePointer valuePointer = valuePointer(child); NodePointer pointer; if ((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()) { pointer = doPredicateName(context, valuePointer, steps, currentStep, predicates, currentPredicate); } else if (isNameAttributeEqual(valuePointer, key)) { pointer = doPredicate(context, valuePointer, steps, currentStep, predicates, currentPredicate + 1); } else { pointer = null; } if (pointer != null) { int quality = computeQuality(pointer); if (quality == PERFECT_MATCH) { return pointer; } if (quality > bestQuality) { bestMatch = (NodePointer) pointer.clone(); bestQuality = quality; } } } if (bestMatch != null) { return bestMatch; } } else { NodePointer found = doPredicatesStandard(context, Collections.singletonList(child), steps, currentStep, predicates, currentPredicate); if (found != null) { return found; } } return createNullPointerForPredicates(context, child, steps, currentStep, predicates, currentPredicate); }"
                    ],
                    [
                        0.9869058132171631,
                        "public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (!(node instanceof Element)) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { String nodeNS = JDOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { switch(((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE: return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT: return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT: return node instanceof Comment; case Compiler.NODE_TYPE_PI: return node instanceof ProcessingInstruction; } return false; } if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } return false; }"
                    ],
                    [
                        0.9855855703353882,
                        "protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { if (nodeTest instanceof NodeNameTest) { QName qname = ((NodeNameTest) nodeTest).getNodeName(); String prefix = qname.getPrefix(); if (prefix != null) { String namespaceURI = context.getJXPathContext().getNamespaceURI(prefix); nodeTest = new NodeNameTest(qname, namespaceURI); } } switch(axis) { case Compiler.AXIS_ANCESTOR: return new AncestorContext(context, false, nodeTest); case Compiler.AXIS_ANCESTOR_OR_SELF: return new AncestorContext(context, true, nodeTest); case Compiler.AXIS_ATTRIBUTE: return new AttributeContext(context, nodeTest); case Compiler.AXIS_CHILD: return new ChildContext(context, nodeTest, false, false); case Compiler.AXIS_DESCENDANT: return new DescendantContext(context, false, nodeTest); case Compiler.AXIS_DESCENDANT_OR_SELF: return new DescendantContext(context, true, nodeTest); case Compiler.AXIS_FOLLOWING: return new PrecedingOrFollowingContext(context, nodeTest, false); case Compiler.AXIS_FOLLOWING_SIBLING: return new ChildContext(context, nodeTest, true, false); case Compiler.AXIS_NAMESPACE: return new NamespaceContext(context, nodeTest); case Compiler.AXIS_PARENT: return new ParentContext(context, nodeTest); case Compiler.AXIS_PRECEDING: return new PrecedingOrFollowingContext(context, nodeTest, true); case Compiler.AXIS_PRECEDING_SIBLING: return new ChildContext(context, nodeTest, true, true); case Compiler.AXIS_SELF: return new SelfContext(context, nodeTest); default: return null; } }"
                    ],
                    [
                        0.9853518605232239,
                        "private static String findFactory(String property, String defaultFactory) { try { String systemProp = System.getProperty(property); if (systemProp != null) { if (debug) { System.err.println(\\\"JXPath: found system property\\\" + systemProp); } return systemProp; } } catch (SecurityException se) { } try { String javah = System.getProperty(\\\"java.home\\\"); String configFile = javah + File.separator + \\\"lib\\\" + File.separator + \\\"jxpath.properties\\\"; File f = new File(configFile); if (f.exists()) { Properties props = new Properties(); props.load(new FileInputStream(f)); String factory = props.getProperty(property); if (factory != null) { if (debug) { System.err.println(\\\"JXPath: found java.home property \\\" + factory); } return factory; } } } catch (Exception ex) { if (debug) { ex.printStackTrace(); } } String serviceId = \\\"META-INF/services/\\\" + property; try { ClassLoader cl = JXPathContextFactory.class.getClassLoader(); InputStream is = null; if (cl == null) { is = ClassLoader.getSystemResourceAsStream(serviceId); } else { is = cl.getResourceAsStream(serviceId); } if (is != null) { if (debug) { System.err.println(\\\"JXPath: found \\\" + serviceId); } BufferedReader rd = new BufferedReader(new InputStreamReader(is)); String factory = rd.readLine(); rd.close(); if (factory != null && !\\\"\\\".equals(factory)) { if (debug) { System.err.println(\\\"JXPath: loaded from services: \\\" + factory); } return factory; } } } catch (Exception ex) { if (debug) { ex.printStackTrace(); } } return defaultFactory; }"
                    ],
                    [
                        0.9827759861946106,
                        "public String asPath() { if (id != null) { return \\\"id('\\\" + escape(id) + \\\"')\\\"; } StringBuffer buffer = new StringBuffer(); if (parent != null) { buffer.append(parent.asPath()); } switch(node.getNodeType()) { case Node.ELEMENT_NODE: if (parent instanceof DOMNodePointer) { if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { buffer.append('/'); } String ln = DOMNodePointer.getLocalName(node); String nsURI = getNamespaceURI(); if (nsURI == null) { buffer.append(ln); buffer.append('['); buffer.append(getRelativePositionByName()).append(']'); } else { String prefix = getNamespaceResolver().getPrefix(nsURI); if (prefix != null) { buffer.append(prefix); buffer.append(':'); buffer.append(ln); buffer.append('['); buffer.append(getRelativePositionByName()); buffer.append(']'); } else { buffer.append(\\\"node()\\\"); buffer.append('['); buffer.append(getRelativePositionOfElement()); buffer.append(']'); } } } break; case Node.TEXT_NODE: case Node.CDATA_SECTION_NODE: buffer.append(\\\"/text()\\\"); buffer.append('['); buffer.append(getRelativePositionOfTextNode()).append(']'); break; case Node.PROCESSING_INSTRUCTION_NODE: buffer.append(\\\"/processing-instruction(\\'\\\"); buffer.append(((ProcessingInstruction) node).getTarget()).append(\\\"')\\\"); buffer.append('['); buffer.append(getRelativePositionOfPI()).append(']'); break; case Node.DOCUMENT_NODE: } return buffer.toString(); }"
                    ],
                    [
                        0.9813107848167419,
                        "public Object convert(Object object, final Class toType) { if (object == null) { return toType.isPrimitive() ? convertNullToPrimitive(toType) : null; } if (toType == Object.class) { if (object instanceof NodeSet) { return convert(((NodeSet) object).getValues(), toType); } if (object instanceof Pointer) { return convert(((Pointer) object).getValue(), toType); } return object; } final Class useType = TypeUtils.wrapPrimitive(toType); Class fromType = object.getClass(); if (useType.isAssignableFrom(fromType)) { return object; } if (fromType.isArray()) { int length = Array.getLength(object); if (useType.isArray()) { Class cType = useType.getComponentType(); Object array = Array.newInstance(cType, length); for (int i = 0; i < length; i++) { Object value = Array.get(object, i); Array.set(array, i, convert(value, cType)); } return array; } if (Collection.class.isAssignableFrom(useType)) { Collection collection = allocateCollection(useType); for (int i = 0; i < length; i++) { collection.add(Array.get(object, i)); } return unmodifiableCollection(collection); } if (length > 0) { Object value = Array.get(object, 0); return convert(value, useType); } return convert(\\\"\\\", useType); } if (object instanceof Collection) { int length = ((Collection) object).size(); if (useType.isArray()) { Class cType = useType.getComponentType(); Object array = Array.newInstance(cType, length); Iterator it = ((Collection) object).iterator(); for (int i = 0; i < length; i++) { Object value = it.next(); Array.set(array, i, convert(value, cType)); } return array; } if (Collection.class.isAssignableFrom(useType)) { Collection collection = allocateCollection(useType); collection.addAll((Collection) object); return unmodifiableCollection(collection); } if (length > 0) { Object value; if (object instanceof List) { value = ((List) object).get(0); } else { Iterator it = ((Collection) object).iterator(); value = it.next(); } return convert(value, useType); } return convert(\\\"\\\", useType); } if (object instanceof NodeSet) { return convert(((NodeSet) object).getValues(), useType); } if (object instanceof Pointer) { return convert(((Pointer) object).getValue(), useType); } if (useType == String.class) { return object.toString(); } if (object instanceof Boolean) { if (Number.class.isAssignableFrom(useType)) { return allocateNumber(useType, ((Boolean) object).booleanValue() ? 1 : 0); } if (\\\"java.util.concurrent.atomic.AtomicBoolean\\\".equals(useType.getName())) { try { return useType.getConstructor(new Class[] { boolean.class }).newInstance(new Object[] { object }); } catch (Exception e) { throw new JXPathTypeConversionException(useType.getName(), e); } } } if (object instanceof Number) { double value = ((Number) object).doubleValue(); if (useType == Boolean.class) { return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; } if (Number.class.isAssignableFrom(useType)) { return allocateNumber(useType, value); } } if (object instanceof String) { Object value = convertStringToPrimitive(object, useType); if (value != null) { return value; } } Converter converter = ConvertUtils.lookup(useType); if (converter != null) { return converter.convert(useType, object); } throw new JXPathTypeConversionException(\\\"Cannot convert \\\" + object.getClass() + \\\" to \\\" + useType); }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisFollowing",
                    "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisPreceding"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }\n```\n#Error message: junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)  assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n \n#Test method 2:\n```java\n    public void testAxisPreceding() {\n        // preceding::\n        assertXPathPointer(\n                context,\n                \"//location[2]/preceding-sibling::location//street\",\n        \"/vendor[1]/location[1]/address[1]/street[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::*[1]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[4]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n    }\n```\n#Error message: junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/preceding::node()[3]> expected:<...ndor[1]/location[1]/[employeeCount[1]/text()][1]> but was:<...ndor[1]/location[1]/[address][1]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisPreceding(XMLModelTestCase.java:474)  assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Match any node\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE && node.getNodeType() != Node.ATTRIBUTE_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE:\n                    return true;\n                case Compiler.NODE_TYPE_TEXT:\n                    return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT:\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI:\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && (testPrefix == null || testPrefix.isEmpty())) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.COMMENT_NODE\n                            || nodeType == Node.CDATA_SECTION_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Changed to consider any node type\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Changed to return true for any node type\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.COMMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.CDATA_SECTION_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE:\n                    // Fixed condition for NODE_TYPE_NODE\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.COMMENT_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                case Compiler.NODE_TYPE_TEXT:\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT:\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI:\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                String nodePrefix = getPrefix(node);\n                return (equalStrings(namespaceURI, nodeNS) || (nodeNS == null && equalStrings(testPrefix, nodePrefix)))\n                        || (wildcard && equalStrings(testPrefix, nodePrefix));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.CDATA_SECTION_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE\n                            || nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || \n                       (nodeNS == null && namespaceURI == null) || \n                       (nodeNS == null && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Match any node type\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI == null || testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Match any node\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE && node.getNodeType() != Node.ATTRIBUTE_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE:\n                    return true;\n                case Compiler.NODE_TYPE_TEXT:\n                    return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT:\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI:\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && (testPrefix == null || testPrefix.isEmpty())) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.COMMENT_NODE\n                            || nodeType == Node.CDATA_SECTION_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Changed to consider any node type\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.COMMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.CDATA_SECTION_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    /**\n     * Test a Node.\n     * @param node to test\n     * @param test to execute\n     * @return true if node passes test\n     */\n\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE:\n                    // Fixed condition for NODE_TYPE_NODE\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.COMMENT_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n                case Compiler.NODE_TYPE_TEXT:\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT:\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI:\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                String nodePrefix = getPrefix(node);\n                return (equalStrings(namespaceURI, nodeNS) || (nodeNS == null && equalStrings(testPrefix, nodePrefix)))\n                        || (wildcard && equalStrings(testPrefix, nodePrefix));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return nodeType == Node.ELEMENT_NODE\n                            || nodeType == Node.DOCUMENT_NODE\n                            || nodeType == Node.TEXT_NODE\n                            || nodeType == Node.CDATA_SECTION_NODE\n                            || nodeType == Node.PROCESSING_INSTRUCTION_NODE\n                            || nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n",
                            "\n    public static boolean testNode(Node node, NodeTest test) {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(DOMNodePointer.getLocalName(node))) {\n                String nodeNS = DOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || \n                       (nodeNS == null && namespaceURI == null) || \n                       (nodeNS == null && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            int nodeType = node.getNodeType();\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Match any node type\n                case Compiler.NODE_TYPE_TEXT :\n                    return nodeType == Node.CDATA_SECTION_NODE\n                        || nodeType == Node.TEXT_NODE;\n                case Compiler.NODE_TYPE_COMMENT :\n                    return nodeType == Node.COMMENT_NODE;\n                case Compiler.NODE_TYPE_PI :\n                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest) {\n            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n                String testPI = ((ProcessingInstructionTest) test).getTarget();\n                String nodePI = ((ProcessingInstruction) node).getTarget();\n                return testPI == null || testPI.equals(nodePI);\n            }\n        }\n        return false;\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java",
                "start_loc": 358,
                "end_loc": 407,
                "buggy_function": "    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return (node instanceof Element) || (node instanceof Document);\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n",
                "fixed_function": "    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (!(node instanceof Element)) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { String nodeNS = JDOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { switch(((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE: return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT: return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT: return node instanceof Comment; case Compiler.NODE_TYPE_PI: return node instanceof ProcessingInstruction; } return false; } if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } return false; }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (!(node instanceof Element)) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { String nodeNS = JDOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { switch(((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE: return (node instanceof Element) || (node instanceof Document); case Compiler.NODE_TYPE_TEXT: return (node instanceof Text) || (node instanceof CDATA); case Compiler.NODE_TYPE_COMMENT: return node instanceof Comment; case Compiler.NODE_TYPE_PI: return node instanceof ProcessingInstruction; } return false; } if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } return false; }"
                    ],
                    [
                        0.9869059324264526,
                        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType() != Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch(((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE: return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT: return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT: return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI: return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }"
                    ],
                    [
                        0.9838866591453552,
                        "private static NodePointer doStepPredicatesStandard(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { Step step = steps[currentStep]; Expression[] predicates = step.getPredicates(); int axis = step.getAxis(); if (axis == Compiler.AXIS_SELF) { return doPredicate(context, parent, steps, currentStep, predicates, 0); } Expression predicate = predicates[0]; if (predicates.length == 1) { NodeIterator it = getNodeIterator(context, parent, step); NodePointer pointer = null; if (it != null) { if (predicate instanceof NameAttributeTest) { String key = keyFromPredicate(context, predicate); for (int i = 1; it.setPosition(i); i++) { NodePointer ptr = it.getNodePointer(); if (isNameAttributeEqual(ptr, key)) { pointer = ptr; break; } } } else { int index = indexFromPredicate(context, predicate); if (it.setPosition(index + 1)) { pointer = it.getNodePointer(); } } } if (pointer != null) { return doStep(context, pointer, steps, currentStep + 1); } } else { NodeIterator it = getNodeIterator(context, parent, step); if (it != null) { List list = new ArrayList(); for (int i = 1; it.setPosition(i); i++) { list.add(it.getNodePointer()); } NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0); if (pointer != null) { return pointer; } } } return createNullPointer(context, parent, steps, currentStep); }"
                    ],
                    [
                        0.9817062616348267,
                        "private static String findFactory(String property, String defaultFactory) { try { String systemProp = System.getProperty(property); if (systemProp != null) { if (debug) { System.err.println(\\\"JXPath: found system property\\\" + systemProp); } return systemProp; } } catch (SecurityException se) { } try { String javah = System.getProperty(\\\"java.home\\\"); String configFile = javah + File.separator + \\\"lib\\\" + File.separator + \\\"jxpath.properties\\\"; File f = new File(configFile); if (f.exists()) { Properties props = new Properties(); props.load(new FileInputStream(f)); String factory = props.getProperty(property); if (factory != null) { if (debug) { System.err.println(\\\"JXPath: found java.home property \\\" + factory); } return factory; } } } catch (Exception ex) { if (debug) { ex.printStackTrace(); } } String serviceId = \\\"META-INF/services/\\\" + property; try { ClassLoader cl = JXPathContextFactory.class.getClassLoader(); InputStream is = null; if (cl == null) { is = ClassLoader.getSystemResourceAsStream(serviceId); } else { is = cl.getResourceAsStream(serviceId); } if (is != null) { if (debug) { System.err.println(\\\"JXPath: found \\\" + serviceId); } BufferedReader rd = new BufferedReader(new InputStreamReader(is)); String factory = rd.readLine(); rd.close(); if (factory != null && !\\\"\\\".equals(factory)) { if (debug) { System.err.println(\\\"JXPath: loaded from services: \\\" + factory); } return factory; } } } catch (Exception ex) { if (debug) { ex.printStackTrace(); } } return defaultFactory; }"
                    ],
                    [
                        0.9799097776412964,
                        "public Object invoke(ExpressionContext context, Object[] parameters) { try { Object target; Object[] args; if (Modifier.isStatic(method.getModifiers())) { target = null; if (parameters == null) { parameters = EMPTY_ARRAY; } int pi = 0; Class[] types = method.getParameterTypes(); if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { pi = 1; } args = new Object[parameters.length + pi]; if (pi == 1) { args[0] = context; } for (int i = 0; i < parameters.length; i++) { args[i + pi] = TypeUtils.convert(parameters[i], types[i + pi]); } } else { int pi = 0; Class[] types = method.getParameterTypes(); if (types.length >= 1 && ExpressionContext.class.isAssignableFrom(types[0])) { pi = 1; } target = TypeUtils.convert(parameters[0], method.getDeclaringClass()); args = new Object[parameters.length - 1 + pi]; if (pi == 1) { args[0] = context; } for (int i = 1; i < parameters.length; i++) { args[pi + i - 1] = TypeUtils.convert(parameters[i], types[i + pi - 1]); } } return method.invoke(target, args); } catch (Throwable ex) { if (ex instanceof InvocationTargetException) { ex = ((InvocationTargetException) ex).getTargetException(); } throw new JXPathInvalidAccessException(\\\"Cannot invoke \\\" + method, ex); } }"
                    ],
                    [
                        0.9790632724761963,
                        "public String asPath() { if (id != null) { return \\\"id('\\\" + escape(id) + \\\"')\\\"; } StringBuffer buffer = new StringBuffer(); if (parent != null) { buffer.append(parent.asPath()); } switch(node.getNodeType()) { case Node.ELEMENT_NODE: if (parent instanceof DOMNodePointer) { if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { buffer.append('/'); } String ln = DOMNodePointer.getLocalName(node); String nsURI = getNamespaceURI(); if (nsURI == null) { buffer.append(ln); buffer.append('['); buffer.append(getRelativePositionByName()).append(']'); } else { String prefix = getNamespaceResolver().getPrefix(nsURI); if (prefix != null) { buffer.append(prefix); buffer.append(':'); buffer.append(ln); buffer.append('['); buffer.append(getRelativePositionByName()); buffer.append(']'); } else { buffer.append(\\\"node()\\\"); buffer.append('['); buffer.append(getRelativePositionOfElement()); buffer.append(']'); } } } break; case Node.TEXT_NODE: case Node.CDATA_SECTION_NODE: buffer.append(\\\"/text()\\\"); buffer.append('['); buffer.append(getRelativePositionOfTextNode()).append(']'); break; case Node.PROCESSING_INSTRUCTION_NODE: buffer.append(\\\"/processing-instruction(\\'\\\"); buffer.append(((ProcessingInstruction) node).getTarget()).append(\\\"')\\\"); buffer.append('['); buffer.append(getRelativePositionOfPI()).append(']'); break; case Node.DOCUMENT_NODE: } return buffer.toString(); }"
                    ],
                    [
                        0.9786763191223145,
                        "private static NodePointer doPredicateName(EvalContext context, NodePointer parent, Step[] steps, int currentStep, Expression[] predicates, int currentPredicate) { Expression predicate = predicates[currentPredicate]; String key = keyFromPredicate(context, predicate); NodePointer child = valuePointer(parent); if (child instanceof PropertyOwnerPointer) { PropertyPointer pointer = ((PropertyOwnerPointer) child).getPropertyPointer(); pointer.setPropertyName(key); if (pointer.isActual()) { return doPredicate(context, pointer, steps, currentStep, predicates, currentPredicate + 1); } } else if (child.isCollection()) { NodePointer bestMatch = null; int bestQuality = 0; child = (NodePointer) child.clone(); int count = child.getLength(); for (int i = 0; i < count; i++) { child.setIndex(i); NodePointer valuePointer = valuePointer(child); NodePointer pointer; if ((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()) { pointer = doPredicateName(context, valuePointer, steps, currentStep, predicates, currentPredicate); } else if (isNameAttributeEqual(valuePointer, key)) { pointer = doPredicate(context, valuePointer, steps, currentStep, predicates, currentPredicate + 1); } else { pointer = null; } if (pointer != null) { int quality = computeQuality(pointer); if (quality == PERFECT_MATCH) { return pointer; } if (quality > bestQuality) { bestMatch = (NodePointer) pointer.clone(); bestQuality = quality; } } } if (bestMatch != null) { return bestMatch; } } else { NodePointer found = doPredicatesStandard(context, Collections.singletonList(child), steps, currentStep, predicates, currentPredicate); if (found != null) { return found; } } return createNullPointerForPredicates(context, child, steps, currentStep, predicates, currentPredicate); }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisFollowing",
                    "org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisPreceding"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return (node instanceof Element) || (node instanceof Document);\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }\n```\n#Error message: junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)  assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n \n#Test method 2:\n```java\n    public void testAxisPreceding() {\n        // preceding::\n        assertXPathPointer(\n                context,\n                \"//location[2]/preceding-sibling::location//street\",\n        \"/vendor[1]/location[1]/address[1]/street[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::*[1]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[4]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n    }\n```\n#Error message: junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/preceding::node()[3]> expected:<...ndor[1]/location[1]/[employeeCount[1]/text()][1]> but was:<...ndor[1]/location[1]/[address][1]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisPreceding(XMLModelTestCase.java:474)  assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true; // Changed line to always return true for node()\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        \n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true; // Changed from checking only Element or Document types.\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node)));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true;\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n",
                            "\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Changed from checking specific instances to always returning true for nodes\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                    && (testPrefix == null || equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true;\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null && namespaceURI == null)\n                    || (nodeNS == null && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true;\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE:\n                return true; // Fix for handling any node type correctly\n            case Compiler.NODE_TYPE_TEXT:\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT:\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI:\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true; // Fix: Allow any node type when node() type is tested\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return (node instanceof Element) || (node instanceof Document) ||\n                       (node instanceof Text) || (node instanceof Comment) ||\n                       (node instanceof ProcessingInstruction);\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Match any node, not just Element or Document\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n"
                        ],
                        "plausible_patches": [
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true; // Changed line to always return true for node()\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\n    public static boolean testNode(\n        NodePointer pointer,\n        Object node,\n        NodeTest test)\n    {\n        if (test == null) {\n            return true;\n        }\n        if (test instanceof NodeNameTest) {\n            if (!(node instanceof Element)) {\n                return false;\n            }\n\n            NodeNameTest nodeNameTest = (NodeNameTest) test;\n            QName testName = nodeNameTest.getNodeName();\n            String namespaceURI = nodeNameTest.getNamespaceURI();\n            boolean wildcard = nodeNameTest.isWildcard();\n            String testPrefix = testName.getPrefix();\n            if (wildcard && testPrefix == null) {\n                return true;\n            }\n            if (wildcard\n                || testName.getName()\n                        .equals(JDOMNodePointer.getLocalName(node))) {\n                String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n                return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                        && equalStrings(testPrefix, getPrefix(node));\n            }\n            return false;\n        }\n        if (test instanceof NodeTypeTest) {\n            switch (((NodeTypeTest) test).getNodeType()) {\n                case Compiler.NODE_TYPE_NODE :\n                    return true; // Changed from checking specific instances to always returning true for nodes\n                case Compiler.NODE_TYPE_TEXT :\n                    return (node instanceof Text) || (node instanceof CDATA);\n                case Compiler.NODE_TYPE_COMMENT :\n                    return node instanceof Comment;\n                case Compiler.NODE_TYPE_PI :\n                    return node instanceof ProcessingInstruction;\n            }\n            return false;\n        }\n        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n            String testPI = ((ProcessingInstructionTest) test).getTarget();\n            String nodePI = ((ProcessingInstruction) node).getTarget();\n            return testPI.equals(nodePI);\n        }\n        return false;\n    }\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n                    && (testPrefix == null || equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true;\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null && namespaceURI == null)\n                    || (nodeNS == null && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return true;\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n",
                            "\npublic static boolean testNode(\n    NodePointer pointer,\n    Object node,\n    NodeTest test)\n{\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (!(node instanceof Element)) {\n            return false;\n        }\n\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(JDOMNodePointer.getLocalName(node))) {\n            String nodeNS = JDOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS) || (nodeNS == null\n                    && equalStrings(testPrefix, getPrefix(node)));\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        switch (((NodeTypeTest) test).getNodeType()) {\n            case Compiler.NODE_TYPE_NODE :\n                return (node instanceof Element) || (node instanceof Document) ||\n                       (node instanceof Text) || (node instanceof Comment) ||\n                       (node instanceof ProcessingInstruction);\n            case Compiler.NODE_TYPE_TEXT :\n                return (node instanceof Text) || (node instanceof CDATA);\n            case Compiler.NODE_TYPE_COMMENT :\n                return node instanceof Comment;\n            case Compiler.NODE_TYPE_PI :\n                return node instanceof ProcessingInstruction;\n        }\n        return false;\n    }\n    if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {\n        String testPI = ((ProcessingInstructionTest) test).getTarget();\n        String nodePI = ((ProcessingInstruction) node).getTarget();\n        return testPI.equals(nodePI);\n    }\n    return false;\n}\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisFollowing": {
                "path": "commons/jxpath/ri/model/XMLModelTestCase.java",
                "function_name": "testAxisFollowing",
                "src": "    public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }",
                "error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:261)\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)  assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");"
            },
            "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisPreceding": {
                "path": "commons/jxpath/ri/model/XMLModelTestCase.java",
                "function_name": "testAxisPreceding",
                "src": "    public void testAxisPreceding() {\n        // preceding::\n        assertXPathPointer(\n                context,\n                \"//location[2]/preceding-sibling::location//street\",\n        \"/vendor[1]/location[1]/address[1]/street[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::*[1]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[4]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n    }",
                "error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/preceding::node()[3]> expected:<...ndor[1]/location[1]/[employeeCount[1]/text()][1]> but was:<...ndor[1]/location[1]/[address][1]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:261)\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisPreceding(XMLModelTestCase.java:474)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/preceding::node()[3]> expected:<...ndor[1]/location[1]/[employeeCount[1]/text()][1]> but was:<...ndor[1]/location[1]/[address][1]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisPreceding(XMLModelTestCase.java:474)  assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");"
            },
            "org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisFollowing": {
                "path": "commons/jxpath/ri/model/XMLModelTestCase.java",
                "function_name": "testAxisFollowing",
                "src": "    public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }",
                "error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:261)\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)  assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");"
            },
            "org.apache.commons.jxpath.ri.model.jdom.JDOMModelTest::testAxisPreceding": {
                "path": "commons/jxpath/ri/model/XMLModelTestCase.java",
                "function_name": "testAxisPreceding",
                "src": "    public void testAxisPreceding() {\n        // preceding::\n        assertXPathPointer(\n                context,\n                \"//location[2]/preceding-sibling::location//street\",\n        \"/vendor[1]/location[1]/address[1]/street[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::*[1]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");\n        assertXPathPointer(context, \"//location[2]/preceding::node()[4]\", \"/vendor[1]/location[1]/employeeCount[1]\");\n    }",
                "error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/preceding::node()[3]> expected:<...ndor[1]/location[1]/[employeeCount[1]/text()][1]> but was:<...ndor[1]/location[1]/[address][1]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:261)\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisPreceding(XMLModelTestCase.java:474)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/preceding::node()[3]> expected:<...ndor[1]/location[1]/[employeeCount[1]/text()][1]> but was:<...ndor[1]/location[1]/[address][1]>\n\tat org.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)  assertEquals(\"Evaluating pointer <\" + xpath + \">\", expected, actual);\n\tat org.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisPreceding(XMLModelTestCase.java:474)  assertXPathPointer(context, \"//location[2]/preceding::node()[3]\", \"/vendor[1]/location[1]/employeeCount[1]/text()[1]\");"
            }
        },
        "evaluation_done": true
    }
}