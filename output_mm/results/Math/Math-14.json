{
    "Math-14": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java",
                "start_loc": 41,
                "end_loc": 47,
                "buggy_function": "    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }\n",
                "fixed_function": "    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = new DiagonalMatrix(weight);\n    }\n",
                "comment": "    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n",
                "normalized_body": [
                    "    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }\n"
                ],
                "isConstructor": true,
                "top_similar_methods": [
                    [
                        0.9710587859153748,
                        "@Test @Ignore public void testRandomUnsymmetricMatrix() { for (int run = 0; run < 100; run++) { Random r = new Random(System.currentTimeMillis()); int size = r.nextInt(20) + 4; double[][] data = new double[size][size]; for (int i = 0; i < size; i++) { for (int j = 0; j < size; j++) { data[i][j] = r.nextInt(100); } } RealMatrix m = MatrixUtils.createRealMatrix(data); checkUnsymmetricMatrix(m); } }"
                    ],
                    [
                        0.9690061211585999,
                        "public FieldMatrix<T> scalarMultiply(final T d) { final int rowCount = getRowDimension(); final int columnCount = getColumnDimension(); final FieldMatrix<T> out = createMatrix(rowCount, columnCount); for (int row = 0; row < rowCount; ++row) { for (int col = 0; col < columnCount; ++col) { out.setEntry(row, col, getEntry(row, col).multiply(d)); } } return out; }"
                    ],
                    [
                        0.9685503244400024,
                        "public void remainder(final double[] lhs, final int lhsOffset, final double[] rhs, final int rhsOffset, final double[] result, final int resultOffset) { final double rem = lhs[lhsOffset] % rhs[rhsOffset]; final double k = FastMath.rint((lhs[lhsOffset] - rem) / rhs[rhsOffset]); result[resultOffset] = rem; for (int i = 1; i < getSize(); ++i) { result[resultOffset + i] = lhs[lhsOffset + i] - k * rhs[rhsOffset + i]; } }"
                    ],
                    [
                        0.9676450490951538,
                        "@Test public void testMinpackRosenbrok() { minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); }"
                    ],
                    [
                        0.9676450490951538,
                        "@Test public void testMinpackRosenbrok() { minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, FastMath.sqrt(24.2)), false); minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, FastMath.sqrt(1795769.0)), false); minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * FastMath.sqrt(169000121.0)), false); }"
                    ],
                    [
                        0.967619776725769,
                        "@Override public void setSeed(final int[] seed) { if (seed == null) { setSeed(System.currentTimeMillis() + System.identityHashCode(this)); return; } System.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length)); if (seed.length < v.length) { for (int i = seed.length; i < v.length; ++i) { final long l = v[i - seed.length]; v[i] = (int) ((1812433253l * (l ^ (l >> 30)) + i) & 0xffffffffL); } } index = 0; clear(); }"
                    ],
                    [
                        0.9670875072479248,
                        "@Test public void testSSENonNegative() { double[] y = { 8915.102, 8919.302, 8923.502 }; double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 }; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++) { reg.addData(x[i], y[i]); } Assert.assertTrue(reg.getSumSquaredErrors() >= 0.0); }"
                    ]
                ],
                "non_directly_related_tests": [
                    "org.apache.commons.math3.fitting.PolynomialFitterTest::testLargeSample"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }\n\n```\n\n```java\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }\n```\n#Error message from the test method 1: java.lang.OutOfMemoryError: Java heap space\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n",
                            "\n/**\n * Creates a diagonal weight matrix.\n *\n * @param weight List of the values of the diagonal.\n */\npublic Weight(double[] weight) {\n    final int dim = weight.length;\n    weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n}\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n    \n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n",
                            "\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(weight);\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java",
                "start_loc": 266,
                "end_loc": 269,
                "buggy_function": "    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }\n",
                "fixed_function": "    private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }\n",
                "comment": "    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n",
                "normalized_body": [
                    "private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); }"
                    ],
                    [
                        1.000000238418579,
                        "private RealMatrix squareRoot(RealMatrix m) { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); }"
                    ],
                    [
                        0.9845491647720337,
                        "private double getDeterminant(final FieldMatrix<Fraction> m) { return new FieldLUDecomposition<Fraction>(m).getDeterminant().doubleValue(); }"
                    ],
                    [
                        0.9834842085838318,
                        "private double intersectionAbscissa(Line l0, Line l1) { Vector2D p = l0.intersection(l1); return (l0.toSubSpace(p)).getX(); }"
                    ],
                    [
                        0.9828812479972839,
                        "private double getDeterminant(RealMatrix m) { return new LUDecomposition(m).getDeterminant(); }"
                    ],
                    [
                        0.9814577698707581,
                        "private double getDeterminant(RealMatrix m) { return new CholeskyDecomposition(m).getDeterminant(); }"
                    ],
                    [
                        0.9812992811203003,
                        "private void checkAllTransforms(int[] x, int[] y) { checkDoubleTransform(x, y); checkInverseDoubleTransform(x, y); checkIntTransform(x, y); }"
                    ]
                ],
                "non_directly_related_tests": [
                    "org.apache.commons.math3.fitting.PolynomialFitterTest::testLargeSample"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * Creates a diagonal weight matrix.\n     *\n     * @param weight List of the values of the diagonal.\n     */\n\n    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }\n\n```\n\n```java\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }\n```\n#Error message from the test method 1: java.lang.OutOfMemoryError: Java heap space\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m, 0);\n            return dec.getSquareRoot();\n    }\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n        final EigenDecomposition dec = new EigenDecomposition(m, 1e-12);\n        return dec.getSquareRoot();\n    }\n",
                            "\n/**\n * Computes the square-root of the weight matrix.\n *\n * @param m Symmetric, positive-definite (weight) matrix.\n * @return the square-root of the weight matrix.\n */\nprivate RealMatrix squareRoot(RealMatrix m) {\n    if (!m.isSquare()) {\n        throw new IllegalArgumentException(\"Matrix is not square\");\n    }\n    CholeskyDecomposition decomposition = new CholeskyDecomposition(m);\n    return decomposition.getLT();\n}\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        final EigenDecomposition dec = new EigenDecomposition(m, 0);\n        return dec.getSquareRoot();\n    }\n\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     * @throws IllegalArgumentException if the matrix is not symmetric and positive-definite.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        if (!m.isSquare() || !m.isSymmetric()) {\n            throw new IllegalArgumentException(\"The matrix is not symmetric.\");\n        }\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        if (dec.hasComplexEigenvalues()) {\n            throw new IllegalArgumentException(\"The matrix is not positive-definite.\");\n        }\n        return dec.getSquareRoot();\n    }\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        if (!m.isSquare()) {\n            throw new IllegalArgumentException(\"Matrix is not square\");\n        }\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        double[] sqrtEigenValues = new double[m.getRowDimension()];\n        for (int i = 0; i < sqrtEigenValues.length; i++) {\n            sqrtEigenValues[i] = FastMath.sqrt(dec.getRealEigenvalue(i));\n        }\n        return dec.getV().multiply(MatrixUtils.createRealDiagonalMatrix(sqrtEigenValues))\n                   .multiply(dec.getVT());\n    }\n\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        // Ensure that diagonal matrix is used because square root of it is well defined\n        if (!(m instanceof DiagonalMatrix)) return null;\n        double[] diag = ((DiagonalMatrix) m).getData();\n        for (int i = 0; i < diag.length; i++) {\n            diag[i] = Math.sqrt(diag[i]);\n        }\n        return new DiagonalMatrix(diag);\n    }\n\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        if (!m.isSquare()) {\n            throw new IllegalArgumentException(\"Matrix is not square\");\n        }\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        RealMatrix sqrtMatrix = dec.getSquareRoot();\n        return sqrtMatrix;\n    }\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        final EigenDecomposition dec = new EigenDecomposition(m, 1e-6);\n        return dec.getSquareRoot();\n    }\n",
                            "\n    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n\n    private RealMatrix squareRoot(RealMatrix m) {\n        if (!m.isSquare()) {\n            throw new IllegalArgumentException(\"Matrix is not square.\");\n        }\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.math3.fitting.PolynomialFitterTest::testLargeSample": {
                "path": "src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java",
                "function_name": "testLargeSample",
                "src": "    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }",
                "error_msg": "java.lang.OutOfMemoryError: Java heap space\n\tat org.apache.commons.math3.linear.BlockRealMatrix.createBlocksLayout(BlockRealMatrix.java:271)\n\tat org.apache.commons.math3.linear.BlockRealMatrix.<init>(BlockRealMatrix.java:107)\n\tat org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(MatrixUtils.java:81)\n\tat org.apache.commons.math3.optim.nonlinear.vector.Weight.<init>(Weight.java:43)\n\tat org.apache.commons.math3.fitting.CurveFitter.fit(CurveFitter.java:172)\n\tat org.apache.commons.math3.fitting.CurveFitter.fit(CurveFitter.java:136)\n\tat org.apache.commons.math3.fitting.PolynomialFitter.fit(PolynomialFitter.java:68)\n\tat org.apache.commons.math3.fitting.PolynomialFitterTest.testLargeSample(PolynomialFitterTest.java:238)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)",
                "clean_error_msg": "java.lang.OutOfMemoryError: Java heap space\n\tat org.apache.commons.math3.linear.BlockRealMatrix.createBlocksLayout(BlockRealMatrix.java:271)  blocks[blockIndex] = new double[iHeight * jWidth];\n\tat org.apache.commons.math3.linear.BlockRealMatrix.<init>(BlockRealMatrix.java:107)  blocks = createBlocksLayout(rows, columns);\n\tat org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(MatrixUtils.java:81)  return (rows * columns <= 4096) ?\n\tat org.apache.commons.math3.optim.nonlinear.vector.Weight.<init>(Weight.java:43)  weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n\tat org.apache.commons.math3.fitting.CurveFitter.fit(CurveFitter.java:172)  final PointVectorValuePair optimum\n\tat org.apache.commons.math3.fitting.CurveFitter.fit(CurveFitter.java:136)  return fit(Integer.MAX_VALUE, f, initialGuess);\n\tat org.apache.commons.math3.fitting.PolynomialFitter.fit(PolynomialFitter.java:68)  return fit(new PolynomialFunction.Parametric(), guess);\n\tat org.apache.commons.math3.fitting.PolynomialFitterTest.testLargeSample(PolynomialFitterTest.java:238)  PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));"
            }
        },
        "evaluation_done": true
    }
}