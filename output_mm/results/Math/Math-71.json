{
    "Math-71": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java",
                "start_loc": 191,
                "end_loc": 366,
                "buggy_function": "  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                "fixed_function": "  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  interpolator.storeTime(stepStart);\n                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n                  hNew     = 0;\n                  stepSize = 0;\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                "comment": "  /** {@inheritDoc} */\n",
                "normalized_body": [
                    "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][y0.length]; final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; boolean firstTime = true; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { if (firstTime || !fsal) { computeDerivatives(stepStart, y, yDotK[0]); } if (firstTime) { final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } stepSize = hNew; for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } error = estimateError(yDotK, y, yTmp, stepSize); if (error <= 1.0) { interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { hNew = dt; } } else { loop = false; } } else { final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); hNew = filterStep(stepSize * factor, forward, false); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (fsal) { System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length); } if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); } } final double stopTime = stepStart; resetInternalState(); return stopTime; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000000596046448,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][y0.length]; final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; boolean firstTime = true; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { if (firstTime || !fsal) { computeDerivatives(stepStart, y, yDotK[0]); } if (firstTime) { final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } stepSize = hNew; for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } error = estimateError(yDotK, y, yTmp, stepSize); if (error <= 1.0) { interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { hNew = dt; } } else { loop = false; } } else { final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); hNew = filterStep(stepSize * factor, forward, false); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (fsal) { System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length); } if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); } } final double stopTime = stepStart; resetInternalState(); return stopTime; }"
                    ],
                    [
                        0.9908885558446249,
                        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][]; for (int i = 0; i < stages; ++i) { yDotK[i] = new double[y0.length]; } final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; stepSize = forward ? step : -step; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); for (boolean loop = true; loop; ) { computeDerivatives(stepStart, y, yDotK[0]); for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { stepSize = dt; } } else { loop = false; } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } stepSize = forward ? step : -step; } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }"
                    ],
                    [
                        0.9891127943992615,
                        "@Override public void estimate(EstimationProblem problem) throws EstimationException { initializeEstimate(problem); solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k * cols + pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * parameters[k].getEstimate(); xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; int index = pj; for (int i = 0; i <= j; ++i) { sum += jacobian[index] * residuals[i]; index += cols; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return; } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = parameters[pj].getEstimate(); } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; parameters[pj].setEstimate(oldX[pj] + lmDir[pj]); double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; int index = pj; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[index] * dirJ; index += cols; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * parameters[k].getEstimate(); xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; parameters[pj].setEstimate(oldX[pj]); } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return; } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new EstimationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new EstimationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new EstimationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }"
                    ],
                    [
                        0.9890805085500082,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[n]; final double[] yTmp = new double[y0.length]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator(); interpolatorTmp.reinitialize(yTmp, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); final int lastRow = nordsieck.getRowDimension() - 1; double hNew = stepSize; interpolator.rescale(hNew); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { stepSize = hNew; error = 0; for (int i = 0; i < y0.length; ++i) { final double yScale = Math.abs(y[i]); final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); final double ratio = nordsieck.getEntry(lastRow, i) / tol; error += ratio * ratio; } error = Math.sqrt(error / y0.length); if (error <= 1.0) { final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length); computeDerivatives(stepEnd, yTmp, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; interpolator.rescale(hNew); } } else { scaled = predictedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); loop = false; } } else { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, n); interpolator.storeTime(nextStep); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); for (StepHandler handler : stepHandlers) { interpolator.setInterpolatedTime(nextStep); handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (!lastStep && manager.reset(stepStart, y)) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); interpolator.rescale(hNew); } } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }"
                    ],
                    [
                        0.9883905450503031,
                        "@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { incrementIterationsCounter(); updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return new VectorialPointValuePair(point, objective); } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return new VectorialPointValuePair(point, objective); } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new OptimizationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }"
                    ],
                    [
                        0.9875869750976562,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[y0.length]; final double[] yTmp = new double[y0.length]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator(); interpolatorTmp.reinitialize(yTmp, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); double hNew = stepSize; interpolator.rescale(hNew); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { stepSize = hNew; final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length); computeDerivatives(stepEnd, yTmp, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp)); if (error <= 1.0) { computeDerivatives(stepEnd, yTmp, yDot); final double[] correctedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { correctedScaled[j] = stepSize * yDot[j]; } updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp); interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; interpolator.rescale(hNew); } } else { scaled = correctedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); loop = false; } } else { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, n); interpolator.storeTime(nextStep); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); for (StepHandler handler : stepHandlers) { interpolator.setInterpolatedTime(nextStep); handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (!lastStep && manager.reset(stepStart, y)) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); interpolator.rescale(hNew); } } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }"
                    ],
                    [
                        0.9863178730010986,
                        "@Override public VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { VectorialPointValuePair current = null; for (boolean converged = false; !converged; ) { incrementIterationsCounter(); VectorialPointValuePair previous = current; updateResidualsAndCost(); updateJacobian(); current = new VectorialPointValuePair(point, objective); final double[] b = new double[cols]; final double[][] a = new double[cols][cols]; for (int i = 0; i < rows; ++i) { final double[] grad = jacobian[i]; final double weight = residualsWeights[i]; final double residual = objective[i] - targetValues[i]; final double wr = weight * residual; for (int j = 0; j < cols; ++j) { b[j] += wr * grad[j]; } for (int k = 0; k < cols; ++k) { double[] ak = a[k]; double wgk = weight * grad[k]; for (int l = 0; l < cols; ++l) { ak[l] += wgk * grad[l]; } } } try { RealMatrix mA = new BlockRealMatrix(a); DecompositionSolver solver = useLU ? new LUDecompositionImpl(mA).getSolver() : new QRDecompositionImpl(mA).getSolver(); final double[] dX = solver.solve(b); for (int i = 0; i < cols; ++i) { point[i] += dX[i]; } } catch (InvalidMatrixException e) { throw new OptimizationException(\\\"unable to solve: singular problem\\\"); } if (previous != null) { converged = checker.converged(getIterations(), previous, current); } } return current; }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testMissedEndEvent"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n                                                                             1.0e-10, 1.0e-10);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      integrator.setInitialStepSize(60.0);\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.setInitialStepSize(60.0);\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250479999994E9>\n\tat org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest.testMissedEndEvent(DormandPrince853IntegratorTest.java:72)  Assert.assertEquals(tEvent, finalT, 5.0e-6);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart) || dt <= Math.ulp(stepStart)) {\n                  // we need to accept the step as an artificial 0 size step\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || nextStep >= t; // Fix here\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n          // stepsize control for next step\n          final double factor = Math.min(maxGrowth,\n                                         Math.max(minReduction,\n                                                  safety * Math.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT > t) : (nextT < t); // Fixed bug by changing >= to >\n          hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart         = t0;\n  double  hNew      = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n    handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    boolean loop = true;\n    while (loop) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n          }\n        } else {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n          }\n        }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            // we cannot simply truncate the step, reject the current computation\n            // and let the loop compute another state with the truncated step.\n            // it is so small (much probably exactly 0 due to limited accuracy)\n            // that the code above would fail handling it.\n            // So we set up an artificial 0 size step by copying states\n            loop     = false;\n          } else {\n            // reject the step to match exactly the next switch time\n            hNew = dt;\n          }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop() || (forward ? nextStep >= t : nextStep <= t);\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n      handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n      stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n      sanityChecks(equations, t0, y0, t, y);\n      setEquations(equations);\n      resetEvaluations();\n      final boolean forward = t > t0;\n\n      // create some internal working arrays\n      final int stages = c.length + 1;\n      if (y != y0) {\n          System.arraycopy(y0, 0, y, 0, y0.length);\n      }\n      final double[][] yDotK = new double[stages][y0.length];\n      final double[] yTmp = new double[y0.length];\n\n      // set up an interpolator sharing the integrator arrays\n      AbstractStepInterpolator interpolator;\n      if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n          final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n          rki.reinitialize(this, yTmp, yDotK, forward);\n          interpolator = rki;\n      } else {\n          interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n      }\n      interpolator.storeTime(t0);\n\n      // set up integration control objects\n      stepStart         = t0;\n      double  hNew      = 0;\n      boolean firstTime = true;\n      for (StepHandler handler : stepHandlers) {\n          handler.reset();\n      }\n      CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n      boolean lastStep = false;\n\n      // main integration loop\n      while (!lastStep) {\n\n          interpolator.shift();\n\n          double error = 0;\n          for (boolean loop = true; loop;) {\n\n              if (firstTime || !fsal) {\n                  // first stage\n                  computeDerivatives(stepStart, y, yDotK[0]);\n              }\n\n              if (firstTime) {\n                  final double[] scale = new double[y0.length];\n                  if (vecAbsoluteTolerance == null) {\n                      for (int i = 0; i < scale.length; ++i) {\n                          scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n                      }\n                  } else {\n                      for (int i = 0; i < scale.length; ++i) {\n                          scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n                      }\n                  }\n                  hNew = initializeStep(equations, forward, getOrder(), scale,\n                                        stepStart, y, yDotK[0], yTmp, yDotK[1]);\n                  firstTime = false;\n              }\n\n              stepSize = hNew;\n\n              // next stages\n              for (int k = 1; k < stages; ++k) {\n\n                  for (int j = 0; j < y0.length; ++j) {\n                      double sum = a[k-1][0] * yDotK[0][j];\n                      for (int l = 1; l < k; ++l) {\n                          sum += a[k-1][l] * yDotK[l][j];\n                      }\n                      yTmp[j] = y[j] + stepSize * sum;\n                  }\n\n                  computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n              }\n\n              // estimate the state at the end of the step\n              for (int j = 0; j < y0.length; ++j) {\n                  double sum    = b[0] * yDotK[0][j];\n                  for (int l = 1; l < stages; ++l) {\n                      sum    += b[l] * yDotK[l][j];\n                  }\n                  yTmp[j] = y[j] + stepSize * sum;\n              }\n\n              // estimate the error at the end of the step\n              error = estimateError(yDotK, y, yTmp, stepSize);\n              if (error <= 1.0) {\n\n                  // discrete events handling\n                  interpolator.storeTime(stepStart + stepSize);\n                  if (manager.evaluateStep(interpolator)) {\n                      final double dt = manager.getEventTime() - stepStart;\n                      if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                          // we cannot simply truncate the step, reject the current computation\n                          // and let the loop compute another state with the truncated step.\n                          // it is so small (much probably exactly 0 due to limited accuracy)\n                          // that the code above would fail handling it.\n                          // So we set up an artificial 0 size step by copying states\n                          loop     = false;\n                      } else {\n                          // reject the step to match exactly the next switch time\n                          hNew = dt;\n                      }\n                  } else {\n                      // accept the step\n                      loop = false;\n                  }\n\n              } else {\n                  // reject the step and attempt to reduce error by stepsize control\n                  final double factor =\n                      Math.min(maxGrowth,\n                               Math.max(minReduction, safety * Math.pow(error, exp)));\n                  hNew = filterStep(stepSize * factor, forward, false);\n              }\n\n          }\n\n          // the step has been accepted\n          final double nextStep = stepStart + stepSize;\n          System.arraycopy(yTmp, 0, y, 0, y0.length);\n          manager.stepAccepted(nextStep, y);\n          lastStep = manager.stop();\n\n          // provide the step data to the step handler\n          interpolator.storeTime(nextStep);\n          for (StepHandler handler : stepHandlers) {\n              handler.handleStep(interpolator, lastStep);\n          }\n          stepStart = nextStep;\n\n          if (fsal) {\n              // save the last evaluation for the next step\n              System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n          }\n\n          if (manager.reset(stepStart, y) && ! lastStep) {\n              // some event handler has triggered changes that\n              // invalidate the derivatives, we need to recompute them\n              computeDerivatives(stepStart, y, yDotK[0]);\n          }\n\n          if (! lastStep) {\n              // in some rare cases we may get here with stepSize = 0, for example\n              // when an event occurs at integration start, reducing the first step\n              // to zero; we have to reset the step to some safe non zero value\n              stepSize = Math.max(1e-12, filterStep(stepSize, forward, true));\n\n              // stepsize control for next step\n              final double factor = Math.min(maxGrowth,\n                                             Math.max(minReduction,\n                                                      safety * Math.pow(error, exp)));\n              final double  scaledH    = stepSize * factor;\n              final double  nextT      = stepStart + scaledH;\n              final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n              hNew = filterStep(scaledH, forward, nextIsLast);\n          }\n\n      }\n\n      final double stopTime = stepStart;\n      resetInternalState();\n      return stopTime;\n  }\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart         = t0;\n  double  hNew      = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                loop = false;\n            } else {\n                hNew = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      } else {\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      stepSize = filterStep(stepSize, forward, true);\n\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || (forward ? nextStep >= t : nextStep <= t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || Math.abs(nextStep - t) < Math.ulp(t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || (forward ? nextStep >= t : nextStep <= t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  double hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n    handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n          }\n        } else {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n          }\n        }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            loop = false;\n          } else {\n            stepSize = dt;\n            loop = true;\n          }\n        } else {\n          loop = false;\n        }\n\n      } else {\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n      handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && !lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (!lastStep) {\n      stepSize = filterStep(stepSize, forward, true);\n\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double scaledH = stepSize * factor;\n      final double nextT = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n"
                        ]
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n                                                                             1.0e-10, 1.0e-10);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      integrator.setInitialStepSize(60.0);\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.setInitialStepSize(60.0);\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250479999994E9>\n\tat org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest.testMissedEndEvent(DormandPrince853IntegratorTest.java:72)  Assert.assertEquals(tEvent, finalT, 5.0e-6);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][]; for (int i = 0; i < stages; ++i) { yDotK[i] = new double[y0.length]; } final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; stepSize = forward ? step : -step; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); for (boolean loop = true; loop; ) { computeDerivatives(stepStart, y, yDotK[0]); for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { stepSize = dt; } } else { loop = false; } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } stepSize = forward ? step : -step; } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }\n```\n\n            \n```java\n@Override public void estimate(EstimationProblem problem) throws EstimationException { initializeEstimate(problem); solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k * cols + pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * parameters[k].getEstimate(); xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; int index = pj; for (int i = 0; i <= j; ++i) { sum += jacobian[index] * residuals[i]; index += cols; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return; } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = parameters[pj].getEstimate(); } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; parameters[pj].setEstimate(oldX[pj] + lmDir[pj]); double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; int index = pj; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[index] * dirJ; index += cols; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * parameters[k].getEstimate(); xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; parameters[pj].setEstimate(oldX[pj]); } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return; } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new EstimationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new EstimationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new EstimationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }\n```\n\n            \n```java\n@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[n]; final double[] yTmp = new double[y0.length]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator(); interpolatorTmp.reinitialize(yTmp, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); final int lastRow = nordsieck.getRowDimension() - 1; double hNew = stepSize; interpolator.rescale(hNew); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { stepSize = hNew; error = 0; for (int i = 0; i < y0.length; ++i) { final double yScale = Math.abs(y[i]); final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); final double ratio = nordsieck.getEntry(lastRow, i) / tol; error += ratio * ratio; } error = Math.sqrt(error / y0.length); if (error <= 1.0) { final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length); computeDerivatives(stepEnd, yTmp, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; interpolator.rescale(hNew); } } else { scaled = predictedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); loop = false; } } else { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, n); interpolator.storeTime(nextStep); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); for (StepHandler handler : stepHandlers) { interpolator.setInterpolatedTime(nextStep); handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (!lastStep && manager.reset(stepStart, y)) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); interpolator.rescale(hNew); } } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }\n```\n\n            \n```java\n@Override protected VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { incrementIterationsCounter(); updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k][pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * point[k]; xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * residuals[i]; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return new VectorialPointValuePair(point, objective); } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = point[pj]; } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; point[pj] = oldX[pj] + lmDir[pj]; double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[i][pj] * dirJ; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * point[k]; xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; point[pj] = oldX[pj]; } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return new VectorialPointValuePair(point, objective); } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new OptimizationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new OptimizationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new OptimizationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }\n```\n\n            \n```java\n@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[y0.length]; final double[] yTmp = new double[y0.length]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator(); interpolatorTmp.reinitialize(yTmp, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); double hNew = stepSize; interpolator.rescale(hNew); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { stepSize = hNew; final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length); computeDerivatives(stepEnd, yTmp, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp)); if (error <= 1.0) { computeDerivatives(stepEnd, yTmp, yDot); final double[] correctedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { correctedScaled[j] = stepSize * yDot[j]; } updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp); interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp); interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; interpolator.rescale(hNew); } } else { scaled = correctedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); loop = false; } } else { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, n); interpolator.storeTime(nextStep); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); for (StepHandler handler : stepHandlers) { interpolator.setInterpolatedTime(nextStep); handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (!lastStep && manager.reset(stepStart, y)) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); interpolator.rescale(hNew); } } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // Create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // Set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // Set up integration control objects\n  stepStart = t0;\n  double  hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // Main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // First stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // Next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // Estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // Estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // Discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            // Handle zero-sized step due to limited accuracy\n            loop = false;\n          } else {\n            // Reject the step to match exactly the next switch time\n            hNew = dt;\n          }\n        } else {\n          // Accept the step\n          loop = false;\n        }\n\n      } else {\n        // Reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // The step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // Provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // Save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && !lastStep) {\n      // Recompute derivatives if an event handler has triggered changes\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (!lastStep) {\n      // Reset step size to a safe non-zero value if needed\n      stepSize = filterStep(stepSize, forward, true);\n\n      // Stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double scaledH = stepSize * factor;\n      final double nextT = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart         = t0;\n  double  hNew      = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n        stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  double hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            loop = false;\n          } else {\n            hNew = dt;\n          }\n        } else {\n          loop = false;\n        }\n\n      } else {\n        final double factor = Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (!lastStep) {\n      stepSize = filterStep(stepSize, forward, true);\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                          safety * Math.pow(error, exp)));\n      final double scaledH = stepSize * factor;\n      final double nextT = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n}\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart         = t0;\n  double  hNew      = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n        stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  double  hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                loop = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop() || Math.abs(nextStep - t) <= Math.ulp(t);\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n        stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n\n}\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  double hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n          }\n        } else {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n          }\n        }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && !lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (!lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n      stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double scaledH = stepSize * factor;\n      final double nextT = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  // Make sure we precisely hit the target time requested.\n  if (forward) {\n    stepStart = Math.min(stepStart, t);\n  } else {\n    stepStart = Math.max(stepStart, t);\n  }\n  System.arraycopy(yTmp, 0, y, 0, y0.length);\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (!lastStep && manager.reset(stepStart, y)) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (!lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n        stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  double  hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                hNew = dt;\n            }\n        } else {\n          // accept the step\n          loop = false;\n        }\n\n      } else {\n        // reject the step and attempt to reduce error by stepsize control\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      // save the last evaluation for the next step\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some event handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      // in some rare cases we may get here with stepSize = 0, for example\n      // when an event occurs at integration start, reducing the first step\n      // to zero; we have to reset the step to some safe non zero value\n      stepSize = filterStep(stepSize, forward, true);\n\n      // stepsize control for next step\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double  scaledH    = stepSize * factor;\n      final double  nextT      = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  // Ensure that we hit the final time exactly\n  if ((forward && stepStart < t) || (!forward && stepStart > t)) {\n    for (boolean loop = true; loop;) {\n      interpolator.shift();\n      computeDerivatives(stepStart, y, yDotK[0]);\n      for (int k = 1; k < stages; ++k) {\n        for (int j = 0; j < y.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n      }\n      for (int j = 0; j < y.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n      stepStart += stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y.length);\n      if ((forward && stepStart >= t) || (!forward && stepStart <= t)) {\n        loop = false;\n      }\n    }\n  }\n\n  resetInternalState();\n  return stepStart;\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale = new double[y0.length];\n          if (vecAbsoluteTolerance == null) {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n              }\n            } else {\n              for (int i = 0; i < scale.length; ++i) {\n                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n              }\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // we cannot simply truncate the step, reject the current computation\n                  // and let the loop compute another state with the truncated step.\n                  // it is so small (much probably exactly 0 due to limited accuracy)\n                  // that the code above would fail handling it.\n                  // So we set up an artificial 0 size step by copying states\n                  loop     = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n        if (Math.abs(stepSize) < Math.ulp(stepStart)) {\n          stepSize = filterStep(stepSize, forward, true);\n        }\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }\n",
                            "\n@Override\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][y0.length];\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  double hNew = 0;\n  boolean firstTime = true;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    double error = 0;\n    for (boolean loop = true; loop;) {\n\n      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[y0.length];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n            }\n          } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n            }\n          }\n        hNew = initializeStep(equations, forward, getOrder(), scale,\n                              stepStart, y, yDotK[0], yTmp, yDotK[1]);\n        firstTime = false;\n      }\n\n      stepSize = hNew;\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // estimate the error at the end of the step\n      error = estimateError(yDotK, y, yTmp, stepSize);\n      if (error <= 1.0) {\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                loop = false;\n            } else {\n                hNew = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      } else {\n        final double factor =\n            Math.min(maxGrowth,\n                     Math.max(minReduction, safety * Math.pow(error, exp)));\n        hNew = filterStep(stepSize * factor, forward, false);\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (fsal) {\n      System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (! lastStep) {\n      stepSize = filterStep(stepSize, forward, true);\n\n      final double factor = Math.min(maxGrowth,\n                                     Math.max(minReduction,\n                                              safety * Math.pow(error, exp)));\n      final double scaledH = stepSize * factor;\n      final double nextT = stepStart + scaledH;\n      final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n      hNew = filterStep(scaledH, forward, nextIsLast);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  resetInternalState();\n  return stopTime;\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java",
                "start_loc": 95,
                "end_loc": 220,
                "buggy_function": "  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                "fixed_function": "  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                interpolator.storeTime(stepStart);\n                System.arraycopy(y, 0, yTmp, 0, y0.length);\n                stepSize = 0;\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                "comment": "  /** {@inheritDoc} */\n",
                "normalized_body": [
                    "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][]; for (int i = 0; i < stages; ++i) { yDotK[i] = new double[y0.length]; } final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; stepSize = forward ? step : -step; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); for (boolean loop = true; loop; ) { computeDerivatives(stepStart, y, yDotK[0]); for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { stepSize = dt; } } else { loop = false; } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } stepSize = forward ? step : -step; } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001788139343,
                        "public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][]; for (int i = 0; i < stages; ++i) { yDotK[i] = new double[y0.length]; } final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; stepSize = forward ? step : -step; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); for (boolean loop = true; loop; ) { computeDerivatives(stepStart, y, yDotK[0]); for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { stepSize = dt; } } else { loop = false; } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } stepSize = forward ? step : -step; } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }"
                    ],
                    [
                        0.9923491179943085,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][y0.length]; final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; boolean firstTime = true; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { if (firstTime || !fsal) { computeDerivatives(stepStart, y, yDotK[0]); } if (firstTime) { final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } stepSize = hNew; for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } error = estimateError(yDotK, y, yTmp, stepSize); if (error <= 1.0) { interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { hNew = dt; } } else { loop = false; } } else { final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); hNew = filterStep(stepSize * factor, forward, false); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (fsal) { System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length); } if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); } } final double stopTime = stepStart; resetInternalState(); return stopTime; }"
                    ],
                    [
                        0.9918530881404877,
                        "@Override public void estimate(EstimationProblem problem) throws EstimationException { initializeEstimate(problem); solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k * cols + pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * parameters[k].getEstimate(); xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; int index = pj; for (int i = 0; i <= j; ++i) { sum += jacobian[index] * residuals[i]; index += cols; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return; } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = parameters[pj].getEstimate(); } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; parameters[pj].setEstimate(oldX[pj] + lmDir[pj]); double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; int index = pj; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[index] * dirJ; index += cols; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * parameters[k].getEstimate(); xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; parameters[pj].setEstimate(oldX[pj]); } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return; } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new EstimationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new EstimationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new EstimationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }"
                    ],
                    [
                        0.9911209046840668,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final double[] yDot0 = new double[y0.length]; final double[] y1 = new double[y0.length]; final double[] yTmp = new double[y0.length]; final double[] yTmpDot = new double[y0.length]; final double[][] diagonal = new double[sequence.length - 1][]; final double[][] y1Diag = new double[sequence.length - 1][]; for (int k = 0; k < sequence.length - 1; ++k) { diagonal[k] = new double[y0.length]; y1Diag[k] = new double[y0.length]; } final double[][][] fk = new double[sequence.length][][]; for (int k = 0; k < sequence.length; ++k) { fk[k] = new double[sequence[k] + 1][]; fk[k][0] = yDot0; for (int l = 0; l < sequence[k]; ++l) { fk[k][l + 1] = new double[y0.length]; } } if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } double[] yDot1 = null; double[][] yMidDots = null; if (denseOutput) { yDot1 = new double[y0.length]; yMidDots = new double[1 + 2 * sequence.length][]; for (int j = 0; j < yMidDots.length; ++j) { yMidDots[j] = new double[y0.length]; } } else { yMidDots = new double[1][]; yMidDots[0] = new double[y0.length]; } final double[] scale = new double[y0.length]; rescale(y, y, scale); final double tol = (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0]; final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0); int targetIter = Math.max(1, Math.min(sequence.length - 2, (int) Math.floor(0.5 - 0.6 * log10R))); AbstractStepInterpolator interpolator = null; if (denseOutput || (!eventsHandlersManager.isEmpty())) { interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0, y1, yDot1, yMidDots, forward); } else { interpolator = new DummyStepInterpolator(y, yDot1, forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; double maxError = Double.MAX_VALUE; boolean previousRejected = false; boolean firstTime = true; boolean newStep = true; boolean lastStep = false; boolean firstStepAlreadyComputed = false; for (StepHandler handler : stepHandlers) { handler.reset(); } costPerTimeUnit[0] = 0; while (!lastStep) { double error; boolean reject = false; if (newStep) { interpolator.shift(); if (!firstStepAlreadyComputed) { computeDerivatives(stepStart, y, yDot0); } if (firstTime) { hNew = initializeStep(equations, forward, 2 * targetIter + 1, scale, stepStart, y, yDot0, yTmp, yTmpDot); if (!forward) { hNew = -hNew; } } newStep = false; } stepSize = hNew; if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) { stepSize = t - stepStart; } final double nextT = stepStart + stepSize; lastStep = forward ? (nextT >= t) : (nextT <= t); int k = -1; for (boolean loop = true; loop; ) { ++k; if (!tryStep(stepStart, y, stepSize, k, scale, fk[k], (k == 0) ? yMidDots[0] : diagonal[k - 1], (k == 0) ? y1 : y1Diag[k - 1], yTmp)) { hNew = Math.abs(filterStep(stepSize * stabilityReduction, forward, false)); reject = true; loop = false; } else { if (k > 0) { extrapolate(0, k, y1Diag, y1); rescale(y, y1, scale); error = 0; for (int j = 0; j < y0.length; ++j) { final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j]; error += e * e; } error = Math.sqrt(error / y0.length); if ((error > 1.0e15) || ((k > 1) && (error > maxError))) { hNew = Math.abs(filterStep(stepSize * stabilityReduction, forward, false)); reject = true; loop = false; } else { maxError = Math.max(4 * error, 1.0); final double exp = 1.0 / (2 * k + 1); double fac = stepControl2 / Math.pow(error / stepControl1, exp); final double pow = Math.pow(stepControl3, exp); fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac)); optimalStep[k] = Math.abs(filterStep(stepSize * fac, forward, true)); costPerTimeUnit[k] = costPerStep[k] / optimalStep[k]; switch(k - targetIter) { case -1: if ((targetIter > 1) && !previousRejected) { if (error <= 1.0) { loop = false; } else { final double ratio = ((double) sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]); if (error > ratio * ratio) { reject = true; loop = false; targetIter = k; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } } } break; case 0: if (error <= 1.0) { loop = false; } else { final double ratio = ((double) sequence[k + 1]) / sequence[0]; if (error > ratio * ratio) { reject = true; loop = false; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } } break; case 1: if (error > 1.0) { reject = true; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } loop = false; break; default: if ((firstTime || lastStep) && (error <= 1.0)) { loop = false; } break; } } } } } double hInt = getMaxStep(); if (denseOutput && !reject) { for (int j = 1; j <= k; ++j) { extrapolate(0, j, diagonal, yMidDots[0]); } computeDerivatives(stepStart + stepSize, y1, yDot1); final int mu = 2 * k - mudif + 3; for (int l = 0; l < mu; ++l) { final int l2 = l / 2; double factor = Math.pow(0.5 * sequence[l2], l); int middleIndex = fk[l2].length / 2; for (int i = 0; i < y0.length; ++i) { yMidDots[l + 1][i] = factor * fk[l2][middleIndex + l][i]; } for (int j = 1; j <= k - l2; ++j) { factor = Math.pow(0.5 * sequence[j + l2], l); middleIndex = fk[l2 + j].length / 2; for (int i = 0; i < y0.length; ++i) { diagonal[j - 1][i] = factor * fk[l2 + j][middleIndex + l][i]; } extrapolate(l2, j, diagonal, yMidDots[l + 1]); } for (int i = 0; i < y0.length; ++i) { yMidDots[l + 1][i] *= stepSize; } for (int j = (l + 1) / 2; j <= k; ++j) { for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) { for (int i = 0; i < y0.length; ++i) { fk[j][m][i] -= fk[j][m - 2][i]; } } } } if (mu >= 0) { final GraggBulirschStoerStepInterpolator gbsInterpolator = (GraggBulirschStoerStepInterpolator) interpolator; gbsInterpolator.computeCoefficients(mu, stepSize); if (useInterpolationError) { final double interpError = gbsInterpolator.estimateError(scale); hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu + 4)), 0.01)); if (interpError > 10.0) { hNew = hInt; reject = true; } } if (!reject) { interpolator.storeTime(stepStart + stepSize); if (eventsHandlersManager.evaluateStep(interpolator)) { final double dt = eventsHandlersManager.getEventTime() - stepStart; if (Math.abs(dt) > Math.ulp(stepStart)) { hNew = Math.abs(dt); reject = true; } } } } if (!reject) { firstStepAlreadyComputed = true; System.arraycopy(yDot1, 0, yDot0, 0, y0.length); } } if (!reject) { final double nextStep = stepStart + stepSize; System.arraycopy(y1, 0, y, 0, y0.length); eventsHandlersManager.stepAccepted(nextStep, y); if (eventsHandlersManager.stop()) { lastStep = true; } interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (eventsHandlersManager.reset(stepStart, y) && !lastStep) { firstStepAlreadyComputed = false; } int optimalIter; if (k == 1) { optimalIter = 2; if (previousRejected) { optimalIter = 1; } } else if (k <= targetIter) { optimalIter = k; if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) { optimalIter = k - 1; } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) { optimalIter = Math.min(k + 1, sequence.length - 2); } } else { optimalIter = k - 1; if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) { optimalIter = k - 2; } if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) { optimalIter = Math.min(k, sequence.length - 2); } } if (previousRejected) { targetIter = Math.min(optimalIter, k); hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]); } else { if (optimalIter <= k) { hNew = optimalStep[optimalIter]; } else { if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) { hNew = filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k], forward, false); } else { hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k], forward, false); } } targetIter = optimalIter; } newStep = true; } hNew = Math.min(hNew, hInt); if (!forward) { hNew = -hNew; } firstTime = false; if (reject) { lastStep = false; previousRejected = true; } else { previousRejected = false; } } return stepStart; }"
                    ],
                    [
                        0.9899850785732269,
                        "@Override public VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { VectorialPointValuePair current = null; for (boolean converged = false; !converged; ) { incrementIterationsCounter(); VectorialPointValuePair previous = current; updateResidualsAndCost(); updateJacobian(); current = new VectorialPointValuePair(point, objective); final double[] b = new double[cols]; final double[][] a = new double[cols][cols]; for (int i = 0; i < rows; ++i) { final double[] grad = jacobian[i]; final double weight = residualsWeights[i]; final double residual = objective[i] - targetValues[i]; final double wr = weight * residual; for (int j = 0; j < cols; ++j) { b[j] += wr * grad[j]; } for (int k = 0; k < cols; ++k) { double[] ak = a[k]; double wgk = weight * grad[k]; for (int l = 0; l < cols; ++l) { ak[l] += wgk * grad[l]; } } } try { RealMatrix mA = new BlockRealMatrix(a); DecompositionSolver solver = useLU ? new LUDecompositionImpl(mA).getSolver() : new QRDecompositionImpl(mA).getSolver(); final double[] dX = solver.solve(b); for (int i = 0; i < cols; ++i) { point[i] += dX[i]; } } catch (InvalidMatrixException e) { throw new OptimizationException(\\\"unable to solve: singular problem\\\"); } if (previous != null) { converged = checker.converged(getIterations(), previous, current); } } return current; }"
                    ],
                    [
                        0.9892157316207886,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[n]; final double[] yTmp = new double[y0.length]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator(); interpolatorTmp.reinitialize(yTmp, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); final int lastRow = nordsieck.getRowDimension() - 1; double hNew = stepSize; interpolator.rescale(hNew); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { stepSize = hNew; error = 0; for (int i = 0; i < y0.length; ++i) { final double yScale = Math.abs(y[i]); final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); final double ratio = nordsieck.getEntry(lastRow, i) / tol; error += ratio * ratio; } error = Math.sqrt(error / y0.length); if (error <= 1.0) { final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length); computeDerivatives(stepEnd, yTmp, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; interpolator.rescale(hNew); } } else { scaled = predictedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); loop = false; } } else { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, n); interpolator.storeTime(nextStep); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); for (StepHandler handler : stepHandlers) { interpolator.setInterpolatedTime(nextStep); handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (!lastStep && manager.reset(stepStart, y)) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); interpolator.rescale(hNew); } } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }"
                    ],
                    [
                        0.9891601204872131,
                        "public RealMatrix multiply(final RealMatrix m) throws IllegalArgumentException { try { return multiply((RecursiveLayoutRealMatrix) m); } catch (ClassCastException cce) { checkMultiplicationCompatible(m); final RecursiveLayoutRealMatrix out = new RecursiveLayoutRealMatrix(rows, m.getColumnDimension()); for (int index = 0; index < out.tileNumber * out.tileNumber; ++index) { final int tileStart = index * out.tileSizeRows * out.tileSizeColumns; final long indices = tilesIndices(index); final int iTile = (int) (indices >> 32); final int jTile = (int) (indices & 0xffffffff); final int iStart = iTile * out.tileSizeRows; final int iEnd = Math.min(iStart + out.tileSizeRows, out.rows); final int jStart = jTile * out.tileSizeColumns; final int jEnd = Math.min(jStart + out.tileSizeColumns, out.columns); for (int kTile = 0; kTile < tileNumber; ++kTile) { final int kTileStart = tileIndex(iTile, kTile) * tileSizeRows * tileSizeColumns; for (int i = iStart, lStart = kTileStart, oStart = tileStart; i < iEnd; ++i, lStart += tileSizeColumns, oStart += out.tileSizeColumns) { final int lEnd = Math.min(lStart + tileSizeColumns, columns); for (int j = jStart, o = oStart; j < jEnd; ++j, ++o) { double sum = 0; for (int l = lStart, k = kTile * tileSizeColumns; l < lEnd; ++l, ++k) { sum += data[l] * m.getEntry(k, j); } out.data[o] += sum; } } } } return out; } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest::testMissedEndEvent"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\n\tat org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)  Assert.assertEquals(tEvent, finalT, 5.0e-6);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || Math.abs(nextStep - t) <= Math.ulp(t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && !lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK [i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n              // we cannot simply truncate the step, reject the current computation\n              // and let the loop compute another state with the truncated step.\n              // it is so small (much probably exactly 0 due to limited accuracy)\n              // that the code above would fail handling it.\n              // So we set up an artificial 0 size step by copying states\n              loop     = false;\n          } else {\n              // reject the step to match exactly the next switch time\n              stepSize = dt;\n          }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop() || Math.abs(nextStep - t) < Math.ulp(t);\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some events handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    // make sure step size is set to default before next step\n    stepSize = forward ? step : -step;\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || Math.abs(nextStep - t) < Math.ulp(t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || Math.abs(nextStep - t) <= Math.ulp(t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK [i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n              // we cannot simply truncate the step, reject the current computation\n              // and let the loop compute another state with the truncated step.\n              // it is so small (much probably exactly 0 due to limited accuracy)\n              // that the code above would fail handling it.\n              // So we set up an artificial 0 size step by copying states\n              loop     = false;\n          } else {\n              // reject the step to match exactly the next switch time\n              stepSize = dt;\n          }\n      } \n      \n      if (Math.abs(stepStart + stepSize - t) <= Math.ulp(t)) {\n          stepSize = t - stepStart;\n          loop = false;\n      } else {\n          if (!manager.evaluateStep(interpolator)) {\n              loop = false;\n          }\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop() || (Math.abs(nextStep - t) <= Math.ulp(t));\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some events handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    // make sure step size is set to default before next step\n    if (!lastStep) {\n      stepSize = forward ? step : -step;\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n      handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            // we cannot simply truncate the step, reject the current computation\n            // and let the loop compute another state with the truncated step.\n            // it is so small (much probably exactly 0 due to limited accuracy)\n            // that the code above would fail handling it.\n            // So we set up an artificial 0 size step by copying states\n            loop     = false;\n          } else {\n            // reject the step to match exactly the next switch time\n            stepSize = dt;\n          }\n        } else {\n          loop = false;\n        }\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || (!forward && nextStep <= t) || (forward && nextStep >= t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && !lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n      handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k - 1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k - 1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            // we cannot simply truncate the step, reject the current computation\n            // and let the loop compute another state with the truncated step.\n            // it is so small (much probably exactly 0 due to limited accuracy)\n            // that the code above would fail handling it.\n            // So we set up an artificial 0 size step by copying states\n            loop = false;\n            stepSize = 0; // Fix: set stepSize to 0 to avoid endless loop\n          } else {\n            // reject the step to match exactly the next switch time\n            stepSize = dt;\n          }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && !lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || (forward ? nextStep >= t : nextStep <= t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator) && (stepStart + stepSize) != t) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || Math.abs(nextStep - t) < Math.ulp(t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop() || Math.abs(nextStep - t) < Math.ulp(t);\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      if (!lastStep) {\n        stepSize = forward ? step : -step;\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n"
                        ]
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\n\tat org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)  Assert.assertEquals(tEvent, finalT, 5.0e-6);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\n@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][y0.length]; final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; boolean firstTime = true; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { if (firstTime || !fsal) { computeDerivatives(stepStart, y, yDotK[0]); } if (firstTime) { final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } stepSize = hNew; for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } error = estimateError(yDotK, y, yTmp, stepSize); if (error <= 1.0) { interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { loop = false; } else { hNew = dt; } } else { loop = false; } } else { final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); hNew = filterStep(stepSize * factor, forward, false); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (fsal) { System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length); } if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); } } final double stopTime = stepStart; resetInternalState(); return stopTime; }\n```\n\n            \n```java\n@Override public void estimate(EstimationProblem problem) throws EstimationException { initializeEstimate(problem); solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k * cols + pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * parameters[k].getEstimate(); xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; int index = pj; for (int i = 0; i <= j; ++i) { sum += jacobian[index] * residuals[i]; index += cols; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return; } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = parameters[pj].getEstimate(); } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; parameters[pj].setEstimate(oldX[pj] + lmDir[pj]); double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; int index = pj; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[index] * dirJ; index += cols; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * parameters[k].getEstimate(); xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; parameters[pj].setEstimate(oldX[pj]); } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return; } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new EstimationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new EstimationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new EstimationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }\n```\n\n            \n```java\n@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final double[] yDot0 = new double[y0.length]; final double[] y1 = new double[y0.length]; final double[] yTmp = new double[y0.length]; final double[] yTmpDot = new double[y0.length]; final double[][] diagonal = new double[sequence.length - 1][]; final double[][] y1Diag = new double[sequence.length - 1][]; for (int k = 0; k < sequence.length - 1; ++k) { diagonal[k] = new double[y0.length]; y1Diag[k] = new double[y0.length]; } final double[][][] fk = new double[sequence.length][][]; for (int k = 0; k < sequence.length; ++k) { fk[k] = new double[sequence[k] + 1][]; fk[k][0] = yDot0; for (int l = 0; l < sequence[k]; ++l) { fk[k][l + 1] = new double[y0.length]; } } if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } double[] yDot1 = null; double[][] yMidDots = null; if (denseOutput) { yDot1 = new double[y0.length]; yMidDots = new double[1 + 2 * sequence.length][]; for (int j = 0; j < yMidDots.length; ++j) { yMidDots[j] = new double[y0.length]; } } else { yMidDots = new double[1][]; yMidDots[0] = new double[y0.length]; } final double[] scale = new double[y0.length]; rescale(y, y, scale); final double tol = (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0]; final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0); int targetIter = Math.max(1, Math.min(sequence.length - 2, (int) Math.floor(0.5 - 0.6 * log10R))); AbstractStepInterpolator interpolator = null; if (denseOutput || (!eventsHandlersManager.isEmpty())) { interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0, y1, yDot1, yMidDots, forward); } else { interpolator = new DummyStepInterpolator(y, yDot1, forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; double maxError = Double.MAX_VALUE; boolean previousRejected = false; boolean firstTime = true; boolean newStep = true; boolean lastStep = false; boolean firstStepAlreadyComputed = false; for (StepHandler handler : stepHandlers) { handler.reset(); } costPerTimeUnit[0] = 0; while (!lastStep) { double error; boolean reject = false; if (newStep) { interpolator.shift(); if (!firstStepAlreadyComputed) { computeDerivatives(stepStart, y, yDot0); } if (firstTime) { hNew = initializeStep(equations, forward, 2 * targetIter + 1, scale, stepStart, y, yDot0, yTmp, yTmpDot); if (!forward) { hNew = -hNew; } } newStep = false; } stepSize = hNew; if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) { stepSize = t - stepStart; } final double nextT = stepStart + stepSize; lastStep = forward ? (nextT >= t) : (nextT <= t); int k = -1; for (boolean loop = true; loop; ) { ++k; if (!tryStep(stepStart, y, stepSize, k, scale, fk[k], (k == 0) ? yMidDots[0] : diagonal[k - 1], (k == 0) ? y1 : y1Diag[k - 1], yTmp)) { hNew = Math.abs(filterStep(stepSize * stabilityReduction, forward, false)); reject = true; loop = false; } else { if (k > 0) { extrapolate(0, k, y1Diag, y1); rescale(y, y1, scale); error = 0; for (int j = 0; j < y0.length; ++j) { final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j]; error += e * e; } error = Math.sqrt(error / y0.length); if ((error > 1.0e15) || ((k > 1) && (error > maxError))) { hNew = Math.abs(filterStep(stepSize * stabilityReduction, forward, false)); reject = true; loop = false; } else { maxError = Math.max(4 * error, 1.0); final double exp = 1.0 / (2 * k + 1); double fac = stepControl2 / Math.pow(error / stepControl1, exp); final double pow = Math.pow(stepControl3, exp); fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac)); optimalStep[k] = Math.abs(filterStep(stepSize * fac, forward, true)); costPerTimeUnit[k] = costPerStep[k] / optimalStep[k]; switch(k - targetIter) { case -1: if ((targetIter > 1) && !previousRejected) { if (error <= 1.0) { loop = false; } else { final double ratio = ((double) sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]); if (error > ratio * ratio) { reject = true; loop = false; targetIter = k; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } } } break; case 0: if (error <= 1.0) { loop = false; } else { final double ratio = ((double) sequence[k + 1]) / sequence[0]; if (error > ratio * ratio) { reject = true; loop = false; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } } break; case 1: if (error > 1.0) { reject = true; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } loop = false; break; default: if ((firstTime || lastStep) && (error <= 1.0)) { loop = false; } break; } } } } } double hInt = getMaxStep(); if (denseOutput && !reject) { for (int j = 1; j <= k; ++j) { extrapolate(0, j, diagonal, yMidDots[0]); } computeDerivatives(stepStart + stepSize, y1, yDot1); final int mu = 2 * k - mudif + 3; for (int l = 0; l < mu; ++l) { final int l2 = l / 2; double factor = Math.pow(0.5 * sequence[l2], l); int middleIndex = fk[l2].length / 2; for (int i = 0; i < y0.length; ++i) { yMidDots[l + 1][i] = factor * fk[l2][middleIndex + l][i]; } for (int j = 1; j <= k - l2; ++j) { factor = Math.pow(0.5 * sequence[j + l2], l); middleIndex = fk[l2 + j].length / 2; for (int i = 0; i < y0.length; ++i) { diagonal[j - 1][i] = factor * fk[l2 + j][middleIndex + l][i]; } extrapolate(l2, j, diagonal, yMidDots[l + 1]); } for (int i = 0; i < y0.length; ++i) { yMidDots[l + 1][i] *= stepSize; } for (int j = (l + 1) / 2; j <= k; ++j) { for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) { for (int i = 0; i < y0.length; ++i) { fk[j][m][i] -= fk[j][m - 2][i]; } } } } if (mu >= 0) { final GraggBulirschStoerStepInterpolator gbsInterpolator = (GraggBulirschStoerStepInterpolator) interpolator; gbsInterpolator.computeCoefficients(mu, stepSize); if (useInterpolationError) { final double interpError = gbsInterpolator.estimateError(scale); hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu + 4)), 0.01)); if (interpError > 10.0) { hNew = hInt; reject = true; } } if (!reject) { interpolator.storeTime(stepStart + stepSize); if (eventsHandlersManager.evaluateStep(interpolator)) { final double dt = eventsHandlersManager.getEventTime() - stepStart; if (Math.abs(dt) > Math.ulp(stepStart)) { hNew = Math.abs(dt); reject = true; } } } } if (!reject) { firstStepAlreadyComputed = true; System.arraycopy(yDot1, 0, yDot0, 0, y0.length); } } if (!reject) { final double nextStep = stepStart + stepSize; System.arraycopy(y1, 0, y, 0, y0.length); eventsHandlersManager.stepAccepted(nextStep, y); if (eventsHandlersManager.stop()) { lastStep = true; } interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (eventsHandlersManager.reset(stepStart, y) && !lastStep) { firstStepAlreadyComputed = false; } int optimalIter; if (k == 1) { optimalIter = 2; if (previousRejected) { optimalIter = 1; } } else if (k <= targetIter) { optimalIter = k; if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) { optimalIter = k - 1; } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) { optimalIter = Math.min(k + 1, sequence.length - 2); } } else { optimalIter = k - 1; if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) { optimalIter = k - 2; } if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) { optimalIter = Math.min(k, sequence.length - 2); } } if (previousRejected) { targetIter = Math.min(optimalIter, k); hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]); } else { if (optimalIter <= k) { hNew = optimalStep[optimalIter]; } else { if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) { hNew = filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k], forward, false); } else { hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k], forward, false); } } targetIter = optimalIter; } newStep = true; } hNew = Math.min(hNew, hInt); if (!forward) { hNew = -hNew; } firstTime = false; if (reject) { lastStep = false; previousRejected = true; } else { previousRejected = false; } } return stepStart; }\n```\n\n            \n```java\n@Override public VectorialPointValuePair doOptimize() throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { VectorialPointValuePair current = null; for (boolean converged = false; !converged; ) { incrementIterationsCounter(); VectorialPointValuePair previous = current; updateResidualsAndCost(); updateJacobian(); current = new VectorialPointValuePair(point, objective); final double[] b = new double[cols]; final double[][] a = new double[cols][cols]; for (int i = 0; i < rows; ++i) { final double[] grad = jacobian[i]; final double weight = residualsWeights[i]; final double residual = objective[i] - targetValues[i]; final double wr = weight * residual; for (int j = 0; j < cols; ++j) { b[j] += wr * grad[j]; } for (int k = 0; k < cols; ++k) { double[] ak = a[k]; double wgk = weight * grad[k]; for (int l = 0; l < cols; ++l) { ak[l] += wgk * grad[l]; } } } try { RealMatrix mA = new BlockRealMatrix(a); DecompositionSolver solver = useLU ? new LUDecompositionImpl(mA).getSolver() : new QRDecompositionImpl(mA).getSolver(); final double[] dX = solver.solve(b); for (int i = 0; i < cols; ++i) { point[i] += dX[i]; } } catch (InvalidMatrixException e) { throw new OptimizationException(\\\"unable to solve: singular problem\\\"); } if (previous != null) { converged = checker.converged(getIterations(), previous, current); } } return current; }\n```\n\n            \n```java\n@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[n]; final double[] yTmp = new double[y0.length]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator(); interpolatorTmp.reinitialize(yTmp, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); final int lastRow = nordsieck.getRowDimension() - 1; double hNew = stepSize; interpolator.rescale(hNew); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { stepSize = hNew; error = 0; for (int i = 0; i < y0.length; ++i) { final double yScale = Math.abs(y[i]); final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); final double ratio = nordsieck.getEntry(lastRow, i) / tol; error += ratio * ratio; } error = Math.sqrt(error / y0.length); if (error <= 1.0) { final double stepEnd = stepStart + stepSize; interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length); computeDerivatives(stepEnd, yTmp, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); interpolatorTmp.storeTime(stepStart); interpolatorTmp.shift(); interpolatorTmp.storeTime(stepEnd); if (manager.evaluateStep(interpolatorTmp)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; interpolator.rescale(hNew); } } else { scaled = predictedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); loop = false; } } else { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, n); interpolator.storeTime(nextStep); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); for (StepHandler handler : stepHandlers) { interpolator.setInterpolatedTime(nextStep); handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (!lastStep && manager.reset(stepStart, y)) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); interpolator.rescale(hNew); } } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK[i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n    handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop; ) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n        final double dt = manager.getEventTime() - stepStart;\n        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n          loop = false;\n        } else {\n          stepSize = dt;\n        }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n      handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && !lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    if (!lastStep) {\n      if (forward) {\n        stepSize = Math.min(stepSize, t - stepStart);\n      } else {\n        stepSize = Math.max(stepSize, t - stepStart);\n      }\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK[i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n    handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k - 1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k - 1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n        final double dt = manager.getEventTime() - stepStart;\n        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n          loop = false;\n        } else {\n          stepSize = dt;\n        }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop() || Math.abs(nextStep - t) < 5.0e-6;\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n      handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && !lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    // make sure step size is set to default before next step\n    stepSize = forward ? step : -step;\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\n  /** {@inheritDoc} */\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK[i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      for (int k = 1; k < stages; ++k) {\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n      }\n\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n              loop     = false;\n          } else {\n              stepSize = dt;\n          }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\n  /** {@inheritDoc} */\n\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize  = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop;) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n            final double dt = manager.getEventTime() - stepStart;\n            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                // we cannot simply truncate the step, reject the current computation\n                // and let the loop compute another state with the truncated step.\n                // it is so small (much probably exactly 0 due to limited accuracy)\n                // that the code above would fail handling it.\n                // So we set up an artificial 0 size step by copying states\n                loop     = false;\n            } else {\n                // reject the step to match exactly the next switch time\n                stepSize = dt;\n            }\n        } else {\n          loop = false;\n        }\n        \n        if (!loop) {\n            // check if step must be truncated to reach exactly the target time\n            final double nextStep = stepStart + stepSize;\n            lastStep = forward ? (nextStep >= t) : (nextStep <= t);\n            if (lastStep && (Math.abs(nextStep - t) > Math.ulp(t))) {\n                stepSize = t - stepStart;\n            }\n        }\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n      \n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n    return stopTime;\n\n  }\n\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\n    throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK[i] = new double[y0.length];\n    }\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart = t0;\n    stepSize = forward ? step : -step;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      for (boolean loop = true; loop; ) {\n\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k - 1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k - 1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // discrete events handling\n        interpolator.storeTime(stepStart + stepSize);\n        if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n            // we cannot simply truncate the step, reject the current computation\n            // and let the loop compute another state with the truncated step.\n            // it is so small (much probably exactly 0 due to limited accuracy)\n            // that the code above would fail handling it.\n            // So we set up an artificial 0 size step by copying states\n            System.arraycopy(y, 0, yTmp, 0, y0.length);\n            loop = false;\n          } else {\n            // reject the step to match exactly the next switch time\n            stepSize = dt;\n          }\n        } else {\n          loop = false;\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (manager.reset(stepStart, y) && !lastStep) {\n        // some events handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      // make sure step size is set to default before next step\n      stepSize = forward ? step : -step;\n\n    }\n\n    final double stopTime = stepStart;\n    stepStart = Double.NaN;\n    stepSize = Double.NaN;\n    return stopTime;\n\n  }\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK[i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n              // we cannot simply truncate the step, reject the current computation\n              // and let the loop compute another state with the truncated step.\n              // it is so small (much probably exactly 0 due to limited accuracy)\n              // that the code above would fail handling it.\n              // So we set up an artificial 0 size step by copying states\n              loop     = false;\n          } else {\n              // reject the step to match exactly the next switch time\n              stepSize = dt;\n          }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some events handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    // make sure step size is set to default before next step\n    if (!lastStep) {\n      stepSize = forward ? step : -step;\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK[i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n        final double dt = manager.getEventTime() - stepStart;\n        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n          loop = false;\n        } else {\n          stepSize = dt;\n        }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && !lastStep) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    // make sure step size is set to default or truncated before next step\n    if (!lastStep) {\n      stepSize = forward ? Math.min(step, t - stepStart) : Math.max(-step, t - stepStart);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK[i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n              loop = false;\n          } else {\n              stepSize = dt;\n          }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop();\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (lastStep) {\n        stepSize = forward ? step : -step;\n    } else if (manager.reset(stepStart, y)) {\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n",
                            "\npublic double integrate(final FirstOrderDifferentialEquations equations,\n                        final double t0, final double[] y0,\n                        final double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\n  sanityChecks(equations, t0, y0, t, y);\n  setEquations(equations);\n  resetEvaluations();\n  final boolean forward = t > t0;\n\n  // create some internal working arrays\n  final int stages = c.length + 1;\n  if (y != y0) {\n    System.arraycopy(y0, 0, y, 0, y0.length);\n  }\n  final double[][] yDotK = new double[stages][];\n  for (int i = 0; i < stages; ++i) {\n    yDotK [i] = new double[y0.length];\n  }\n  final double[] yTmp = new double[y0.length];\n\n  // set up an interpolator sharing the integrator arrays\n  AbstractStepInterpolator interpolator;\n  if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n    final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n    rki.reinitialize(this, yTmp, yDotK, forward);\n    interpolator = rki;\n  } else {\n    interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n  }\n  interpolator.storeTime(t0);\n\n  // set up integration control objects\n  stepStart = t0;\n  stepSize  = forward ? step : -step;\n  for (StepHandler handler : stepHandlers) {\n      handler.reset();\n  }\n  CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n  boolean lastStep = false;\n\n  // main integration loop\n  while (!lastStep) {\n\n    interpolator.shift();\n\n    for (boolean loop = true; loop;) {\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n        for (int j = 0; j < y0.length; ++j) {\n          double sum = a[k-1][0] * yDotK[0][j];\n          for (int l = 1; l < k; ++l) {\n            sum += a[k-1][l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n        double sum    = b[0] * yDotK[0][j];\n        for (int l = 1; l < stages; ++l) {\n          sum    += b[l] * yDotK[l][j];\n        }\n        yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      if (manager.evaluateStep(interpolator)) {\n          final double dt = manager.getEventTime() - stepStart;\n          if (Math.abs(dt) <= Math.ulp(stepStart)) {\n              // we cannot simply truncate the step, reject the current computation\n              // and let the loop compute another state with the truncated step.\n              // it is so small (much probably exactly 0 due to limited accuracy)\n              // that the code above would fail handling it.\n              // So we set up an artificial 0 size step by copying states\n              loop     = false;\n          } else {\n              // reject the step to match exactly the next switch time\n              stepSize = dt;\n          }\n      } else {\n        loop = false;\n      }\n\n    }\n\n    // the step has been accepted\n    final double nextStep = stepStart + stepSize;\n    System.arraycopy(yTmp, 0, y, 0, y0.length);\n    manager.stepAccepted(nextStep, y);\n    lastStep = manager.stop() || (forward ? nextStep >= t : nextStep <= t);\n\n    // provide the step data to the step handler\n    interpolator.storeTime(nextStep);\n    for (StepHandler handler : stepHandlers) {\n        handler.handleStep(interpolator, lastStep);\n    }\n    stepStart = nextStep;\n\n    if (manager.reset(stepStart, y) && ! lastStep) {\n      // some events handler has triggered changes that\n      // invalidate the derivatives, we need to recompute them\n      computeDerivatives(stepStart, y, yDotK[0]);\n    }\n\n    // make sure step size is set to default before next step\n    stepSize = forward ? step : -step;\n\n  }\n\n  final double stopTime = stepStart;\n  stepStart = Double.NaN;\n  stepSize  = Double.NaN;\n  return stopTime;\n\n}\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest::testMissedEndEvent": {
                "path": "src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java",
                "function_name": "testMissedEndEvent",
                "src": "  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:120)\n\tat junit.framework.Assert.assertEquals(Assert.java:129)\n\tat org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\n\tat org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)  Assert.assertEquals(tEvent, finalT, 5.0e-6);"
            },
            "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testMissedEndEvent": {
                "path": "src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java",
                "function_name": "testMissedEndEvent",
                "src": "  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k  = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n                                                                             1.0e-10, 1.0e-10);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      integrator.setInitialStepSize(60.0);\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n      integrator.setInitialStepSize(60.0);\n      integrator.addEventHandler(new EventHandler() {\n\n          public void resetState(double t, double[] y) {\n          }\n\n          public double g(double t, double[] y) {\n              return t - tEvent;\n          }\n\n          public int eventOccurred(double t, double[] y, boolean increasing) {\n              Assert.assertEquals(tEvent, t, 5.0e-6);\n              return CONTINUE;\n          }\n      }, Double.POSITIVE_INFINITY, 1.0e-20, 100);\n      finalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\n      Assert.assertEquals(tEvent + 120, finalT, 5.0e-6);\n      for (int i = 0; i < y.length; ++i) {\n          Assert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n      }\n\n  }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250479999994E9>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:120)\n\tat junit.framework.Assert.assertEquals(Assert.java:129)\n\tat org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest.testMissedEndEvent(DormandPrince853IntegratorTest.java:72)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250479999994E9>\n\tat org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest.testMissedEndEvent(DormandPrince853IntegratorTest.java:72)  Assert.assertEquals(tEvent, finalT, 5.0e-6);"
            }
        },
        "context_generation_done": true
    }
}