{
    "Math-54": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/math/dfp/Dfp.java",
                "start_loc": 256,
                "end_loc": 314,
                "buggy_function": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n",
                "fixed_function": "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n",
                "comment": "    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n",
                "normalized_body": [
                    "    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n"
                ],
                "isConstructor": true,
                "top_similar_methods": [
                    [
                        0.9630915820598602,
                        "protected String dfp2sci() { char[] rawdigits = new char[mant.length * 4]; char[] outputbuffer = new char[mant.length * 4 + 20]; int p; int q; int e; int ae; int shf; p = 0; for (int i = mant.length - 1; i >= 0; i--) { rawdigits[p++] = (char) ((mant[i] / 1000) + '0'); rawdigits[p++] = (char) (((mant[i] / 100) % 10) + '0'); rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0'); rawdigits[p++] = (char) (((mant[i]) % 10) + '0'); } for (p = 0; p < rawdigits.length; p++) { if (rawdigits[p] != '0') { break; } } shf = p; q = 0; if (sign == -1) { outputbuffer[q++] = '-'; } if (p != rawdigits.length) { outputbuffer[q++] = rawdigits[p++]; outputbuffer[q++] = '.'; while (p < rawdigits.length) { outputbuffer[q++] = rawdigits[p++]; } } else { outputbuffer[q++] = '0'; outputbuffer[q++] = '.'; outputbuffer[q++] = '0'; outputbuffer[q++] = 'e'; outputbuffer[q++] = '0'; return new String(outputbuffer, 0, 5); } outputbuffer[q++] = 'e'; e = exp * 4 - shf - 1; ae = e; if (e < 0) { ae = -e; } for (p = 1000000000; p > ae; p /= 10) { } if (e < 0) { outputbuffer[q++] = '-'; } while (p > 0) { outputbuffer[q++] = (char) (ae / p + '0'); ae = ae % p; p = p / 10; } return new String(outputbuffer, 0, q); }"
                    ],
                    [
                        0.9620676636695862,
                        "public Dfp divide(Dfp divisor) { int[] dividend; int[] quotient; int[] remainder; int qd; int nsqd; int trial = 0; int minadj; boolean trialgood; int md = 0; int excp; if (field.getRadixDigits() != divisor.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); } Dfp result = newInstance(getZero()); if (nans != FINITE || divisor.nans != FINITE) { if (isNaN()) { return this; } if (divisor.isNaN()) { return divisor; } if (nans == INFINITE && divisor.nans == FINITE) { result = newInstance(this); result.sign = (byte) (sign * divisor.sign); return result; } if (divisor.nans == INFINITE && nans == FINITE) { result = newInstance(getZero()); result.sign = (byte) (sign * divisor.sign); return result; } if (divisor.nans == INFINITE && nans == INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result); return result; } } if (divisor.mant[mant.length - 1] == 0) { field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO); result = newInstance(getZero()); result.sign = (byte) (sign * divisor.sign); result.nans = INFINITE; result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result); return result; } dividend = new int[mant.length + 1]; quotient = new int[mant.length + 2]; remainder = new int[mant.length + 1]; dividend[mant.length] = 0; quotient[mant.length] = 0; quotient[mant.length + 1] = 0; remainder[mant.length] = 0; for (int i = 0; i < mant.length; i++) { dividend[i] = mant[i]; quotient[i] = 0; remainder[i] = 0; } nsqd = 0; for (qd = mant.length + 1; qd >= 0; qd--) { final int divMsb = dividend[mant.length] * RADIX + dividend[mant.length - 1]; int min = divMsb / (divisor.mant[mant.length - 1] + 1); int max = (divMsb + 1) / divisor.mant[mant.length - 1]; trialgood = false; while (!trialgood) { trial = (min + max) / 2; int rh = 0; for (int i = 0; i < mant.length + 1; i++) { int dm = (i < mant.length) ? divisor.mant[i] : 0; final int r = (dm * trial) + rh; rh = r / RADIX; remainder[i] = r - rh * RADIX; } rh = 1; for (int i = 0; i < mant.length + 1; i++) { final int r = ((RADIX - 1) - remainder[i]) + dividend[i] + rh; rh = r / RADIX; remainder[i] = r - rh * RADIX; } if (rh == 0) { max = trial - 1; continue; } minadj = (remainder[mant.length] * RADIX) + remainder[mant.length - 1]; minadj = minadj / (divisor.mant[mant.length - 1] + 1); if (minadj >= 2) { min = trial + minadj; continue; } trialgood = false; for (int i = mant.length - 1; i >= 0; i--) { if (divisor.mant[i] > remainder[i]) { trialgood = true; } if (divisor.mant[i] < remainder[i]) { break; } } if (remainder[mant.length] != 0) { trialgood = false; } if (trialgood == false) { min = trial + 1; } } quotient[qd] = trial; if (trial != 0 || nsqd != 0) { nsqd++; } if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) { break; } if (nsqd > mant.length) { break; } dividend[0] = 0; for (int i = 0; i < mant.length; i++) { dividend[i + 1] = remainder[i]; } } md = mant.length; for (int i = mant.length + 1; i >= 0; i--) { if (quotient[i] != 0) { md = i; break; } } for (int i = 0; i < mant.length; i++) { result.mant[mant.length - i - 1] = quotient[md - i]; } result.exp = exp - divisor.exp + md - mant.length; result.sign = (byte) ((sign == divisor.sign) ? 1 : -1); if (result.mant[mant.length - 1] == 0) { result.exp = 0; } if (md > (mant.length - 1)) { excp = result.round(quotient[md - mant.length]); } else { excp = result.round(0); } if (excp != 0) { result = dotrap(excp, DIVIDE_TRAP, divisor, result); } return result; }"
                    ],
                    [
                        0.9601735472679138,
                        "public Dfp add(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); } if (nans != FINITE || x.nans != FINITE) { if (isNaN()) { return this; } if (x.isNaN()) { return x; } if (nans == INFINITE && x.nans == FINITE) { return this; } if (x.nans == INFINITE && nans == FINITE) { return x; } if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) { return x; } if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); Dfp result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result); return result; } } Dfp a = newInstance(this); Dfp b = newInstance(x); Dfp result = newInstance(getZero()); final byte asign = a.sign; final byte bsign = b.sign; a.sign = 1; b.sign = 1; byte rsign = bsign; if (compare(a, b) > 0) { rsign = asign; } if (b.mant[mant.length - 1] == 0) { b.exp = a.exp; } if (a.mant[mant.length - 1] == 0) { a.exp = b.exp; } int aextradigit = 0; int bextradigit = 0; if (a.exp < b.exp) { aextradigit = a.align(b.exp); } else { bextradigit = b.align(a.exp); } if (asign != bsign) { if (asign == rsign) { bextradigit = b.complement(bextradigit); } else { aextradigit = a.complement(aextradigit); } } int rh = 0; for (int i = 0; i < mant.length; i++) { final int r = a.mant[i] + b.mant[i] + rh; rh = r / RADIX; result.mant[i] = r - rh * RADIX; } result.exp = a.exp; result.sign = rsign; if (rh != 0 && (asign == bsign)) { final int lostdigit = result.mant[0]; result.shiftRight(); result.mant[mant.length - 1] = rh; final int excp = result.round(lostdigit); if (excp != 0) { result = dotrap(excp, ADD_TRAP, x, result); } } for (int i = 0; i < mant.length; i++) { if (result.mant[mant.length - 1] != 0) { break; } result.shiftLeft(); if (i == 0) { result.mant[0] = aextradigit + bextradigit; aextradigit = 0; bextradigit = 0; } } if (result.mant[mant.length - 1] == 0) { result.exp = 0; if (asign != bsign) { result.sign = 1; } } final int excp = result.round(aextradigit + bextradigit); if (excp != 0) { result = dotrap(excp, ADD_TRAP, x, result); } return result; }"
                    ],
                    [
                        0.9593366980552673,
                        "public Dfp nextAfter(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result); } boolean up = false; if (this.lessThan(x)) { up = true; } if (compare(this, x) == 0) { return newInstance(x); } if (lessThan(getZero())) { up = !up; } final Dfp inc; Dfp result; if (up) { inc = newInstance(getOne()); inc.exp = this.exp - mant.length + 1; inc.sign = this.sign; if (this.equals(getZero())) { inc.exp = MIN_EXP - mant.length; } result = add(inc); } else { inc = newInstance(getOne()); inc.exp = this.exp; inc.sign = this.sign; if (this.equals(inc)) { inc.exp = this.exp - mant.length; } else { inc.exp = this.exp - mant.length + 1; } if (this.equals(getZero())) { inc.exp = MIN_EXP - mant.length; } result = this.subtract(inc); } if (result.classify() == INFINITE && this.classify() != INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } if (result.equals(getZero()) && this.equals(getZero()) == false) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } return result; }"
                    ],
                    [
                        0.9585024118423462,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathUserException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final double[] yDot0 = new double[y0.length]; final double[] y1 = new double[y0.length]; final double[] yTmp = new double[y0.length]; final double[] yTmpDot = new double[y0.length]; final double[][] diagonal = new double[sequence.length - 1][]; final double[][] y1Diag = new double[sequence.length - 1][]; for (int k = 0; k < sequence.length - 1; ++k) { diagonal[k] = new double[y0.length]; y1Diag[k] = new double[y0.length]; } final double[][][] fk = new double[sequence.length][][]; for (int k = 0; k < sequence.length; ++k) { fk[k] = new double[sequence[k] + 1][]; fk[k][0] = yDot0; for (int l = 0; l < sequence[k]; ++l) { fk[k][l + 1] = new double[y0.length]; } } if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } double[] yDot1 = new double[y0.length]; double[][] yMidDots = null; final boolean denseOutput = requiresDenseOutput(); if (denseOutput) { yMidDots = new double[1 + 2 * sequence.length][]; for (int j = 0; j < yMidDots.length; ++j) { yMidDots[j] = new double[y0.length]; } } else { yMidDots = new double[1][]; yMidDots[0] = new double[y0.length]; } final double[] scale = new double[mainSetDimension]; rescale(y, y, scale); final double tol = (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0]; final double log10R = FastMath.log10(FastMath.max(1.0e-10, tol)); int targetIter = FastMath.max(1, FastMath.min(sequence.length - 2, (int) FastMath.floor(0.5 - 0.6 * log10R))); AbstractStepInterpolator interpolator = null; if (denseOutput) { interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0, y1, yDot1, yMidDots, forward); } else { interpolator = new DummyStepInterpolator(y, yDot1, forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; double maxError = Double.MAX_VALUE; boolean previousRejected = false; boolean firstTime = true; boolean newStep = true; boolean firstStepAlreadyComputed = false; for (StepHandler handler : stepHandlers) { handler.reset(); } setStateInitialized(false); costPerTimeUnit[0] = 0; isLastStep = false; do { double error; boolean reject = false; if (newStep) { interpolator.shift(); if (!firstStepAlreadyComputed) { computeDerivatives(stepStart, y, yDot0); } if (firstTime) { hNew = initializeStep(equations, forward, 2 * targetIter + 1, scale, stepStart, y, yDot0, yTmp, yTmpDot); } newStep = false; } stepSize = hNew; if ((forward && (stepStart + stepSize > t)) || ((!forward) && (stepStart + stepSize < t))) { stepSize = t - stepStart; } final double nextT = stepStart + stepSize; isLastStep = forward ? (nextT >= t) : (nextT <= t); int k = -1; for (boolean loop = true; loop; ) { ++k; if (!tryStep(stepStart, y, stepSize, k, scale, fk[k], (k == 0) ? yMidDots[0] : diagonal[k - 1], (k == 0) ? y1 : y1Diag[k - 1], yTmp)) { hNew = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false)); reject = true; loop = false; } else { if (k > 0) { extrapolate(0, k, y1Diag, y1); rescale(y, y1, scale); error = 0; for (int j = 0; j < mainSetDimension; ++j) { final double e = FastMath.abs(y1[j] - y1Diag[0][j]) / scale[j]; error += e * e; } error = FastMath.sqrt(error / mainSetDimension); if ((error > 1.0e15) || ((k > 1) && (error > maxError))) { hNew = FastMath.abs(filterStep(stepSize * stabilityReduction, forward, false)); reject = true; loop = false; } else { maxError = FastMath.max(4 * error, 1.0); final double exp = 1.0 / (2 * k + 1); double fac = stepControl2 / FastMath.pow(error / stepControl1, exp); final double pow = FastMath.pow(stepControl3, exp); fac = FastMath.max(pow / stepControl4, FastMath.min(1 / pow, fac)); optimalStep[k] = FastMath.abs(filterStep(stepSize * fac, forward, true)); costPerTimeUnit[k] = costPerStep[k] / optimalStep[k]; switch(k - targetIter) { case -1: if ((targetIter > 1) && !previousRejected) { if (error <= 1.0) { loop = false; } else { final double ratio = ((double) sequence[targetIter] * sequence[targetIter + 1]) / (sequence[0] * sequence[0]); if (error > ratio * ratio) { reject = true; loop = false; targetIter = k; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } } } break; case 0: if (error <= 1.0) { loop = false; } else { final double ratio = ((double) sequence[k + 1]) / sequence[0]; if (error > ratio * ratio) { reject = true; loop = false; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } } break; case 1: if (error > 1.0) { reject = true; if ((targetIter > 1) && (costPerTimeUnit[targetIter - 1] < orderControl1 * costPerTimeUnit[targetIter])) { --targetIter; } hNew = optimalStep[targetIter]; } loop = false; break; default: if ((firstTime || isLastStep) && (error <= 1.0)) { loop = false; } break; } } } } } if (!reject) { computeDerivatives(stepStart + stepSize, y1, yDot1); } double hInt = getMaxStep(); if (denseOutput && !reject) { for (int j = 1; j <= k; ++j) { extrapolate(0, j, diagonal, yMidDots[0]); } final int mu = 2 * k - mudif + 3; for (int l = 0; l < mu; ++l) { final int l2 = l / 2; double factor = FastMath.pow(0.5 * sequence[l2], l); int middleIndex = fk[l2].length / 2; for (int i = 0; i < y0.length; ++i) { yMidDots[l + 1][i] = factor * fk[l2][middleIndex + l][i]; } for (int j = 1; j <= k - l2; ++j) { factor = FastMath.pow(0.5 * sequence[j + l2], l); middleIndex = fk[l2 + j].length / 2; for (int i = 0; i < y0.length; ++i) { diagonal[j - 1][i] = factor * fk[l2 + j][middleIndex + l][i]; } extrapolate(l2, j, diagonal, yMidDots[l + 1]); } for (int i = 0; i < y0.length; ++i) { yMidDots[l + 1][i] *= stepSize; } for (int j = (l + 1) / 2; j <= k; ++j) { for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) { for (int i = 0; i < y0.length; ++i) { fk[j][m][i] -= fk[j][m - 2][i]; } } } } if (mu >= 0) { final GraggBulirschStoerStepInterpolator gbsInterpolator = (GraggBulirschStoerStepInterpolator) interpolator; gbsInterpolator.computeCoefficients(mu, stepSize); if (useInterpolationError) { final double interpError = gbsInterpolator.estimateError(scale); hInt = FastMath.abs(stepSize / FastMath.max(FastMath.pow(interpError, 1.0 / (mu + 4)), 0.01)); if (interpError > 10.0) { hNew = hInt; reject = true; } } } } if (!reject) { interpolator.storeTime(stepStart + stepSize); stepStart = acceptStep(interpolator, y1, yDot1, t); interpolator.storeTime(stepStart); System.arraycopy(y1, 0, y, 0, y0.length); System.arraycopy(yDot1, 0, yDot0, 0, y0.length); firstStepAlreadyComputed = true; int optimalIter; if (k == 1) { optimalIter = 2; if (previousRejected) { optimalIter = 1; } } else if (k <= targetIter) { optimalIter = k; if (costPerTimeUnit[k - 1] < orderControl1 * costPerTimeUnit[k]) { optimalIter = k - 1; } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1]) { optimalIter = FastMath.min(k + 1, sequence.length - 2); } } else { optimalIter = k - 1; if ((k > 2) && (costPerTimeUnit[k - 2] < orderControl1 * costPerTimeUnit[k - 1])) { optimalIter = k - 2; } if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) { optimalIter = FastMath.min(k, sequence.length - 2); } } if (previousRejected) { targetIter = FastMath.min(optimalIter, k); hNew = FastMath.min(FastMath.abs(stepSize), optimalStep[targetIter]); } else { if (optimalIter <= k) { hNew = optimalStep[optimalIter]; } else { if ((k < targetIter) && (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k - 1])) { hNew = filterStep(optimalStep[k] * costPerStep[optimalIter + 1] / costPerStep[k], forward, false); } else { hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k], forward, false); } } targetIter = optimalIter; } newStep = true; } hNew = FastMath.min(hNew, hInt); if (!forward) { hNew = -hNew; } firstTime = false; if (reject) { isLastStep = false; previousRejected = true; } else { previousRejected = false; } } while (!isLastStep); final double stopTime = stepStart; resetInternalState(); return stopTime; }"
                    ],
                    [
                        0.9575377106666565,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathUserException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[n]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } setStateInitialized(false); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); final int lastRow = nordsieck.getRowDimension() - 1; double hNew = stepSize; interpolator.rescale(hNew); isLastStep = false; do { double error = 10; while (error >= 1.0) { stepSize = hNew; error = 0; for (int i = 0; i < mainSetDimension; ++i) { final double yScale = FastMath.abs(y[i]); final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); final double ratio = nordsieck.getEntry(lastRow, i) / tol; error += ratio * ratio; } error = FastMath.sqrt(error / mainSetDimension); if (error >= 1.0) { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double stepEnd = stepStart + stepSize; interpolator.shift(); interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length); computeDerivatives(stepEnd, y, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); interpolator.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); interpolator.storeTime(stepEnd); stepStart = acceptStep(interpolator, y, yDot, t); scaled = predictedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); if (!isLastStep) { interpolator.storeTime(stepStart); if (resetOccurred) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); final double filteredNextT = stepStart + hNew; final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t); if (filteredNextIsLast) { hNew = t - stepStart; } interpolator.rescale(hNew); } } while (!isLastStep); final double stopTime = stepStart; resetInternalState(); return stopTime; }"
                    ],
                    [
                        0.957481324672699,
                        "protected Dfp trunc(final DfpField.RoundingMode rmode) { boolean changed = false; if (isNaN()) { return newInstance(this); } if (nans == INFINITE) { return newInstance(this); } if (mant[mant.length - 1] == 0) { return newInstance(this); } if (exp < 0) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); Dfp result = newInstance(getZero()); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } if (exp >= mant.length) { return newInstance(this); } Dfp result = newInstance(this); for (int i = 0; i < mant.length - result.exp; i++) { changed |= result.mant[i] != 0; result.mant[i] = 0; } if (changed) { switch(rmode) { case ROUND_FLOOR: if (result.sign == -1) { result = result.add(newInstance(-1)); } break; case ROUND_CEIL: if (result.sign == 1) { result = result.add(getOne()); } break; case ROUND_HALF_EVEN: default: final Dfp half = newInstance(\\\"0.5\\\"); Dfp a = subtract(result); a.sign = 1; if (a.greaterThan(half)) { a = newInstance(getOne()); a.sign = sign; result = result.add(a); } if (a.equals(half) && result.exp > 0 && (result.mant[mant.length - result.exp] & 1) != 0) { a = newInstance(getOne()); a.sign = sign; result = result.add(a); } break; } field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result); return result; } return result; }"
                    ]
                ],
                "non_directly_related_tests": [
                    "org.apache.commons.math.dfp.DfpTest::testIssue567"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n```\n\n```java\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testIssue567() {\n        DfpField field = new DfpField(100);\n        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);\n        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // assign sign correctly\n                sign = (byte) ((bits & 0x8000000000000000L) != 0 ? -1 : 1);\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = (byte) -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                } else {\n                    sign = 1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n    }\n\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                } else {\n                    sign = 1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ((mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496L)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                sign = (bits & 0x8000000000000000L) != 0 ? -1 : 1;\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = (byte) -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = (byte) -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n",
                            "\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/math/dfp/Dfp.java",
                "start_loc": 2303,
                "end_loc": 2384,
                "buggy_function": "    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n",
                "fixed_function": "    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n",
                "comment": "    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n",
                "normalized_body": [
                    "public double toDouble() { if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; } int exponent = (int) (y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--; y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; } y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length() - 1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) { mantissa = 0; exponent++; } if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } return x; }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "public double toDouble() { if (isInfinite()) { if (lessThan(getZero())) { return Double.NEGATIVE_INFINITY; } else { return Double.POSITIVE_INFINITY; } } if (isNaN()) { return Double.NaN; } Dfp y = this; boolean negate = false; if (lessThan(getZero())) { y = negate(); negate = true; } int exponent = (int) (y.log10() * 3.32); if (exponent < 0) { exponent--; } Dfp tempDfp = DfpMath.pow(getTwo(), exponent); while (tempDfp.lessThan(y) || tempDfp.equals(y)) { tempDfp = tempDfp.multiply(2); exponent++; } exponent--; y = y.divide(DfpMath.pow(getTwo(), exponent)); if (exponent > -1023) { y = y.subtract(getOne()); } if (exponent < -1074) { return 0; } if (exponent > 1023) { return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY; } y = y.multiply(newInstance(4503599627370496l)).rint(); String str = y.toString(); str = str.substring(0, str.length() - 1); long mantissa = Long.parseLong(str); if (mantissa == 4503599627370496L) { mantissa = 0; exponent++; } if (exponent <= -1023) { exponent--; } while (exponent < -1023) { exponent++; mantissa >>>= 1; } long bits = mantissa | ((exponent + 1023L) << 52); double x = Double.longBitsToDouble(bits); if (negate) { x = -x; } return x; }"
                    ],
                    [
                        0.9908450245857239,
                        "public static Dfp pow(Dfp x, final Dfp y) { if (x.getField().getRadixDigits() != y.getField().getRadixDigits()) { x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = x.newInstance(x.getZero()); result.nans = Dfp.QNAN; return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, result); } final Dfp zero = x.getZero(); final Dfp one = x.getOne(); final Dfp two = x.getTwo(); boolean invert = false; int ui; if (y.equals(zero)) { return x.newInstance(one); } if (y.equals(one)) { if (x.isNaN()) { x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x); } return x; } if (x.isNaN() || y.isNaN()) { x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN)); } if (x.equals(zero)) { if (Dfp.copysign(one, x).greaterThan(zero)) { if (y.greaterThan(zero)) { return x.newInstance(zero); } else { return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE)); } } else { if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) { if (y.greaterThan(zero)) { return x.newInstance(zero.negate()); } else { return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE)); } } else { if (y.greaterThan(zero)) { return x.newInstance(zero); } else { return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE)); } } } } if (x.lessThan(zero)) { x = x.negate(); invert = true; } if (x.greaterThan(one) && y.classify() == Dfp.INFINITE) { if (y.greaterThan(zero)) { return y; } else { return x.newInstance(zero); } } if (x.lessThan(one) && y.classify() == Dfp.INFINITE) { if (y.greaterThan(zero)) { return x.newInstance(zero); } else { return x.newInstance(Dfp.copysign(y, one)); } } if (x.equals(one) && y.classify() == Dfp.INFINITE) { x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN)); } if (x.classify() == Dfp.INFINITE) { if (invert) { if (y.classify() == Dfp.FINITE && y.rint().equals(y) && !y.remainder(two).equals(zero)) { if (y.greaterThan(zero)) { return x.newInstance(x.newInstance((byte) -1, Dfp.INFINITE)); } else { return x.newInstance(zero.negate()); } } else { if (y.greaterThan(zero)) { return x.newInstance(x.newInstance((byte) 1, Dfp.INFINITE)); } else { return x.newInstance(zero); } } } else { if (y.greaterThan(zero)) { return x; } else { return x.newInstance(zero); } } } if (invert && !y.rint().equals(y)) { x.getField().setIEEEFlagsBits(DfpField.FLAG_INVALID); return x.dotrap(DfpField.FLAG_INVALID, POW_TRAP, x, x.newInstance((byte) 1, Dfp.QNAN)); } Dfp r; if (y.lessThan(x.newInstance(100000000)) && y.greaterThan(x.newInstance(-100000000))) { final Dfp u = y.rint(); ui = u.intValue(); final Dfp v = y.subtract(u); if (v.unequal(zero)) { final Dfp a = v.multiply(log(x)); final Dfp b = a.divide(x.getField().getLn2()).rint(); final Dfp c = a.subtract(b.multiply(x.getField().getLn2())); r = splitPow(split(x), ui); r = r.multiply(pow(two, b.intValue())); r = r.multiply(exp(c)); } else { r = splitPow(split(x), ui); } } else { r = exp(log(x).multiply(y)); } if (invert) { if (y.rint().equals(y) && !y.remainder(two).equals(zero)) { r = r.negate(); } } return x.newInstance(r); }"
                    ],
                    [
                        0.9893950819969177,
                        "public long nextPoisson(double mean) { if (mean <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean); } final RandomGenerator generator = getRan(); final double pivot = 40.0d; if (mean < pivot) { double p = FastMath.exp(-mean); long n = 0; double r = 1.0d; double rnd = 1.0d; while (n < 1000 * mean) { rnd = generator.nextDouble(); r = r * rnd; if (r >= p) { n++; } else { return n; } } return n; } else { final double lambda = FastMath.floor(mean); final double lambdaFractional = mean - lambda; final double logLambda = FastMath.log(lambda); final double logLambdaFactorial = MathUtils.factorialLog((int) lambda); final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional); final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1)); final double halfDelta = delta / 2; final double twolpd = 2 * lambda + delta; final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / 8 * lambda); final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd); final double aSum = a1 + a2 + 1; final double p1 = a1 / aSum; final double p2 = a2 / aSum; final double c1 = 1 / (8 * lambda); double x = 0; double y = 0; double v = 0; int a = 0; double t = 0; double qr = 0; double qa = 0; for (; ; ) { final double u = nextUniform(0.0, 1); if (u <= p1) { final double n = nextGaussian(0d, 1d); x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d; if (x > delta || x < -lambda) { continue; } y = x < 0 ? FastMath.floor(x) : FastMath.ceil(x); final double e = nextExponential(1d); v = -e - (n * n / 2) + c1; } else { if (u > p1 + p2) { y = lambda; break; } else { x = delta + (twolpd / delta) * nextExponential(1d); y = FastMath.ceil(x); v = -nextExponential(1d) - delta * (x + 1) / twolpd; } } a = x < 0 ? 1 : 0; t = y * (y + 1) / (2 * lambda); if (v < -t && a == 0) { y = lambda + y; break; } qr = t * ((2 * y + 1) / (6 * lambda) - 1); qa = qr - (t * t) / (3 * (lambda + a * (y + 1))); if (v < qa) { y = lambda + y; break; } if (v > qr) { continue; } if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) { y = lambda + y; break; } } return y2 + (long) y; } }"
                    ],
                    [
                        0.9886934757232666,
                        "@Test public void testSubtract() { BigFraction a = new BigFraction(1, 2); BigFraction b = new BigFraction(2, 3); assertFraction(0, 1, a.subtract(a)); assertFraction(-1, 6, a.subtract(b)); assertFraction(1, 6, b.subtract(a)); assertFraction(0, 1, b.subtract(b)); BigFraction f = new BigFraction(1, 1); try { f.subtract((BigFraction) null); Assert.fail(\\\"expecting NullArgumentException\\\"); } catch (NullArgumentException ex) { } BigFraction f1 = new BigFraction(1, 32768 * 3); BigFraction f2 = new BigFraction(1, 59049); f = f1.subtract(f2); Assert.assertEquals(-13085, f.getNumeratorAsInt()); Assert.assertEquals(1934917632, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MIN_VALUE, 3); f2 = new BigFraction(1, 3).negate(); f = f1.subtract(f2); Assert.assertEquals(Integer.MIN_VALUE + 1, f.getNumeratorAsInt()); Assert.assertEquals(3, f.getDenominatorAsInt()); f1 = new BigFraction(Integer.MAX_VALUE, 1); f2 = BigFraction.ONE; f = f1.subtract(f2); Assert.assertEquals(Integer.MAX_VALUE - 1, f.getNumeratorAsInt()); Assert.assertEquals(1, f.getDenominatorAsInt()); }"
                    ],
                    [
                        0.9882586002349854,
                        "@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws MathUserException, IntegratorException { final int n = y0.length; sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; if (y != y0) { System.arraycopy(y0, 0, y, 0, n); } final double[] yDot = new double[n]; final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator(); interpolator.reinitialize(y, forward); for (StepHandler handler : stepHandlers) { handler.reset(); } setStateInitialized(false); start(t0, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); interpolator.storeTime(stepStart); final int lastRow = nordsieck.getRowDimension() - 1; double hNew = stepSize; interpolator.rescale(hNew); isLastStep = false; do { double error = 10; while (error >= 1.0) { stepSize = hNew; error = 0; for (int i = 0; i < mainSetDimension; ++i) { final double yScale = FastMath.abs(y[i]); final double tol = (vecAbsoluteTolerance == null) ? (scalAbsoluteTolerance + scalRelativeTolerance * yScale) : (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale); final double ratio = nordsieck.getEntry(lastRow, i) / tol; error += ratio * ratio; } error = FastMath.sqrt(error / mainSetDimension); if (error >= 1.0) { final double factor = computeStepGrowShrinkFactor(error); hNew = filterStep(stepSize * factor, forward, false); interpolator.rescale(hNew); } } final double stepEnd = stepStart + stepSize; interpolator.shift(); interpolator.setInterpolatedTime(stepEnd); System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length); computeDerivatives(stepEnd, y, yDot); final double[] predictedScaled = new double[y0.length]; for (int j = 0; j < y0.length; ++j) { predictedScaled[j] = stepSize * yDot[j]; } final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck); updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp); interpolator.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp); interpolator.storeTime(stepEnd); stepStart = acceptStep(interpolator, y, yDot, t); scaled = predictedScaled; nordsieck = nordsieckTmp; interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck); if (!isLastStep) { interpolator.storeTime(stepStart); if (resetOccurred) { start(stepStart, y, t); interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck); } final double factor = computeStepGrowShrinkFactor(error); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); final double filteredNextT = stepStart + hNew; final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t); if (filteredNextIsLast) { hNew = t - stepStart; } interpolator.rescale(hNew); } } while (!isLastStep); final double stopTime = stepStart; resetInternalState(); return stopTime; }"
                    ],
                    [
                        0.9879794120788574,
                        "public Dfp nextAfter(final Dfp x) { if (field.getRadixDigits() != x.field.getRadixDigits()) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); final Dfp result = newInstance(getZero()); result.nans = QNAN; return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result); } boolean up = false; if (this.lessThan(x)) { up = true; } if (compare(this, x) == 0) { return newInstance(x); } if (lessThan(getZero())) { up = !up; } final Dfp inc; Dfp result; if (up) { inc = newInstance(getOne()); inc.exp = this.exp - mant.length + 1; inc.sign = this.sign; if (this.equals(getZero())) { inc.exp = MIN_EXP - mant.length; } result = add(inc); } else { inc = newInstance(getOne()); inc.exp = this.exp; inc.sign = this.sign; if (this.equals(inc)) { inc.exp = this.exp - mant.length; } else { inc.exp = this.exp - mant.length + 1; } if (this.equals(getZero())) { inc.exp = MIN_EXP - mant.length; } result = this.subtract(inc); } if (result.classify() == INFINITE && this.classify() != INFINITE) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } if (result.equals(getZero()) && this.equals(getZero()) == false) { field.setIEEEFlagsBits(DfpField.FLAG_INEXACT); result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result); } return result; }"
                    ],
                    [
                        0.9873353242874146,
                        "public Dfp multiply(final int x) { Dfp result = newInstance(this); if (nans != FINITE) { if (isNaN()) { return this; } if (nans == INFINITE && x != 0) { result = newInstance(this); return result; } if (nans == INFINITE && x == 0) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result); return result; } } if (x < 0 || x >= RADIX) { field.setIEEEFlagsBits(DfpField.FLAG_INVALID); result = newInstance(getZero()); result.nans = QNAN; result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result); return result; } int rh = 0; for (int i = 0; i < mant.length; i++) { final int r = mant[i] * x + rh; rh = r / RADIX; result.mant[i] = r - rh * RADIX; } int lostdigit = 0; if (rh != 0) { lostdigit = result.mant[0]; result.shiftRight(); result.mant[mant.length - 1] = rh; } if (result.mant[mant.length - 1] == 0) { result.exp = 0; } final int excp = result.round(lostdigit); if (excp != 0) { result = dotrap(excp, MULTIPLY_TRAP, result, result); } return result; }"
                    ]
                ],
                "non_directly_related_tests": [
                    "org.apache.commons.math.dfp.DfpTest::testIssue567"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n```\n\n```java\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testIssue567() {\n        DfpField field = new DfpField(100);\n        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);\n        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = y.negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to the next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* It's going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        if (equals(getZero())) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n    }\n\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496L)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        if (negate) {\n            bits |= 0x8000000000000000L;\n        }\n        double x = Double.longBitsToDouble(bits);\n\n        return x;\n\n    }\n\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            return sign < 0 ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = y.negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        bits |= (negate ? 1L : 0L) << 63; // set the sign bit\n        double x = Double.longBitsToDouble(bits);\n\n        return x;\n\n    }\n\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        if (equals(getZero())) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        if (equals(getZero())) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n",
                            "\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        if (y.equals(getZero())) {\n            return negate ? -0.0 : 0.0;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.math.dfp.DfpTest::testIssue567": {
                "path": "src/test/java/org/apache/commons/math/dfp/DfpTest.java",
                "function_name": "testIssue567",
                "src": "    public void testIssue567() {\n        DfpField field = new DfpField(100);\n        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);\n        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>\n\tat org.junit.Assert.fail(Assert.java:88)\n\tat org.junit.Assert.failNotEquals(Assert.java:743)\n\tat org.junit.Assert.assertEquals(Assert.java:494)\n\tat org.junit.Assert.assertEquals(Assert.java:592)\n\tat org.apache.commons.math.dfp.DfpTest.testIssue567(DfpTest.java:1512)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>\n\tat org.apache.commons.math.dfp.DfpTest.testIssue567(DfpTest.java:1512)  Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);"
            }
        },
        "evaluation_done": true
    }
}