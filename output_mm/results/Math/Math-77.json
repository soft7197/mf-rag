{
    "Math-77": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/math/linear/ArrayRealVector.java",
                "start_loc": 717,
                "end_loc": 724,
                "buggy_function": "    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                "fixed_function": "    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                "comment": "    /** {@inheritDoc} */\n",
                "normalized_body": [
                    "@Override public double getLInfNorm() { double max = 0; for (double a : data) { max += Math.max(max, Math.abs(a)); } return max; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999997615814209,
                        "@Override public double getLInfNorm() { double max = 0; for (double a : data) { max += Math.max(max, Math.abs(a)); } return max; }"
                    ],
                    [
                        0.985853910446167,
                        "@Override public double getL1Norm() { double sum = 0; for (double a : data) { sum += Math.abs(a); } return sum; }"
                    ],
                    [
                        0.9843339920043945,
                        "@Override public double getNorm() { double sum = 0; for (double a : data) { sum += a * a; } return Math.sqrt(sum); }"
                    ],
                    [
                        0.9807502031326294,
                        "@Override public int hashCode() { int h = 3542; for (final T a : data) { h = h ^ a.hashCode(); } return h; }"
                    ],
                    [
                        0.9795954823493958,
                        "@Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + Arrays.hashCode(means); return result; }"
                    ],
                    [
                        0.9782818555831909,
                        "@Override public int hashCode() { if (isNaN()) { return 7; } return 37 * (17 * MathUtils.hash(imaginary) + MathUtils.hash(real)); }"
                    ],
                    [
                        0.9779178500175476,
                        "@Override public void clear() { if (incMoment) { moment.clear(); } else { throw MathRuntimeException.createIllegalStateException(\\\"statistics constructed from external moments cannot be cleared\\\"); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.math.linear.ArrayRealVectorTest::testBasicFunctions"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max += Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBasicFunctions() {\n        ArrayRealVector v1 = new ArrayRealVector(vec1);\n        ArrayRealVector v2 = new ArrayRealVector(vec2);\n        ArrayRealVector v5 = new ArrayRealVector(vec5);\n        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_3 = v1.getDistance((RealVector) v2);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n\n        //octave =  v1 + v2\n        ArrayRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        ArrayRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n        double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);\n\n        // octave v1 ./ v2\n        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n        assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n        RealVector v_projection_3 = v1.projection(v2.getData());\n        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n\n    }\n```\n#Error message: junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>\n\tat org.apache.commons.math.linear.ArrayRealVectorTest.testBasicFunctions(ArrayRealVectorTest.java:1098)  assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                            "\n@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max = Math.max(max, Math.abs(a));\n    }\n    return max;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                            "\n@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max = Math.max(max, Math.abs(a));\n    }\n    return max;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                            "\n@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max = Math.max(max, Math.abs(a));\n    }\n    return max;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n",
                            "\n@Override\npublic double getLInfNorm() {\n    double max = 0;\n    for (double a : data) {\n        max = Math.max(max, Math.abs(a));\n    }\n    return max;\n}\n"
                        ],
                        "plausible_patches": [
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public double getLInfNorm() {\n        double max = 0;\n        for (double a : data) {\n            max = Math.max(max, Math.abs(a));\n        }\n        return max;\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java",
                "start_loc": 498,
                "end_loc": 506,
                "buggy_function": "    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n",
                "fixed_function": null,
                "comment": "",
                "normalized_body": [
                    "public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public double getLInfNorm() { double max = 0; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); max += iter.value(); } return max; }"
                    ],
                    [
                        0.9835618734359741,
                        "public boolean isSingular() { if (lu == null) { try { luDecompose(); return false; } catch (InvalidMatrixException ex) { return true; } } else { return false; } }"
                    ],
                    [
                        0.982994556427002,
                        "public double[] getData() { double[] res = new double[virtualSize]; Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res[iter.key()] = iter.value(); } return res; }"
                    ],
                    [
                        0.9816403388977051,
                        "public double getPartialRadiusX() { double dRdX = 0; for (PointModel point : points) { dRdX += point.getPartialDiX(); } return dRdX / points.size(); }"
                    ],
                    [
                        0.9816403388977051,
                        "public double getPartialRadiusX() { double dRdX = 0; for (PointModel point : points) { dRdX += point.getPartialDiX(); } return dRdX / points.size(); }"
                    ],
                    [
                        0.9804723262786865,
                        "public double[] getOptima() throws IllegalStateException { if (optima == null) { throw MathRuntimeException.createIllegalStateException(\\\"no optimum computed yet\\\"); } return optima.clone(); }"
                    ],
                    [
                        0.979760468006134,
                        "public boolean isNaN() { Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); if (Double.isNaN(iter.value())) { return true; } } return false; }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.math.linear.SparseRealVectorTest::testBasicFunctions"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    public double getLInfNorm() {\n        double max = 0;\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            max += iter.value();\n        }\n        return max;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBasicFunctions() {\n        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n        OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n\n        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        //octave =  v1 + v2\n        OpenMapRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        OpenMapRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        // octave v1 ./ v2\n        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        OpenMapRealVector v_unitize = v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        RealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n    }\n```\n#Error message: junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>\n\tat org.apache.commons.math.linear.SparseRealVectorTest.testBasicFunctions(SparseRealVectorTest.java:968)  assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        double value = Math.abs(iter.value());\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        double value = Math.abs(iter.value());\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        double absValue = Math.abs(iter.value());\n        if (absValue > max) {\n            max = absValue;\n        }\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        double value = Math.abs(iter.value());\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n"
                        ],
                        "plausible_patches": [
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        double value = Math.abs(iter.value());\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        max = Math.max(max, Math.abs(iter.value()));\n    }\n    return max;\n}\n",
                            "\npublic double getLInfNorm() {\n    double max = 0;\n    Iterator iter = entries.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        double absValue = Math.abs(iter.value());\n        if (absValue > max) {\n            max = absValue;\n        }\n    }\n    return max;\n}\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.math.linear.ArrayRealVectorTest::testBasicFunctions": {
                "path": "src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java",
                "function_name": "testBasicFunctions",
                "src": "    public void testBasicFunctions() {\n        ArrayRealVector v1 = new ArrayRealVector(vec1);\n        ArrayRealVector v2 = new ArrayRealVector(vec2);\n        ArrayRealVector v5 = new ArrayRealVector(vec5);\n        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_3 = v1.getDistance((RealVector) v2);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_3 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        double d_getL1Distance_3 = v1. getL1Distance((RealVector) v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_3 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        double d_getLInfDistance_3 = v1. getLInfDistance((RealVector) v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_3 );\n\n        //octave =  v1 + v2\n        ArrayRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        ArrayRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        ArrayRealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        RealVector  v_ebeMultiply_3 = v1.ebeMultiply((RealVector) v2);\n        double[] result_ebeMultiply_3 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_3.getData(),result_ebeMultiply_3,normTolerance);\n\n        // octave v1 ./ v2\n        ArrayRealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        RealVector  v_ebeDivide_3 = v1.ebeDivide((RealVector) v2);\n        double[] result_ebeDivide_3 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_3.getData(),result_ebeDivide_3,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealMatrix m_outerProduct_3 = v1.outerProduct((RealVector) v2);\n        assertEquals(\"compare val \",4d, m_outerProduct_3.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_unitize = (ArrayRealVector)v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        ArrayRealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n        RealVector v_projection_3 = v1.projection(v2.getData());\n        double[] result_projection_3 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_3.getData(), result_projection_3, normTolerance);\n\n    }",
                "error_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:244)\n\tat org.apache.commons.math.linear.ArrayRealVectorTest.testBasicFunctions(ArrayRealVectorTest.java:1098)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>\n\tat org.apache.commons.math.linear.ArrayRealVectorTest.testBasicFunctions(ArrayRealVectorTest.java:1098)  assertEquals(\"compare values  \", 6.0, d_getLInfNorm);"
            },
            "org.apache.commons.math.linear.SparseRealVectorTest::testBasicFunctions": {
                "path": "src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java",
                "function_name": "testBasicFunctions",
                "src": "    public void testBasicFunctions() {\n        OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n        OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n        OpenMapRealVector v5 = new OpenMapRealVector(vec5);\n        OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n\n        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n        assertEquals(\"compare values  \", 8.4261497731763586307, d_getNorm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n        assertEquals(\"compare values  \", 17.0, d_getL1Norm);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm);\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist = v1.getDistance(v2);\n        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n\n        //octave =  sqrt(sumsq(v1-v2))\n        double dist_2 = v1.getDistance(v2_t);\n        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n\n        //octave =  ???\n        double d_getL1Distance = v1. getL1Distance(v2);\n        assertEquals(\"compare values  \",9d, d_getL1Distance );\n\n        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n\n        //octave =  ???\n        double d_getLInfDistance = v1. getLInfDistance(v2);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n\n        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n\n        //octave =  v1 + v2\n        OpenMapRealVector v_add = v1.add(v2);\n        double[] result_add = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n\n        SparseRealVectorTestImpl vt2 = new SparseRealVectorTestImpl(vec2);\n        RealVector v_add_i = v1.add(vt2);\n        double[] result_add_i = {5d, 7d, 9d};\n        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n\n        //octave =  v1 - v2\n        OpenMapRealVector v_subtract = v1.subtract(v2);\n        double[] result_subtract = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n\n        RealVector v_subtract_i = v1.subtract(vt2);\n        double[] result_subtract_i = {-3d, -3d, -3d};\n        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n\n        // octave v1 .* v2\n        RealVector  v_ebeMultiply = v1.ebeMultiply(v2);\n        double[] result_ebeMultiply = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n\n        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n\n        // octave v1 ./ v2\n        RealVector  v_ebeDivide = v1.ebeDivide(v2);\n        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n\n        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n\n        // octave  dot(v1,v2)\n        double dot =  v1.dotProduct(v2);\n        assertEquals(\"compare val \",32d, dot);\n\n        // octave  dot(v1,v2_t)\n        double dot_2 =  v1.dotProduct(v2_t);\n        assertEquals(\"compare val \",32d, dot_2);\n\n        RealMatrix m_outerProduct = v1.outerProduct(v2);\n        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n\n        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n\n        RealVector v_unitVector = v1.unitVector();\n        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n\n        try {\n            v_null.unitVector();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        OpenMapRealVector v_unitize = v1.copy();\n        v_unitize.unitize();\n        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n        try {\n            v_null.unitize();\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected behavior\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        RealVector v_projection = v1.projection(v2);\n        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n\n        RealVector v_projection_2 = v1.projection(v2_t);\n        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n\n    }",
                "error_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:244)\n\tat org.apache.commons.math.linear.SparseRealVectorTest.testBasicFunctions(SparseRealVectorTest.java:968)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<-3.0>\n\tat org.apache.commons.math.linear.SparseRealVectorTest.testBasicFunctions(SparseRealVectorTest.java:968)  assertEquals(\"compare values  \", 6.0, d_getLInfNorm);"
            }
        },
        "evaluation_done": true
    }
}