{
    "Math-29": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java",
                "start_loc": 340,
                "end_loc": 355,
                "buggy_function": "    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n",
                "fixed_function": "    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        final int n = getDimension();\n        for (int i = 0; i < n; i++) {\n            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n        }\n        return res;\n    }\n",
                "comment": "    /** {@inheritDoc} */\n",
                "normalized_body": [
                    "@Override public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); } return res; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); } return res; }"
                    ],
                    [
                        0.9838644862174988,
                        "public RealVector subtract(RealVector v) { checkVectorDimensions(v); RealVector result = v.mapMultiply(-1d); Iterator<Entry> it = sparseIterator(); while (it.hasNext()) { final Entry e = it.next(); final int index = e.getIndex(); result.setEntry(index, e.getValue() + result.getEntry(index)); } return result; }"
                    ],
                    [
                        0.9817398190498352,
                        "@Override public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); } return res; }"
                    ],
                    [
                        0.9809582829475403,
                        "public T dotProduct(FieldVector<T> v) { checkVectorDimensions(v.getDimension()); T res = field.getZero(); OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res = res.add(v.getEntry(iter.key()).multiply(iter.value())); } return res; }"
                    ],
                    [
                        0.9796963930130005,
                        "private OpenIntToFieldHashMap<Fraction> createFromJavaMap(Field<Fraction> field) { OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field); for (Map.Entry<Integer, Fraction> mapEntry : javaMap.entrySet()) { map.put(mapEntry.getKey(), mapEntry.getValue()); } return map; }"
                    ],
                    [
                        0.9753137826919556,
                        "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) { double[][] d = new double[m.getRowDimension()][cols.length]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < cols.length; c++) { d[r][c] = m.getEntry(r, cols[c]); } } return new Array2DRowRealMatrix(d, false); }"
                    ],
                    [
                        0.975166916847229,
                        "private void checkSampleData(final double[] data) throws NullArgumentException, NumberIsTooSmallException { if (data == null) { throw new NullArgumentException(); } if (data.length < 2) { throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DATA_FOR_T_STATISTIC, data.length, 2, true); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.math3.linear.SparseRealVectorTest::testEbeDivideMixedTypes"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        double value = getEntry(i) / v.getEntry(i);\n        res.setEntry(i, value);\n    }\n    return res;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        \n        for (int i = 0; i < getDimension(); i++) {\n            double entry = getEntry(i) / v.getEntry(i);\n            res.setEntry(i, entry);\n        }\n        \n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        for (int i = 0; i < getDimension(); i++) {\n            res.setEntry(i, getEntry(i) / v.getEntry(i));\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector();\n        for (int i = 0; i < this.getDimension(); i++) {\n            double value = this.getEntry(i) / v.getEntry(i);\n            res.setEntry(i, value);\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        for (int i = 0; i < getDimension(); i++) {\n            if (!res.containsKey(i) && v.getEntry(i) != 0) {\n                res.setEntry(i, 0.0 / v.getEntry(i));\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n\n        for (int i = 0; i < getDimension(); i++) {\n            double dividend = this.getEntry(i);\n            double divisor = v.getEntry(i);\n            res.setEntry(i, dividend / divisor);\n        }\n\n        return res;\n    }\n",
                            "\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(getDimension());\n    \n    for (int i = 0; i < getDimension(); i++) {\n        double value = getEntry(i) / v.getEntry(i);\n        if (Double.isNaN(value) || value != 0.0) {\n            res.setEntry(i, value);\n        }\n    }\n    \n    return res;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        \n        for (int i = 0; i < getDimension(); i++) {\n            res.setEntry(i, getEntry(i) / v.getEntry(i));\n        }\n        \n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        for (int i = 0; i < getDimension(); i++) {\n            res.setEntry(i, getEntry(i) / v.getEntry(i));\n        }\n        return res;\n    }\n",
                            "\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    \n    for (int i = 0; i < res.getDimension(); i++) {\n        res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n    }\n    \n    return res;\n}\n"
                        ],
                        "plausible_patches": [
                            "\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        double value = getEntry(i) / v.getEntry(i);\n        res.setEntry(i, value);\n    }\n    return res;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        \n        for (int i = 0; i < getDimension(); i++) {\n            double entry = getEntry(i) / v.getEntry(i);\n            res.setEntry(i, entry);\n        }\n        \n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        for (int i = 0; i < getDimension(); i++) {\n            res.setEntry(i, getEntry(i) / v.getEntry(i));\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n\n        for (int i = 0; i < getDimension(); i++) {\n            double dividend = this.getEntry(i);\n            double divisor = v.getEntry(i);\n            res.setEntry(i, dividend / divisor);\n        }\n\n        return res;\n    }\n",
                            "\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(getDimension());\n    \n    for (int i = 0; i < getDimension(); i++) {\n        double value = getEntry(i) / v.getEntry(i);\n        if (Double.isNaN(value) || value != 0.0) {\n            res.setEntry(i, value);\n        }\n    }\n    \n    return res;\n}\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        \n        for (int i = 0; i < getDimension(); i++) {\n            res.setEntry(i, getEntry(i) / v.getEntry(i));\n        }\n        \n        return res;\n    }\n",
                            "\n@Override\npublic OpenMapRealVector ebeDivide(RealVector v) {\n    checkVectorDimensions(v.getDimension());\n    OpenMapRealVector res = new OpenMapRealVector(this);\n    \n    for (int i = 0; i < res.getDimension(); i++) {\n        res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n    }\n    \n    return res;\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java",
                "start_loc": 358,
                "end_loc": 375,
                "buggy_function": "    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }\n",
                "fixed_function": "    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        if (v.isNaN() || v.isInfinite()) {\n            final int n = getDimension();\n            for (int i = 0; i < n; i++) {\n                final double y = v.getEntry(i);\n                if (Double.isNaN(y)) {\n                    res.setEntry(i, Double.NaN);\n                } else if (Double.isInfinite(y)) {\n                    final double x = this.getEntry(i);\n                    res.setEntry(i, x * y);\n                }\n            }\n        }\n        return res;\n    }\n",
                "comment": "    /** {@inheritDoc} */\n",
                "normalized_body": [
                    "@Override public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); } return res; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public OpenMapRealVector ebeMultiply(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key())); } return res; }"
                    ],
                    [
                        0.9817398190498352,
                        "@Override public OpenMapRealVector ebeDivide(RealVector v) { checkVectorDimensions(v.getDimension()); OpenMapRealVector res = new OpenMapRealVector(this); Iterator iter = entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key())); } return res; }"
                    ],
                    [
                        0.975408673286438,
                        "@Test public void testIterator() throws Exception { RealVector v = new TestVectorImpl(vec2.clone()); Entry e; int i = 0; for (Iterator<Entry> it = v.iterator(); it.hasNext() && (e = it.next()) != null; i++) { Assert.assertEquals(vec2[i], e.getValue(), 0); } }"
                    ],
                    [
                        0.972403883934021,
                        "private static RealMatrix log(final RealMatrix m) { double[][] d = new double[m.getRowDimension()][m.getColumnDimension()]; for (int r = 0; r < m.getRowDimension(); r++) { for (int c = 0; c < m.getColumnDimension(); c++) { d[r][c] = Math.log(m.getEntry(r, c)); } } return new Array2DRowRealMatrix(d, false); }"
                    ],
                    [
                        0.9723705053329468,
                        "public RealVector subtract(RealVector v) { checkVectorDimensions(v); RealVector result = v.mapMultiply(-1d); Iterator<Entry> it = sparseIterator(); while (it.hasNext()) { final Entry e = it.next(); final int index = e.getIndex(); result.setEntry(index, e.getValue() + result.getEntry(index)); } return result; }"
                    ],
                    [
                        0.9723303318023682,
                        "public FieldVector<T> ebeMultiply(FieldVector<T> v) { checkVectorDimensions(v.getDimension()); SparseFieldVector<T> res = new SparseFieldVector<T>(this); OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator(); while (iter.hasNext()) { iter.advance(); res.setEntry(iter.key(), iter.value().multiply(v.getEntry(iter.key()))); } return res; }"
                    ],
                    [
                        0.9722636342048645,
                        "public static double factorialDouble(final int n) { if (n < 0) { throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n); } if (n < 21) { return factorial(n); } return FastMath.floor(FastMath.exp(ArithmeticUtils.factorialLog(n)) + 0.5); }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.math3.linear.SparseRealVectorTest::testEbeMultiplyMixedTypes",
                    "org.apache.commons.math3.linear.SparseRealVectorTest::testEbeMultiplySameType"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!entries.containsKey(i)) {\n                double vi = v.getEntry(i);\n                if (Double.isNaN(vi) || Double.isInfinite(vi)) {\n                    res.setEntry(i, 0.0 * vi);\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        \n        // Handle cases where this[i] == 0d and (v[i] = NaN or v[i] = Infinity)\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!this.containsKey(i)) {\n                double val = v.getEntry(i);\n                if (Double.isNaN(val) || Double.isInfinite(val)) {\n                    res.setEntry(i, 0.0 * val);\n                }\n            }\n        }\n        \n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n\n        // Handle special cases where this[i] == 0d and (v[i] is NaN or Infinity)\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (res.getEntry(i) == 0d && (Double.isNaN(v.getEntry(i)) || Double.isInfinite(v.getEntry(i)))) {\n                res.setEntry(i, 0d * v.getEntry(i)); // ensures NaN or Infinity is handled\n            }\n        }\n\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!this.containsKey(i)) {\n                double value = v.getEntry(i);\n                if (Double.isNaN(value) || Double.isInfinite(value)) {\n                    res.setEntry(i, 0.0 * value);\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        Set<Integer> visitedIndices = new HashSet<>();\n        while (iter.hasNext()) {\n            iter.advance();\n            int index = iter.key();\n            res.setEntry(index, iter.value() * v.getEntry(index));\n            visitedIndices.add(index);\n        }\n        \n        // Handle special cases where this[i] == 0d and v[i] is NaN or Infinity\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!visitedIndices.contains(i)) {\n                double vEntry = v.getEntry(i);\n                if (Double.isNaN(vEntry) || Double.isInfinite(vEntry)) {\n                    res.setEntry(i, 0d * vEntry);\n                }\n            }\n        }\n        \n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n\n        // Handle cases where this[i] == 0d and v[i] is NaN or Infinity\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (this.getEntry(i) == 0.0 && (Double.isNaN(v.getEntry(i)) || Double.isInfinite(v.getEntry(i)))) {\n                res.setEntry(i, 0.0 * v.getEntry(i)); // Ensure 0.0 * NaN or Infinity is NaN or Infinity\n            }\n        }\n\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        // Check for all zero entries in this vector that may require special treatment\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!res.getEntries().containsKey(i)) { // If res does not have this index\n                double value = v.getEntry(i);\n                if (Double.isNaN(value) || Double.isInfinite(value)) {\n                    res.setEntry(i, 0.0 * value); // NaN or Infinite * 0\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        int dimension = getDimension();\n        for (int i = 0; i < dimension; i++) {\n            if (!entries.containsKey(i)) {\n                double value = v.getEntry(i);\n                if (Double.isNaN(value) || Double.isInfinite(value)) {\n                    res.setEntry(i, 0.0 * value);\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        // Handle special cases when this[i] == 0d and (v[i] = NaN or v[i] = Infinity)\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (Double.isNaN(v.getEntry(i)) || Double.isInfinite(v.getEntry(i))) {\n                res.setEntry(i, 0d * v.getEntry(i));\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        // Handle special cases where this[i] == 0d and v[i] = NaN or v[i] = Infinity\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!entries.containsKey(i)) { // this[i] is implicitly 0d\n                double vi = v.getEntry(i);\n                if (Double.isNaN(vi) || Double.isInfinite(vi)) {\n                    res.setEntry(i, 0d * vi);\n                }\n            }\n        }\n        return res;\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!entries.containsKey(i)) {\n                double vi = v.getEntry(i);\n                if (Double.isNaN(vi) || Double.isInfinite(vi)) {\n                    res.setEntry(i, 0.0 * vi);\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n\n        // Handle special cases where this[i] == 0d and (v[i] is NaN or Infinity)\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (res.getEntry(i) == 0d && (Double.isNaN(v.getEntry(i)) || Double.isInfinite(v.getEntry(i)))) {\n                res.setEntry(i, 0d * v.getEntry(i)); // ensures NaN or Infinity is handled\n            }\n        }\n\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n\n        // Handle cases where this[i] == 0d and v[i] is NaN or Infinity\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (this.getEntry(i) == 0.0 && (Double.isNaN(v.getEntry(i)) || Double.isInfinite(v.getEntry(i)))) {\n                res.setEntry(i, 0.0 * v.getEntry(i)); // Ensure 0.0 * NaN or Infinity is NaN or Infinity\n            }\n        }\n\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        // Check for all zero entries in this vector that may require special treatment\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!res.getEntries().containsKey(i)) { // If res does not have this index\n                double value = v.getEntry(i);\n                if (Double.isNaN(value) || Double.isInfinite(value)) {\n                    res.setEntry(i, 0.0 * value); // NaN or Infinite * 0\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        int dimension = getDimension();\n        for (int i = 0; i < dimension; i++) {\n            if (!entries.containsKey(i)) {\n                double value = v.getEntry(i);\n                if (Double.isNaN(value) || Double.isInfinite(value)) {\n                    res.setEntry(i, 0.0 * value);\n                }\n            }\n        }\n        return res;\n    }\n",
                            "\n    /** {@inheritDoc} */\n\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        // Handle special cases where this[i] == 0d and v[i] = NaN or v[i] = Infinity\n        for (int i = 0; i < v.getDimension(); i++) {\n            if (!entries.containsKey(i)) { // this[i] is implicitly 0d\n                double vi = v.getEntry(i);\n                if (Double.isNaN(vi) || Double.isInfinite(vi)) {\n                    res.setEntry(i, 0d * vi);\n                }\n            }\n        }\n        return res;\n    }\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.math3.linear.SparseRealVectorTest::isNaN": {
                "path": "src/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.java",
                "function_name": "isNaN",
                "src": "@Override\n      public boolean isNaN() {\n          boolean isNaN = false;\n          for (int i = 0; i < data.length; i++) {\n              isNaN |= Double.isNaN(data[i]);\n          }\n          return isNaN;\n      }",
                "error_msg": "junit.framework.AssertionFailedError: entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>\n\tat org.junit.Assert.fail(Assert.java:88)\n\tat org.junit.Assert.failNotEquals(Assert.java:743)\n\tat org.junit.Assert.assertEquals(Assert.java:494)\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.doTestEbeBinaryOperation(RealVectorAbstractTest.java:519)\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.testEbeDivideMixedTypes(RealVectorAbstractTest.java:595)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.doTestEbeBinaryOperation(RealVectorAbstractTest.java:519)  Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.testEbeDivideMixedTypes(RealVectorAbstractTest.java:595)  doTestEbeBinaryOperation(BinaryOperation.DIV, true);"
            },
            "org.apache.commons.math3.linear.SparseRealVectorTest::isInfinite": {
                "path": "src/test/java/org/apache/commons/math3/linear/SparseRealVectorTest.java",
                "function_name": "isInfinite",
                "src": "        @Override\n        public boolean isInfinite() {\n            boolean isInfinite = false;\n            for (int i = 0; i < data.length; i++) {\n                final double x = data[i];\n                if (Double.isNaN(x)) {\n                    return false;\n                }\n                isInfinite |= Double.isInfinite(x);\n            }\n            return isInfinite;\n        }",
                "error_msg": "junit.framework.AssertionFailedError: entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>\n\tat org.junit.Assert.fail(Assert.java:88)\n\tat org.junit.Assert.failNotEquals(Assert.java:743)\n\tat org.junit.Assert.assertEquals(Assert.java:494)\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.doTestEbeBinaryOperation(RealVectorAbstractTest.java:519)\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.testEbeMultiplySameType(RealVectorAbstractTest.java:575)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.doTestEbeBinaryOperation(RealVectorAbstractTest.java:519)  Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\n\tat org.apache.commons.math3.linear.RealVectorAbstractTest.testEbeMultiplySameType(RealVectorAbstractTest.java:575)  doTestEbeBinaryOperation(BinaryOperation.MUL, false);"
            }
        },
        "evaluation_done": true
    }
}