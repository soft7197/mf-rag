{
    "Closure-90": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
                "start_loc": 176,
                "end_loc": 190,
                "buggy_function": "    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }\n",
                "fixed_function": "    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.restrictByNotNullOrUndefined().isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public boolean apply(JSType type) { ObjectType objectType = ObjectType.cast(type); if (objectType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString()); } else if (objectType.isUnknownType() && (objectType.getImplicitPrototype() == null || objectType.getImplicitPrototype().isResolved())) { reportWarning(RESOLVED_TAG_EMPTY, \\\"@extends\\\", fnName); } else { return true; } return false; }",
                    "@Override public boolean apply(JSType type) { ObjectType objectType = ObjectType.cast(type); if (objectType == null) { reportError(BAD_IMPLEMENTED_TYPE, fnName); } else if (objectType.isUnknownType() && (objectType.getImplicitPrototype() == null || objectType.getImplicitPrototype().isResolved())) { reportWarning(RESOLVED_TAG_EMPTY, \\\"@implements\\\", fnName); } else { return true; } return false; }",
                    "@Override public boolean apply(JSType type) { if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) { reportWarning(THIS_TYPE_NON_OBJECT, type.toString()); return false; } return true; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public boolean apply(JSType type) { ObjectType objectType = ObjectType.cast(type); if (objectType == null) { reportWarning(EXTENDS_NON_OBJECT, fnName, type.toString()); } else if (objectType.isUnknownType() && (objectType.getImplicitPrototype() == null || objectType.getImplicitPrototype().isResolved())) { reportWarning(RESOLVED_TAG_EMPTY, \\\"@extends\\\", fnName); } else { return true; } return false; }"
                    ],
                    [
                        0.9687766432762146,
                        "static JSDocInfo getInfoForNameNode(Node nameNode) { JSDocInfo info = null; Node parent = null; if (nameNode != null) { info = nameNode.getJSDocInfo(); parent = nameNode.getParent(); } if (info == null && parent != null && ((parent.getType() == Token.VAR && parent.hasOneChild()) || parent.getType() == Token.FUNCTION)) { info = parent.getJSDocInfo(); } return info; }"
                    ],
                    [
                        0.9658522009849548,
                        "private void handleFunctionInputs(Node fnNode) { Node fnNameNode = fnNode.getFirstChild(); String fnName = fnNameNode.getString(); if (!fnName.isEmpty()) { Scope.Var fnVar = scope.getVar(fnName); if (fnVar == null || (fnVar.getNameNode() != null && fnVar.getInitialValue() != fnNode)) { defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false); } } declareArguments(fnNode); }"
                    ],
                    [
                        0.9634888172149658,
                        "public TypePair getTypesUnderShallowInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderShallowInequality(this); return new TypePair(p.typeB, p.typeA); } if (this.isNullType() && that.isNullType() || this.isVoidType() && that.isVoidType()) { return new TypePair(null, null); } else { return new TypePair(this, that); } }"
                    ],
                    [
                        0.9628894329071045,
                        "private ConcreteType createType(Node name, ConcreteScope scope) { Preconditions.checkNotNull(name); Preconditions.checkArgument(name.getType() == Token.NAME); if (name.getJSType() == null) { return ConcreteType.ALL; } if ((name.getFirstChild() != null) && (name.getFirstChild().getType() == Token.FUNCTION)) { return createConcreteFunction(name.getFirstChild(), scope); } return createType(name.getJSType()); }"
                    ],
                    [
                        0.9558138847351074,
                        "private void processPrototypeParent(NodeTraversal t, Node n) { switch(n.getType()) { case Token.GETPROP: case Token.GETELEM: Node dest = n.getFirstChild().getNext(); Node parent = n.getParent().getParent(); if (dest.getType() == Token.STRING && parent.getType() == Token.ASSIGN) { Node assignee = parent.getFirstChild().getNext(); addPossibleSignature(dest.getString(), assignee, t); } break; } }"
                    ],
                    [
                        0.952515721321106,
                        "public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.GETPROP: case Token.GETELEM: Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING && (whitelist.isEmpty() || whitelist.contains(dest.getString()))) { props.put(dest.getString(), newSymbolForProperty(dest.getString())); } } }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse8",
                    "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse9"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }\n\n```\n\n```java\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: unexpected warnings(s):\n \n#Test method 2:\n```java\n  public void testBackwardsTypedefUse9() throws Exception {\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : Error\\n\" +\n        \"required: Array\");\n  }\n```\n#Error message from the test method 2: junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic boolean apply(JSType type) {\n  if (!(type instanceof ObjectType) || \n          (type.isUnionType() && !type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE)))) {\n    reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n    return false;\n  }\n  return true;\n}\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n    if (!(type instanceof ObjectType) &&\n        !type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n    }\n    return true;\n}\n",
                            "\n    @Override\n    public boolean apply(JSType type) {\n      if (!type.isSubtypeWithinBounds(typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n  if (type == null || !type.isObjectType()) {\n    reportWarning(THIS_TYPE_NON_OBJECT, type == null ? \"null\" : type.toString());\n    return false;\n  }\n  return true;\n}\n",
                            "\n    @Override\n    public boolean apply(JSType type) {\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE)) &&\n          !(type instanceof UnionType && ((UnionType) type).hasAlternateNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n  // Check if the type is not a subtype of OBJECT_TYPE\n  if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n    reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n    return false;\n  }\n  return true;\n}\n\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  // Resolve typeOfThis and cast to ObjectType if possible\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis == null || maybeTypeOfThis.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n  if (!(type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE)) ||\n        type.isUnionType() && ((UnionType)type).getAlternates().stream()\n          .allMatch(t -> t.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))))) {\n    reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n    return false;\n  }\n  return true;\n}\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n  if (type == null || !(type instanceof ObjectType) && !type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n    reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n    return false;\n  }\n  return true;\n}\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n  JSType objectType = typeRegistry.getNativeType(OBJECT_TYPE);\n  if (!type.isSubtype(objectType) && !(type instanceof UnionType && ((UnionType) type).contains(objectType))) {\n    reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n    return false;\n  }\n  return true;\n}\n",
                            "\n@Override\npublic boolean apply(JSType type) {\n  if (type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE)) ||\n      type.isUnionType() && type.toMaybeUnionType().getAlternates().stream()\n          .anyMatch(subType -> subType.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE)))) {\n    return true;\n  }\n  reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n  return false;\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
                "start_loc": 861,
                "end_loc": 903,
                "buggy_function": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n",
                "fixed_function": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n",
                "comment": "",
                "normalized_body": [
                    "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }"
                    ],
                    [
                        0.971359133720398,
                        "int processResults(Result result, List<JSModule> modules, B options) throws FlagUsageException, IOException { if (config.computePhaseOrdering) { return 0; } if (config.printPassGraph) { if (compiler.getRoot() == null) { return 1; } else { out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph())); out.append('\\n'); return 0; } } if (config.printAst) { if (compiler.getRoot() == null) { return 1; } else { ControlFlowGraph<Node> cfg = compiler.computeCFG(); DotFormatter.appendDot(compiler.getRoot().getLastChild(), cfg, out); out.append('\\n'); return 0; } } if (config.printTree) { if (compiler.getRoot() == null) { out.append(\\\"Code contains errors; no tree was generated.\\n\\\"); return 1; } else { compiler.getRoot().appendStringTree(out); out.append(\\\"\\n\\\"); return 0; } } if (result.success) { if (modules == null) { writeOutput(out, compiler, compiler.toSource(), config.outputWrapper, config.outputWrapperMarker); outputSourceMap(options); } else { String moduleFilePrefix = config.moduleOutputPathPrefix; maybeCreateDirsForPath(moduleFilePrefix); Map<String, String> moduleWrappers = parseModuleWrappers(config.moduleWrapper, modules); Writer mapOut = null; if (!shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, null)); } for (JSModule m : modules) { if (shouldGenerateMapPerModule(options)) { mapOut = fileNameToOutputWriter(expandSourceMapPath(options, m)); } Writer writer = fileNameToOutputWriter(moduleFilePrefix + m.getName() + \\\".js\\\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().reset(); } writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(m.getName()), \\\"%s\\\"); if (options.sourceMapOutputPath != null) { compiler.getSourceMap().appendTo(mapOut, m.getName()); } writer.close(); if (shouldGenerateMapPerModule(options) && mapOut != null) { mapOut.close(); mapOut = null; } } if (mapOut != null) { mapOut.close(); } } if (options.externExportsPath != null) { Writer eeOut = openExternExportsStream(options, options.jsOutputFile); eeOut.append(result.externExport); eeOut.close(); } outputNameMaps(options); outputManifest(); } return Math.min(result.errors.length, 0x7f); }"
                    ],
                    [
                        0.9713253974914551,
                        "private void helperMoveExpression(String code, String fnName, String expectedResult, Set<String> knownConstants) { Compiler compiler = new Compiler(); if (knownConstants == null) { knownConstants = Sets.newHashSet(); } ExpressionDecomposer decomposer = new ExpressionDecomposer(compiler, compiler.getUniqueNameIdSupplier(), knownConstants); decomposer.setTempNamePrefix(\\\"temp\\\"); Node expectedRoot = parse(compiler, expectedResult); Node tree = parse(compiler, code); assertNotNull(tree); Node externsRoot = new Node(Token.EMPTY); Node mainRoot = tree; Node callSite = findCall(tree, fnName); assertNotNull(\\\"Call to \\\" + fnName + \\\" was not found.\\\", callSite); compiler.resetUniqueNameId(); decomposer.moveExpression(callSite); validateSourceInfo(compiler, tree); String explanation = expectedRoot.checkTreeEquals(tree); assertNull(\\\"\\nExpected: \\\" + compiler.toSource(expectedRoot) + \\\"\\nResult: \\\" + compiler.toSource(tree) + \\\"\\n\\\" + explanation, explanation); }"
                    ],
                    [
                        0.9708259105682373,
                        "@Override public void process(Node externRoot, Node jsRoot) { topScope = new ConcreteScope(null); topScope.initForExternRoot(externRoot); topScope.initForScopeRoot(jsRoot); long maxIterations = 1000; long iterations = 0; Set<ConcreteScope> workSet = Sets.newHashSet(topScope); List<ConcreteScope> workList = Lists.newArrayList(topScope); boolean changed; do { changed = false; for (int i = 0; i < workList.size(); ++i) { ConcreteScope scope = workList.get(i); for (Action action : scope.getActions()) { for (Assignment assign : action.getAssignments(scope)) { if (assign.slot.addConcreteType(assign.type)) { changed = true; ConcreteScope varScope = assign.slot.getScope(); if ((varScope != scope) && !workSet.contains(varScope)) { workSet.add(varScope); workList.add(varScope); } } } } } Preconditions.checkState(++iterations != maxIterations, NON_HALTING_ERROR_MSG); } while (changed); }"
                    ],
                    [
                        0.9700092077255249,
                        "void endEvent(Tracer t, int silenceThreshold) { boolean wasOutstanding = outstandingEvents.remove(t); if (!wasOutstanding) { if (isOutstandingEventsTruncated) { logger.log(Level.WARNING, \\\"event not found, probably because the event stack \\\" + \\\"overflowed and was truncated\\\", new Throwable()); } else { throw new IllegalStateException(); } } long elapsed = t.stopTimeMs - t.startTimeMs; if (silenceThreshold == -1) { silenceThreshold = defaultSilenceThreshold; } if (elapsed < silenceThreshold) { boolean removed = false; for (int i = 0; i < events.size(); i++) { Event e = events.get(i); if (e.tracer == t) { Preconditions.checkState(e.isStart); events.remove(i); removed = true; break; } } Preconditions.checkState(removed || isEventsTruncated); } else { events.add(new Event(false, t)); } if (t.type != null) { Stat stat = stats.get(t.type); if (stat == null) { stat = new Stat(); if (!extraTracingStatistics.isEmpty()) { stat.extraInfo = new int[extraTracingStatistics.size()]; } stats.put(t.type, stat); } stat.count++; if (typeToCountMap != null) { typeToCountMap.incrementBy(t.type, 1); } stat.clockTime += elapsed; if (typeToTimeMap != null) { typeToTimeMap.incrementBy(t.type, elapsed); } if (stat.extraInfo != null && t.extraTracingValues != null) { int overlapLength = Math.min(stat.extraInfo.length, t.extraTracingValues.length); for (int i = 0; i < overlapLength; i++) { stat.extraInfo[i] += t.extraTracingValues[i]; AtomicTracerStatMap map = extraTracingStatistics.get(i).getTracingStat(); if (map != null) { map.incrementBy(t.type, t.extraTracingValues[i]); } } } if (elapsed < silenceThreshold) { stat.silent++; if (typeToSilentMap != null) { typeToSilentMap.incrementBy(t.type, 1); } } } }"
                    ],
                    [
                        0.9697787165641785,
                        "private void updateScopeForTypeChange(FlowScope scope, Node left, JSType leftType, JSType resultType) { Preconditions.checkNotNull(resultType); switch(left.getType()) { case Token.NAME: String varName = left.getString(); Var var = syntacticScope.getVar(varName); if (var != null && var.isLocal() && var.getScope() != syntacticScope) { assignedOuterLocalVars.put(var.getScope(), var); } boolean isVarDeclaration = left.hasChildren(); if (!isVarDeclaration || var == null || var.isTypeInferred()) { redeclare(scope, varName, resultType); } left.setJSType(isVarDeclaration || leftType == null ? resultType : null); if (var != null && var.isTypeInferred()) { JSType oldType = var.getType(); var.setType(oldType == null ? resultType : oldType.getLeastSupertype(resultType)); } break; case Token.GETPROP: String qualifiedName = left.getQualifiedName(); if (qualifiedName != null) { scope.inferQualifiedSlot(qualifiedName, leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType, resultType); } left.setJSType(resultType); ensurePropertyDefined(left, resultType); break; } }"
                    ],
                    [
                        0.9692577123641968,
                        "private Config parseConfiguration(String function) { int first = function.indexOf('('); int last = function.indexOf(')'); Preconditions.checkState(first != -1 && last != -1); String name = function.substring(0, first); String params = function.substring(first + 1, last); int paramCount = 0; int replacementParameter = -1; String[] parts = params.split(\\\",\\\"); for (String param : parts) { paramCount++; if (param.equals(REPLACE_ALL_MARKER)) { Preconditions.checkState(paramCount == 1 && parts.length == 1); replacementParameter = Config.REPLACE_ALL_VALUE; } else if (param.equals(REPLACE_ONE_MARKER)) { Preconditions.checkState(replacementParameter == -1); replacementParameter = paramCount; } else { Preconditions.checkState(param.isEmpty(), \\\"Unknown marker\\\", param); } } Preconditions.checkState(replacementParameter != -1); return new Config(name, replacementParameter); }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse8",
                    "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse9"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }\n\n```\n\n```java\n\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: unexpected warnings(s):\n \n#Test method 2:\n```java\n  public void testBackwardsTypedefUse9() throws Exception {\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : Error\\n\" +\n        \"required: Array\");\n  }\n```\n#Error message from the test method 2: junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis instanceof ObjectType) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  } else if (maybeTypeOfThis != null && maybeTypeOfThis.isUnionType()) {\n    for (JSType alt : maybeTypeOfThis.toMaybeUnionType().getAlternates()) {\n      if (alt instanceof ObjectType) {\n        typeOfThis = (ObjectType) alt;\n        break;\n      }\n    }\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n",
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    } else if (maybeTypeOfThis != null &&\n               maybeTypeOfThis.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n        typeOfThis = (ObjectType) maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n\n    return super.resolveInternal(t, scope);\n}\n",
                            "\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis.isSubtypeWithinBounds(typeRegistry.getNativeType(OBJECT_TYPE))) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n",
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis instanceof ObjectType || maybeTypeOfThis.isUnionType()) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n",
                            "\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType || \n        (maybeTypeOfThis instanceof UnionType && \n         ((UnionType) maybeTypeOfThis).hasAlternateNativeType(OBJECT_TYPE))) {\n      if (maybeTypeOfThis.isNullable()) {\n        typeOfThis = (ObjectType) maybeTypeOfThis.restrictByNotNullOrUndefined();\n      } else {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n      }\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }\n",
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis instanceof ObjectType || maybeTypeOfThis.isUnionType()) {\n    typeOfThis = (ObjectType) coerceToObjectTypeIfPossible(maybeTypeOfThis);\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n\nprivate ObjectType coerceToObjectTypeIfPossible(JSType type) {\n  if (type instanceof ObjectType) {\n    return (ObjectType) type;\n  }\n  if (type.isUnionType()) {\n    UnionType unionType = (UnionType) type;\n    for (JSType alternate : unionType.getAlternates()) {\n      if (alternate instanceof ObjectType) {\n        return (ObjectType) alternate;\n      }\n    }\n  }\n  return null;\n}\n",
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  // Handle typeOfThis: if it resolves to non-object, set to null.\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis != null && maybeTypeOfThis.isSubtype(\n          typeRegistry.getNativeType(OBJECT_TYPE))) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  } else {\n    typeOfThis = null;\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n",
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis instanceof ObjectType) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  } else if (maybeTypeOfThis instanceof UnionType) {\n    for (JSType alt : ((UnionType) maybeTypeOfThis).getAlternates()) {\n      if (alt instanceof ObjectType) {\n        typeOfThis = (ObjectType) alt;\n        break;\n      }\n    }\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces =\n      ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n",
                            "\n@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n  JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n  if (maybeTypeOfThis.isObjectType() || (maybeTypeOfThis.isUnionType() && maybeTypeOfThis.toMaybeUnionType().getAlternates().stream().anyMatch(JSType::isObjectType))) {\n    typeOfThis = (ObjectType) maybeTypeOfThis;\n  }\n\n  boolean changed = false;\n  ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n  for (ObjectType iface : implementedInterfaces) {\n    ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n    resolvedInterfaces.add(resolvedIface);\n    changed |= (resolvedIface != iface);\n  }\n  if (changed) {\n    implementedInterfaces = resolvedInterfaces.build();\n  }\n\n  if (subTypes != null) {\n    for (int i = 0; i < subTypes.size(); i++) {\n      subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n    }\n  }\n\n  return super.resolveInternal(t, scope);\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse8": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testBackwardsTypedefUse8",
                "src": "  public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):\nJSC_THIS_TYPE_NON_OBJECT. @this type of a function must be an object\nActual type: (Array|null|undefined) at [testcode] line 1 : 80\nJSC_TYPE_MISMATCH. actual parameter 1 of g does not match formal parameter\nfound   : goog.MyTypedef\nrequired: Array at [testcode] line 1 : 88\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7752)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7726)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7670)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7666)\n\tat com.google.javascript.jscomp.TypeCheckTest.testBackwardsTypedefUse8(TypeCheckTest.java:2670)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):\nJSC_THIS_TYPE_NON_OBJECT. @this type of a function must be an object\nActual type: (Array|null|undefined) at [testcode] line 1 : 80\nJSC_TYPE_MISMATCH. actual parameter 1 of g does not match formal parameter\nfound   : goog.MyTypedef\nrequired: Array at [testcode] line 1 : 88\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7752)  fail(\"unexpected warnings(s):\\n\" + Joiner.on(\"\\n\").join(warnings));\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7726)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7670)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7666)  testTypes(js, (String) null);\n\tat com.google.javascript.jscomp.TypeCheckTest.testBackwardsTypedefUse8(TypeCheckTest.java:2670)  testTypes(        \"/** @param {!Array} x */ function g(x) {}\" +        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +        \"var goog = {};\" +        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\");"
            },
            "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse9": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testBackwardsTypedefUse9",
                "src": "  public void testBackwardsTypedefUse9() throws Exception {\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",\n        \"actual parameter 1 of g does not match formal parameter\\n\" +\n        \"found   : Error\\n\" +\n        \"required: Array\");\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter\nfound   : Error\nrequired: Array]> but was:<[@this type of a function must be an object\nActual type: (Error|null|undefined)]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7747)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7726)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7670)\n\tat com.google.javascript.jscomp.TypeCheckTest.testBackwardsTypedefUse9(TypeCheckTest.java:2678)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[actual parameter 1 of g does not match formal parameter\nfound   : Error\nrequired: Array]> but was:<[@this type of a function must be an object\nActual type: (Error|null|undefined)]>\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7747)  assertEquals(description, warnings[0].description);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7726)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7670)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testBackwardsTypedefUse9(TypeCheckTest.java:2678)  testTypes(        \"/** @param {!Array} x */ function g(x) {}\" +        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +        \"var goog = {};\" +        \"/** @typedef {(Error|null|undefined)} */ goog.MyTypedef;\",        \"actual parameter 1 of g does not match formal parameter\\n\" +        \"found   : Error\\n\" +        \"required: Array\");"
            }
        },
        "evaluation_done": true
    }
}