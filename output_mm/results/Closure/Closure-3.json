{
    "Closure-3": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
                "start_loc": 124,
                "end_loc": 170,
                "buggy_function": "  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n",
                "fixed_function": "  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline(t.getScope())) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) { return; } ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); Preconditions.checkState(t.getScopeRoot().isFunction()); cfa.process(null, t.getScopeRoot().getLastChild()); cfg = cfa.getCfg(); reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler); reachingDef.analyze(); candidates = Lists.newLinkedList(); new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild()); reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline()) { c.inlineVariable(); if (!c.defMetadata.depends.isEmpty()) { inlinedNewDependencies.add(t.getScope().getVar(c.varName)); } } } }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "@Override public void enterScope(NodeTraversal t) { if (t.inGlobalScope()) { return; } if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) { return; } ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true); Preconditions.checkState(t.getScopeRoot().isFunction()); cfa.process(null, t.getScopeRoot().getLastChild()); cfg = cfa.getCfg(); reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler); reachingDef.analyze(); candidates = Lists.newLinkedList(); new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild()); reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler); reachingUses.analyze(); for (Candidate c : candidates) { if (c.canInline()) { c.inlineVariable(); if (!c.defMetadata.depends.isEmpty()) { inlinedNewDependencies.add(t.getScope().getVar(c.varName)); } } } }"
                    ],
                    [
                        0.9730017185211182,
                        "private void applyCollapses() { for (Collapse collapse : collapses) { Node var = new Node(Token.VAR); var.copyInformationFrom(collapse.startNode); collapse.parent.addChildBefore(var, collapse.startNode); boolean redeclaration = false; for (Node n = collapse.startNode; n != collapse.endNode; ) { Node next = n.getNext(); Preconditions.checkState(var.getNext() == n); collapse.parent.removeChildAfter(var); if (n.isVar()) { while (n.hasChildren()) { var.addChildToBack(n.removeFirstChild()); } } else { Node assign = n.getFirstChild(); Node lhs = assign.getFirstChild(); Preconditions.checkState(lhs.isName()); Node rhs = assign.getLastChild(); lhs.addChildToBack(rhs.detachFromParent()); var.addChildToBack(lhs.detachFromParent()); redeclaration = true; } n = next; } if (redeclaration) { JSDocInfo info = new JSDocInfo(); info.addSuppression(\\\"duplicate\\\"); var.setJSDocInfo(info); } } }"
                    ],
                    [
                        0.9722400307655334,
                        "boolean checkEquivalenceHelper(JSType that, EquivalenceMethod eqMethod) { if (this == that) { return true; } boolean thisUnknown = isUnknownType(); boolean thatUnknown = that.isUnknownType(); if (thisUnknown || thatUnknown) { if (eqMethod == EquivalenceMethod.INVARIANT) { return true; } else if (eqMethod == EquivalenceMethod.DATA_FLOW) { return thisUnknown && thatUnknown; } else if (thisUnknown && thatUnknown && (isNominalType() ^ that.isNominalType())) { return false; } } if (isUnionType() && that.isUnionType()) { return toMaybeUnionType().checkUnionEquivalenceHelper(that.toMaybeUnionType(), eqMethod); } if (isFunctionType() && that.isFunctionType()) { return toMaybeFunctionType().checkFunctionEquivalenceHelper(that.toMaybeFunctionType(), eqMethod); } if (isRecordType() && that.isRecordType()) { return toMaybeRecordType().checkRecordEquivalenceHelper(that.toMaybeRecordType(), eqMethod); } ParameterizedType thisParamType = toMaybeParameterizedType(); ParameterizedType thatParamType = that.toMaybeParameterizedType(); if (thisParamType != null || thatParamType != null) { boolean paramsMatch = false; if (thisParamType != null && thatParamType != null) { paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(thatParamType.getParameterType(), eqMethod); } else if (eqMethod == EquivalenceMethod.IDENTITY) { paramsMatch = false; } else { paramsMatch = true; } JSType thisRootType = thisParamType == null ? this : thisParamType.getReferencedTypeInternal(); JSType thatRootType = thatParamType == null ? that : thatParamType.getReferencedTypeInternal(); return paramsMatch && thisRootType.checkEquivalenceHelper(thatRootType, eqMethod); } if (isNominalType() && that.isNominalType()) { return toObjectType().getReferenceName().equals(that.toObjectType().getReferenceName()); } if (this instanceof ProxyObjectType) { return ((ProxyObjectType) this).getReferencedTypeInternal().checkEquivalenceHelper(that, eqMethod); } if (that instanceof ProxyObjectType) { return checkEquivalenceHelper(((ProxyObjectType) that).getReferencedTypeInternal(), eqMethod); } return this == that; }"
                    ],
                    [
                        0.9721872806549072,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (!n.isName()) { return; } String varName = n.getString(); if (varName.isEmpty()) { Preconditions.checkState(parent.isFunction()); Preconditions.checkState(NodeUtil.isFunctionExpression(parent)); return; } if ((parent.isVar() || NodeUtil.isFunctionDeclaration(parent)) && varsToDeclareInExterns.contains(varName)) { createSynthesizedExternVar(varName); n.addSuppression(\\\"duplicate\\\"); } Scope scope = t.getScope(); Scope.Var var = scope.getVar(varName); if (var == null) { if (NodeUtil.isFunctionExpression(parent)) { } else { if (!strictExternCheck || !t.getInput().isExtern()) { t.report(n, UNDEFINED_VAR_ERROR, varName); } if (sanityCheck) { throw new IllegalStateException(\\\"Unexpected variable \\\" + varName); } else { createSynthesizedExternVar(varName); scope.getGlobalScope().declare(varName, n, null, getSynthesizedExternsInput()); } } return; } CompilerInput currInput = t.getInput(); CompilerInput varInput = var.input; if (currInput == varInput || currInput == null || varInput == null) { return; } JSModule currModule = currInput.getModule(); JSModule varModule = varInput.getModule(); JSModuleGraph moduleGraph = compiler.getModuleGraph(); if (!sanityCheck && varModule != currModule && varModule != null && currModule != null) { if (moduleGraph.dependsOn(currModule, varModule)) { } else { if (scope.isGlobal()) { if (moduleGraph.dependsOn(varModule, currModule)) { t.report(n, VIOLATED_MODULE_DEP_ERROR, currModule.getName(), varModule.getName(), varName); } else { t.report(n, MISSING_MODULE_DEP_ERROR, currModule.getName(), varModule.getName(), varName); } } else { t.report(n, STRICT_MODULE_DEP_ERROR, currModule.getName(), varModule.getName(), varName); } } } }"
                    ],
                    [
                        0.9717833399772644,
                        "@Override public void process(Node externs, Node root) { FindExportableNodes findExportableNodes = new FindExportableNodes(compiler); NodeTraversal.traverse(compiler, root, findExportableNodes); Map<String, GenerateNodeContext> exports = findExportableNodes.getExports(); CodingConvention convention = compiler.getCodingConvention(); for (Map.Entry<String, GenerateNodeContext> entry : exports.entrySet()) { String export = entry.getKey(); GenerateNodeContext context = entry.getValue(); String parent = null; String grandparent = null; Node node = context.getNode().getFirstChild(); if (node.isGetProp()) { parent = node.getFirstChild().getQualifiedName(); if (node.getFirstChild().isGetProp() && getPropertyName(node.getFirstChild()).equals(PROTOTYPE_PROPERTY)) { grandparent = node.getFirstChild().getFirstChild().getQualifiedName(); } } boolean useExportSymbol = true; if (grandparent != null && exports.containsKey(grandparent)) { useExportSymbol = false; } else if (parent != null && exports.containsKey(parent)) { useExportSymbol = false; } Node call; if (useExportSymbol) { call = IR.call(NodeUtil.newQualifiedNameNode(convention, exportSymbolFunction, context.getNode(), export), IR.string(export), NodeUtil.newQualifiedNameNode(convention, export, context.getNode(), export)); } else { String property = getPropertyName(node); call = IR.call(NodeUtil.newQualifiedNameNode(convention, exportPropertyFunction, context.getNode(), exportPropertyFunction), NodeUtil.newQualifiedNameNode(convention, parent, context.getNode(), exportPropertyFunction), IR.string(property), NodeUtil.newQualifiedNameNode(convention, export, context.getNode(), exportPropertyFunction)); } Node expression = IR.exprResult(call); annotate(expression); Node insertionPoint = context.getContextNode().getNext(); while (insertionPoint != null && NodeUtil.isExprCall(insertionPoint) && convention.getClassesDefinedByCall(insertionPoint.getFirstChild()) != null) { insertionPoint = insertionPoint.getNext(); } if (insertionPoint == null) { context.getScriptNode().addChildToBack(expression); } else { context.getScriptNode().addChildBefore(expression, insertionPoint); } compiler.reportCodeChange(); } }"
                    ],
                    [
                        0.9714374542236328,
                        "void defineSlot(Node n, Node parent, String variableName, JSType type, boolean inferred) { Preconditions.checkArgument(!variableName.isEmpty()); boolean isGlobalVar = n.isName() && scope.isGlobal(); boolean shouldDeclareOnGlobalThis = isGlobalVar && (parent.isVar() || parent.isFunction()); Scope scopeToDeclareIn = scope; if (n.isGetProp() && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } } boolean isExtern = n.isFromExterns(); Var newVar = null; CompilerInput input = compiler.getInput(inputId); if (scopeToDeclareIn.isDeclared(variableName, false)) { Var oldVar = scopeToDeclareIn.getVar(variableName); newVar = validator.expectUndeclaredVariable(sourceName, input, n, parent, oldVar, variableName, type); } else { if (type != null) { setDeferredType(n, type); } newVar = scopeToDeclareIn.declare(variableName, n, type, input, inferred); if (type instanceof EnumType) { Node initialValue = newVar.getInitialValue(); boolean isValidValue = initialValue != null && (initialValue.isObjectLit() || initialValue.isQualifiedName()); if (!isValidValue) { compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER)); } } } FunctionType fnType = JSType.toMaybeFunctionType(type); if (fnType != null && !type.isEmptyType()) { if ((fnType.isConstructor() || fnType.isInterface()) && variableName.equals(fnType.getReferenceName())) { finishConstructorDefinition(n, variableName, fnType, scopeToDeclareIn, input, newVar); } } if (shouldDeclareOnGlobalThis) { ObjectType globalThis = typeRegistry.getNativeObjectType(GLOBAL_THIS); if (inferred) { globalThis.defineInferredProperty(variableName, type == null ? getNativeType(JSTypeNative.NO_TYPE) : type, n); } else { globalThis.defineDeclaredProperty(variableName, type, n); } } if (isGlobalVar && \\\"Window\\\".equals(variableName) && type != null && type.isFunctionType() && type.isConstructor()) { FunctionType globalThisCtor = typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor(); globalThisCtor.getInstanceType().clearCachedValues(); globalThisCtor.getPrototype().clearCachedValues(); globalThisCtor.setPrototypeBasedOn((type.toMaybeFunctionType()).getInstanceType()); } }"
                    ],
                    [
                        0.9712403416633606,
                        "public void testGenerationIncrementing2() { SimpleErrorReporter reporter = new SimpleErrorReporter(); final JSTypeRegistry typeRegistry = new JSTypeRegistry(reporter); StaticScope<JSType> scope = new AbstractStaticScope<JSType>() { @Override public StaticSlot<JSType> getSlot(final String name) { return new SimpleSlot(name, typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE), false); } }; ObjectType namedType = (ObjectType) typeRegistry.getType(scope, \\\"Foo\\\", null, 0, 0); FunctionType functionType = typeRegistry.createFunctionType(namedType); typeRegistry.setLastGeneration(false); typeRegistry.resolveTypesInScope(scope); assertTrue(functionType.getReturnType().isUnknownType()); functionType.resolve(reporter, scope); assertTrue(functionType.getReturnType().isUnknownType()); typeRegistry.declareType(\\\"Foo\\\", typeRegistry.createAnonymousObjectType(null)); typeRegistry.resolveTypesInScope(scope); assertTrue(functionType.getReturnType().isUnknownType()); assertNull(\\\"Unexpected errors: \\\" + reporter.errors(), reporter.errors()); assertNull(\\\"Unexpected warnings: \\\" + reporter.warnings(), reporter.warnings()); typeRegistry.incrementGeneration(); typeRegistry.setLastGeneration(true); typeRegistry.resolveTypesInScope(scope); assertFalse(functionType.getReturnType().isUnknownType()); }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1a",
                    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1",
                    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression3"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n\n```\n\n```java\n\n    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testDoNotInlineCatchExpression1a() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err + 1;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError:\n \n#Test method 2:\n```java\n  public void testDoNotInlineCatchExpression1() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n```\n#Error message from the test method 2: junit.framework.AssertionFailedError:\n \n#Test method 3:\n```java\n  public void testDoNotInlineCatchExpression3() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"} catch(err) {\" +\n        \"  err = x;\\n\" +\n        \"  a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError:\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n\n  if (t.inGlobalScope()) {\n    return; // Don't even brother. All global variables are likely escaped.\n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n      t.getScope().getVarCount()) {\n    return;\n  }\n\n  // Compute the forward reaching definition.\n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  // Process the body of the function.\n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  // Using the forward reaching definition search to find all the inline\n  // candidates\n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n      t.getScopeRoot().getLastChild());\n\n  // Compute the backward reaching use. The CFG can be reused.\n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n    if (c.canInline()) {\n      c.inlineVariable();\n\n      // If definition c has dependencies, then inlining it may have\n      // introduced new dependencies for our other inlining candidates.\n      //\n      // MustBeReachingVariableDef uses this dependency graph in its\n      // analysis, so some of these candidates may no longer be valid.\n      // We keep track of when the variable dependency graph changed\n      // so that we can back off appropriately.\n      if (!c.defMetadata.depends.isEmpty()) {\n        inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n      }\n    }\n  }\n}\n\nprivate boolean canInline() {\n  // Cannot inline a parameter.\n  if (getDefCfgNode().isFunction()) {\n    return false;\n  }\n\n  // If one of our dependencies has been inlined, then our dependency\n  // graph is wrong. Re-computing it would take another CFG computation,\n  // so we just back off for now.\n  for (Var dependency : defMetadata.depends) {\n    if (inlinedNewDependencies.contains(dependency)) {\n      return false;\n    }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  // Definition was not found.\n  if (def == null) {\n    return false;\n  }\n\n  // Check that the assignment isn't used as a R-Value.\n  // TODO: Certain cases we can still inline.\n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n    return false;\n  }\n\n  // The right of the definition has side effect:\n  // Example, for x:\n  // x = readProp(b), modifyProp(b); print(x);\n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Similar check as the above but this time, all the sub-expressions\n  // left of the use of the variable.\n  // x = readProp(b); modifyProp(b), print(x);\n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Check if the definition or use is within a 'catch' node\n  if (NodeUtil.hasAncestor(def, node -> node.isCatch()) || NodeUtil.hasAncestor(use, node -> node.isCatch())) {\n    return false;\n  }\n\n  // TODO: Side-effect is OK sometimes. As long as there are no\n  // side-effect function down all paths to the use. Once we have all the\n  // side-effect analysis tool.\n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n    return false;\n  }\n\n  // Finally we have to make sure that there are no more than one use\n  // in the program and in the CFG node. Even when it is semantically\n  // correctly inlining twice increases code size.\n  if (numUseWithinUseCfgNode != 1) {\n    return false;\n  }\n\n  // Make sure that the name is not within a loop\n  if (NodeUtil.isWithinLoop(use)) {\n    return false;\n  }\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n    return false;\n  }\n\n  // We give up inlining stuff with R-Value that has:\n  // 1) GETPROP, GETELEM,\n  // 2) anything that creates a new object.\n  // 3) a direct reference to a catch expression.\n  // Example:\n  // var x = a.b.c; j.c = 1; print(x);\n  // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n  if (NodeUtil.has(def.getLastChild(),\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            switch (input.getType()) {\n              case Token.GETELEM:\n              case Token.GETPROP:\n              case Token.ARRAYLIT:\n              case Token.OBJECTLIT:\n              case Token.REGEXP:\n              case Token.NEW:\n                return true;\n            }\n            return false;\n          }\n      },\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n          }\n      })) {\n    return false;\n  }\n\n  // We can skip the side effect check along the paths of two nodes if\n  // they are just next to each other.\n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n      getDefCfgNode().getNext() != useCfgNode) {\n    // Similar side effect check as above but this time the side effect is\n    // else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n      pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n             cfg,\n             cfg.getDirectedGraphNode(getDefCfgNode()),\n             cfg.getDirectedGraphNode(useCfgNode),\n             SIDE_EFFECT_PREDICATE,\n             Predicates.\n                 <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n             false);\n    if (pathCheck.somePathsSatisfyPredicate()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
                            "\n    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // Cannot inline a catch expression.\n      if (getDefCfgNode().isCatch()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n\n  if (t.inGlobalScope()) {\n    return; // Don't even brother. All global variables are likely escaped.\n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n      t.getScope().getVarCount()) {\n    return;\n  }\n\n  // Compute the forward reaching definition.\n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  // Process the body of the function.\n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  // Using the forward reaching definition search to find all the inline\n  // candidates\n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n      t.getScopeRoot().getLastChild());\n\n  // Compute the backward reaching use. The CFG can be reused.\n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n    if (c.canInline()) {\n      c.inlineVariable();\n\n      // If definition c has dependencies, then inlining it may have\n      // introduced new dependencies for our other inlining candidates.\n      //\n      // MustBeReachingVariableDef uses this dependency graph in its\n      // analysis, so some of these candidates may no longer be valid.\n      // We keep track of when the variable dependency graph changed\n      // so that we can back off appropriately.\n      if (!c.defMetadata.depends.isEmpty()) {\n        inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n      }\n    }\n  }\n}\n\nprivate boolean canInline() {\n  // Cannot inline a parameter.\n  if (getDefCfgNode().isFunction()) {\n    return false;\n  }\n\n  // If one of our dependencies has been inlined, then our dependency\n  // graph is wrong. Re-computing it would take another CFG computation,\n  // so we just back off for now.\n  for (Var dependency : defMetadata.depends) {\n    if (inlinedNewDependencies.contains(dependency)) {\n      return false;\n    }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  // Definition was not found.\n  if (def == null) {\n    return false;\n  }\n\n  // Check that the assignment isn't used as a R-Value.\n  // TODO(user): Certain cases we can still inline.\n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n    return false;\n  }\n\n  // The right of the definition has side effect:\n  // Example, for x:\n  // x = readProp(b), modifyProp(b); print(x);\n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Similar check as the above but this time, all the sub-expressions\n  // left of the use of the variable.\n  // x = readProp(b); modifyProp(b), print(x);\n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // TODO(user): Side-effect is OK sometimes. As long as there are no\n  // side-effect function down all paths to the use. Once we have all the\n  // side-effect analysis tool.\n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n    return false;\n  }\n\n  // Ensure we are not inlining variables assigned from catch expressions\n  if (def.hasParent() && def.getParent().isCatch()) {\n    return false;\n  }\n\n  // TODO(user): We could inline all the uses if the expression is short.\n\n  // Finally we have to make sure that there are no more than one use\n  // in the program and in the CFG node. Even when it is semantically\n  // correctly inlining twice increases code size.\n  if (numUseWithinUseCfgNode != 1) {\n    return false;\n  }\n\n  // Make sure that the name is not within a loop\n  if (NodeUtil.isWithinLoop(use)) {\n    return false;\n  }\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n    return false;\n  }\n\n  // We give up inlining stuff with R-Value that has:\n  // 1) GETPROP, GETELEM,\n  // 2) anything that creates a new object.\n  // 3) a direct reference to a catch expression.\n  // Example:\n  // var x = a.b.c; j.c = 1; print(x);\n  // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n  // TODO(user): We could get more accuracy by looking more in-detail\n  // what j is and what x is trying to into to.\n  // TODO(johnlenz): rework catch expression handling when we\n  // have lexical scope support so catch expressions don't\n  // need to be special cased.\n  if (NodeUtil.has(def.getLastChild(),\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            switch (input.getType()) {\n              case Token.GETELEM:\n              case Token.GETPROP:\n              case Token.ARRAYLIT:\n              case Token.OBJECTLIT:\n              case Token.REGEXP:\n              case Token.NEW:\n                return true;\n            }\n            return false;\n          }\n      },\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n          }\n      })) {\n    return false;\n  }\n\n  // We can skip the side effect check along the paths of two nodes if\n  // they are just next to each other.\n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n      getDefCfgNode().getNext() != useCfgNode) {\n    // Similar side effect check as above but this time the side effect is\n    // else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n      pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n             cfg,\n             cfg.getDirectedGraphNode(getDefCfgNode()),\n             cfg.getDirectedGraphNode(useCfgNode),\n             SIDE_EFFECT_PREDICATE,\n             Predicates.\n                 <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n             false);\n    if (pathCheck.somePathsSatisfyPredicate()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n\n  if (t.inGlobalScope()) {\n    return; // Don't even brother. All global variables are likely escaped.\n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n      t.getScope().getVarCount()) {\n    return;\n  }\n\n  // Compute the forward reaching definition.\n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  // Process the body of the function.\n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  // Using the forward reaching definition search to find all the inline\n  // candidates\n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n      t.getScopeRoot().getLastChild());\n\n  // Compute the backward reaching use. The CFG can be reused.\n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n    if (c.canInline()) {\n      c.inlineVariable();\n\n      // If definition c has dependencies, then inlining it may have\n      // introduced new dependencies for our other inlining candidates.\n      //\n      // MustBeReachingVariableDef uses this dependency graph in its\n      // analysis, so some of these candidates may no longer be valid.\n      // We keep track of when the variable dependency graph changed\n      // so that we can back off appropriately.\n      if (!c.defMetadata.depends.isEmpty()) {\n        inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n      }\n    }\n  }\n}\n\nprivate boolean canInline() {\n  // Cannot inline a parameter.\n  if (getDefCfgNode().isFunction()) {\n    return false;\n  }\n\n  // Do not inline a variable initialized inside a catch block.\n  if (NodeUtil.hasAncestor(use, Node::isCatch)) {\n    return false;\n  }\n\n  // If one of our dependencies has been inlined, then our dependency\n  // graph is wrong. Re-computing it would take another CFG computation,\n  // so we just back off for now.\n  for (Var dependency : defMetadata.depends) {\n    if (inlinedNewDependencies.contains(dependency)) {\n      return false;\n    }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  // Definition was not found.\n  if (def == null) {\n    return false;\n  }\n\n  // Check that the assignment isn't used as a R-Value.\n  // TODO(user): Certain cases we can still inline.\n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n    return false;\n  }\n\n  // The right of the definition has side effect:\n  // Example, for x:\n  // x = readProp(b), modifyProp(b); print(x);\n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Similar check as the above but this time, all the sub-expressions\n  // left of the use of the variable.\n  // x = readProp(b); modifyProp(b), print(x);\n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // TODO(user): Side-effect is OK sometimes. As long as there are no\n  // side-effect function down all paths to the use. Once we have all the\n  // side-effect analysis tool.\n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n    return false;\n  }\n\n  // TODO(user): We could inline all the uses if the expression is short.\n\n  // Finally we have to make sure that there are no more than one use\n  // in the program and in the CFG node. Even when it is semantically\n  // correctly inlining twice increases code size.\n  if (numUseWithinUseCfgNode != 1) {\n    return false;\n  }\n\n  // Make sure that the name is not within a loop\n  if (NodeUtil.isWithinLoop(use)) {\n    return false;\n  }\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n    return false;\n  }\n\n  // We give up inlining stuff with R-Value that has:\n  // 1) GETPROP, GETELEM,\n  // 2) anything that creates a new object.\n  // 3) a direct reference to a catch expression.\n  // Example:\n  // var x = a.b.c; j.c = 1; print(x);\n  // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n  // TODO(user): We could get more accuracy by looking more in-detail\n  // what j is and what x is trying to into to.\n  // TODO(johnlenz): rework catch expression handling when we\n  // have lexical scope support so catch expressions don't\n  // need to be special cased.\n  if (NodeUtil.has(def.getLastChild(),\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            switch (input.getType()) {\n              case Token.GETELEM:\n              case Token.GETPROP:\n              case Token.ARRAYLIT:\n              case Token.OBJECTLIT:\n              case Token.REGEXP:\n              case Token.NEW:\n                return true;\n            }\n            return false;\n          }\n      },\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n          }\n      })) {\n    return false;\n  }\n\n  // We can skip the side effect check along the paths of two nodes if\n  // they are just next to each other.\n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n      getDefCfgNode().getNext() != useCfgNode) {\n    // Similar side effect check as above but this time the side effect is\n    // else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n      pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n             cfg,\n             cfg.getDirectedGraphNode(getDefCfgNode()),\n             cfg.getDirectedGraphNode(useCfgNode),\n             SIDE_EFFECT_PREDICATE,\n             Predicates.\n                 <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n             false);\n    if (pathCheck.somePathsSatisfyPredicate()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
                            "\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n  \n  if (t.inGlobalScope()) {\n    return; // Don't even brother. All global variables are likely escaped.\n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n      t.getScope().getVarCount()) {\n    return;\n  }\n\n  // Compute the forward reaching definition.\n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  // Process the body of the function.\n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  // Using the forward reaching definition search to find all the inline\n  // candidates\n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n      t.getScopeRoot().getLastChild());\n\n  // Compute the backward reaching use. The CFG can be reused.\n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n    if (c.canInline()) {\n      c.inlineVariable();\n\n      // If definition c has dependencies, then inlining it may have\n      // introduced new dependencies for our other inlining candidates.\n      //\n      // MustBeReachingVariableDef uses this dependency graph in its\n      // analysis, so some of these candidates may no longer be valid.\n      // We keep track of when the variable dependency graph changed\n      // so that we can back off appropriately.\n      if (!c.defMetadata.depends.isEmpty()) {\n        inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n      }\n    }\n  }\n}\n\nprivate boolean canInline() {\n  // Cannot inline a parameter.\n  if (getDefCfgNode().isFunction()) {\n    return false;\n  }\n\n  // If one of our dependencies has been inlined, then our dependency\n  // graph is wrong. Re-computing it would take another CFG computation,\n  // so we just back off for now.\n  for (Var dependency : defMetadata.depends) {\n    if (inlinedNewDependencies.contains(dependency)) {\n      return false;\n    }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  // Definition was not found.\n  if (def == null) {\n    return false;\n  }\n\n  // Check that the assignment isn't used as a R-Value.\n  // TODO(user): Certain cases we can still inline.\n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n    return false;\n  }\n\n  // The right of the definition has side effect:\n  // Example, for x:\n  // x = readProp(b), modifyProp(b); print(x);\n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Similar check as the above but this time, all the sub-expressions\n  // left of the use of the variable.\n  // x = readProp(b); modifyProp(b), print(x);\n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // TODO(user): Side-effect is OK sometimes. As long as there are no\n  // side-effect function down all paths to the use. Once we have all the\n  // side-effect analysis tool.\n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n    return false;\n  }\n\n  // TODO(user): We could inline all the uses if the expression is short.\n\n  // Finally we have to make sure that there are no more than one use\n  // in the program and in the CFG node. Even when it is semantically\n  // correctly inlining twice increases code size.\n  if (numUseWithinUseCfgNode != 1) {\n    return false;\n  }\n\n  // Make sure that the name is not within a loop\n  if (NodeUtil.isWithinLoop(use)) {\n    return false;\n  }\n\n  // Ensure the variable isn't a catch block variable\n  if (NodeUtil.isCatchBlockVariable(def)) {\n    return false;\n  }\n  \n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n    return false;\n  }\n\n  // We give up inlining stuff with R-Value that has:\n  // 1) GETPROP, GETELEM,\n  // 2) anything that creates a new object.\n  // 3) a direct reference to a catch expression.\n  // Example:\n  // var x = a.b.c; j.c = 1; print(x);\n  // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n  // TODO(user): We could get more accuracy by looking more in-detail\n  // what j is and what x is trying to into to.\n  // TODO(johnlenz): rework catch expression handling when we\n  // have lexical scope support so catch expressions don't\n  // need to be special cased.\n  if (NodeUtil.has(def.getLastChild(),\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            switch (input.getType()) {\n              case Token.GETELEM:\n              case Token.GETPROP:\n              case Token.ARRAYLIT:\n              case Token.OBJECTLIT:\n              case Token.REGEXP:\n              case Token.NEW:\n                return true;\n            }\n            return false;\n          }\n      },\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n          }\n      })) {\n    return false;\n  }\n\n  // We can skip the side effect check along the paths of two nodes if\n  // they are just next to each other.\n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n      getDefCfgNode().getNext() != useCfgNode) {\n    // Similar side effect check as above but this time the side effect is\n    // else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n      pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n             cfg,\n             cfg.getDirectedGraphNode(getDefCfgNode()),\n             cfg.getDirectedGraphNode(useCfgNode),\n             SIDE_EFFECT_PREDICATE,\n             Predicates.\n                 <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n             false);\n    if (pathCheck.somePathsSatisfyPredicate()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
                            "\nprivate boolean canInline() {\n  // Cannot inline a parameter.\n  if (getDefCfgNode().isFunction()) {\n    return false;\n  }\n\n  // If one of our dependencies has been inlined, then our dependency\n  // graph is wrong. Re-computing it would take another CFG computation,\n  // so we just back off for now.\n  for (Var dependency : defMetadata.depends) {\n    if (inlinedNewDependencies.contains(dependency)) {\n      return false;\n    }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  // Definition was not found.\n  if (def == null) {\n    return false;\n  }\n\n  // Check that the assignment isn't used as a R-Value.\n  // TODO: Certain cases we can still inline.\n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n    return false;\n  }\n\n  // The right of the definition has side effect:\n  // Example, for x:\n  // x = readProp(b), modifyProp(b); print(x);\n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Similar check as the above but this time, all the sub-expressions\n  // left of the use of the variable.\n  // x = readProp(b); modifyProp(b), print(x);\n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // TODO: Side-effect is OK sometimes. As long as there are no\n  // side-effect function down all paths to the use. Once we have all the\n  // side-effect analysis tool.\n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n    return false;\n  }\n\n  // Make sure the definition is not within a catch expression.\n  if (NodeUtil.isNameReferencedWithinCatch(use)) {\n    return false;\n  }\n\n  // Finally we have to make sure that there are no more than one use\n  // in the program and in the CFG node. Even when it is semantically\n  // correctly inlining twice increases code size.\n  if (numUseWithinUseCfgNode != 1) {\n    return false;\n  }\n\n  // Make sure that the name is not within a loop\n  if (NodeUtil.isWithinLoop(use)) {\n    return false;\n  }\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n    return false;\n  }\n\n  // We give up inlining stuff with R-Value that has:\n  // 1) GETPROP, GETELEM,\n  // 2) anything that creates a new object.\n  // 3) a direct reference to a catch expression.\n  // Example:\n  // var x = a.b.c; j.c = 1; print(x);\n  // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n  // TODO: We could get more accuracy by looking more in-detail\n  // what j is and what x is trying to into to.\n  // TODO: rework catch expression handling when we\n  // have lexical scope support so catch expressions don't\n  // need to be special cased.\n  if (NodeUtil.has(def.getLastChild(),\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            switch (input.getType()) {\n              case Token.GETELEM:\n              case Token.GETPROP:\n              case Token.ARRAYLIT:\n              case Token.OBJECTLIT:\n              case Token.REGEXP:\n              case Token.NEW:\n                return true;\n            }\n            return false;\n          }\n      },\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n          }\n      })) {\n    return false;\n  }\n\n  // We can skip the side effect check along the paths of two nodes if\n  // they are just next to each other.\n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n      getDefCfgNode().getNext() != useCfgNode) {\n    // Similar side effect check as above but this time the side effect is\n    // else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n      pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n             cfg,\n             cfg.getDirectedGraphNode(getDefCfgNode()),\n             cfg.getDirectedGraphNode(useCfgNode),\n             SIDE_EFFECT_PREDICATE,\n             Predicates.\n                 <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n             false);\n    if (pathCheck.somePathsSatisfyPredicate()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        return; // Don't even bother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n\n    // Check for direct reference to a catch expression\n    if (getDefCfgNode().isCatch()) {\n        return false;\n    }\n\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n\n    // Check that the assignment isn't used as a R-Value.\n    // TODO: Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n\n    // TODO: Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n\n    // TODO: We could inline all the uses if the expression is short.\n\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n    if (uses.size() != 1) {\n        return false;\n    }\n\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO: We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(),\n            new Predicate<Node>() {\n                @Override\n                public boolean apply(Node input) {\n                    switch (input.getType()) {\n                        case Token.GETELEM:\n                        case Token.GETPROP:\n                        case Token.ARRAYLIT:\n                        case Token.OBJECTLIT:\n                        case Token.REGEXP:\n                        case Token.NEW:\n                            return true;\n                    }\n                    return false;\n                }\n            },\n            new Predicate<Node>() {\n                @Override\n                public boolean apply(Node input) {\n                    // Recurse if the node is not a function.\n                    return !input.isFunction();\n                }\n            })) {\n        return false;\n    }\n\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n            getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n                pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                    cfg,\n                    cfg.getDirectedGraphNode(getDefCfgNode()),\n                    cfg.getDirectedGraphNode(useCfgNode),\n                    SIDE_EFFECT_PREDICATE,\n                    Predicates.\n                            <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                    false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n\n    return true;\n}\n",
                            "\n@Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n\n  private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check if the definition is a catch block parameter.\n      if (def.isName() && def.hasParent() && def.getParent().isCatch()) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n\n  if (t.inGlobalScope()) {\n    return; // Don't even brother. All global variables are likely escaped.\n  }\n\n  if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n      t.getScope().getVarCount()) {\n    return;\n  }\n\n  // Compute the forward reaching definition.\n  ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n  // Process the body of the function.\n  Preconditions.checkState(t.getScopeRoot().isFunction());\n  cfa.process(null, t.getScopeRoot().getLastChild());\n  cfg = cfa.getCfg();\n  reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n  reachingDef.analyze();\n  candidates = Lists.newLinkedList();\n\n  // Using the forward reaching definition search to find all the inline\n  // candidates\n  new NodeTraversal(compiler, new GatherCandiates()).traverse(\n      t.getScopeRoot().getLastChild());\n\n  // Compute the backward reaching use. The CFG can be reused.\n  reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n  reachingUses.analyze();\n  for (Candidate c : candidates) {\n    if (c.canInline()) {\n      c.inlineVariable();\n\n      // If definition c has dependencies, then inlining it may have\n      // introduced new dependencies for our other inlining candidates.\n      //\n      // MustBeReachingVariableDef uses this dependency graph in its\n      // analysis, so some of these candidates may no longer be valid.\n      // We keep track of when the variable dependency graph changed\n      // so that we can back off appropriately.\n      if (!c.defMetadata.depends.isEmpty()) {\n        inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n      }\n    }\n  }\n}\n\n\nprivate boolean canInline() {\n  // Cannot inline a parameter.\n  if (getDefCfgNode().isFunction()) {\n    return false;\n  }\n\n  // If one of our dependencies has been inlined, then our dependency\n  // graph is wrong. Re-computing it would take another CFG computation,\n  // so we just back off for now.\n  for (Var dependency : defMetadata.depends) {\n    if (inlinedNewDependencies.contains(dependency)) {\n      return false;\n    }\n  }\n\n  getDefinition(getDefCfgNode(), null);\n  getNumUseInUseCfgNode(useCfgNode, null);\n\n  // Definition was not found.\n  if (def == null) {\n    return false;\n  }\n\n  // Check that the assignment isn't used as a R-Value.\n  // TODO(user): Certain cases we can still inline.\n  if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n    return false;\n  }\n\n  // The right of the definition has side effect:\n  // Example, for x:\n  // x = readProp(b), modifyProp(b); print(x);\n  if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // Similar check as the above but this time, all the sub-expressions\n  // left of the use of the variable.\n  // x = readProp(b); modifyProp(b), print(x);\n  if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n    return false;\n  }\n\n  // TODO(user): Side-effect is OK sometimes. As long as there are no\n  // side-effect function down all paths to the use. Once we have all the\n  // side-effect analysis tool.\n  if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n    return false;\n  }\n\n  // TODO(user): We could inline all the uses if the expression is short.\n\n  // Finally we have to make sure that there are no more than one use\n  // in the program and in the CFG node. Even when it is semantically\n  // correctly inlining twice increases code size.\n  if (numUseWithinUseCfgNode != 1) {\n    return false;\n  }\n\n  // Make sure that the name is not within a loop\n  if (NodeUtil.isWithinLoop(use)) {\n    return false;\n  }\n\n  Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n  if (uses.size() != 1) {\n    return false;\n  }\n\n  // We give up inlining stuff with R-Value that has:\n  // 1) GETPROP, GETELEM,\n  // 2) anything that creates a new object.\n  // 3) a direct reference to a catch expression.\n  // Example:\n  // var x = a.b.c; j.c = 1; print(x);\n  // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n  // TODO(user): We could get more accuracy by looking more in-detail\n  // what j is and what x is trying to into to.\n  // TODO(johnlenz): rework catch expression handling when we\n  // have lexical scope support so catch expressions don't\n  // need to be special cased.\n  if (NodeUtil.has(def.getLastChild(),\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            switch (input.getType()) {\n              case Token.GETELEM:\n              case Token.GETPROP:\n              case Token.ARRAYLIT:\n              case Token.OBJECTLIT:\n              case Token.REGEXP:\n              case Token.NEW:\n                return true;\n            }\n            return false;\n          }\n      },\n      new Predicate<Node>() {\n          @Override\n          public boolean apply(Node input) {\n            // Recurse if the node is not a function or catch scope.\n            return !input.isFunction() && !NodeUtil.isCatchScope(input);\n          }\n      })) {\n    return false;\n  }\n\n  // We can skip the side effect check along the paths of two nodes if\n  // they are just next to each other.\n  if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n      getDefCfgNode().getNext() != useCfgNode) {\n    // Similar side effect check as above but this time the side effect is\n    // else where along the path.\n    // x = readProp(b); while(modifyProp(b)) {}; print(x);\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n      pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n             cfg,\n             cfg.getDirectedGraphNode(getDefCfgNode()),\n             cfg.getDirectedGraphNode(useCfgNode),\n             SIDE_EFFECT_PREDICATE,\n             Predicates.\n                 <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n             false);\n    if (pathCheck.somePathsSatisfyPredicate()) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java",
                "start_loc": 280,
                "end_loc": 411,
                "buggy_function": "    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
                "fixed_function": "    private boolean canInline(final Scope scope) {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                  case Token.NAME:\n                    Var var = scope.getOwnSlot(input.getString());\n                    if (var != null\n                        && var.getParentNode().isCatch()) {\n                      return true;\n                    }\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private boolean canInline() { if (getDefCfgNode().isFunction()) { return false; } for (Var dependency : defMetadata.depends) { if (inlinedNewDependencies.contains(dependency)) { return false; } } getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) { return false; } if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) { return false; } if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) { return false; } if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) { return false; } if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) { return false; } if (numUseWithinUseCfgNode != 1) { return false; } if (NodeUtil.isWithinLoop(use)) { return false; } Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode()); if (uses.size() != 1) { return false; } if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() { @Override public boolean apply(Node input) { switch(input.getType()) { case Token.GETELEM: case Token.GETPROP: case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: case Token.NEW: return true; } return false; } }, new Predicate<Node>() { @Override public boolean apply(Node input) { return !input.isFunction(); } })) { return false; } if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) { CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false); if (pathCheck.somePathsSatisfyPredicate()) { return false; } } return true; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private boolean canInline() { if (getDefCfgNode().isFunction()) { return false; } for (Var dependency : defMetadata.depends) { if (inlinedNewDependencies.contains(dependency)) { return false; } } getDefinition(getDefCfgNode(), null); getNumUseInUseCfgNode(useCfgNode, null); if (def == null) { return false; } if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) { return false; } if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) { return false; } if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) { return false; } if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) { return false; } if (numUseWithinUseCfgNode != 1) { return false; } if (NodeUtil.isWithinLoop(use)) { return false; } Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode()); if (uses.size() != 1) { return false; } if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() { @Override public boolean apply(Node input) { switch(input.getType()) { case Token.GETELEM: case Token.GETPROP: case Token.ARRAYLIT: case Token.OBJECTLIT: case Token.REGEXP: case Token.NEW: return true; } return false; } }, new Predicate<Node>() { @Override public boolean apply(Node input) { return !input.isFunction(); } })) { return false; } if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) { CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false); if (pathCheck.somePathsSatisfyPredicate()) { return false; } } return true; }"
                    ],
                    [
                        0.9751184582710266,
                        "@Override @SuppressWarnings(\\\"fallthrough\\\") List<FlowScope> branchedFlowThrough(Node source, FlowScope input) { FlowScope output = flowThrough(source, input); Node condition = null; FlowScope conditionFlowScope = null; BooleanOutcomePair conditionOutcomes = null; List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source); List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size()); for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) { Branch branch = branchEdge.getValue(); FlowScope newScope = output; switch(branch) { case ON_TRUE: if (NodeUtil.isForIn(source)) { Node item = source.getFirstChild(); Node obj = item.getNext(); FlowScope informed = traverse(obj, output.createChildFlowScope()); if (item.isVar()) { item = item.getFirstChild(); } if (item.isName()) { JSType iterKeyType = getNativeType(STRING_TYPE); ObjectType objType = getJSType(obj).dereference(); JSType objIndexType = objType == null ? null : objType.getIndexType(); if (objIndexType != null && !objIndexType.isUnknownType()) { JSType narrowedKeyType = iterKeyType.getGreatestSubtype(objIndexType); if (!narrowedKeyType.isEmptyType()) { iterKeyType = narrowedKeyType; } } redeclareSimpleVar(informed, item, iterKeyType); } newScope = informed; break; } case ON_FALSE: if (condition == null) { condition = NodeUtil.getConditionExpression(source); if (condition == null && source.isCase()) { condition = source; if (conditionFlowScope == null) { conditionFlowScope = traverse(condition.getFirstChild(), output.createChildFlowScope()); } } } if (condition != null) { if (condition.isAnd() || condition.isOr()) { if (conditionOutcomes == null) { conditionOutcomes = condition.isAnd() ? traverseAnd(condition, output.createChildFlowScope()) : traverseOr(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionOutcomes.getOutcomeFlowScope(condition.getType(), branch == Branch.ON_TRUE), branch == Branch.ON_TRUE); } else { if (conditionFlowScope == null) { conditionFlowScope = traverse(condition, output.createChildFlowScope()); } newScope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(condition, conditionFlowScope, branch == Branch.ON_TRUE); } } break; } result.add(newScope.optimize()); } return result; }"
                    ],
                    [
                        0.9718992710113525,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (!(n.isName() || NodeUtil.isGet(n) && !parent.isGetProp())) { return; } NameInformation nameInfo = createNameInformation(t, n, parent); if (nameInfo == null) { return; } if (nameInfo.onlyAffectsClassDef) { if (nameInfo.superclass != null) { recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE); } String nodeName = n.getQualifiedName(); if (nodeName != null) { recordReference(nameInfo.name, nodeName, RefType.REGULAR); } return; } if (parent.isInstanceOf() && parent.getLastChild() == n && n.isQualifiedName()) { JsName checkedClass = getName(nameInfo.name, true); refNodes.add(new InstanceOfCheckNode(checkedClass, n)); checkedClass.hasInstanceOfReference = true; return; } NameInformation referring = getDependencyScope(n); String referringName = \\\"\\\"; if (referring != null) { referringName = referring.isPrototype ? referring.prototypeClass : referring.name; } String name = nameInfo.name; if (maybeHiddenAlias(name, n)) { recordAlias(name, WINDOW); } if (nameInfo.isExternallyReferenceable) { recordReference(WINDOW, name, RefType.REGULAR); maybeRecordAlias(name, parent, referring, referringName); return; } if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) { if (referring != null) { recordReference(referringName, name, RefType.REGULAR); } return; } if (nodesToKeep.contains(n)) { NameInformation functionScope = getEnclosingFunctionDependencyScope(t); if (functionScope != null) { recordReference(functionScope.name, name, RefType.REGULAR); } else { recordReference(WINDOW, name, RefType.REGULAR); } } else if (referring != null) { if (!maybeRecordAlias(name, parent, referring, referringName)) { RefType depType = referring.onlyAffectsClassDef ? RefType.INHERITANCE : RefType.REGULAR; recordReference(referringName, name, depType); } } else { for (Node ancestor : n.getAncestors()) { if (NodeUtil.isAssignmentOp(ancestor) || ancestor.isFunction()) { recordReference(WINDOW, name, RefType.REGULAR); break; } } } }"
                    ],
                    [
                        0.9704472422599792,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (!n.isName()) { return; } String varName = n.getString(); if (varName.isEmpty()) { Preconditions.checkState(parent.isFunction()); Preconditions.checkState(NodeUtil.isFunctionExpression(parent)); return; } if ((parent.isVar() || NodeUtil.isFunctionDeclaration(parent)) && varsToDeclareInExterns.contains(varName)) { createSynthesizedExternVar(varName); n.addSuppression(\\\"duplicate\\\"); } Scope scope = t.getScope(); Scope.Var var = scope.getVar(varName); if (var == null) { if (NodeUtil.isFunctionExpression(parent)) { } else { if (!strictExternCheck || !t.getInput().isExtern()) { t.report(n, UNDEFINED_VAR_ERROR, varName); } if (sanityCheck) { throw new IllegalStateException(\\\"Unexpected variable \\\" + varName); } else { createSynthesizedExternVar(varName); scope.getGlobalScope().declare(varName, n, null, getSynthesizedExternsInput()); } } return; } CompilerInput currInput = t.getInput(); CompilerInput varInput = var.input; if (currInput == varInput || currInput == null || varInput == null) { return; } JSModule currModule = currInput.getModule(); JSModule varModule = varInput.getModule(); JSModuleGraph moduleGraph = compiler.getModuleGraph(); if (!sanityCheck && varModule != currModule && varModule != null && currModule != null) { if (moduleGraph.dependsOn(currModule, varModule)) { } else { if (scope.isGlobal()) { if (moduleGraph.dependsOn(varModule, currModule)) { t.report(n, VIOLATED_MODULE_DEP_ERROR, currModule.getName(), varModule.getName(), varName); } else { t.report(n, MISSING_MODULE_DEP_ERROR, currModule.getName(), varModule.getName(), varName); } } else { t.report(n, STRICT_MODULE_DEP_ERROR, currModule.getName(), varModule.getName(), varName); } } } }"
                    ],
                    [
                        0.9695354700088501,
                        "@Override public void onRedeclaration(Scope s, String name, Node n, CompilerInput input) { Node parent = n.getParent(); if (scope.isGlobal()) { Scope.Var origVar = scope.getVar(name); Node origParent = origVar.getParentNode(); if (origParent.isCatch() && parent.isCatch()) { return; } boolean allowDupe = hasDuplicateDeclarationSuppression(n, origVar); if (!allowDupe) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \\\"??\\\"))); } } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) { compiler.report(JSError.make(NodeUtil.getSourceName(n), n, VAR_ARGUMENTS_SHADOWED_ERROR)); } }"
                    ],
                    [
                        0.9685460031032562,
                        "private void computeMayUse(Node n, Node cfgNode, ReachingUses output, boolean conditional) { switch(n.getType()) { case Token.BLOCK: case Token.FUNCTION: return; case Token.NAME: addToUseIfLocal(n.getString(), cfgNode, output); return; case Token.WHILE: case Token.DO: case Token.IF: computeMayUse(NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMayUse(NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (lhs.isVar()) { lhs = lhs.getLastChild(); } if (lhs.isName() && !conditional) { removeFromUseIfLocal(lhs.getString(), output); } computeMayUse(rhs, cfgNode, output, conditional); } return; case Token.AND: case Token.OR: computeMayUse(n.getLastChild(), cfgNode, output, true); computeMayUse(n.getFirstChild(), cfgNode, output, conditional); return; case Token.HOOK: computeMayUse(n.getLastChild(), cfgNode, output, true); computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true); computeMayUse(n.getFirstChild(), cfgNode, output, conditional); return; case Token.VAR: Node varName = n.getFirstChild(); Preconditions.checkState(n.hasChildren(), \\\"AST should be normalized\\\"); if (varName.hasChildren()) { computeMayUse(varName.getFirstChild(), cfgNode, output, conditional); if (!conditional) { removeFromUseIfLocal(varName.getString(), output); } } return; default: if (NodeUtil.isAssignmentOp(n) && n.getFirstChild().isName()) { Node name = n.getFirstChild(); if (!conditional) { removeFromUseIfLocal(name.getString(), output); } if (!n.isAssign()) { addToUseIfLocal(name.getString(), cfgNode, output); } computeMayUse(name.getNext(), cfgNode, output, conditional); } else { for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) { computeMayUse(c, cfgNode, output, conditional); } } } }"
                    ],
                    [
                        0.9680932462215424,
                        "private XMLList matchDescendantChildren(XMLName xmlName) { XMLList result = new XMLList(lib); XmlCursor curs = newCursor(); TokenType tt = curs.currentTokenType(); result.setTargets(this, null); if (tt.isStartdoc()) { tt = curs.toFirstContentToken(); } if (tt.isContainer()) { int nestLevel = 1; while (nestLevel > 0) { tt = curs.toNextToken(); if (!tt.isAttr() && !tt.isEnd() && !tt.isEnddoc()) { if (!tt.isStart() && !tt.isProcinst()) { if (xmlName.localName().equals(\\\"*\\\")) { result.addToList(findAnnotation(curs)); } } else { if (qnameMatches(xmlName, curs.getName())) { result.addToList(findAnnotation(curs)); } } } if (tt.isStart()) { nestLevel++; } else if (tt.isEnd()) { nestLevel--; } else if (tt.isEnddoc()) { break; } } } curs.dispose(); return result; }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1a",
                    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1",
                    "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression3"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }\n\n```\n\n```java\n\n    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testDoNotInlineCatchExpression1a() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err + 1;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError:\n \n#Test method 2:\n```java\n  public void testDoNotInlineCatchExpression1() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n```\n#Error message from the test method 2: junit.framework.AssertionFailedError:\n \n#Test method 3:\n```java\n  public void testDoNotInlineCatchExpression3() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"} catch(err) {\" +\n        \"  err = x;\\n\" +\n        \"  a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError:\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // Cannot inline catch expression\n      if (getDefCfgNode().isCatch()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n              switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                  return true;\n              }\n              return false;\n            }\n          },\n          new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n              // Recurse if the node is not a function.\n              return !input.isFunction();\n            }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n               cfg,\n               cfg.getDirectedGraphNode(getDefCfgNode()),\n               cfg.getDirectedGraphNode(useCfgNode),\n               SIDE_EFFECT_PREDICATE,\n               Predicates.\n                   <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n               false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1a": {
                "path": "test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java",
                "function_name": "testDoNotInlineCatchExpression1a",
                "src": "  public void testDoNotInlineCatchExpression1a() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err + 1;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function _func(){var a;try{throw Error(\"\");}catch(err){a=err+1}return a.stack}\nResult: function _func(){var a;try{throw Error(\"\");}catch(err){}return(err+1).stack}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: expected0] [input_id: InputId: expected0]\n        FUNCTION _func 1 [source_file: expected0]\n            NAME _func 1 [source_file: expected0]\n            PARAM_LIST 1 [source_file: expected0]\n            BLOCK 1 [source_file: expected0]\n                VAR 1 [source_file: expected0]\n                    NAME a 1 [source_file: expected0]\n                TRY 2 [source_file: expected0]\n                    BLOCK 2 [source_file: expected0]\n                        THROW 3 [source_file: expected0]\n                            CALL 3 [free_call: 1] [source_file: expected0]\n                                NAME Error 3 [source_file: expected0]\n                                STRING  3 [source_file: expected0]\n                    BLOCK 4 [source_file: expected0]\n                        CATCH 4 [source_file: expected0]\n                            NAME err 4 [source_file: expected0]\n                            BLOCK 4 [source_file: expected0]\n                                EXPR_RESULT 4 [source_file: expected0]\n                                    ASSIGN 4 [source_file: expected0]\n                                        NAME a 4 [source_file: expected0]\n                                        ADD 4 [source_file: expected0]\n                                            NAME err 4 [source_file: expected0]\n                                            NUMBER 1.0 4 [source_file: expected0]\n                RETURN 6 [source_file: expected0]\n                    GETPROP 6 [source_file: expected0]\n                        NAME a 6 [source_file: expected0]\n                        STRING stack 6 [source_file: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: testcode] [input_id: InputId: testcode]\n        FUNCTION _func 1 [source_file: testcode]\n            NAME _func 1 [source_file: testcode]\n            PARAM_LIST 1 [source_file: testcode]\n            BLOCK 1 [source_file: testcode]\n                VAR 1 [source_file: testcode]\n                    NAME a 1 [source_file: testcode]\n                TRY 2 [source_file: testcode]\n                    BLOCK 2 [source_file: testcode]\n                        THROW 3 [source_file: testcode]\n                            CALL 3 [free_call: 1] [source_file: testcode]\n                                NAME Error 3 [source_file: testcode]\n                                STRING  3 [source_file: testcode]\n                    BLOCK 4 [source_file: testcode]\n                        CATCH 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            BLOCK 4 [source_file: testcode]\n                RETURN 6 [source_file: testcode]\n                    GETPROP 6 [source_file: testcode]\n                        ADD 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            NUMBER 1.0 4 [source_file: testcode]\n                        STRING stack 6 [source_file: testcode]\n\n\nSubtree1: BLOCK 4 [source_file: expected0]\n    EXPR_RESULT 4 [source_file: expected0]\n        ASSIGN 4 [source_file: expected0]\n            NAME a 4 [source_file: expected0]\n            ADD 4 [source_file: expected0]\n                NAME err 4 [source_file: expected0]\n                NUMBER 1.0 4 [source_file: expected0]\n\n\nSubtree2: BLOCK 4 [source_file: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1a(FlowSensitiveInlineVariablesTest.java:157)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function _func(){var a;try{throw Error(\"\");}catch(err){a=err+1}return a.stack}\nResult: function _func(){var a;try{throw Error(\"\");}catch(err){}return(err+1).stack}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: expected0] [input_id: InputId: expected0]\n        FUNCTION _func 1 [source_file: expected0]\n            NAME _func 1 [source_file: expected0]\n            PARAM_LIST 1 [source_file: expected0]\n            BLOCK 1 [source_file: expected0]\n                VAR 1 [source_file: expected0]\n                    NAME a 1 [source_file: expected0]\n                TRY 2 [source_file: expected0]\n                    BLOCK 2 [source_file: expected0]\n                        THROW 3 [source_file: expected0]\n                            CALL 3 [free_call: 1] [source_file: expected0]\n                                NAME Error 3 [source_file: expected0]\n                                STRING  3 [source_file: expected0]\n                    BLOCK 4 [source_file: expected0]\n                        CATCH 4 [source_file: expected0]\n                            NAME err 4 [source_file: expected0]\n                            BLOCK 4 [source_file: expected0]\n                                EXPR_RESULT 4 [source_file: expected0]\n                                    ASSIGN 4 [source_file: expected0]\n                                        NAME a 4 [source_file: expected0]\n                                        ADD 4 [source_file: expected0]\n                                            NAME err 4 [source_file: expected0]\n                                            NUMBER 1.0 4 [source_file: expected0]\n                RETURN 6 [source_file: expected0]\n                    GETPROP 6 [source_file: expected0]\n                        NAME a 6 [source_file: expected0]\n                        STRING stack 6 [source_file: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: testcode] [input_id: InputId: testcode]\n        FUNCTION _func 1 [source_file: testcode]\n            NAME _func 1 [source_file: testcode]\n            PARAM_LIST 1 [source_file: testcode]\n            BLOCK 1 [source_file: testcode]\n                VAR 1 [source_file: testcode]\n                    NAME a 1 [source_file: testcode]\n                TRY 2 [source_file: testcode]\n                    BLOCK 2 [source_file: testcode]\n                        THROW 3 [source_file: testcode]\n                            CALL 3 [free_call: 1] [source_file: testcode]\n                                NAME Error 3 [source_file: testcode]\n                                STRING  3 [source_file: testcode]\n                    BLOCK 4 [source_file: testcode]\n                        CATCH 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            BLOCK 4 [source_file: testcode]\n                RETURN 6 [source_file: testcode]\n                    GETPROP 6 [source_file: testcode]\n                        ADD 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            NUMBER 1.0 4 [source_file: testcode]\n                        STRING stack 6 [source_file: testcode]\n\n\nSubtree1: BLOCK 4 [source_file: expected0]\n    EXPR_RESULT 4 [source_file: expected0]\n        ASSIGN 4 [source_file: expected0]\n            NAME a 4 [source_file: expected0]\n            ADD 4 [source_file: expected0]\n                NAME err 4 [source_file: expected0]\n                NUMBER 1.0 4 [source_file: expected0]\n\n\nSubtree2: BLOCK 4 [source_file: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +              \"\\nResult: \" + compiler.toSource(mainRoot) +              \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)  test(externsInputs, js, expected, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)  test(externs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)  test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",        \"function _func() {\" + expected + \"}\", null, null);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)  inline(input, input);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1a(FlowSensitiveInlineVariablesTest.java:157)  noInline(        \"var a;\\n\" +        \"try {\\n\" +        \"  throw Error(\\\"\\\");\\n\" +        \"}catch(err) {\" +        \"   a = err + 1;\\n\" +        \"}\\n\" +        \"return a.stack\\n\");"
            },
            "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1": {
                "path": "test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java",
                "function_name": "testDoNotInlineCatchExpression1",
                "src": "  public void testDoNotInlineCatchExpression1() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function _func(){var a;try{throw Error(\"\");}catch(err){a=err}return a.stack}\nResult: function _func(){var a;try{throw Error(\"\");}catch(err){}return err.stack}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: expected0] [input_id: InputId: expected0]\n        FUNCTION _func 1 [source_file: expected0]\n            NAME _func 1 [source_file: expected0]\n            PARAM_LIST 1 [source_file: expected0]\n            BLOCK 1 [source_file: expected0]\n                VAR 1 [source_file: expected0]\n                    NAME a 1 [source_file: expected0]\n                TRY 2 [source_file: expected0]\n                    BLOCK 2 [source_file: expected0]\n                        THROW 3 [source_file: expected0]\n                            CALL 3 [free_call: 1] [source_file: expected0]\n                                NAME Error 3 [source_file: expected0]\n                                STRING  3 [source_file: expected0]\n                    BLOCK 4 [source_file: expected0]\n                        CATCH 4 [source_file: expected0]\n                            NAME err 4 [source_file: expected0]\n                            BLOCK 4 [source_file: expected0]\n                                EXPR_RESULT 4 [source_file: expected0]\n                                    ASSIGN 4 [source_file: expected0]\n                                        NAME a 4 [source_file: expected0]\n                                        NAME err 4 [source_file: expected0]\n                RETURN 6 [source_file: expected0]\n                    GETPROP 6 [source_file: expected0]\n                        NAME a 6 [source_file: expected0]\n                        STRING stack 6 [source_file: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: testcode] [input_id: InputId: testcode]\n        FUNCTION _func 1 [source_file: testcode]\n            NAME _func 1 [source_file: testcode]\n            PARAM_LIST 1 [source_file: testcode]\n            BLOCK 1 [source_file: testcode]\n                VAR 1 [source_file: testcode]\n                    NAME a 1 [source_file: testcode]\n                TRY 2 [source_file: testcode]\n                    BLOCK 2 [source_file: testcode]\n                        THROW 3 [source_file: testcode]\n                            CALL 3 [free_call: 1] [source_file: testcode]\n                                NAME Error 3 [source_file: testcode]\n                                STRING  3 [source_file: testcode]\n                    BLOCK 4 [source_file: testcode]\n                        CATCH 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            BLOCK 4 [source_file: testcode]\n                RETURN 6 [source_file: testcode]\n                    GETPROP 6 [source_file: testcode]\n                        NAME err 4 [source_file: testcode]\n                        STRING stack 6 [source_file: testcode]\n\n\nSubtree1: BLOCK 4 [source_file: expected0]\n    EXPR_RESULT 4 [source_file: expected0]\n        ASSIGN 4 [source_file: expected0]\n            NAME a 4 [source_file: expected0]\n            NAME err 4 [source_file: expected0]\n\n\nSubtree2: BLOCK 4 [source_file: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1(FlowSensitiveInlineVariablesTest.java:146)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function _func(){var a;try{throw Error(\"\");}catch(err){a=err}return a.stack}\nResult: function _func(){var a;try{throw Error(\"\");}catch(err){}return err.stack}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: expected0] [input_id: InputId: expected0]\n        FUNCTION _func 1 [source_file: expected0]\n            NAME _func 1 [source_file: expected0]\n            PARAM_LIST 1 [source_file: expected0]\n            BLOCK 1 [source_file: expected0]\n                VAR 1 [source_file: expected0]\n                    NAME a 1 [source_file: expected0]\n                TRY 2 [source_file: expected0]\n                    BLOCK 2 [source_file: expected0]\n                        THROW 3 [source_file: expected0]\n                            CALL 3 [free_call: 1] [source_file: expected0]\n                                NAME Error 3 [source_file: expected0]\n                                STRING  3 [source_file: expected0]\n                    BLOCK 4 [source_file: expected0]\n                        CATCH 4 [source_file: expected0]\n                            NAME err 4 [source_file: expected0]\n                            BLOCK 4 [source_file: expected0]\n                                EXPR_RESULT 4 [source_file: expected0]\n                                    ASSIGN 4 [source_file: expected0]\n                                        NAME a 4 [source_file: expected0]\n                                        NAME err 4 [source_file: expected0]\n                RETURN 6 [source_file: expected0]\n                    GETPROP 6 [source_file: expected0]\n                        NAME a 6 [source_file: expected0]\n                        STRING stack 6 [source_file: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: testcode] [input_id: InputId: testcode]\n        FUNCTION _func 1 [source_file: testcode]\n            NAME _func 1 [source_file: testcode]\n            PARAM_LIST 1 [source_file: testcode]\n            BLOCK 1 [source_file: testcode]\n                VAR 1 [source_file: testcode]\n                    NAME a 1 [source_file: testcode]\n                TRY 2 [source_file: testcode]\n                    BLOCK 2 [source_file: testcode]\n                        THROW 3 [source_file: testcode]\n                            CALL 3 [free_call: 1] [source_file: testcode]\n                                NAME Error 3 [source_file: testcode]\n                                STRING  3 [source_file: testcode]\n                    BLOCK 4 [source_file: testcode]\n                        CATCH 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            BLOCK 4 [source_file: testcode]\n                RETURN 6 [source_file: testcode]\n                    GETPROP 6 [source_file: testcode]\n                        NAME err 4 [source_file: testcode]\n                        STRING stack 6 [source_file: testcode]\n\n\nSubtree1: BLOCK 4 [source_file: expected0]\n    EXPR_RESULT 4 [source_file: expected0]\n        ASSIGN 4 [source_file: expected0]\n            NAME a 4 [source_file: expected0]\n            NAME err 4 [source_file: expected0]\n\n\nSubtree2: BLOCK 4 [source_file: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +              \"\\nResult: \" + compiler.toSource(mainRoot) +              \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)  test(externsInputs, js, expected, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)  test(externs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)  test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",        \"function _func() {\" + expected + \"}\", null, null);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)  inline(input, input);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1(FlowSensitiveInlineVariablesTest.java:146)  noInline(        \"var a;\\n\" +        \"try {\\n\" +        \"  throw Error(\\\"\\\");\\n\" +        \"}catch(err) {\" +        \"   a = err;\\n\" +        \"}\\n\" +        \"return a.stack\\n\");"
            },
            "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression3": {
                "path": "test/com/google/javascript/jscomp/FlowSensitiveInlineVariablesTest.java",
                "function_name": "testDoNotInlineCatchExpression3",
                "src": "  public void testDoNotInlineCatchExpression3() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"} catch(err) {\" +\n        \"  err = x;\\n\" +\n        \"  a = err;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function _func(){var a;try{throw Error(\"\");}catch(err){err=x;a=err}return a.stack}\nResult: function _func(){var a;try{throw Error(\"\");}catch(err){err=x}return err.stack}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: expected0] [input_id: InputId: expected0]\n        FUNCTION _func 1 [source_file: expected0]\n            NAME _func 1 [source_file: expected0]\n            PARAM_LIST 1 [source_file: expected0]\n            BLOCK 1 [source_file: expected0]\n                VAR 1 [source_file: expected0]\n                    NAME a 1 [source_file: expected0]\n                TRY 2 [source_file: expected0]\n                    BLOCK 2 [source_file: expected0]\n                        THROW 3 [source_file: expected0]\n                            CALL 3 [free_call: 1] [source_file: expected0]\n                                NAME Error 3 [source_file: expected0]\n                                STRING  3 [source_file: expected0]\n                    BLOCK 4 [source_file: expected0]\n                        CATCH 4 [source_file: expected0]\n                            NAME err 4 [source_file: expected0]\n                            BLOCK 4 [source_file: expected0]\n                                EXPR_RESULT 4 [source_file: expected0]\n                                    ASSIGN 4 [source_file: expected0]\n                                        NAME err 4 [source_file: expected0]\n                                        NAME x 4 [source_file: expected0]\n                                EXPR_RESULT 5 [source_file: expected0]\n                                    ASSIGN 5 [source_file: expected0]\n                                        NAME a 5 [source_file: expected0]\n                                        NAME err 5 [source_file: expected0]\n                RETURN 7 [source_file: expected0]\n                    GETPROP 7 [source_file: expected0]\n                        NAME a 7 [source_file: expected0]\n                        STRING stack 7 [source_file: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: testcode] [input_id: InputId: testcode]\n        FUNCTION _func 1 [source_file: testcode]\n            NAME _func 1 [source_file: testcode]\n            PARAM_LIST 1 [source_file: testcode]\n            BLOCK 1 [source_file: testcode]\n                VAR 1 [source_file: testcode]\n                    NAME a 1 [source_file: testcode]\n                TRY 2 [source_file: testcode]\n                    BLOCK 2 [source_file: testcode]\n                        THROW 3 [source_file: testcode]\n                            CALL 3 [free_call: 1] [source_file: testcode]\n                                NAME Error 3 [source_file: testcode]\n                                STRING  3 [source_file: testcode]\n                    BLOCK 4 [source_file: testcode]\n                        CATCH 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            BLOCK 4 [source_file: testcode]\n                                EXPR_RESULT 4 [source_file: testcode]\n                                    ASSIGN 4 [source_file: testcode]\n                                        NAME err 4 [source_file: testcode]\n                                        NAME x 4 [source_file: testcode]\n                RETURN 7 [source_file: testcode]\n                    GETPROP 7 [source_file: testcode]\n                        NAME err 5 [source_file: testcode]\n                        STRING stack 7 [source_file: testcode]\n\n\nSubtree1: BLOCK 4 [source_file: expected0]\n    EXPR_RESULT 4 [source_file: expected0]\n        ASSIGN 4 [source_file: expected0]\n            NAME err 4 [source_file: expected0]\n            NAME x 4 [source_file: expected0]\n    EXPR_RESULT 5 [source_file: expected0]\n        ASSIGN 5 [source_file: expected0]\n            NAME a 5 [source_file: expected0]\n            NAME err 5 [source_file: expected0]\n\n\nSubtree2: BLOCK 4 [source_file: testcode]\n    EXPR_RESULT 4 [source_file: testcode]\n        ASSIGN 4 [source_file: testcode]\n            NAME err 4 [source_file: testcode]\n            NAME x 4 [source_file: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression3(FlowSensitiveInlineVariablesTest.java:179)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function _func(){var a;try{throw Error(\"\");}catch(err){err=x;a=err}return a.stack}\nResult: function _func(){var a;try{throw Error(\"\");}catch(err){err=x}return err.stack}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: expected0] [input_id: InputId: expected0]\n        FUNCTION _func 1 [source_file: expected0]\n            NAME _func 1 [source_file: expected0]\n            PARAM_LIST 1 [source_file: expected0]\n            BLOCK 1 [source_file: expected0]\n                VAR 1 [source_file: expected0]\n                    NAME a 1 [source_file: expected0]\n                TRY 2 [source_file: expected0]\n                    BLOCK 2 [source_file: expected0]\n                        THROW 3 [source_file: expected0]\n                            CALL 3 [free_call: 1] [source_file: expected0]\n                                NAME Error 3 [source_file: expected0]\n                                STRING  3 [source_file: expected0]\n                    BLOCK 4 [source_file: expected0]\n                        CATCH 4 [source_file: expected0]\n                            NAME err 4 [source_file: expected0]\n                            BLOCK 4 [source_file: expected0]\n                                EXPR_RESULT 4 [source_file: expected0]\n                                    ASSIGN 4 [source_file: expected0]\n                                        NAME err 4 [source_file: expected0]\n                                        NAME x 4 [source_file: expected0]\n                                EXPR_RESULT 5 [source_file: expected0]\n                                    ASSIGN 5 [source_file: expected0]\n                                        NAME a 5 [source_file: expected0]\n                                        NAME err 5 [source_file: expected0]\n                RETURN 7 [source_file: expected0]\n                    GETPROP 7 [source_file: expected0]\n                        NAME a 7 [source_file: expected0]\n                        STRING stack 7 [source_file: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: testcode] [input_id: InputId: testcode]\n        FUNCTION _func 1 [source_file: testcode]\n            NAME _func 1 [source_file: testcode]\n            PARAM_LIST 1 [source_file: testcode]\n            BLOCK 1 [source_file: testcode]\n                VAR 1 [source_file: testcode]\n                    NAME a 1 [source_file: testcode]\n                TRY 2 [source_file: testcode]\n                    BLOCK 2 [source_file: testcode]\n                        THROW 3 [source_file: testcode]\n                            CALL 3 [free_call: 1] [source_file: testcode]\n                                NAME Error 3 [source_file: testcode]\n                                STRING  3 [source_file: testcode]\n                    BLOCK 4 [source_file: testcode]\n                        CATCH 4 [source_file: testcode]\n                            NAME err 4 [source_file: testcode]\n                            BLOCK 4 [source_file: testcode]\n                                EXPR_RESULT 4 [source_file: testcode]\n                                    ASSIGN 4 [source_file: testcode]\n                                        NAME err 4 [source_file: testcode]\n                                        NAME x 4 [source_file: testcode]\n                RETURN 7 [source_file: testcode]\n                    GETPROP 7 [source_file: testcode]\n                        NAME err 5 [source_file: testcode]\n                        STRING stack 7 [source_file: testcode]\n\n\nSubtree1: BLOCK 4 [source_file: expected0]\n    EXPR_RESULT 4 [source_file: expected0]\n        ASSIGN 4 [source_file: expected0]\n            NAME err 4 [source_file: expected0]\n            NAME x 4 [source_file: expected0]\n    EXPR_RESULT 5 [source_file: expected0]\n        ASSIGN 5 [source_file: expected0]\n            NAME a 5 [source_file: expected0]\n            NAME err 5 [source_file: expected0]\n\n\nSubtree2: BLOCK 4 [source_file: testcode]\n    EXPR_RESULT 4 [source_file: testcode]\n        ASSIGN 4 [source_file: testcode]\n            NAME err 4 [source_file: testcode]\n            NAME x 4 [source_file: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +              \"\\nResult: \" + compiler.toSource(mainRoot) +              \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)  test(externsInputs, js, expected, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)  test(externs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)  test(EXTERN_FUNCTIONS, \"function _func() {\" + input + \"}\",        \"function _func() {\" + expected + \"}\", null, null);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)  inline(input, input);\n\tat com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression3(FlowSensitiveInlineVariablesTest.java:179)  noInline(        \"var a;\\n\" +        \"try {\\n\" +        \"  throw Error(\\\"\\\");\\n\" +        \"} catch(err) {\" +        \"  err = x;\\n\" +        \"  a = err;\\n\" +        \"}\\n\" +        \"return a.stack\\n\");"
            }
        },
        "evaluation_done": true
    }
}