{
    "Closure-68": {
        "function_num": 3,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
                "start_loc": 169,
                "end_loc": 913,
                "buggy_function": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                  token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n",
                "fixed_function": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }\n",
                "comment": "  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n",
                "normalized_body": [
                    "boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\\\"\\\"); } } retry: for (; ; ) { switch(token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch(annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\\\"msg.jsdoc.const\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \\\"\\\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\\\"number\\\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\\\"msg.jsdoc.export\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\\\"msg.jsdoc.externs\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState(annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\\\"msg.end.annotation.expected\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\\\"msg.jsdoc.hidden\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\\\"msg.jsdoc.noalias\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\\\"msg.jsdoc.override\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\\\"msg.missing.variable.name\\\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name, lineno, charno); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.private\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.protected\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.public\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) { parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token, lineno, charno); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch(annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\\\"msg.jsdoc.define\\\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription(returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; } token = eatTokensUntilEOL(); } continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\\\"msg.unexpected.eof\\\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000000596046448,
                        "boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\\\"\\\"); } } retry: for (; ; ) { switch(token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch(annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\\\"msg.jsdoc.const\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \\\"\\\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\\\"number\\\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\\\"msg.jsdoc.export\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\\\"msg.jsdoc.externs\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState(annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\\\"msg.end.annotation.expected\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\\\"msg.jsdoc.hidden\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\\\"msg.jsdoc.noalias\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\\\"msg.jsdoc.override\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\\\"msg.missing.variable.name\\\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name, lineno, charno); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.private\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.protected\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.public\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) { parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token, lineno, charno); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch(annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\\\"msg.jsdoc.define\\\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription(returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; } token = eatTokensUntilEOL(); } continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\\\"msg.unexpected.eof\\\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
                    ],
                    [
                        0.9924680829048157,
                        "private Node statementHelper(Node statementLabel) throws IOException, ParserException { Node pn = null; int tt; tt = peekToken(); switch(tt) { case Token.IF: { consumeToken(); decompiler.addToken(Token.IF); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node cond = condition(); decompiler.addEOL(Token.LC); Node ifTrue = statement(); Node ifFalse = null; if (matchToken(Token.ELSE)) { decompiler.addToken(Token.RC); decompiler.addToken(Token.ELSE); decompiler.addEOL(Token.LC); ifFalse = statement(); } decompiler.addEOL(Token.RC); pn = nf.createIf(cond, ifTrue, ifFalse, lineno, charno); return pn; } case Token.SWITCH: { consumeToken(); decompiler.addToken(Token.SWITCH); int lineno = ts.getLineno(); int charno = ts.getCharno(); mustMatchToken(Token.LP, \\\"msg.no.paren.switch\\\"); decompiler.addToken(Token.LP); pn = enterSwitch(expr(false), lineno, charno); try { mustMatchToken(Token.RP, \\\"msg.no.paren.after.switch\\\"); decompiler.addToken(Token.RP); mustMatchToken(Token.LC, \\\"msg.no.brace.switch\\\"); decompiler.addEOL(Token.LC); boolean hasDefault = false; switchLoop: for (; ; ) { tt = nextToken(); lineno = ts.getLineno(); charno = ts.getCharno(); Node caseExpression; switch(tt) { case Token.RC: break switchLoop; case Token.CASE: decompiler.addToken(Token.CASE); caseExpression = expr(false); mustMatchToken(Token.COLON, \\\"msg.no.colon.case\\\"); decompiler.addEOL(Token.COLON); break; case Token.DEFAULT: if (hasDefault) { reportError(\\\"msg.double.switch.default\\\"); } decompiler.addToken(Token.DEFAULT); hasDefault = true; caseExpression = null; mustMatchToken(Token.COLON, \\\"msg.no.colon.case\\\"); decompiler.addEOL(Token.COLON); break; default: reportError(\\\"msg.bad.switch\\\"); break switchLoop; } Node block = nf.createLeaf(Token.BLOCK, lineno, charno); block.setIsSyntheticBlock(true); while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) { nf.addChildToBack(block, statement()); } nf.addSwitchCase(pn, caseExpression, block, lineno, charno); } decompiler.addEOL(Token.RC); nf.closeSwitch(pn); } finally { exitSwitch(); } return pn; } case Token.WHILE: { consumeToken(); decompiler.addToken(Token.WHILE); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node cond = condition(); decompiler.addEOL(Token.LC); Node body = statement(); decompiler.addEOL(Token.RC); pn = nf.createWhile(cond, body, lineno, charno); return pn; } case Token.DO: { consumeToken(); decompiler.addToken(Token.DO); decompiler.addEOL(Token.LC); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node body = statement(); decompiler.addToken(Token.RC); mustMatchToken(Token.WHILE, \\\"msg.no.while.do\\\"); decompiler.addToken(Token.WHILE); Node cond = condition(); pn = nf.createDoWhile(body, cond, lineno, charno); matchToken(Token.SEMI); decompiler.addEOL(Token.SEMI); return pn; } case Token.FOR: { consumeToken(); boolean isForEach = false; decompiler.addToken(Token.FOR); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node init; Node cond; Node incr = null; Node body; if (matchToken(Token.NAME)) { decompiler.addName(ts.getString()); if (ts.getString().equals(\\\"each\\\")) { isForEach = true; } else { reportError(\\\"msg.no.paren.for\\\"); } } mustMatchToken(Token.LP, \\\"msg.no.paren.for\\\"); decompiler.addToken(Token.LP); tt = peekToken(); if (tt == Token.SEMI) { init = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); } else { if (tt == Token.VAR) { consumeToken(); init = variables(Token.FOR); } else { init = expr(true); } } if (matchToken(Token.IN)) { decompiler.addToken(Token.IN); cond = expr(false); } else { mustMatchToken(Token.SEMI, \\\"msg.no.semi.for\\\"); decompiler.addToken(Token.SEMI); if (peekToken() == Token.SEMI) { cond = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); } else { cond = expr(false); } mustMatchToken(Token.SEMI, \\\"msg.no.semi.for.cond\\\"); decompiler.addToken(Token.SEMI); if (peekToken() == Token.RP) { incr = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); } else { incr = expr(false); } } mustMatchToken(Token.RP, \\\"msg.no.paren.for.ctrl\\\"); decompiler.addToken(Token.RP); decompiler.addEOL(Token.LC); body = statement(); decompiler.addEOL(Token.RC); if (incr == null) { pn = nf.createForIn(init, cond, body, lineno, charno); } else { pn = nf.createFor(init, cond, incr, body, lineno, charno); } return pn; } case Token.TRY: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node tryblock; Node catchblocks = null; Node finallyblock = null; JSDocInfo info = ts.getAndResetJSDocInfo(); decompiler.addToken(Token.TRY); decompiler.addEOL(Token.LC); tryblock = statement(); decompiler.addEOL(Token.RC); catchblocks = nf.createLeaf(Token.BLOCK, ts.getLineno(), ts.getCharno()); boolean sawDefaultCatch = false; int peek = peekToken(); if (peek == Token.CATCH) { while (matchToken(Token.CATCH)) { int catchLineno = ts.getLineno(); int catchCharno = ts.getCharno(); if (sawDefaultCatch) { reportError(\\\"msg.catch.unreachable\\\"); } decompiler.addToken(Token.CATCH); mustMatchToken(Token.LP, \\\"msg.no.paren.catch\\\"); decompiler.addToken(Token.LP); mustMatchToken(Token.NAME, \\\"msg.bad.catchcond\\\"); String varName = ts.getString(); int nameLineno = ts.getLineno(); int nameCharno = ts.getCharno(); decompiler.addName(varName); Node catchCond = null; if (matchToken(Token.IF)) { decompiler.addToken(Token.IF); catchCond = expr(false); } else { sawDefaultCatch = true; } mustMatchToken(Token.RP, \\\"msg.bad.catchcond\\\"); decompiler.addToken(Token.RP); mustMatchToken(Token.LC, \\\"msg.no.brace.catchblock\\\"); decompiler.addEOL(Token.LC); nf.addChildToBack(catchblocks, nf.createCatch(varName, nameLineno, nameCharno, catchCond, statements(), catchLineno, catchCharno)); mustMatchToken(Token.RC, \\\"msg.no.brace.after.body\\\"); decompiler.addEOL(Token.RC); } } else if (peek != Token.FINALLY) { mustMatchToken(Token.FINALLY, \\\"msg.try.no.catchfinally\\\"); } if (matchToken(Token.FINALLY)) { decompiler.addToken(Token.FINALLY); decompiler.addEOL(Token.LC); finallyblock = statement(); decompiler.addEOL(Token.RC); } pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno, charno); if (info != null) { pn.setJSDocInfo(info); } return pn; } case Token.THROW: { consumeToken(); if (peekTokenOrEOL() == Token.EOL) { reportError(\\\"msg.bad.throw.eol\\\"); } int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.THROW); pn = nf.createThrow(expr(false), lineno, charno); break; } case Token.BREAK: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.BREAK); String label = matchLabel(); if (label != null) { decompiler.addToken(Token.NAME); decompiler.addName(label); } pn = nf.createBreak(label, lineno, charno); break; } case Token.CONTINUE: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.CONTINUE); String label = matchLabel(); if (label != null) { decompiler.addToken(Token.NAME); decompiler.addName(label); } pn = nf.createContinue(label, lineno, charno); break; } case Token.DEBUGGER: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.DEBUGGER); pn = nf.createDebugger(lineno, charno); break; } case Token.WITH: { consumeToken(); decompiler.addToken(Token.WITH); int lineno = ts.getLineno(); int charno = ts.getCharno(); mustMatchToken(Token.LP, \\\"msg.no.paren.with\\\"); decompiler.addToken(Token.LP); Node obj = expr(false); mustMatchToken(Token.RP, \\\"msg.no.paren.after.with\\\"); decompiler.addToken(Token.RP); decompiler.addEOL(Token.LC); ++nestingOfWith; Node body; try { body = statement(); } finally { --nestingOfWith; } decompiler.addEOL(Token.RC); pn = nf.createWith(obj, body, lineno, charno); return pn; } case Token.CONST: case Token.VAR: { consumeToken(); pn = variables(tt); break; } case Token.RETURN: { if (!insideFunction()) { reportError(\\\"msg.bad.return\\\"); } consumeToken(); decompiler.addToken(Token.RETURN); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node retExpr; tt = peekTokenOrEOL(); switch(tt) { case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null; break; default: retExpr = expr(false); hasReturnValue = true; } pn = nf.createReturn(retExpr, lineno, charno); break; } case Token.LC: consumeToken(); if (statementLabel != null) { decompiler.addToken(Token.LC); } pn = statements(); mustMatchToken(Token.RC, \\\"msg.no.brace.block\\\"); if (statementLabel != null) { decompiler.addEOL(Token.RC); } return pn; case Token.ERROR: case Token.SEMI: consumeToken(); pn = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); return pn; case Token.FUNCTION: { consumeToken(); pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT); return pn; } case Token.DEFAULT: { consumeToken(); mustHaveXML(); decompiler.addToken(Token.DEFAULT); int lineno = ts.getLineno(); int charno = ts.getCharno(); if (!(matchToken(Token.NAME) && ts.getString().equals(\\\"xml\\\"))) { reportError(\\\"msg.bad.namespace\\\"); } decompiler.addName(\\\" xml\\\"); if (!(matchToken(Token.NAME) && ts.getString().equals(\\\"namespace\\\"))) { reportError(\\\"msg.bad.namespace\\\"); } decompiler.addName(\\\" namespace\\\"); if (!matchToken(Token.ASSIGN)) { reportError(\\\"msg.bad.namespace\\\"); } decompiler.addToken(Token.ASSIGN); Node expr = expr(false); pn = nf.createDefaultNamespace(expr, lineno, charno); break; } case Token.NAME: { int lineno = ts.getLineno(); int charno = ts.getCharno(); String name = ts.getString(); setCheckForLabel(); pn = expr(false); if (pn.getType() != Token.LABEL) { pn = nf.createExprStatement(pn, lineno, charno); } else { if (peekToken() != Token.COLON) Kit.codeBug(); consumeToken(); decompiler.addName(name); decompiler.addEOL(Token.COLON); if (labelSet == null) { labelSet = new Hashtable<String, Node>(); } else if (labelSet.containsKey(name)) { reportError(\\\"msg.dup.label\\\"); } labelSet.put(name, pn); pn = nf.createLabel(name, lineno, charno); try { nf.addChildToBack(pn, statementHelper(pn)); } finally { labelSet.remove(name); } return pn; } break; } default: { int lineno = ts.getLineno(); int charno = ts.getCharno(); pn = expr(false); pn = nf.createExprStatement(pn, lineno, charno); break; } } int ttFlagged = peekFlaggedToken(); switch(ttFlagged & CLEAR_TI_MASK) { case Token.SEMI: consumeToken(); break; case Token.ERROR: case Token.EOF: case Token.RC: break; default: if ((ttFlagged & TI_AFTER_EOL) == 0) { reportError(\\\"msg.no.semi.stmt\\\"); } break; } decompiler.addEOL(Token.SEMI); return pn; }"
                    ],
                    [
                        0.9918060421943664,
                        "void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState(childCount == 2, \\\"Bad binary operator \\\\\"%s\\\\\": expected 2 arguments but got %s\\\", opstr, childCount); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch(type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\\\"try\\\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\\\"finally\\\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\\\"catch(\\\"); add(first); add(\\\")\\\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\\\"throw\\\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\\\"return\\\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\\\"var \\\"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\\\"=\\\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\\\"[\\\"); addArrayList(first); add(\\\"]\\\"); break; case Token.LP: add(\\\"(\\\"); addList(first); add(\\\")\\\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); addList(first, false, context); break; case Token.NUMBER: Preconditions.checkState(childCount == 0); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().getType() == Token.NUMBER) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\\\"?\\\", true); addExpr(first.getNext(), 1); cc.addOp(\\\":\\\", true); addExpr(last, 1); break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\\\"Expected children to be strings\\\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\\\".\\\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\\\"Unexpected Node subclass.\\\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\\\"(\\\"); } add(\\\"function\\\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\\\")\\\"); } break; case Token.GET: case Token.SET: Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.getType() == Token.FUNCTION); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GET) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\\\"get \\\"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\\\"set \\\"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addJsString(n.getString()); } } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\\\"Unexpected Node subclass.\\\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().getType() == Token.SCRIPT); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\\\"for(\\\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\\\";\\\"); add(first.getNext()); add(\\\";\\\"); add(first.getNext().getNext()); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\\\"for(\\\"); add(first); add(\\\"in\\\"); add(first.getNext()); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\\\"do\\\"); addNonEmptyStatement(first, Context.OTHER, false); add(\\\"while(\\\"); add(last); add(\\\")\\\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\\\"while(\\\"); add(first); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState(childCount == 2, \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount); Preconditions.checkState(last.getType() == Token.STRING, \\\"Bad GETPROP: RHS should be STRING\\\"); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) { add(\\\"(\\\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\\\")\\\"); } add(\\\".\\\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState(childCount == 2, \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount); addLeftExpr(first, NodeUtil.precedence(type), context); add(\\\"[\\\"); add(first.getNext()); add(\\\"]\\\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\\\"with(\\\"); add(first); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\\\"(0,\\\"); addExpr(first, NodeUtil.precedence(Token.COMMA)); add(\\\")\\\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); } add(\\\"(\\\"); addList(first.getNext()); add(\\\")\\\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\\\"if(\\\"); add(first); add(\\\")\\\"); if (hasElse) { addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\\\"else\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\\\"continue\\\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\\\"debugger\\\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\\\"break\\\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.EXPR_VOID: throw new Error(\\\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\\\"); case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\\\"new \\\"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) { add(\\\"(\\\"); addList(next); add(\\\")\\\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) { throw new IllegalStateException(\\\"Unexpected String children: \\\" + n.getParent().toStringTree()); } addJsString(n.getString()); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\\\"delete \\\"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\\\"(\\\"); } add(\\\"{\\\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.getType() == Token.GET || c.getType() == Token.SET) { add(c); } else { Preconditions.checkState(c.getType() == Token.STRING); String key = c.getString(); if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { add(key); } else { double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1); } } add(\\\":\\\"); addExpr(c.getFirstChild(), 1); } } add(\\\"}\\\"); if (needsParens) { add(\\\")\\\"); } break; } case Token.SWITCH: add(\\\"switch(\\\"); add(first); add(\\\")\\\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\\\"case \\\"); add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\\\"default\\\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(first); add(\\\":\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true); break; case Token.SETNAME: break; default: throw new Error(\\\"Unknown type \\\" + type + \\\"\\n\\\" + n.toStringTree()); } cc.endSourceMapping(n); }"
                    ],
                    [
                        0.9905462563037872,
                        "ConcreteType inferConcreteType(ConcreteScope scope, Node expr) { Preconditions.checkNotNull(scope); Preconditions.checkNotNull(expr); ConcreteType ret; switch(expr.getType()) { case Token.NAME: StaticSlot<ConcreteType> slot = scope.getSlot(expr.getString()); if (slot != null) { ret = slot.getType(); } else { ret = ConcreteType.ALL; } break; case Token.THIS: ret = scope.getTypeOfThis(); break; case Token.ASSIGN: ret = inferConcreteType(scope, expr.getLastChild()); break; case Token.COMMA: ret = inferConcreteType(scope, expr.getLastChild()); break; case Token.AND: ret = inferConcreteType(scope, expr.getLastChild()); break; case Token.OR: ret = inferConcreteType(scope, expr.getFirstChild()).unionWith(inferConcreteType(scope, expr.getLastChild())); break; case Token.HOOK: ret = inferConcreteType(scope, expr.getFirstChild().getNext()).unionWith(inferConcreteType(scope, expr.getLastChild())); break; case Token.GETPROP: ConcreteType recvType = inferConcreteType(scope, expr.getFirstChild()); if (recvType.isAll()) { ret = recvType; break; } Node prop = expr.getLastChild(); String propName = prop.getString(); ConcreteType type = recvType.getPropertyType(propName); if (\\\"prototype\\\".equals(propName)) { for (ConcreteFunctionType funType : recvType.getFunctions()) { type = type.unionWith(funType.getPrototypeType()); } } else if (compiler.getCodingConvention().isSuperClassReference(propName)) { for (ConcreteFunctionType superType : recvType.getSuperclassTypes()) { type = type.unionWith(superType.getPrototypeType()); } } else if (\\\"call\\\".equals(propName)) { type = recvType; } ret = type; break; case Token.GETELEM: ret = ConcreteType.ALL; break; case Token.CALL: ConcreteType targetType = inferConcreteType(scope, expr.getFirstChild()); if (targetType.isAll()) { ret = targetType; break; } ret = ConcreteType.NONE; for (ConcreteFunctionType funType : targetType.getFunctions()) { ret = ret.unionWith(funType.getReturnSlot().getType()); } break; case Token.NEW: ConcreteType constructorType = inferConcreteType(scope, expr.getFirstChild()); if (constructorType.isAll()) { throw new AssertionError(\\\"Attempted new call on all type!\\\"); } ret = ConcreteType.NONE; for (ConcreteInstanceType instType : constructorType.getFunctionInstanceTypes()) { ret = ret.unionWith(instType); } allInstantiatedTypes.add(ret); break; case Token.FUNCTION: ret = createConcreteFunction(expr, scope); break; case Token.OBJECTLIT: if ((expr.getJSType() != null) && !expr.getJSType().isUnknownType()) { JSType exprType = expr.getJSType().restrictByNotNullOrUndefined(); ConcreteType inst = createConcreteInstance(exprType.toObjectType()); allInstantiatedTypes.add(inst); ret = inst; } else { ret = ConcreteType.ALL; } break; case Token.ARRAYLIT: ObjectType arrayType = (ObjectType) getTypeRegistry().getNativeType(JSTypeNative.ARRAY_TYPE); ConcreteInstanceType inst = createConcreteInstance(arrayType); allInstantiatedTypes.add(inst); ret = inst; break; default: ret = ConcreteType.NONE; } return createTypeIntersection(ret, expr.getJSType()); }"
                    ],
                    [
                        0.9895610272884369,
                        "public void visit(NodeTraversal t, Node n, Node parent) { JSType childType; JSType leftType, rightType; Node left, right; boolean typeable = true; switch(n.getType()) { case Token.NAME: typeable = visitName(t, n, parent); break; case Token.LP: if (parent.getType() != Token.FUNCTION) { ensureTyped(t, n, getJSType(n.getFirstChild())); } else { typeable = false; } break; case Token.COMMA: ensureTyped(t, n, getJSType(n.getLastChild())); break; case Token.TRUE: case Token.FALSE: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.THIS: ensureTyped(t, n, t.getScope().getTypeOfThis()); break; case Token.REF_SPECIAL: ensureTyped(t, n); break; case Token.GET_REF: ensureTyped(t, n, getJSType(n.getFirstChild())); break; case Token.NULL: ensureTyped(t, n, NULL_TYPE); break; case Token.NUMBER: ensureTyped(t, n, NUMBER_TYPE); break; case Token.STRING: if (!NodeUtil.isObjectLitKey(n, n.getParent())) { ensureTyped(t, n, STRING_TYPE); } break; case Token.GET: case Token.SET: break; case Token.ARRAYLIT: ensureTyped(t, n, ARRAY_TYPE); break; case Token.REGEXP: ensureTyped(t, n, REGEXP_TYPE); break; case Token.GETPROP: visitGetProp(t, n, parent); typeable = !(parent.getType() == Token.ASSIGN && parent.getFirstChild() == n); break; case Token.GETELEM: visitGetElem(t, n); typeable = false; break; case Token.VAR: visitVar(t, n); typeable = false; break; case Token.NEW: visitNew(t, n); typeable = true; break; case Token.CALL: visitCall(t, n); typeable = !NodeUtil.isExpressionNode(parent); break; case Token.RETURN: visitReturn(t, n); typeable = false; break; case Token.DEC: case Token.INC: left = n.getFirstChild(); validator.expectNumber(t, left, getJSType(left), \\\"increment/decrement\\\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.NOT: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.VOID: ensureTyped(t, n, VOID_TYPE); break; case Token.TYPEOF: ensureTyped(t, n, STRING_TYPE); break; case Token.BITNOT: childType = getJSType(n.getFirstChild()); if (!childType.matchesInt32Context()) { report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString()); } ensureTyped(t, n, NUMBER_TYPE); break; case Token.POS: case Token.NEG: left = n.getFirstChild(); validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.EQ: case Token.NE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted); if (result != TernaryValue.UNKNOWN) { if (n.getType() == Token.NE) { result = result.not(); } report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString()); } ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.SHEQ: case Token.SHNE: { leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) { report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString()); } ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.LT: case Token.LE: case Token.GT: case Token.GE: leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); if (rightType.isNumber()) { validator.expectNumber(t, n, leftType, \\\"left side of numeric comparison\\\"); } else if (leftType.isNumber()) { validator.expectNumber(t, n, rightType, \\\"right side of numeric comparison\\\"); } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) { } else { String message = \\\"left side of comparison\\\"; validator.expectString(t, n, leftType, message); validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE)); message = \\\"right side of comparison\\\"; validator.expectString(t, n, rightType, message); validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE)); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.IN: left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right); validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\"); validator.expectString(t, left, leftType, \\\"left side of 'in'\\\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.INSTANCEOF: left = n.getFirstChild(); right = n.getLastChild(); leftType = getJSType(left); rightType = getJSType(right).restrictByNotNullOrUndefined(); validator.expectAnyObject(t, left, leftType, \\\"deterministic instanceof yields false\\\"); validator.expectActualObject(t, right, rightType, \\\"instanceof requires an object\\\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.ASSIGN: visitAssign(t, n); typeable = false; break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_SUB: case Token.ASSIGN_ADD: case Token.ASSIGN_MUL: case Token.LSH: case Token.RSH: case Token.URSH: case Token.DIV: case Token.MOD: case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.SUB: case Token.ADD: case Token.MUL: visitBinaryOperator(n.getType(), t, n); break; case Token.DELPROP: if (!isReference(n.getFirstChild())) { report(t, n, BAD_DELETE); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.CASE: JSType switchType = getJSType(parent.getFirstChild()); JSType caseType = getJSType(n.getFirstChild()); validator.expectSwitchMatchesCase(t, n, switchType, caseType); typeable = false; break; case Token.WITH: { Node child = n.getFirstChild(); childType = getJSType(child); validator.expectObject(t, child, childType, \\\"with requires an object\\\"); typeable = false; break; } case Token.FUNCTION: visitFunction(t, n); break; case Token.LABEL: case Token.LABEL_NAME: case Token.SWITCH: case Token.BREAK: case Token.CATCH: case Token.TRY: case Token.SCRIPT: case Token.EXPR_RESULT: case Token.BLOCK: case Token.EMPTY: case Token.DEFAULT: case Token.CONTINUE: case Token.DEBUGGER: case Token.THROW: typeable = false; break; case Token.DO: case Token.FOR: case Token.IF: case Token.WHILE: typeable = false; break; case Token.AND: case Token.HOOK: case Token.OBJECTLIT: case Token.OR: if (n.getJSType() != null) { ensureTyped(t, n); } else { if ((n.getType() == Token.OBJECTLIT) && (parent.getJSType() instanceof EnumType)) { ensureTyped(t, n, parent.getJSType()); } else { ensureTyped(t, n); } } if (n.getType() == Token.OBJECTLIT) { for (Node key : n.children()) { visitObjLitKey(t, key, n); } } break; default: report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType())); ensureTyped(t, n); break; } typeable = typeable && !inExterns; if (typeable) { doPercentTypedAccounting(t, n); } checkNoTypeCheckSection(n, false); }"
                    ],
                    [
                        0.9895013332366943,
                        "private FlowScope traverse(Node n, FlowScope scope) { switch(n.getType()) { case Token.ASSIGN: scope = traverseAssign(n, scope); break; case Token.NAME: scope = traverseName(n, scope); break; case Token.GETPROP: scope = traverseGetProp(n, scope); break; case Token.AND: scope = traverseAnd(n, scope).getJoinedFlowScope().createChildFlowScope(); break; case Token.OR: scope = traverseOr(n, scope).getJoinedFlowScope().createChildFlowScope(); break; case Token.HOOK: scope = traverseHook(n, scope); break; case Token.OBJECTLIT: scope = traverseObjectLiteral(n, scope); break; case Token.CALL: scope = traverseCall(n, scope); break; case Token.NEW: scope = traverseNew(n, scope); break; case Token.ASSIGN_ADD: case Token.ADD: scope = traverseAdd(n, scope); break; case Token.POS: case Token.NEG: scope = traverse(n.getFirstChild(), scope); n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.ARRAYLIT: scope = traverseArrayLiteral(n, scope); break; case Token.THIS: n.setJSType(scope.getTypeOfThis()); break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.LSH: case Token.RSH: case Token.ASSIGN_URSH: case Token.URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITAND: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITOR: case Token.ASSIGN_MUL: case Token.ASSIGN_SUB: case Token.DIV: case Token.MOD: case Token.BITAND: case Token.BITXOR: case Token.BITOR: case Token.MUL: case Token.SUB: case Token.DEC: case Token.INC: case Token.BITNOT: scope = traverseChildren(n, scope); n.setJSType(getNativeType(NUMBER_TYPE)); break; case Token.LP: case Token.GET_REF: scope = traverse(n.getFirstChild(), scope); n.setJSType(getJSType(n.getFirstChild())); break; case Token.COMMA: scope = traverseChildren(n, scope); n.setJSType(getJSType(n.getLastChild())); break; case Token.TYPEOF: scope = traverseChildren(n, scope); n.setJSType(getNativeType(STRING_TYPE)); break; case Token.DELPROP: case Token.LT: case Token.LE: case Token.GT: case Token.GE: case Token.NOT: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.INSTANCEOF: case Token.IN: scope = traverseChildren(n, scope); n.setJSType(getNativeType(BOOLEAN_TYPE)); break; case Token.GETELEM: scope = traverseGetElem(n, scope); break; case Token.EXPR_RESULT: scope = traverseChildren(n, scope); if (n.getFirstChild().getType() == Token.GETPROP) { ensurePropertyDeclared(n.getFirstChild()); } break; case Token.SWITCH: scope = traverse(n.getFirstChild(), scope); break; case Token.VAR: case Token.RETURN: case Token.THROW: scope = traverseChildren(n, scope); break; case Token.CATCH: scope = traverseCatch(n, scope); break; } if (n.getType() != Token.FUNCTION) { JSDocInfo info = n.getJSDocInfo(); if (info != null && info.hasType()) { JSType castType = info.getType().evaluate(syntacticScope, registry); if (n.isQualifiedName() && n.getParent().getType() == Token.EXPR_RESULT) { updateScopeForTypeChange(scope, n, n.getJSType(), castType); } n.setJSType(castType); } } return scope; }"
                    ],
                    [
                        0.9890600144863129,
                        "public void visit(NodeTraversal t, Node n, Node parent) { RefInfo refInfo = allRefInfo.get(n); if (refInfo != null) { Ref ref = refInfo.ref; Name name = refInfo.name; String fullName = name.fullName(); switch(ref.type) { case SET_FROM_GLOBAL: case SET_FROM_LOCAL: Node valParent = getValueParent(ref); Node val = valParent.getLastChild(); if (valParent.getType() == Token.ASSIGN && name.isSimpleName() && name.declaration == ref) { compiler.report(t.makeError(val, INVALID_DEFINE_INIT_ERROR, fullName)); } else if (processDefineAssignment(t, fullName, val, valParent)) { refInfo.name.removeRef(ref); lvalueToRemoveLater = valParent; } break; default: if (t.inGlobalScope()) { DefineInfo info = assignableDefines.get(fullName); if (info != null) { setDefineInfoNotAssignable(info, t); assignableDefines.remove(fullName); } } break; } } if (!t.inGlobalScope() && n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) { compiler.report(t.makeError(n, NON_GLOBAL_DEFINE_INIT_ERROR, \\\"\\\")); } if (lvalueToRemoveLater == n) { lvalueToRemoveLater = null; if (n.getType() == Token.ASSIGN) { Node last = n.getLastChild(); n.removeChild(last); parent.replaceChild(n, last); } else { Preconditions.checkState(n.getType() == Token.NAME); n.removeChild(n.getFirstChild()); } compiler.reportCodeChange(); } if (n.getType() == Token.CALL) { if (t.inGlobalScope()) { for (DefineInfo info : assignableDefines.values()) { setDefineInfoNotAssignable(info, t); } assignableDefines.clear(); } } updateAssignAllowedStack(n, false); }"
                    ],
                    [
                        0.9887201309204101,
                        "private void updateObjLitOrFunctionDeclarationAtAssignNode(Name n, String alias, boolean canCollapseChildNames) { Ref ref = n.declaration; Node rvalue = ref.node.getNext(); Node varNode = new Node(Token.VAR); Node varParent = ref.node.getAncestor(3); Node gramps = ref.node.getAncestor(2); boolean isObjLit = rvalue.getType() == Token.OBJECTLIT; boolean insertedVarNode = false; if (isObjLit && n.canEliminate()) { varParent.replaceChild(gramps, varNode); ref.node = null; insertedVarNode = true; } else if (!n.isSimpleName()) { if (rvalue.getType() == Token.FUNCTION) { checkForHosedThisReferences(rvalue, n.docInfo, n); } ref.node.getParent().removeChild(rvalue); Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, ref.node.getAncestor(2), n.fullName()); JSDocInfo info = ref.node.getParent().getJSDocInfo(); if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME) || (info != null && info.isConstant())) { nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true); } varNode.addChildToBack(nameNode); nameNode.addChildToFront(rvalue); varParent.replaceChild(gramps, varNode); ref.node = nameNode; insertedVarNode = true; } if (canCollapseChildNames) { if (isObjLit) { declareVarsForObjLitValues(n, alias, rvalue, varNode, varParent.getChildBefore(varNode), varParent); } addStubsForUndeclaredProperties(n, alias, varParent, varNode); } if (insertedVarNode) { if (!varNode.hasChildren()) { varParent.removeChild(varNode); } compiler.reportCodeChange(); } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
                "start_loc": 1685,
                "end_loc": 1710,
                "buggy_function": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                "fixed_function": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                "comment": "  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n",
                "normalized_body": [
                    "private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\\\"function\\\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\\\"null\\\".equals(string) || \\\"undefined\\\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } return reportGenericTypeSyntaxWarning(); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "private Node parseBasicTypeExpression(JsDocToken token) { if (token == JsDocToken.STAR) { return newNode(Token.STAR); } else if (token == JsDocToken.LB) { skipEOLs(); return parseArrayType(next()); } else if (token == JsDocToken.LC) { skipEOLs(); return parseRecordType(next()); } else if (token == JsDocToken.LP) { skipEOLs(); return parseUnionType(next()); } else if (token == JsDocToken.STRING) { String string = stream.getString(); if (\\\"function\\\".equals(string)) { skipEOLs(); return parseFunctionType(next()); } else if (\\\"null\\\".equals(string) || \\\"undefined\\\".equals(string)) { return newStringNode(string); } else { return parseTypeName(token); } } return reportGenericTypeSyntaxWarning(); }"
                    ],
                    [
                        0.9690847396850586,
                        "@Override public void enterScope(NodeTraversal t) { JSType returnType = explicitReturnExpected(t.getScopeRoot()); if (returnType == null) { return; } if (fastAllPathsReturnCheck(t.getControlFlowGraph())) { return; } CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(t.getControlFlowGraph(), t.getControlFlowGraph().getEntry(), t.getControlFlowGraph().getImplicitReturn(), IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE); if (!test.allPathsSatisfyPredicate()) { compiler.report(t.makeError(t.getScopeRoot(), level, MISSING_RETURN_STATEMENT, returnType.toString())); } }"
                    ],
                    [
                        0.9688736796379089,
                        "private void removeVarDeclaration(Node name) { Node var = name.getParent(); Node parent = var.getParent(); if (NodeUtil.isForIn(parent)) { var.removeChild(name); parent.replaceChild(var, name); } else if (var.hasOneChild()) { if (name.hasChildren()) { Node value = name.removeFirstChild(); var.removeChild(name); Node assign = new Node(Token.ASSIGN, name, value).copyInformationFrom(name); if (parent.getType() != Token.FOR) { assign = NodeUtil.newExpr(assign); } parent.replaceChild(var, assign); } else { NodeUtil.removeChild(parent, var); } } else { if (!name.hasChildren()) { var.removeChild(name); } } }"
                    ],
                    [
                        0.9686537981033325,
                        "private void addWrite(Node nameNode, NodeTraversal t, boolean objLit) { String name = nameNode.getString(); Property prop = getProperty(name); prop.writeCount++; if (prop.readCount == 0 && !isExported(name)) { if (checkWrites.isOn() && !objLit) { if (prop.writes == null) { prop.writes = new ArrayList<Node>(MAX_REPORTS_PER_PROPERTY); } if (prop.writes.size() < MAX_REPORTS_PER_PROPERTY) { nameNode.putProp(Node.SOURCENAME_PROP, t.getSourceName()); prop.writes.add(nameNode); } } } else { prop.writes = null; } prop.reads = null; }"
                    ],
                    [
                        0.9673550724983215,
                        "final void analyze(int maxSteps) { initialize(); int step = 0; while (!orderedWorkSet.isEmpty()) { if (step > maxSteps) { throw new MaxIterationsExceededException(\\\"Analysis did not terminate after \\\" + maxSteps + \\\" iterations\\\"); } DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next(); orderedWorkSet.remove(curNode); joinInputs(curNode); if (flow(curNode)) { List<DiGraphNode<N, Branch>> nextNodes = isForward() ? cfg.getDirectedSuccNodes(curNode) : cfg.getDirectedPredNodes(curNode); for (DiGraphNode<N, Branch> nextNode : nextNodes) { if (nextNode != cfg.getImplicitReturn()) { orderedWorkSet.add(nextNode); } } } step++; } if (isForward()) { joinInputs(getCfg().getImplicitReturn()); } }"
                    ],
                    [
                        0.9671143889427185,
                        "private Collection<Action> getImplicitActionsFromPropNonUnion(ObjectType jsType, String prop, Node fnNode) { JSType propType = jsType.getPropertyType(prop).restrictByNotNullOrUndefined(); if (jsType.isPropertyInExterns(prop) && propType.isFunctionType()) { ObjectType thisType = jsType; if (jsType instanceof FunctionPrototypeType) { thisType = ((FunctionPrototypeType) jsType).getOwnerFunction().getInstanceType(); } FunctionType callType = null; if (propType instanceof FunctionType) { callType = (FunctionType) propType; } Action action = createExternFunctionCall(fnNode, thisType, callType); return Lists.<Action>newArrayList(action); } return Lists.<Action>newArrayList(); }"
                    ],
                    [
                        0.9671003818511963,
                        "void expectSuperType(NodeTraversal t, Node n, ObjectType superObject, ObjectType subObject) { FunctionType subCtor = subObject.getConstructor(); ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype(); if (!declaredSuper.equals(superObject)) { if (declaredSuper.equals(getNativeType(OBJECT_TYPE))) { if (shouldReport) { compiler.report(t.makeError(n, MISSING_EXTENDS_TAG_WARNING, subObject.toString())); } registerMismatch(superObject, declaredSuper); } else { mismatch(t.getSourceName(), n, \\\"mismatch in declaration of superclass type\\\", superObject, declaredSuper); } if (!subCtor.hasCachedValues()) { subCtor.setPrototypeBasedOn(superObject); } } }"
                    ],
                    [
                        0.9670963883399963,
                        "private void createFunctionsAndCallsites(Node jsRoot, final DefinitionProvider provider) { mainFunction = createFunction(jsRoot); NodeTraversal.traverse(compiler, jsRoot, new AbstractPostOrderCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { int nodeType = n.getType(); if (nodeType == Token.CALL || nodeType == Token.NEW) { Callsite callsite = createCallsite(n); Node containingFunctionNode = t.getScopeRoot(); Function containingFunction = functionsByNode.get(containingFunctionNode); if (containingFunction == null) { containingFunction = createFunction(containingFunctionNode); } callsite.containingFunction = containingFunction; containingFunction.addCallsiteInFunction(callsite); connectCallsiteToTargets(callsite, provider); } else if (NodeUtil.isFunction(n)) { if (!functionsByNode.containsKey(n)) { createFunction(n); } } } }); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: extra warning: Unexpected end of file\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    if (token == JsDocToken.EOF) {\n      // Handle unexpected EOF case\n      reportUnexpectedEOF();\n      return null;\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    } else if (token == JsDocToken.EOF) {\n      // Handle unexpected end of file scenario\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        // Check for the next token as LP (expecting a function type definition)\n        if (next().getType() != JsDocToken.LP) {\n          return reportGenericTypeSyntaxWarning(\"missing opening (\");\n        }\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        if (peek() != JsDocToken.LP) {\n          return reportGenericTypeSyntaxWarning();\n        }\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    reportGenericTypeSyntaxWarning();\n    return null;\n  }\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        if (next() != JsDocToken.LP) {\n          return reportGenericTypeSyntaxWarning();\n        }\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    } else if (token == JsDocToken.RP) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\nprivate Node parseBasicTypeExpression(JsDocToken token) {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.LB) {\n    skipEOLs();\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LC) {\n    skipEOLs();\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LP) {\n    skipEOLs();\n    return parseUnionType(next());\n  } else if (token == JsDocToken.STRING) {\n    String string = stream.getString();\n    if (\"function\".equals(string)) {\n      skipEOLs();\n      if (next() == JsDocToken.LP) {\n        return parseFunctionType(next());\n      } else {\n        return reportGenericTypeSyntaxWarning();\n      }\n    } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n      return newStringNode(string);\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  return reportGenericTypeSyntaxWarning();\n}\n",
                            "\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        JsDocToken nextToken = next();\n        if (nextToken != JsDocToken.LP) {\n          return reportGenericTypeSyntaxWarning();\n        }\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }\n",
                            "\nprivate Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n        skipEOLs();\n        return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n        skipEOLs();\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n        skipEOLs();\n        return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n        String string = stream.getString();\n        if (\"function\".equals(string)) {\n            skipEOLs();\n            if (next() != JsDocToken.LP) {\n                return reportGenericTypeSyntaxWarning();\n            }\n            return parseFunctionType(next());\n        } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n            return newStringNode(string);\n        } else {\n            return parseTypeName(token);\n        }\n    }\n    \n    return reportGenericTypeSyntaxWarning();\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
                "start_loc": 1757,
                "end_loc": 1826,
                "buggy_function": "  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                "fixed_function": "  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                "comment": "  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n",
                "normalized_body": [
                    "private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.lp\\\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \\\"this\\\".equals(tokenStr); boolean isNew = \\\"new\\\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.colon\\\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rp\\\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private Node parseFunctionType(JsDocToken token) { if (token != JsDocToken.LP) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.lp\\\"); } Node functionType = newNode(Token.FUNCTION); Node parameters = null; skipEOLs(); if (!match(JsDocToken.RP)) { token = next(); boolean hasParams = true; if (token == JsDocToken.STRING) { String tokenStr = stream.getString(); boolean isThis = \\\"this\\\".equals(tokenStr); boolean isNew = \\\"new\\\".equals(tokenStr); if (isThis || isNew) { if (match(JsDocToken.COLON)) { next(); skipEOLs(); Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next())); if (contextType == null) { return null; } functionType.addChildToFront(contextType); } else { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.colon\\\"); } if (match(JsDocToken.COMMA)) { next(); skipEOLs(); token = next(); } else { hasParams = false; } } } if (hasParams) { parameters = parseParametersType(token); if (parameters == null) { return null; } } } if (parameters != null) { functionType.addChildToBack(parameters); } skipEOLs(); if (!match(JsDocToken.RP)) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rp\\\"); } skipEOLs(); Node resultType = parseResultType(next()); if (resultType == null) { return null; } else { functionType.addChildToBack(resultType); } return functionType; }"
                    ],
                    [
                        0.9930554628372192,
                        "@SuppressWarnings(\\\"fallthrough\\\") private Node primaryExpr() throws IOException, ParserException { Node pn; int ttFlagged = nextFlaggedToken(); int tt = ttFlagged & CLEAR_TI_MASK; switch(tt) { case Token.FUNCTION: return function(FunctionNode.FUNCTION_EXPRESSION); case Token.LB: { ObjArray elems = new ObjArray(); int skipCount = 0; int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.LB); boolean after_lb_or_comma = true; for (; ; ) { tt = peekToken(); if (tt == Token.COMMA) { consumeToken(); decompiler.addToken(Token.COMMA); if (!after_lb_or_comma) { after_lb_or_comma = true; } else { elems.add(null); ++skipCount; } } else if (tt == Token.RB) { if (after_lb_or_comma && elems.size() > 0) { addWarning(\\\"msg.trailing.comma\\\"); } consumeToken(); decompiler.addToken(Token.RB); break; } else { if (!after_lb_or_comma) { reportError(\\\"msg.no.bracket.arg\\\"); } elems.add(assignExpr(false)); after_lb_or_comma = false; } } return nf.createArrayLiteral(elems, skipCount, lineno, charno); } case Token.LC: { ObjArray elems = new ObjArray(); decompiler.addToken(Token.LC); int lineno = ts.getLineno(); int charno = ts.getCharno(); if (!matchToken(Token.RC)) { boolean first = true; commaloop: do { Node property; if (!first) decompiler.addToken(Token.COMMA); else first = false; tt = peekToken(); switch(tt) { case Token.NAME: case Token.STRING: { consumeToken(); String s = ts.getString(); int linenoName = ts.getLineno(); int charnoName = ts.getCharno(); if (tt == Token.NAME) { if (s.equals(\\\"get\\\") && peekToken() == Token.NAME) { decompiler.addToken(Token.GET); consumeToken(); s = ts.getString(); decompiler.addName(s); if (!getterSetterProperty(elems, s, true, linenoName, charnoName)) { break commaloop; } break; } else if (s.equals(\\\"set\\\") && peekToken() == Token.NAME) { decompiler.addToken(Token.SET); consumeToken(); s = ts.getString(); decompiler.addName(s); if (!getterSetterProperty(elems, s, false, linenoName, charnoName)) { break commaloop; } break; } decompiler.addName(s); property = nf.createString(s, linenoName, charnoName); } else { decompiler.addString(s); property = nf.createString(s, linenoName, charnoName); property.setQuotedString(); } plainProperty(elems, property); break; } case Token.NUMBER: { consumeToken(); double n = ts.getNumber(); int linenoNumber = ts.getLineno(); int charnoNumber = ts.getCharno(); decompiler.addNumber(n); property = nf.createNumber(n, linenoNumber, charnoNumber); plainProperty(elems, property); break; } case Token.COMMA: consumeToken(); case Token.RC: addWarning(\\\"msg.trailing.comma\\\"); break commaloop; default: reportError(\\\"msg.bad.prop\\\"); break commaloop; } } while (matchToken(Token.COMMA)); mustMatchToken(Token.RC, \\\"msg.no.brace.prop\\\"); } decompiler.addToken(Token.RC); return nf.createObjectLiteral(elems, lineno, charno); } case Token.LP: JSDocInfo info = ts.getAndResetJSDocInfo(); decompiler.addToken(Token.LP); pn = expr(false); pn.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); decompiler.addToken(Token.RP); if (info == null) { info = ts.getAndResetJSDocInfo(); } if (info != null && info.hasType()) { pn.setJSDocInfo(info); } mustMatchToken(Token.RP, \\\"msg.no.paren\\\"); return pn; case Token.XMLATTR: mustHaveXML(); decompiler.addToken(Token.XMLATTR); pn = attributeAccess(null, 0); return pn; case Token.NAME: { String name = ts.getString(); int lineno = ts.getLineno(); int charno = ts.getCharno(); if ((ttFlagged & TI_CHECK_LABEL) != 0) { if (peekToken() == Token.COLON) { return nf.createLabel(name, lineno, charno); } } decompiler.addName(name); if (compilerEnv.isXmlAvailable()) { pn = propertyName(null, name, 0, lineno, charno); } else { pn = nf.createName(name, lineno, charno); } return pn; } case Token.NUMBER: { double n = ts.getNumber(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addNumber(n); return nf.createNumber(n, lineno, charno); } case Token.STRING: { String s = ts.getString(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addString(s); return nf.createString(s, lineno, charno); } case Token.DIV: case Token.ASSIGN_DIV: { ts.readRegExp(tt); String flags = ts.regExpFlags; ts.regExpFlags = null; String re = ts.getString(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addRegexp(re, flags); return nf.createRegExp(re, flags, lineno, charno); } case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: { int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(tt); return nf.createLeaf(tt, lineno, charno); } case Token.RESERVED: reportError(\\\"msg.reserved.id\\\"); break; case Token.ERROR: break; case Token.EOF: reportError(\\\"msg.unexpected.eof\\\"); break; default: reportError(\\\"msg.syntax\\\"); break; } return null; }"
                    ],
                    [
                        0.9910833835601807,
                        "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) { runInCompilerThread(new Callable<Void>() { public Void call() throws Exception { if (options.printInputDelimiter) { if ((cb.getLength() > 0) && !cb.endsWith(\\\"\\n\\\")) { cb.append(\\\"\\n\\\"); } Preconditions.checkState(root.getType() == Token.SCRIPT); String delimiter = options.inputDelimiter; String sourceName = (String) root.getProp(Node.SOURCENAME_PROP); Preconditions.checkState(sourceName != null); Preconditions.checkState(!sourceName.isEmpty()); delimiter = delimiter.replaceAll(\\\"%name%\\\", sourceName).replaceAll(\\\"%num%\\\", String.valueOf(inputSeqNum)); cb.append(delimiter).append(\\\"\\n\\\"); } if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) { cb.append(\\\"/*\\n\\\").append(root.getJSDocInfo().getLicense()).append(\\\"*/\\n\\\"); } if (options.sourceMapOutputPath != null) { sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex()); } String code = toSource(root, sourceMap); if (!code.isEmpty()) { cb.append(code); int length = code.length(); char lastChar = code.charAt(length - 1); char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0'; boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';'); if (!hasSemiColon) { cb.append(\\\";\\\"); } } return null; } }); }"
                    ],
                    [
                        0.9909433126449585,
                        "private boolean isEligibleDefinition(SimpleDefinitionFinder defFinder, DefinitionSite definitionSite) { Definition definition = definitionSite.definition; JSModule definitionModule = definitionSite.module; Node rValue = definition.getRValue(); if (rValue == null || !NodeUtil.isFunction(rValue) || NodeUtil.isVarArgsFunction(rValue)) { return false; } Node lValue = definition.getLValue(); if ((lValue == null) || !NodeUtil.isGetProp(lValue)) { return false; } CodingConvention codingConvention = compiler.getCodingConvention(); if (codingConvention.isExported(lValue.getLastChild().getString())) { return false; } Collection<UseSite> useSites = defFinder.getUseSites(definition); if (useSites.isEmpty()) { return false; } JSModuleGraph moduleGraph = compiler.getModuleGraph(); for (UseSite site : useSites) { if (!isCall(site)) { return false; } Node nameNode = site.node; if (specializationState != null && !specializationState.canFixupSpecializedFunctionContainingNode(nameNode)) { return false; } Collection<Definition> singleSiteDefinitions = defFinder.getDefinitionsReferencedAt(nameNode); if (singleSiteDefinitions.size() > 1) { return false; } Preconditions.checkState(!singleSiteDefinitions.isEmpty()); Preconditions.checkState(singleSiteDefinitions.contains(definition)); JSModule callModule = site.module; if ((definitionModule != callModule) && ((callModule == null) || !moduleGraph.dependsOn(callModule, definitionModule))) { return false; } } return true; }"
                    ],
                    [
                        0.9907984733581543,
                        "ConcreteType inferConcreteType(ConcreteScope scope, Node expr) { Preconditions.checkNotNull(scope); Preconditions.checkNotNull(expr); ConcreteType ret; switch(expr.getType()) { case Token.NAME: StaticSlot<ConcreteType> slot = scope.getSlot(expr.getString()); if (slot != null) { ret = slot.getType(); } else { ret = ConcreteType.ALL; } break; case Token.THIS: ret = scope.getTypeOfThis(); break; case Token.ASSIGN: ret = inferConcreteType(scope, expr.getLastChild()); break; case Token.COMMA: ret = inferConcreteType(scope, expr.getLastChild()); break; case Token.AND: ret = inferConcreteType(scope, expr.getLastChild()); break; case Token.OR: ret = inferConcreteType(scope, expr.getFirstChild()).unionWith(inferConcreteType(scope, expr.getLastChild())); break; case Token.HOOK: ret = inferConcreteType(scope, expr.getFirstChild().getNext()).unionWith(inferConcreteType(scope, expr.getLastChild())); break; case Token.GETPROP: ConcreteType recvType = inferConcreteType(scope, expr.getFirstChild()); if (recvType.isAll()) { ret = recvType; break; } Node prop = expr.getLastChild(); String propName = prop.getString(); ConcreteType type = recvType.getPropertyType(propName); if (\\\"prototype\\\".equals(propName)) { for (ConcreteFunctionType funType : recvType.getFunctions()) { type = type.unionWith(funType.getPrototypeType()); } } else if (compiler.getCodingConvention().isSuperClassReference(propName)) { for (ConcreteFunctionType superType : recvType.getSuperclassTypes()) { type = type.unionWith(superType.getPrototypeType()); } } else if (\\\"call\\\".equals(propName)) { type = recvType; } ret = type; break; case Token.GETELEM: ret = ConcreteType.ALL; break; case Token.CALL: ConcreteType targetType = inferConcreteType(scope, expr.getFirstChild()); if (targetType.isAll()) { ret = targetType; break; } ret = ConcreteType.NONE; for (ConcreteFunctionType funType : targetType.getFunctions()) { ret = ret.unionWith(funType.getReturnSlot().getType()); } break; case Token.NEW: ConcreteType constructorType = inferConcreteType(scope, expr.getFirstChild()); if (constructorType.isAll()) { throw new AssertionError(\\\"Attempted new call on all type!\\\"); } ret = ConcreteType.NONE; for (ConcreteInstanceType instType : constructorType.getFunctionInstanceTypes()) { ret = ret.unionWith(instType); } allInstantiatedTypes.add(ret); break; case Token.FUNCTION: ret = createConcreteFunction(expr, scope); break; case Token.OBJECTLIT: if ((expr.getJSType() != null) && !expr.getJSType().isUnknownType()) { JSType exprType = expr.getJSType().restrictByNotNullOrUndefined(); ConcreteType inst = createConcreteInstance(exprType.toObjectType()); allInstantiatedTypes.add(inst); ret = inst; } else { ret = ConcreteType.ALL; } break; case Token.ARRAYLIT: ObjectType arrayType = (ObjectType) getTypeRegistry().getNativeType(JSTypeNative.ARRAY_TYPE); ConcreteInstanceType inst = createConcreteInstance(arrayType); allInstantiatedTypes.add(inst); ret = inst; break; default: ret = ConcreteType.NONE; } return createTypeIntersection(ret, expr.getJSType()); }"
                    ],
                    [
                        0.9906858205795288,
                        "private Node parseParametersType(JsDocToken token) { Node paramsType = newNode(Token.LP); boolean isVarArgs = false; Node paramType = null; if (token != JsDocToken.RP) { do { if (paramType != null) { next(); skipEOLs(); token = next(); } if (token == JsDocToken.ELLIPSIS) { skipEOLs(); if (match(JsDocToken.RP)) { paramType = newNode(Token.ELLIPSIS); } else { skipEOLs(); if (!match(JsDocToken.LB)) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.lb\\\"); } next(); skipEOLs(); paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next())); skipEOLs(); if (!match(JsDocToken.RB)) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\"); } skipEOLs(); next(); } isVarArgs = true; } else { paramType = parseTypeExpression(token); if (match(JsDocToken.EQUALS)) { skipEOLs(); next(); paramType = wrapNode(Token.EQUALS, paramType); } } if (paramType == null) { return null; } paramsType.addChildToBack(paramType); if (isVarArgs) { break; } } while (match(JsDocToken.COMMA)); } if (isVarArgs && match(JsDocToken.COMMA)) { return reportTypeSyntaxWarning(\\\"msg.jsdoc.function.varargs\\\"); } return paramsType; }"
                    ],
                    [
                        0.9906196594238281,
                        "private Node function(int functionType) throws IOException, ParserException { int syntheticType = functionType; int baseLineno = ts.getLineno(); int baseCharno = ts.getCharno(); int functionSourceStart = decompiler.markFunctionStart(functionType); String name; Node memberExprNode = null; int nameLineno, nameCharno; if (matchToken(Token.NAME)) { name = ts.getString(); nameLineno = ts.getLineno(); nameCharno = ts.getCharno(); decompiler.addName(name); if (!matchToken(Token.LP)) { if (compilerEnv.isAllowMemberExprAsFunctionName()) { Node memberExprHead = nf.createName(name, nameLineno, nameCharno); name = \\\"\\\"; memberExprNode = memberExprTail(false, memberExprHead); } mustMatchToken(Token.LP, \\\"msg.no.paren.parms\\\"); } } else { name = \\\"\\\"; nameLineno = ts.getLineno(); nameCharno = ts.getCharno(); if (!matchToken(Token.LP)) { if (compilerEnv.isAllowMemberExprAsFunctionName()) { memberExprNode = memberExpr(false); } mustMatchToken(Token.LP, \\\"msg.no.paren.parms\\\"); } } if (memberExprNode != null) { syntheticType = FunctionNode.FUNCTION_EXPRESSION; } boolean nested = insideFunction(); FunctionNode fnNode = nf.createFunction(name, nameLineno, nameCharno); if (nested || nestingOfWith > 0) { fnNode.itsIgnoreDynamicScope = true; } int functionIndex = currentScriptOrFn.addFunction(fnNode); int functionSourceEnd; ScriptOrFnNode savedScriptOrFn = currentScriptOrFn; currentScriptOrFn = fnNode; int savedNestingOfWith = nestingOfWith; nestingOfWith = 0; Hashtable<String, Node> savedLabelSet = labelSet; labelSet = null; ObjArray savedLoopSet = loopSet; loopSet = null; ObjArray savedLoopAndSwitchSet = loopAndSwitchSet; loopAndSwitchSet = null; boolean savedHasReturnValue = hasReturnValue; int savedFunctionEndFlags = functionEndFlags; Node args; Node body; JSDocInfo info = ts.getAndResetJSDocInfo(); try { decompiler.addToken(Token.LP); args = nf.createLeaf(Token.LP, ts.getLineno(), ts.getCharno()); if (!matchToken(Token.RP)) { boolean first = true; do { if (!first) decompiler.addToken(Token.COMMA); first = false; mustMatchToken(Token.NAME, \\\"msg.no.parm\\\"); String s = ts.getString(); nf.addChildToBack(args, nf.createName(s, ts.getLineno(), ts.getCharno())); decompiler.addName(s); } while (matchToken(Token.COMMA)); mustMatchToken(Token.RP, \\\"msg.no.paren.after.parms\\\"); } decompiler.addToken(Token.RP); mustMatchToken(Token.LC, \\\"msg.no.brace.body\\\"); decompiler.addEOL(Token.LC); body = parseFunctionBody(); mustMatchToken(Token.RC, \\\"msg.no.brace.after.body\\\"); decompiler.addToken(Token.RC); functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) { int tt = peekTokenOrEOL(); if (tt == Token.FUNCTION) { reportError(\\\"msg.no.semi.stmt\\\"); } } decompiler.addToken(Token.EOL); } } finally { hasReturnValue = savedHasReturnValue; functionEndFlags = savedFunctionEndFlags; loopAndSwitchSet = savedLoopAndSwitchSet; loopSet = savedLoopSet; labelSet = savedLabelSet; nestingOfWith = savedNestingOfWith; currentScriptOrFn = savedScriptOrFn; } fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd); fnNode.setSourceName(sourceURI); fnNode.setBaseLineno(baseLineno); fnNode.setEndLineno(ts.getLineno()); Node pn = nf.initFunction(fnNode, functionIndex, args, info, body, syntheticType); if (memberExprNode != null) { pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn, baseLineno, baseCharno); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { pn = nf.createExprStatementNoReturn(pn, baseLineno, baseCharno); } } return pn; }"
                    ],
                    [
                        0.9905459880828857,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (colorings.isEmpty() || !NodeUtil.isName(n) || NodeUtil.isFunction(parent)) { return; } Var var = t.getScope().getVar(n.getString()); GraphNode<Var, ?> vNode = colorings.peek().getGraph().getNode(var); if (vNode == null) { return; } Var coalescedVar = colorings.peek().getPartitionSuperNode(var); if (!usePseudoNames) { if (vNode.getValue().equals(coalescedVar)) { return; } n.setString(coalescedVar.name); compiler.reportCodeChange(); if (NodeUtil.isVar(parent)) { removeVarDeclaration(n); } } else { String pseudoName = null; Set<String> allMergedNames = Sets.newTreeSet(); for (Iterator<Var> i = t.getScope().getVars(); i.hasNext(); ) { Var iVar = i.next(); if (colorings.peek().getGraph().getNode(iVar) != null && coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) { allMergedNames.add(iVar.name); } } if (allMergedNames.size() == 1) { return; } pseudoName = Joiner.on(\\\"_\\\").join(allMergedNames); while (t.getScope().isDeclared(pseudoName, true)) { pseudoName += \\\"$\\\"; } n.setString(pseudoName); compiler.reportCodeChange(); if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) { removeVarDeclaration(n); } } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testIssue477"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: extra warning: Unexpected end of file\n\tat com.google.javascript.jscomp.testing.TestErrorReporter.warning(TestErrorReporter.java:62)  fail(\"extra warning: \" + message);\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParser.parse(JsDocInfoParser.java:887)  parser.addParserWarning(\"msg.unexpected.eof\",              stream.getLineno(), stream.getCharno());\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2690)  jsdocParser.parse();\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2672)  return parse(comment, parseDocumentation, false, warnings);\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2667)  return parse(comment, false, warnings);\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.testIssue477(JsDocInfoParserTest.java:509)  parse(\"@type function */\",        \"Bad type annotation. missing opening (\");  }  public void testMalformedThisAnnotation() throws Exception {    parse(\"@this */\",        \"Bad type annotation. type not recognized due to syntax error\");  }  public void testParseFunctionalTypeError1() throws Exception {    parse(\"@type {function number):string}*/\",        \"Bad type annotation. missing opening (\");  }  public void testParseFunctionalTypeError2() throws Exception {    parse(\"@type {function( number}*/\",        \"Bad type annotation. missing closing )\");  }  public void testParseFunctionalTypeError3() throws Exception {    parse(\"@type {function(...[number], string)}*/\",        \"Bad type annotation. variable length argument must be last\");  }  public void testParseFunctionalTypeError4() throws Exception {    parse(\"@type {function(string, ...[number], boolean):string}*/\",        \"Bad type annotation. variable length argument must be last\");  }  public void testParseFunctionalTypeError5() throws Exception {    parse(\"@type {function (thi:Array)}*/\",        \"Bad type annotation. missing closing )\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    } else {\n      next(); // Move past the ')'\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    skipEOLs(); // Added this line to skip any EOLs before expecting '('\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next(); // Ensure to consume the RP token\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    // Correctly handle the case where the token could be EOF, indicating unexpected end of file\n    if (token != JsDocToken.LP) {\n      if (token == JsDocToken.EOF) {\n        return reportTypeSyntaxWarning(\"msg.unexpected.eof\");\n      } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n      }\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    } else {\n      next(); // Move past the ')' token\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    } else {\n      next(); // Consume the closing ')'\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n/**\n * FunctionType := 'function' FunctionSignatureType\n * FunctionSignatureType :=\n *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n */\n\nprivate Node parseFunctionType(JsDocToken token) {\n  // NOTE(nicksantos): We're not implementing generics at the moment, so\n  // just throw out TypeParameters.\n  if (token != JsDocToken.LP) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  Node functionType = newNode(Token.FUNCTION);\n  Node parameters = null;\n  boolean hasParams = true;\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    token = next();\n    if (token == JsDocToken.STRING) {\n      String tokenStr = stream.getString();\n      boolean isThis = \"this\".equals(tokenStr);\n      boolean isNew = \"new\".equals(tokenStr);\n      if (isThis || isNew) {\n        if (match(JsDocToken.COLON)) {\n          next();\n          skipEOLs();\n          Node contextType = wrapNode(\n              isThis ? Token.THIS : Token.NEW,\n              parseTypeName(next()));\n          if (contextType == null) {\n            return null;\n          }\n\n          functionType.addChildToFront(contextType);\n        } else {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        if (match(JsDocToken.COMMA)) {\n          next();\n          skipEOLs();\n          token = next();\n        } else {\n          hasParams = false;\n        }\n      }\n    }\n\n    if (hasParams) {\n      parameters = parseParametersType(token);\n      if (parameters == null) {\n        return null;\n      }\n    }\n  }\n\n  if (parameters != null) {\n    functionType.addChildToBack(parameters);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next(); // Consume the RP token\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  } else {\n    functionType.addChildToBack(resultType);\n  }\n  return functionType;\n}\n",
                            "\n/**\n * FunctionType := 'function' FunctionSignatureType\n * FunctionSignatureType :=\n *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n */\n\nprivate Node parseFunctionType(JsDocToken token) {\n  // NOTE(nicksantos): We're not implementing generics at the moment, so\n  // just throw out TypeParameters.\n  if (token != JsDocToken.LP) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  Node functionType = newNode(Token.FUNCTION);\n  Node parameters = null;\n  skipEOLs();\n  token = next();\n  if (token != JsDocToken.RP) {\n    boolean hasParams = true;\n    if (token == JsDocToken.STRING) {\n      String tokenStr = stream.getString();\n      boolean isThis = \"this\".equals(tokenStr);\n      boolean isNew = \"new\".equals(tokenStr);\n      if (isThis || isNew) {\n        if (match(JsDocToken.COLON)) {\n          next();\n          skipEOLs();\n          Node contextType = wrapNode(\n              isThis ? Token.THIS : Token.NEW,\n              parseTypeName(next()));\n          if (contextType == null) {\n            return null;\n          }\n\n          functionType.addChildToFront(contextType);\n        } else {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        if (match(JsDocToken.COMMA)) {\n          next();\n          skipEOLs();\n          token = next();\n        } else {\n          hasParams = false;\n        }\n      }\n    }\n\n    if (hasParams) {\n      parameters = parseParametersType(token);\n      if (parameters == null) {\n        return null;\n      }\n    }\n  }\n\n  if (parameters != null) {\n    functionType.addChildToBack(parameters);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();  // Consume the closing RP token\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  } else {\n    functionType.addChildToBack(resultType);\n  }\n  return functionType;\n}\n",
                            "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n      return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n            return null;\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      return null;\n    }\n    next(); // Consume the closing RP\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next(); // Advance token to avoid getting stuck\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    token = next(); // Move to next token after LP\n    if (!match(JsDocToken.RP)) {\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next(); // Consume the RP token\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n",
                            "\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    token = next(); // Ensure the next token is fetched\n    if (!match(JsDocToken.RP)) {\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseTypeName(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next(); // Consume the closing parenthesis\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testIssue477": {
                "path": "test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java",
                "function_name": "testIssue477",
                "src": "  public void testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: extra warning: Unexpected end of file\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat com.google.javascript.jscomp.testing.TestErrorReporter.warning(TestErrorReporter.java:62)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser.addParserWarning(JsDocInfoParser.java:65)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParser.parse(JsDocInfoParser.java:887)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2690)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2672)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2667)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.testIssue477(JsDocInfoParserTest.java:509)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: extra warning: Unexpected end of file\n\tat com.google.javascript.jscomp.testing.TestErrorReporter.warning(TestErrorReporter.java:62)  fail(\"extra warning: \" + message);\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParser.parse(JsDocInfoParser.java:887)  parser.addParserWarning(\"msg.unexpected.eof\",              stream.getLineno(), stream.getCharno());\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2690)  jsdocParser.parse();\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2672)  return parse(comment, parseDocumentation, false, warnings);\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2667)  return parse(comment, false, warnings);\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.testIssue477(JsDocInfoParserTest.java:509)  parse(\"@type function */\",        \"Bad type annotation. missing opening (\");  }  public void testMalformedThisAnnotation() throws Exception {    parse(\"@this */\",        \"Bad type annotation. type not recognized due to syntax error\");  }  public void testParseFunctionalTypeError1() throws Exception {    parse(\"@type {function number):string}*/\",        \"Bad type annotation. missing opening (\");  }  public void testParseFunctionalTypeError2() throws Exception {    parse(\"@type {function( number}*/\",        \"Bad type annotation. missing closing )\");  }  public void testParseFunctionalTypeError3() throws Exception {    parse(\"@type {function(...[number], string)}*/\",        \"Bad type annotation. variable length argument must be last\");  }  public void testParseFunctionalTypeError4() throws Exception {    parse(\"@type {function(string, ...[number], boolean):string}*/\",        \"Bad type annotation. variable length argument must be last\");  }  public void testParseFunctionalTypeError5() throws Exception {    parse(\"@type {function (thi:Array)}*/\",        \"Bad type annotation. missing closing )\");"
            }
        },
        "evaluation_done": true
    }
}