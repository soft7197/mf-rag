{
    "Closure-142": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/CoalesceVariableNames.java",
                "start_loc": 90,
                "end_loc": 120,
                "buggy_function": "  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n      return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }\n",
                "fixed_function": "  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n      return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n      liveness.markAllParametersEscaped();\n    }\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals()); GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker); coloring.color(); colorings.push(coloring); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public void enterScope(NodeTraversal t) { Scope scope = t.getScope(); if (scope.isGlobal()) { return; } ControlFlowGraph<Node> cfg = t.getControlFlowGraph(); LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler); liveness.analyze(); UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals()); GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker); coloring.color(); colorings.push(coloring); }"
                    ],
                    [
                        0.9783997535705566,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (parent == null || parent.getType() != Token.SCRIPT) { return; } if (NodeUtil.isFunctionDeclaration(n)) { parent.removeChild(n); compiler.reportCodeChange(); JSModule module = t.getModule(); List<Node> moduleFunctions = functions.get(module); if (moduleFunctions == null) { moduleFunctions = Lists.newArrayList(); functions.put(module, moduleFunctions); } moduleFunctions.add(n); } }"
                    ],
                    [
                        0.976717472076416,
                        "public void testConstructorWithArgSubtypeChain() throws Exception { FunctionType googBarArgConstructor = registry.createConstructorType(\\\"barArg\\\", null, registry.createParameters(googBar), null); FunctionType googSubBarArgConstructor = registry.createConstructorType(\\\"subBarArg\\\", null, registry.createParameters(googSubBar), null); List<JSType> typeChain = Lists.newArrayList(registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), googBarArgConstructor, googSubBarArgConstructor, registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE)); verifySubtypeChain(typeChain, false); }"
                    ],
                    [
                        0.9753974676132202,
                        "public void process(Node externs, Node root) { externMethods.clear(); externMethodsWithoutSignatures.clear(); getSignatureStore().reset(); methodDefinitions.clear(); if (externs != null) { NodeTraversal.traverse(compiler, externs, new GetExternMethods()); } List<Node> externsAndJs = Lists.newArrayList(externs, root); NodeTraversal.traverseRoots(compiler, Lists.newArrayList(externs, root), new GatherSignatures()); NodeTraversal.traverseRoots(compiler, externsAndJs, getActingCallback()); }"
                    ],
                    [
                        0.973129153251648,
                        "@Override protected CompilerPass getProcessor(final Compiler compiler) { return new CompilerPass() { public void process(Node externs, Node js) { new CreateSyntheticBlocks(compiler, START_MARKER, END_MARKER).process(externs, js); NodeTraversal.traverse(compiler, js, new FoldConstants(compiler)); NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler)); NodeTraversal.traverse(compiler, js, new FoldConstants(compiler)); new Denormalize(compiler).process(externs, js); } }; }"
                    ],
                    [
                        0.9730225801467896,
                        "public void testPartialTraversalOfScope() { Compiler compiler = new Compiler(); ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true); Node script1 = compiler.parseSyntheticCode(\\\"cfgtest\\\", \\\"var foo;\\\"); Node script2 = compiler.parseSyntheticCode(\\\"cfgtest2\\\", \\\"var bar;\\\"); Node root = new Node(Token.BLOCK, script1, script2); cfa.process(null, script1); ControlFlowGraph<Node> cfg = cfa.getCfg(); assertNotNull(cfg.getNode(script1)); assertNull(cfg.getNode(script2)); }"
                    ],
                    [
                        0.9728096723556519,
                        "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); Scope.Var var = t.getScope().getVar(name); if (var != null && var.isLocal()) { return; } Property global = globals.get(name); if (global != null) { if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.getType() == Token.INC || parent.getType() == Token.DEC || parent.getType() == Token.NEW) { global.recordMutator(t); } else { global.recordAccessor(t); } globalUses.add(n); } } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.CoalesceVariableNamesTest::testParameter4"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n      return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testParameter4() {\n    // Make sure that we do not merge two-arg functions because of the\n    // IE sort bug (see comments in computeEscaped)\n    test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",\n         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function FUNC(x,y){var a;y;a=0;a;x;a=0;a}\nResult: function FUNC(x,y){y;y=0;y;x;x=0;x}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION FUNC 1 [sourcename: expected0]\n            NAME FUNC 1 [is_constant_name: 1]\n            LP 1\n                NAME x 1\n                NAME y 1\n            BLOCK 1\n                VAR 1\n                    NAME a 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME a 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME a 1\n                EXPR_RESULT 1\n                    NAME x 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME a 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME a 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION FUNC 1 [sourcename: testcode]\n            NAME FUNC 1 [is_constant_name: 1]\n            LP 1\n                NAME x 1\n                NAME y 1\n            BLOCK 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME y 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    NAME x 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME x 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME x 1\n\n\nSubtree1: BLOCK 1\n    VAR 1\n        NAME a 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME a 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME a 1\n    EXPR_RESULT 1\n        NAME x 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME a 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME a 1\n\n\nSubtree2: BLOCK 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME y 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        NAME x 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME x 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME x 1\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CoalesceVariableNamesTest.testParameter4(CoalesceVariableNamesTest.java:191)  test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    // Ensure that parameters of two-argument functions are marked as escaped due to IE bug.\n    List<Var> escapedLocals = liveness.getEscapedLocals();\n    List<Var> params = scope.getParams();\n    if (params.size() == 2) {\n        escapedLocals.add(params.get(0)); // Mark first parameter as escaped\n        escapedLocals.add(params.get(1)); // Mark second parameter as escaped\n    }\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, escapedLocals);\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n  Scope scope = t.getScope();\n  if (scope.isGlobal()) {\n    return;\n  }\n  ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n  LiveVariablesAnalysis liveness =\n      new LiveVariablesAnalysis(cfg, scope, compiler);\n  \n  liveness.analyze();\n\n  UndiGraph<Var, Void> interferenceGraph =\n      computeVariableNamesInterferenceGraph(\n          t, cfg, liveness.getEscapedLocals());\n\n  GraphColoring<Var, Void> coloring =\n      new GreedyGraphColoring<Var, Void>(interferenceGraph,\n          coloringTieBreaker);\n\n  // Fix: If the function has exactly 2 params, mark both parameters as being used/lived to avoid merging\n  if (scope.getVarCount() == 2) {\n    for (Var var : scope.getVars()) {\n      coloring.setColor(var, GraphColoring.UNCOLORED_COLOR);\n    }\n  }\n\n  coloring.color();\n  colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n            new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    Set<Var> escaped = liveness.getEscapedLocals();\n\n    // Fix: Ensure that parameters in functions with exactly 2 parameters are marked as escaped\n    if (scope.getRootNode().isFunction() && scope.getRootNode().getChildCount() == 3) {\n        Node functionParams = scope.getRootNode().getSecondChild();\n        if (functionParams.getChildCount() == 2) {\n            for (Node param : functionParams.children()) {\n                Var paramVar = scope.getVar(param.getString());\n                if (paramVar != null) {\n                    escaped.add(paramVar);\n                }\n            }\n        }\n    }\n\n    UndiGraph<Var, Void> interferenceGraph =\n            computeVariableNamesInterferenceGraph(\n                    t, cfg, escaped);\n\n    GraphColoring<Var, Void> coloring =\n            new GreedyGraphColoring<Var, Void>(interferenceGraph,\n                    coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    // Handle the special case for functions with exactly two parameters to work around the IE sort bug.\n    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n        liveness.markAllParametersEscaped();\n    }\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    // Fix: Add a condition to skip functions with exactly 2 parameters.\n    if (scope.getRootNode() != null \n            && NodeUtil.getFunctionParameters(scope.getRootNode()).getChildCount() == 2) {\n        return;\n    }\n    \n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n  Scope scope = t.getScope();\n  if (scope.isGlobal()) {\n    return;\n  }\n  ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n  LiveVariablesAnalysis liveness =\n      new LiveVariablesAnalysis(cfg, scope, compiler);\n  liveness.analyze();\n\n  Set<Var> escapedVariables = new HashSet<>(liveness.getEscapedLocals());\n\n  // Ensure functions with exactly two parameters have escaped parameters\n  if (scope.getRootNode().isFunction()) {\n    Node functionNode = scope.getRootNode();\n    Node params = functionNode.getSecondChild();\n    if (params.getChildCount() == 2) {\n      Node param = params.getFirstChild();\n      while (param != null) {\n        Var var = scope.getVar(param.getString());\n        if (var != null) {\n          escapedVariables.add(var);\n        }\n        param = param.getNext();\n      }\n    }\n  }\n\n  UndiGraph<Var, Void> interferenceGraph =\n      computeVariableNamesInterferenceGraph(t, cfg, escapedVariables);\n\n  GraphColoring<Var, Void> coloring =\n      new GreedyGraphColoring<>(interferenceGraph, coloringTieBreaker);\n\n  coloring.color();\n  colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    \n    // Perform live variables analysis\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    // If the function has exactly 2 params, mark them as escaped\n    if (scope.getRootNode().getSecondChild().getChildCount() == 2) {\n        for (Var param : scope.getVarIterable()) {\n            if (param.getNode().getParent().isParamList()) {\n                liveness.markEscaped(param);\n            }\n        }\n    }\n    \n    coloring.color();\n    colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    if (scope.getVarCount() == 2 && scope.getRootNode().isFunction()) {\n        colorings.push(null); // Avoid merging for functions with exactly 2 parameters\n        return;\n    }\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n  Scope scope = t.getScope();\n  if (scope.isGlobal()) {\n    return;\n  }\n  ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n  LiveVariablesAnalysis liveness =\n      new LiveVariablesAnalysis(cfg, scope, compiler);\n  liveness.analyze();\n\n  Set<Var> escapedLocals = liveness.getEscapedLocals();\n\n  // Add parameters to escapedLocals if there are exactly 2 parameters\n  if (scope.getRootNode().getChildAtIndex(1).getChildCount() == 2) {\n    for (Var param : scope.getVarIterable()) {\n        if (param.isParam()) {\n            escapedLocals.add(param);\n        }\n    }\n  }\n\n  UndiGraph<Var, Void> interferenceGraph =\n      computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n\n  GraphColoring<Var, Void> coloring =\n      new GreedyGraphColoring<>(interferenceGraph, coloringTieBreaker);\n\n  coloring.color();\n  colorings.push(coloring);\n}\n",
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n  Scope scope = t.getScope();\n  if (scope.isGlobal()) {\n    return;\n  }\n  ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n  LiveVariablesAnalysis liveness =\n      new LiveVariablesAnalysis(cfg, scope, compiler);\n  liveness.analyze();\n\n  boolean hasTwoParams = scope.getRootNode().getFirstChild().getChildCount() == 2;\n  Set<Var> escapedLocals = liveness.getEscapedLocals();\n\n  if (hasTwoParams) {\n    for (Var var : scope.getVarIterable()) {\n      if (var.isParam()) {\n        escapedLocals.add(var);\n      }\n    }\n  }\n\n  UndiGraph<Var, Void> interferenceGraph =\n      computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n\n  GraphColoring<Var, Void> coloring =\n      new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n\n  coloring.color();\n  colorings.push(coloring);\n}\n"
                        ],
                        "plausible_patches": [
                            "\n@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    // Handle the special case for functions with exactly two parameters to work around the IE sort bug.\n    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n        liveness.markAllParametersEscaped();\n    }\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java",
                "start_loc": 1112,
                "end_loc": 1206,
                "buggy_function": "  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                "fixed_function": "  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n          if (!(option == WhitespaceOption.PRESERVE &&\n                token == JsDocToken.ANNOTATION)) {\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n          }\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                "comment": "  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n",
                "normalized_body": [
                    "@SuppressWarnings(\\\"fallthrough\\\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\\\"\\\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch(token) { case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\\\"\\n\\\"); } ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); } } while (true); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@SuppressWarnings(\\\"fallthrough\\\") private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) { if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) { return new ExtractionInfo(\\\"\\\", token); } stream.update(); int startLineno = stream.getLineno(); int startCharno = stream.getCharno() + 1; String line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = line.trim(); } StringBuilder builder = new StringBuilder(); builder.append(line); state = State.SEARCHING_ANNOTATION; token = next(); boolean ignoreStar = false; do { switch(token) { case STAR: if (!ignoreStar) { if (builder.length() > 0) { builder.append(' '); } builder.append('*'); } token = next(); continue; case EOL: if (option != WhitespaceOption.SINGLE_LINE) { builder.append(\\\"\\n\\\"); } ignoreStar = true; token = next(); continue; case ANNOTATION: case EOC: case EOF: String multilineText = builder.toString(); if (option != WhitespaceOption.PRESERVE) { multilineText = multilineText.trim(); } int endLineno = stream.getLineno(); int endCharno = stream.getCharno(); if (multilineText.length() > 0) { jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno); } return new ExtractionInfo(multilineText, token); default: ignoreStar = false; state = State.SEARCHING_ANNOTATION; if (builder.length() > 0) { builder.append(' '); } builder.append(toString(token)); line = stream.getRemainingJSDocLine(); if (option != WhitespaceOption.PRESERVE) { line = trimEnd(line); } builder.append(line); token = next(); } } while (true); }"
                    ],
                    [
                        0.9952645897865295,
                        "private Node statementHelper(Node statementLabel) throws IOException, ParserException { Node pn = null; int tt; tt = peekToken(); switch(tt) { case Token.IF: { consumeToken(); decompiler.addToken(Token.IF); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node cond = condition(); decompiler.addEOL(Token.LC); Node ifTrue = statement(); Node ifFalse = null; if (matchToken(Token.ELSE)) { decompiler.addToken(Token.RC); decompiler.addToken(Token.ELSE); decompiler.addEOL(Token.LC); ifFalse = statement(); } decompiler.addEOL(Token.RC); pn = nf.createIf(cond, ifTrue, ifFalse, lineno, charno); return pn; } case Token.SWITCH: { consumeToken(); decompiler.addToken(Token.SWITCH); int lineno = ts.getLineno(); int charno = ts.getCharno(); mustMatchToken(Token.LP, \\\"msg.no.paren.switch\\\"); decompiler.addToken(Token.LP); pn = enterSwitch(expr(false), lineno, charno); try { mustMatchToken(Token.RP, \\\"msg.no.paren.after.switch\\\"); decompiler.addToken(Token.RP); mustMatchToken(Token.LC, \\\"msg.no.brace.switch\\\"); decompiler.addEOL(Token.LC); boolean hasDefault = false; switchLoop: for (; ; ) { tt = nextToken(); lineno = ts.getLineno(); charno = ts.getCharno(); Node caseExpression; switch(tt) { case Token.RC: break switchLoop; case Token.CASE: decompiler.addToken(Token.CASE); caseExpression = expr(false); mustMatchToken(Token.COLON, \\\"msg.no.colon.case\\\"); decompiler.addEOL(Token.COLON); break; case Token.DEFAULT: if (hasDefault) { reportError(\\\"msg.double.switch.default\\\"); } decompiler.addToken(Token.DEFAULT); hasDefault = true; caseExpression = null; mustMatchToken(Token.COLON, \\\"msg.no.colon.case\\\"); decompiler.addEOL(Token.COLON); break; default: reportError(\\\"msg.bad.switch\\\"); break switchLoop; } Node block = nf.createLeaf(Token.BLOCK, lineno, charno); block.setIsSyntheticBlock(true); while ((tt = peekToken()) != Token.RC && tt != Token.CASE && tt != Token.DEFAULT && tt != Token.EOF) { nf.addChildToBack(block, statement()); } nf.addSwitchCase(pn, caseExpression, block, lineno, charno); } decompiler.addEOL(Token.RC); nf.closeSwitch(pn); } finally { exitSwitch(); } return pn; } case Token.WHILE: { consumeToken(); decompiler.addToken(Token.WHILE); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node cond = condition(); decompiler.addEOL(Token.LC); Node body = statement(); decompiler.addEOL(Token.RC); pn = nf.createWhile(cond, body, lineno, charno); return pn; } case Token.DO: { consumeToken(); decompiler.addToken(Token.DO); decompiler.addEOL(Token.LC); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node body = statement(); decompiler.addToken(Token.RC); mustMatchToken(Token.WHILE, \\\"msg.no.while.do\\\"); decompiler.addToken(Token.WHILE); Node cond = condition(); pn = nf.createDoWhile(body, cond, lineno, charno); matchToken(Token.SEMI); decompiler.addEOL(Token.SEMI); return pn; } case Token.FOR: { consumeToken(); boolean isForEach = false; decompiler.addToken(Token.FOR); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node init; Node cond; Node incr = null; Node body; if (matchToken(Token.NAME)) { decompiler.addName(ts.getString()); if (ts.getString().equals(\\\"each\\\")) { isForEach = true; } else { reportError(\\\"msg.no.paren.for\\\"); } } mustMatchToken(Token.LP, \\\"msg.no.paren.for\\\"); decompiler.addToken(Token.LP); tt = peekToken(); if (tt == Token.SEMI) { init = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); } else { if (tt == Token.VAR) { consumeToken(); init = variables(Token.FOR); } else { init = expr(true); } } if (matchToken(Token.IN)) { decompiler.addToken(Token.IN); cond = expr(false); } else { mustMatchToken(Token.SEMI, \\\"msg.no.semi.for\\\"); decompiler.addToken(Token.SEMI); if (peekToken() == Token.SEMI) { cond = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); } else { cond = expr(false); } mustMatchToken(Token.SEMI, \\\"msg.no.semi.for.cond\\\"); decompiler.addToken(Token.SEMI); if (peekToken() == Token.RP) { incr = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); } else { incr = expr(false); } } mustMatchToken(Token.RP, \\\"msg.no.paren.for.ctrl\\\"); decompiler.addToken(Token.RP); decompiler.addEOL(Token.LC); body = statement(); decompiler.addEOL(Token.RC); if (incr == null) { pn = nf.createForIn(init, cond, body, lineno, charno); } else { pn = nf.createFor(init, cond, incr, body, lineno, charno); } return pn; } case Token.TRY: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node tryblock; Node catchblocks = null; Node finallyblock = null; JSDocInfo info = ts.getAndResetJSDocInfo(); decompiler.addToken(Token.TRY); decompiler.addEOL(Token.LC); tryblock = statement(); decompiler.addEOL(Token.RC); catchblocks = nf.createLeaf(Token.BLOCK, ts.getLineno(), ts.getCharno()); boolean sawDefaultCatch = false; int peek = peekToken(); if (peek == Token.CATCH) { while (matchToken(Token.CATCH)) { int catchLineno = ts.getLineno(); int catchCharno = ts.getCharno(); if (sawDefaultCatch) { reportError(\\\"msg.catch.unreachable\\\"); } decompiler.addToken(Token.CATCH); mustMatchToken(Token.LP, \\\"msg.no.paren.catch\\\"); decompiler.addToken(Token.LP); mustMatchToken(Token.NAME, \\\"msg.bad.catchcond\\\"); String varName = ts.getString(); int nameLineno = ts.getLineno(); int nameCharno = ts.getCharno(); decompiler.addName(varName); Node catchCond = null; if (matchToken(Token.IF)) { decompiler.addToken(Token.IF); catchCond = expr(false); } else { sawDefaultCatch = true; } mustMatchToken(Token.RP, \\\"msg.bad.catchcond\\\"); decompiler.addToken(Token.RP); mustMatchToken(Token.LC, \\\"msg.no.brace.catchblock\\\"); decompiler.addEOL(Token.LC); nf.addChildToBack(catchblocks, nf.createCatch(varName, nameLineno, nameCharno, catchCond, statements(), catchLineno, catchCharno)); mustMatchToken(Token.RC, \\\"msg.no.brace.after.body\\\"); decompiler.addEOL(Token.RC); } } else if (peek != Token.FINALLY) { mustMatchToken(Token.FINALLY, \\\"msg.try.no.catchfinally\\\"); } if (matchToken(Token.FINALLY)) { decompiler.addToken(Token.FINALLY); decompiler.addEOL(Token.LC); finallyblock = statement(); decompiler.addEOL(Token.RC); } pn = nf.createTryCatchFinally(tryblock, catchblocks, finallyblock, lineno, charno); if (info != null) { pn.setJSDocInfo(info); } return pn; } case Token.THROW: { consumeToken(); if (peekTokenOrEOL() == Token.EOL) { reportError(\\\"msg.bad.throw.eol\\\"); } int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.THROW); pn = nf.createThrow(expr(false), lineno, charno); break; } case Token.BREAK: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.BREAK); String label = matchLabel(); if (label != null) { decompiler.addToken(Token.NAME); decompiler.addName(label); } pn = nf.createBreak(label, lineno, charno); break; } case Token.CONTINUE: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.CONTINUE); String label = matchLabel(); if (label != null) { decompiler.addToken(Token.NAME); decompiler.addName(label); } pn = nf.createContinue(label, lineno, charno); break; } case Token.DEBUGGER: { consumeToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); decompiler.addToken(Token.DEBUGGER); pn = nf.createDebugger(lineno, charno); break; } case Token.WITH: { consumeToken(); decompiler.addToken(Token.WITH); int lineno = ts.getLineno(); int charno = ts.getCharno(); mustMatchToken(Token.LP, \\\"msg.no.paren.with\\\"); decompiler.addToken(Token.LP); Node obj = expr(false); mustMatchToken(Token.RP, \\\"msg.no.paren.after.with\\\"); decompiler.addToken(Token.RP); decompiler.addEOL(Token.LC); ++nestingOfWith; Node body; try { body = statement(); } finally { --nestingOfWith; } decompiler.addEOL(Token.RC); pn = nf.createWith(obj, body, lineno, charno); return pn; } case Token.CONST: case Token.VAR: { consumeToken(); pn = variables(tt); break; } case Token.RETURN: { if (!insideFunction()) { reportError(\\\"msg.bad.return\\\"); } consumeToken(); decompiler.addToken(Token.RETURN); int lineno = ts.getLineno(); int charno = ts.getCharno(); Node retExpr; tt = peekTokenOrEOL(); switch(tt) { case Token.SEMI: case Token.RC: case Token.EOF: case Token.EOL: case Token.ERROR: retExpr = null; break; default: retExpr = expr(false); hasReturnValue = true; } pn = nf.createReturn(retExpr, lineno, charno); break; } case Token.LC: consumeToken(); if (statementLabel != null) { decompiler.addToken(Token.LC); } pn = statements(); mustMatchToken(Token.RC, \\\"msg.no.brace.block\\\"); if (statementLabel != null) { decompiler.addEOL(Token.RC); } return pn; case Token.ERROR: case Token.SEMI: consumeToken(); pn = nf.createLeaf(Token.EMPTY, ts.getLineno(), ts.getCharno()); return pn; case Token.FUNCTION: { consumeToken(); pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT); return pn; } case Token.DEFAULT: { consumeToken(); mustHaveXML(); decompiler.addToken(Token.DEFAULT); int lineno = ts.getLineno(); int charno = ts.getCharno(); if (!(matchToken(Token.NAME) && ts.getString().equals(\\\"xml\\\"))) { reportError(\\\"msg.bad.namespace\\\"); } decompiler.addName(\\\" xml\\\"); if (!(matchToken(Token.NAME) && ts.getString().equals(\\\"namespace\\\"))) { reportError(\\\"msg.bad.namespace\\\"); } decompiler.addName(\\\" namespace\\\"); if (!matchToken(Token.ASSIGN)) { reportError(\\\"msg.bad.namespace\\\"); } decompiler.addToken(Token.ASSIGN); Node expr = expr(false); pn = nf.createDefaultNamespace(expr, lineno, charno); break; } case Token.NAME: { int lineno = ts.getLineno(); int charno = ts.getCharno(); String name = ts.getString(); setCheckForLabel(); pn = expr(false); if (pn.getType() != Token.LABEL) { pn = nf.createExprStatement(pn, lineno, charno); } else { if (peekToken() != Token.COLON) Kit.codeBug(); consumeToken(); decompiler.addName(name); decompiler.addEOL(Token.COLON); if (labelSet == null) { labelSet = new Hashtable<String, Node>(); } else if (labelSet.containsKey(name)) { reportError(\\\"msg.dup.label\\\"); } labelSet.put(name, pn); pn = nf.createLabel(name, lineno, charno); try { nf.addChildToBack(pn, statementHelper(pn)); } finally { labelSet.remove(name); } return pn; } break; } default: { int lineno = ts.getLineno(); int charno = ts.getCharno(); pn = expr(false); pn = nf.createExprStatement(pn, lineno, charno); break; } } int ttFlagged = peekFlaggedToken(); switch(ttFlagged & CLEAR_TI_MASK) { case Token.SEMI: consumeToken(); break; case Token.ERROR: case Token.EOF: case Token.RC: break; default: if ((ttFlagged & TI_AFTER_EOL) == 0) { reportError(\\\"msg.no.semi.stmt\\\"); } break; } decompiler.addEOL(Token.SEMI); return pn; }"
                    ],
                    [
                        0.9945316314697266,
                        "private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) { String name = \\\"\\\"; Node rootNameNode = n; boolean bNameWasShortened = false; while (NodeUtil.isGet(rootNameNode)) { Node prop = rootNameNode.getLastChild(); if (rootNameNode.getType() == Token.GETPROP) { name = \\\".\\\" + prop.getString() + name; } else { bNameWasShortened = true; name = \\\"\\\"; } rootNameNode = rootNameNode.getFirstChild(); } if (NodeUtil.isCall(parent) && t.inGlobalScope()) { SubclassRelationship classes = compiler.getCodingConvention().getClassesDefinedByCall(parent); if (classes != null) { NameInformation nameInfo = new NameInformation(); nameInfo.name = classes.subclassName; nameInfo.onlyAffectsClassDef = true; nameInfo.superclass = classes.superclassName; return nameInfo; } } switch(rootNameNode.getType()) { case Token.NAME: if (!bNameWasShortened && n.getType() == Token.GETPROP && parent.getType() == Token.ASSIGN && \\\"prototype\\\".equals(n.getLastChild().getString())) { if (createNameInformation(t, n.getFirstChild(), n) != null) { name = rootNameNode.getString() + name; name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN); NameInformation nameInfo = new NameInformation(); nameInfo.name = name; return nameInfo; } else { return null; } } return createNameInformation(rootNameNode.getString() + name, t.getScope(), rootNameNode); case Token.THIS: if (t.inGlobalScope()) { NameInformation nameInfo = new NameInformation(); if (name.indexOf('.') == 0) { nameInfo.name = name.substring(1); } else { nameInfo.name = name; } nameInfo.isExternallyReferenceable = true; return nameInfo; } return null; default: return null; } }"
                    ],
                    [
                        0.9936928153038025,
                        "public void visit(NodeTraversal t, Node n, Node parent) { JSDocInfo docInfo; switch(n.getType()) { case Token.NAME: if (parent == null) { return; } if (parent.getType() != Token.VAR && !NodeUtil.isFunctionDeclaration(parent) && !(parent.getType() == Token.ASSIGN && n == parent.getFirstChild())) { return; } docInfo = n.getJSDocInfo(); if (docInfo == null && !(parent.getType() == Token.VAR && !parent.hasOneChild())) { docInfo = parent.getJSDocInfo(); } JSType varType = n.getJSType(); if (varType == null && parent.getType() == Token.FUNCTION) { varType = parent.getJSType(); } if (varType == null || docInfo == null) { return; } ObjectType objType = dereferenceToObject(varType); if (objType == null || objType.getJSDocInfo() != null) { return; } attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString()); break; case Token.GETPROP: if (NodeUtil.isExpressionNode(parent) || (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n)) { docInfo = n.getJSDocInfo(); if (docInfo == null) { docInfo = parent.getJSDocInfo(); } if (docInfo != null) { ObjectType lhsType = dereferenceToObject(n.getFirstChild().getJSType()); if (lhsType != null) { String propName = n.getLastChild().getString(); if (lhsType.hasOwnProperty(propName)) { lhsType.setPropertyJSDocInfo(propName, docInfo, inExterns); } ObjectType propType = dereferenceToObject(lhsType.getPropertyType(propName)); if (propType != null) { attachJSDocInfoToNominalTypeOrShape(propType, docInfo, n.getQualifiedName()); } } } } break; } }"
                    ],
                    [
                        0.9934049844741821,
                        "void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState(childCount == 2); int p = NodeUtil.precedence(type); addLeftExpr(first, p, context); cc.addOp(opstr, true); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(last, p, rhsContext); } else { addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch(type) { case Token.TRY: { Preconditions.checkState(first.getNext().getType() == Token.BLOCK && first.getNext().getChildCount() <= 1); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\\\"try\\\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\\\"finally\\\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 3); if (first.getNext().getType() != Token.EMPTY) { throw new Error(\\\"Catch conditions not suppored because I think\\\" + \\\" that it may be a netscape only feature.\\\"); } add(\\\"catch(\\\"); add(first); add(\\\")\\\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\\\"throw\\\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\\\"return\\\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\\\"var \\\"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.getType() == Token.EMPTY) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\\\"=\\\", true); if (first.getType() == Token.COMMA) { addExpr(first, NodeUtil.precedence(Token.ASSIGN)); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\\\"[\\\"); addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP)); add(\\\"]\\\"); break; case Token.LP: add(\\\"(\\\"); addList(first); add(\\\")\\\"); break; case Token.COMMA: addList(first, false, context); break; case Token.NUMBER: Preconditions.checkState(childCount == 0); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: case Token.NEG: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type)); break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addLeftExpr(first, p + 1, context); cc.addOp(\\\"?\\\", true); addExpr(first.getNext(), p); cc.addOp(\\\":\\\", true); addExpr(last, p); break; } case Token.REGEXP: if (first.getType() != Token.STRING || last.getType() != Token.STRING) { throw new Error(\\\"Expected children to be strings\\\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.GET_REF: add(first); break; case Token.REF_SPECIAL: Preconditions.checkState(childCount == 1); add(first); add(\\\".\\\"); add((String) n.getProp(Node.NAME_PROP)); break; case Token.FUNCTION: Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\\\"(\\\"); } add(\\\"function\\\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\\\")\\\"); } break; case Token.SCRIPT: case Token.BLOCK: { boolean stripBlock = n.isSyntheticBlock() || ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2)); if (!stripBlock) { cc.beginBlock(); } for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.getType() == Token.VAR) { cc.endStatement(); } if (c.getType() == Token.FUNCTION) { cc.maybeLineBreak(); } if (type == Token.SCRIPT) { cc.notePreferredLineBreak(); } } if (!stripBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\\\"for(\\\"); if (first.getType() == Token.VAR) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\\\";\\\"); add(first.getNext()); add(\\\";\\\"); add(first.getNext().getNext()); add(\\\")\\\"); addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\\\"for(\\\"); add(first); add(\\\"in\\\"); add(first.getNext()); add(\\\")\\\"); addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\\\"do\\\"); addNonEmptyExpression(first, Context.OTHER, false); add(\\\"while(\\\"); add(last); add(\\\")\\\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\\\"while(\\\"); add(first); add(\\\")\\\"); addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState(childCount == 2); Preconditions.checkState(last.getType() == Token.STRING); boolean needsParens = (first.getType() == Token.NUMBER); if (needsParens) { add(\\\"(\\\"); } addLeftExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\\\")\\\"); } add(\\\".\\\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState(childCount == 2); addLeftExpr(first, NodeUtil.precedence(type), context); add(\\\"[\\\"); add(first.getNext()); add(\\\"]\\\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\\\"with(\\\"); add(first); add(\\\")\\\"); addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\"; int postProp = n.getIntProp(Node.INCRDECR_PROP, 0); if (postProp != 0) { addLeftExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (first.getType() == Token.NAME && \\\"eval\\\".equals(first.getString()) && !first.getBooleanProp(Node.DIRECT_EVAL)) { add(\\\"(0,eval)\\\"); } else { addLeftExpr(first, NodeUtil.precedence(type), context); } add(\\\"(\\\"); addList(first.getNext()); add(\\\")\\\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\\\"if(\\\"); add(first); add(\\\")\\\"); if (hasElse) { addNonEmptyExpression(first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\\\"else\\\"); addNonEmptyExpression(last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyExpression(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: case Token.THIS: case Token.FALSE: case Token.TRUE: Preconditions.checkState(childCount == 0); add(Node.tokenToName(type)); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\\\"continue\\\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME && validation) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\\\"debugger\\\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\\\"break\\\"); if (childCount == 1) { if (first.getType() != Token.LABEL_NAME && validation) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.EXPR_VOID: case Token.EXPR_RESULT: if (type == Token.EXPR_VOID && validation) { throw new Error(\\\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\\\"); } Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\\\"new \\\"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsCall(first)) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence); Node next = first.getNext(); if (next != null) { add(\\\"(\\\"); addList(next); add(\\\")\\\"); } break; case Token.STRING: Preconditions.checkState(childCount == 0); add(jsString(n.getString(), outputCharsetEncoder)); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\\\"delete \\\"); add(first); break; case Token.OBJECTLIT: { Preconditions.checkState(childCount % 2 == 0); boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\\\"(\\\"); } add(\\\"{\\\"); for (Node c = first; c != null; c = c.getNext().getNext()) { if (c != first) { cc.listSeparator(); } if (c.getType() == Token.STRING && !TokenStream.isKeyword(c.getString()) && TokenStream.isJSIdentifier(c.getString()) && NodeUtil.isLatin(c.getString())) { add(c.getString()); } else { addExpr(c, 1); } add(\\\":\\\"); addExpr(c.getNext(), 1); } add(\\\"}\\\"); if (needsParens) { add(\\\")\\\"); } break; } case Token.SWITCH: add(\\\"switch(\\\"); add(first); add(\\\")\\\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\\\"case \\\"); add(first); addCaseBody(last); break; case Token.DEFAULT: Preconditions.checkState(childCount == 1); add(\\\"default\\\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (first.getType() != Token.LABEL_NAME && validation) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(first); add(\\\":\\\"); addNonEmptyExpression(last, getContextForNonEmptyExpression(context), true); break; case Token.SETNAME: break; default: throw new Error(\\\"Unknown type \\\" + type + \\\"\\n\\\" + n.toStringTree()); } cc.endSourceMapping(n); }"
                    ],
                    [
                        0.9933973550796509,
                        "public JSType createFromTypeNodes(Node n, String sourceName, StaticScope<JSType> scope) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodes(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined(); case Token.QMARK: return createNullableType(createFromTypeNodes(n.getFirstChild(), sourceName, scope)); case Token.EQUALS: return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodes(n.getFirstChild(), sourceName, scope)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodes(child, sourceName, scope)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if ((namedType instanceof ObjectType) && !(enumTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); if (typeList != null && (\\\"Array\\\".equals(n.getString()) || \\\"Object\\\".equals(n.getString()))) { JSType parameterType = createFromTypeNodes(typeList.getLastChild(), sourceName, scope); namedType = new ParameterizedType(this, (ObjectType) namedType, parameterType); if (typeList.hasMoreThanOneChild()) { JSType indexType = createFromTypeNodes(typeList.getFirstChild(), sourceName, scope); namedType = new IndexedType(this, (ObjectType) namedType, indexType); } } return createNullableType(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; Node current = n.getFirstChild(); if (current.getType() == Token.THIS) { Node thisNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodes(thisNode, sourceName, scope).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.thisnotobject\\\"), sourceName, thisNode.getLineno(), \\\"\\\", thisNode.getCharno()); } current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.LP) { Node args = current.getFirstChild(); for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodes(arg.getFirstChild(), sourceName, scope)); } } else { JSType type = createFromTypeNodes(arg, sourceName, scope); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), \\\"\\\", arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodes(current, sourceName, scope); return new FunctionType(this, null, null, paramBuilder.build(), returnType, thisType, null); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }"
                    ],
                    [
                        0.9931116700172424,
                        "public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.GETPROP: Node propNode = n.getFirstChild().getNext(); if (propNode.getType() == Token.STRING) { maybeMarkCandidate(propNode, t); } break; case Token.OBJECTLIT: for (Node key = n.getFirstChild(); key != null; key = key.getNext().getNext()) { if (key.getType() == Token.STRING) { if (!key.isQuotedString()) { maybeMarkCandidate(key, t); } else { quotedNames.add(key.getString()); } } } break; case Token.GETELEM: Node child = n.getLastChild(); if (child != null && child.getType() == Token.STRING) { quotedNames.add(child.getString()); } break; case Token.CALL: Node fnName = n.getFirstChild(); if (fnName.getType() == Token.NAME && RENAME_PROPERTY_FUNCTION_NAME.equals(fnName.getString())) { callNodeToParentMap.put(n, parent); countCallCandidates(t, n); } break; case Token.FUNCTION: if (NodeUtil.isFunctionDeclaration(n)) { String name = n.getFirstChild().getString(); if (RENAME_PROPERTY_FUNCTION_NAME.equals(name)) { if (NodeUtil.isExpressionNode(parent)) { parent.detachFromParent(); } else { parent.removeChild(n); } compiler.reportCodeChange(); } } else if (parent.getType() == Token.NAME && RENAME_PROPERTY_FUNCTION_NAME.equals(parent.getString())) { Node varNode = parent.getParent(); if (varNode.getType() == Token.VAR) { varNode.removeChild(parent); if (!varNode.hasChildren()) { varNode.detachFromParent(); } compiler.reportCodeChange(); } } break; } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicenseWithAnnotation"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Extracts the text found on the current line and all subsequent\n   * until either an annotation, end of comment or end of file is reached.\n   * Note that if this method detects an end of line as the first token, it\n   * will quit immediately (indicating that there is no text where it was\n   * expected).  Note that token = info.token; should be called after this\n   * method is used to update the token properly in the parser.\n   *\n   * @param token The start token.\n   * @param option How to handle whitespace.\n   *\n   * @return The extraction information.\n   */\n\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testParseLicenseWithAnnotation() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@license Foo \\n * @author Charlie Brown */\";\n    parse(comment);\n    assertEquals(\" Foo \\n @author Charlie Brown \",\n        node.getJSDocInfo().getLicense());\n  }\n```\n#Error message: junit.framework.ComparisonFailure: expected:< Foo \n[ @author Charlie Brown ]> but was:< Foo \n[]>\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.testParseLicenseWithAnnotation(JsDocInfoParserTest.java:1078)  assertEquals(\" Foo \\n @author Charlie Brown \",        node.getJSDocInfo().getLicense());\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n    boolean captureAnnotation = true;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (captureAnnotation) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n            builder.append(toString(token));\n            state = State.READING_BODY;\n          }\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          ignoreStar = false;\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n/**\n * Extracts the text found on the current line and all subsequent\n * until either an annotation, end of comment or end of file is reached.\n * Note that if this method detects an end of line as the first token, it\n * will quit immediately (indicating that there is no text where it was\n * expected).  Note that token = info.token; should be called after this\n * method is used to update the token properly in the parser.\n *\n * @param token The start token.\n * @param option How to handle whitespace.\n *\n * @return The extraction information.\n */\n\n@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                    WhitespaceOption option) {\n\n  if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n      token == JsDocToken.EOF) {\n    return new ExtractionInfo(\"\", token);\n  }\n\n  stream.update();\n  int startLineno = stream.getLineno();\n  int startCharno = stream.getCharno() + 1;\n\n  // Read the content from the first line.\n  String line = stream.getRemainingJSDocLine();\n\n  if (option != WhitespaceOption.PRESERVE) {\n    line = line.trim();\n  }\n\n  StringBuilder builder = new StringBuilder();\n  builder.append(line);\n\n  state = State.SEARCHING_ANNOTATION;\n  token = next();\n\n  boolean ignoreStar = false;\n\n  do {\n    switch (token) {\n      case STAR:\n        if (!ignoreStar) {\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append('*');\n        }\n\n        token = next();\n        continue;\n\n      case EOL:\n        if (option != WhitespaceOption.SINGLE_LINE) {\n          builder.append(\"\\n\");\n        }\n\n        ignoreStar = true;\n        token = next();\n        continue;\n\n      case ANNOTATION:\n      case EOC:\n      case EOF:\n        // When we're capturing a license block, annotations\n        // in the block are ok.\n        if (state == State.SEARCHING_ANNOTATION && token == JsDocToken.ANNOTATION) {\n          builder.append(' ').append(toString(token));\n          line = stream.getRemainingJSDocLine();\n          if (option != WhitespaceOption.PRESERVE) {\n            line = line.trim();\n          }\n          builder.append(' ').append(line);\n          token = next();\n          continue;\n        }\n\n        String multilineText = builder.toString();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          multilineText = multilineText.trim();\n        }\n\n        int endLineno = stream.getLineno();\n        int endCharno = stream.getCharno();\n\n        if (multilineText.length() > 0) {\n          jsdocBuilder.markText(multilineText, startLineno, startCharno,\n              endLineno, endCharno);\n        }\n\n        return new ExtractionInfo(multilineText, token);\n\n      default:\n        ignoreStar = false;\n        state = State.SEARCHING_ANNOTATION;\n\n        if (builder.length() > 0) {\n          builder.append(' ');\n        }\n\n        builder.append(toString(token));\n\n        line = stream.getRemainingJSDocLine();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          line = trimEnd(line);\n        }\n\n        builder.append(line);\n        token = next();\n    }\n  } while (true);\n}\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.IN_LICENSE;\n          }\n          // FALL THROUGH\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          // Correct the state before returning\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          // Intentionally fall through to capture the line content\n\n        case EOC:\n        case EOF:\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          // Do not ignore the annotation token\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          \n          builder.append(toString(token));\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          ignoreStar = false;\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n"
                        ],
                        "plausible_patches": [
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          ignoreStar = false;\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          // When we're capturing a license block, annotations\n          // in the block are ok.\n            String multilineText = builder.toString();\n\n            if (option != WhitespaceOption.PRESERVE) {\n              multilineText = multilineText.trim();\n            }\n\n            int endLineno = stream.getLineno();\n            int endCharno = stream.getCharno();\n\n            if (multilineText.length() > 0) {\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                  endLineno, endCharno);\n            }\n\n            return new ExtractionInfo(multilineText, token);\n\n          // FALL THROUGH\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n",
                            "\n  @SuppressWarnings(\"fallthrough\")\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        case ANNOTATION:\n          ignoreStar = false;\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n          builder.append(toString(token));\n          token = next();\n          continue;\n\n        case EOC:\n        case EOF:\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.CoalesceVariableNamesTest::testParameter4": {
                "path": "test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java",
                "function_name": "testParameter4",
                "src": "  public void testParameter4() {\n    // Make sure that we do not merge two-arg functions because of the\n    // IE sort bug (see comments in computeEscaped)\n    test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",\n         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(x,y){var a;y;a=0;a;x;a=0;a}\nResult: function FUNC(x,y){y;y=0;y;x;x=0;x}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION FUNC 1 [sourcename: expected0]\n            NAME FUNC 1 [is_constant_name: 1]\n            LP 1\n                NAME x 1\n                NAME y 1\n            BLOCK 1\n                VAR 1\n                    NAME a 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME a 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME a 1\n                EXPR_RESULT 1\n                    NAME x 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME a 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME a 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION FUNC 1 [sourcename: testcode]\n            NAME FUNC 1 [is_constant_name: 1]\n            LP 1\n                NAME x 1\n                NAME y 1\n            BLOCK 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME y 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    NAME x 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME x 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME x 1\n\n\nSubtree1: BLOCK 1\n    VAR 1\n        NAME a 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME a 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME a 1\n    EXPR_RESULT 1\n        NAME x 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME a 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME a 1\n\n\nSubtree2: BLOCK 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME y 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        NAME x 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME x 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME x 1\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tat com.google.javascript.jscomp.CoalesceVariableNamesTest.testParameter4(CoalesceVariableNamesTest.java:191)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(x,y){var a;y;a=0;a;x;a=0;a}\nResult: function FUNC(x,y){y;y=0;y;x;x=0;x}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION FUNC 1 [sourcename: expected0]\n            NAME FUNC 1 [is_constant_name: 1]\n            LP 1\n                NAME x 1\n                NAME y 1\n            BLOCK 1\n                VAR 1\n                    NAME a 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME a 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME a 1\n                EXPR_RESULT 1\n                    NAME x 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME a 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME a 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION FUNC 1 [sourcename: testcode]\n            NAME FUNC 1 [is_constant_name: 1]\n            LP 1\n                NAME x 1\n                NAME y 1\n            BLOCK 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME y 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME y 1\n                EXPR_RESULT 1\n                    NAME x 1\n                EXPR_RESULT 1\n                    ASSIGN 1\n                        NAME x 1\n                        NUMBER 0.0 1\n                EXPR_RESULT 1\n                    NAME x 1\n\n\nSubtree1: BLOCK 1\n    VAR 1\n        NAME a 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME a 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME a 1\n    EXPR_RESULT 1\n        NAME x 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME a 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME a 1\n\n\nSubtree2: BLOCK 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME y 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME y 1\n    EXPR_RESULT 1\n        NAME x 1\n    EXPR_RESULT 1\n        ASSIGN 1\n            NAME x 1\n            NUMBER 0.0 1\n    EXPR_RESULT 1\n        NAME x 1\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CoalesceVariableNamesTest.testParameter4(CoalesceVariableNamesTest.java:191)  test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");"
            },
            "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicenseWithAnnotation": {
                "path": "test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java",
                "function_name": "testParseLicenseWithAnnotation",
                "src": "  public void testParseLicenseWithAnnotation() throws Exception {\n    Node node = new Node(1);\n    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n    String comment = \"@license Foo \\n * @author Charlie Brown */\";\n    parse(comment);\n    assertEquals(\" Foo \\n @author Charlie Brown \",\n        node.getJSDocInfo().getLicense());\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:< Foo \n[ @author Charlie Brown ]> but was:< Foo \n[]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.testParseLicenseWithAnnotation(JsDocInfoParserTest.java:1078)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:< Foo \n[ @author Charlie Brown ]> but was:< Foo \n[]>\n\tat com.google.javascript.jscomp.parsing.JsDocInfoParserTest.testParseLicenseWithAnnotation(JsDocInfoParserTest.java:1078)  assertEquals(\" Foo \\n @author Charlie Brown \",        node.getJSDocInfo().getLicense());"
            }
        },
        "evaluation_done": true
    }
}