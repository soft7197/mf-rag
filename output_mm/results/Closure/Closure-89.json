{
    "Closure-89": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/CollapseProperties.java",
                "start_loc": 477,
                "end_loc": 540,
                "buggy_function": "  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK;\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                "fixed_function": "  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n    }\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK;\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                "comment": "  /**\n   * Updates the initial assignment to a collapsible property at global scope\n   * by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1).\n   * The property's value may either be a primitive or an object literal or\n   * function whose properties aren't collapsible.\n   *\n   * @param alias The flattened property name (e.g. \"a$b\")\n   * @param refName The name for the reference being updated.\n   * @param ref An object containing information about the assignment getting\n   *     updated\n   */\n",
                "normalized_body": [
                    "private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) { } Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private void updateSimpleDeclaration(String alias, Name refName, Ref ref) { Node rvalue = ref.node.getNext(); Node parent = ref.node.getParent(); Node gramps = parent.getParent(); Node greatGramps = gramps.getParent(); Node greatGreatGramps = greatGramps.getParent(); Node nameNode = NodeUtil.newName(compiler.getCodingConvention(), alias, gramps.getFirstChild(), refName.fullName()); NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode); if (gramps.getType() == Token.EXPR_RESULT) { parent.removeChild(rvalue); nameNode.addChildToFront(rvalue); Node varNode = new Node(Token.VAR, nameNode); greatGramps.replaceChild(gramps, varNode); } else { Preconditions.checkNotNull(ref.getTwin()); Node current = gramps; Node currentParent = gramps.getParent(); for (; currentParent.getType() != Token.SCRIPT && currentParent.getType() != Token.BLOCK; current = currentParent, currentParent = currentParent.getParent()) { } Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode); currentParent.addChildBefore(stubVar, current); parent.replaceChild(ref.node, nameNode); } compiler.reportCodeChange(); }"
                    ],
                    [
                        0.9875784516334534,
                        "private void scanVars(Node n, Node parent) { switch(n.getType()) { case Token.VAR: for (Node child = n.getFirstChild(); child != null; ) { Node next = child.getNext(); Preconditions.checkState(child.getType() == Token.NAME); String name = child.getString(); declareVar(name, child, n, parent, null, n); child = next; } return; case Token.FUNCTION: if (NodeUtil.isFunctionExpression(n)) { return; } String fnName = n.getFirstChild().getString(); if (fnName.isEmpty()) { return; } declareVar(fnName, n.getFirstChild(), n, parent, null, n); return; case Token.CATCH: Preconditions.checkState(n.getChildCount() == 2); Preconditions.checkState(n.getFirstChild().getType() == Token.NAME); final Node var = n.getFirstChild(); final Node block = var.getNext(); declareVar(var.getString(), var, n, parent, null, n); scanVars(block, n); return; case Token.SCRIPT: sourceName = (String) n.getProp(Node.SOURCENAME_PROP); break; } if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) { for (Node child = n.getFirstChild(); child != null; ) { Node next = child.getNext(); scanVars(child, n); child = next; } } }"
                    ],
                    [
                        0.9871509075164795,
                        "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope, boolean forgiving) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined(); case Token.QMARK: Node firstChild = n.getFirstChild(); if (firstChild == null) { return getNativeType(UNKNOWN_TYPE); } return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving)); case Token.EQUALS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if (forgiving) { namedType.forgiveUnknownNames(); } if (resolveMode != ResolveMode.LAZY_NAMES) { namedType = namedType.resolveInternal(reporter, scope); } if ((namedType instanceof ObjectType) && !(nonNullableTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); if (typeList != null && (\\\"Array\\\".equals(n.getString()) || \\\"Object\\\".equals(n.getString()))) { JSType parameterType = createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false); namedType = new ParameterizedType(this, (ObjectType) namedType, parameterType); if (typeList.hasMoreThanOneChild()) { JSType indexType = createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false); namedType = new IndexedType(this, (ObjectType) namedType, indexType); } } return createDefaultObjectUnion(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; Node current = n.getFirstChild(); if (current.getType() == Token.THIS) { Node thisNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.thisnotobject\\\"), sourceName, thisNode.getLineno(), \\\"\\\", thisNode.getCharno()); } current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.LP) { Node args = current.getFirstChild(); for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false)); } } else { JSType type = createFromTypeNodesInternal(arg, sourceName, scope, false); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), \\\"\\\", arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodesInternal(current, sourceName, scope, false); return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build(); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }"
                    ],
                    [
                        0.9867470264434814,
                        "private void visitFunction(NodeTraversal t, Node n) { JSDocInfo info = n.getJSDocInfo(); FunctionType functionType = (FunctionType) n.getJSType(); String functionPrivateName = n.getFirstChild().getString(); if (functionType.isInterface() || functionType.isConstructor()) { FunctionType baseConstructor = functionType.getPrototype().getImplicitPrototype().getConstructor(); if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isConstructor() && functionType.isInterface() || baseConstructor.isInterface() && functionType.isConstructor())) { compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName)); } for (JSType baseInterface : functionType.getImplementedInterfaces()) { boolean badImplementedType = false; ObjectType baseInterfaceObj = ObjectType.cast(baseInterface); if (baseInterfaceObj != null) { FunctionType interfaceConstructor = baseInterfaceObj.getConstructor(); if (interfaceConstructor != null && !interfaceConstructor.isInterface()) { badImplementedType = true; } } else { badImplementedType = true; } if (badImplementedType) { report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName); } } if (functionType.isConstructor()) { validator.expectAllInterfacePropertiesImplemented(functionType); } } }"
                    ],
                    [
                        0.9861906170845032,
                        "private void maybeCollapseIntoForStatements(Node n, Node parent) { if (parent == null || !NodeUtil.isStatementBlock(parent)) { return; } if (!NodeUtil.isExpressionNode(n) && !NodeUtil.isVar(n)) { return; } Node nextSibling = n.getNext(); if (nextSibling == null) { return; } else if (NodeUtil.isForIn(nextSibling)) { Node forNode = nextSibling; Node forVar = forNode.getFirstChild(); if (NodeUtil.isName(forVar) && NodeUtil.isVar(n) && n.hasOneChild()) { Node name = n.getFirstChild(); if (!name.hasChildren() && forVar.getString().equals(name.getString())) { parent.removeChild(n); forNode.replaceChild(forVar, n); compiler.reportCodeChange(); } } } else if (nextSibling.getType() == Token.FOR && nextSibling.getFirstChild().getType() == Token.EMPTY) { if (NodeUtil.containsType(n, Token.IN)) { return; } Node forNode = nextSibling; Node oldInitializer = forNode.getFirstChild(); parent.removeChild(n); Node newInitializer; if (NodeUtil.isVar(n)) { newInitializer = n; } else { Preconditions.checkState(n.hasOneChild()); newInitializer = n.getFirstChild(); n.removeChild(newInitializer); } forNode.replaceChild(oldInitializer, newInitializer); compiler.reportCodeChange(); } }"
                    ],
                    [
                        0.9857552647590637,
                        "static LinkedHashMap<String, Node> getFunctionCallParameterMap(Node fnNode, Node callNode, Supplier<String> safeNameIdSupplier) { LinkedHashMap<String, Node> argMap = Maps.newLinkedHashMap(); Node cArg = callNode.getFirstChild().getNext(); if (callNode.getFirstChild().getType() != Token.NAME) { if (NodeUtil.isFunctionObjectCall(callNode)) { Preconditions.checkNotNull(cArg); Preconditions.checkState(cArg.getType() == Token.THIS); cArg = cArg.getNext(); } else { Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); } } for (Node fnArg : NodeUtil.getFnParameters(fnNode).children()) { if (cArg != null) { argMap.put(fnArg.getString(), cArg); cArg = cArg.getNext(); } else { Node srcLocation = callNode; argMap.put(fnArg.getString(), NodeUtil.newUndefinedNode(srcLocation)); } } int anonArg = 0; while (cArg != null) { String uniquePlaceholder = getUniqueAnonymousParameterName(safeNameIdSupplier); argMap.put(uniquePlaceholder, cArg); cArg = cArg.getNext(); } return argMap; }"
                    ],
                    [
                        0.9857130646705627,
                        "public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.TRY: JSDocInfo info = n.getJSDocInfo(); if (info != null && info.shouldPreserveTry()) { return; } Node tryBlock = n.getFirstChild(); Node catchBlock = tryBlock.getNext(); Node finallyBlock = catchBlock != null ? catchBlock.getNext() : null; if (finallyBlock != null && tryNodesContainingReturnStatements.contains(n)) { return; } if (catchBlock.hasOneChild()) { NodeUtil.redeclareVarsInsideBranch(catchBlock); } n.detachChildren(); Node block; if (!NodeUtil.isStatementBlock(parent)) { block = new Node(Token.BLOCK); parent.replaceChild(n, block); block.addChildToFront(tryBlock); } else { parent.replaceChild(n, tryBlock); block = parent; } if (finallyBlock != null) { block.addChildAfter(finallyBlock, tryBlock); } compiler.reportCodeChange(); break; case Token.RETURN: boolean isInTryBlock = false; for (Node anc = parent; anc != null && anc.getType() != Token.FUNCTION; anc = anc.getParent()) { if (anc.getType() == Token.TRY) { tryNodesContainingReturnStatements.add(anc); break; } } break; } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true,
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are several buggy methods from a large Java project.\nAlthough these methods are not directly linked to any failing test cases, we suspect they may contain bugs.\nYour task is to fix these methods using your reasoning and by learning from the few-shot examples provided below.\n\n---\n\n## Few-shot Examples\n\n\n### Example 1 - Buggy:\n```java\n    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }\n\n```\n\n### Example 1 - Fixed:\n```java\n\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  // Don't try to collapse if the one global set is a twin reference.\n  // We could theoretically handle this case in CollapseProperties, but\n  // it's probably not worth the effort.\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  // If this is a key of an aliased object literal, then it will be aliased\n  // later. So we won't be able to collapse its properties.\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // If this is aliased, then its properties can't be collapsed either.\n  if (type == Type.FUNCTION || aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n\n```\n\n\n---\n\n## Buggy Methods to Fix\n\nBelow are the methods suspected to be buggy. Apply your best judgment to fix them based on patterns from the examples.\n\n\n### Method 1:\n```java\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK;\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n\n```\n\n\n---\n\n## \ud83c\udf1f Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations, comments, or extra text.\n",
                        "patches": [
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      Preconditions.checkNotNull(ref.getTwin());\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent != null &&\n             currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      if (currentParent != null) {\n        currentParent.addChildBefore(stubVar, current);\n      }\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      Preconditions.checkNotNull(ref.getTwin());\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent != null && currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      if (currentParent != null) {\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree()).copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n      }\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                            "\nprivate void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n  Node rvalue = ref.node.getNext();\n  Node parent = ref.node.getParent();\n  Node gramps = parent.getParent();\n  Node greatGramps = gramps.getParent();\n\n  // Create the new alias node.\n  Node nameNode = NodeUtil.newName(\n      compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n      refName.fullName());\n  NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n  if (gramps.getType() == Token.EXPR_RESULT) {\n    // Remove the rvalue (NODE).\n    parent.removeChild(rvalue);\n    nameNode.addChildToFront(rvalue);\n\n    Node varNode = new Node(Token.VAR, nameNode);\n    greatGramps.replaceChild(gramps, varNode);\n  } else {\n    Preconditions.checkNotNull(ref.getTwin());\n\n    Node current = gramps;\n    Node currentParent = gramps.getParent();\n    while (currentParent.getType() != Token.SCRIPT &&\n           currentParent.getType() != Token.BLOCK) {\n      current = currentParent;\n      currentParent = currentParent.getParent();\n    }\n\n    Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n        .copyInformationFrom(nameNode);\n    currentParent.addChildBefore(stubVar, current);\n\n    parent.replaceChild(ref.node, nameNode);\n  }\n\n  compiler.reportCodeChange();\n}\n",
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      Preconditions.checkNotNull(ref.getTwin());\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent != null && currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      if (currentParent != null) {\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n            .copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n      }\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      // AFTER: var a$b$c = ...;\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE: ... (x.y = 3);\n      // AFTER: var x$y; ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent != null &&\n             currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      if (currentParent != null) {\n        currentParent.addChildBefore(stubVar, current);\n      }\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n          .copyInformationFrom(nameNode);\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                            "\nprivate void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n        // Remove the rvalue (NODE).\n        parent.removeChild(rvalue);\n        nameNode.addChildToFront(rvalue);\n\n        Node varNode = new Node(Token.VAR, nameNode);\n        greatGramps.replaceChild(gramps, varNode);\n    } else {\n        Preconditions.checkNotNull(ref.getTwin());\n\n        Node current = gramps;\n        Node currentParent = gramps.getParent();\n        while (currentParent != null &&\n               currentParent.getType() != Token.SCRIPT &&\n               currentParent.getType() != Token.BLOCK) {\n            current = currentParent;\n            currentParent = currentParent.getParent();\n        }\n\n        if (currentParent != null) {\n            Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n                .copyInformationFrom(nameNode);\n            currentParent.addChildBefore(stubVar, current);\n        }\n\n        parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n}\n",
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      Preconditions.checkNotNull(ref.getTwin());\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent != null &&\n             currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      if (currentParent != null) {\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n            .copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n      }\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n",
                            "\nprivate void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n        // Remove the rvalue (NODE).\n        parent.removeChild(rvalue);\n        nameNode.addChildToFront(rvalue);\n\n        Node varNode = new Node(Token.VAR, nameNode);\n        greatGramps.replaceChild(gramps, varNode);\n    } else {\n        Preconditions.checkNotNull(ref.getTwin());\n\n        Node current = gramps;\n        Node currentParent = gramps.getParent();\n        while (currentParent.getType() != Token.SCRIPT &&\n               currentParent.getType() != Token.BLOCK) {\n            current = currentParent;\n            currentParent = currentParent.getParent();\n        }\n\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n            .copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n\n        parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n}\n",
                            "\n  private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(\n        compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n        refName.fullName());\n    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      // AFTER: var a$b$c = ...;\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      while (currentParent != null &&\n             currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK) {\n        current = currentParent;\n        currentParent = currentParent.getParent();\n      }\n\n      if (currentParent != null) {\n        // Create a stub variable declaration right\n        // before the current statement.\n        Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n            .copyInformationFrom(nameNode);\n        currentParent.addChildBefore(stubVar, current);\n      }\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/GlobalNamespace.java",
                "start_loc": 896,
                "end_loc": 925,
                "buggy_function": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }\n",
                "fixed_function": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }\n",
                "comment": "",
                "normalized_body": [
                    "boolean canCollapseUnannotatedChildNames() { if (type == Type.OTHER || globalSets != 1 || localSets != 0) { return false; } Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; } if (isClassOrEnum) { return true; } if (parent != null && parent.shouldKeepKeys()) { return false; } if (type != Type.FUNCTION && aliasingGets > 0) { return false; } return (parent == null || parent.canCollapseUnannotatedChildNames()); }"
                ],
                "top_similar_methods": [
                    [
                        0.9999999403953552,
                        "boolean canCollapseUnannotatedChildNames() { if (type == Type.OTHER || globalSets != 1 || localSets != 0) { return false; } Preconditions.checkNotNull(declaration); if (declaration.getTwin() != null) { return false; } if (isClassOrEnum) { return true; } if (parent != null && parent.shouldKeepKeys()) { return false; } if (type != Type.FUNCTION && aliasingGets > 0) { return false; } return (parent == null || parent.canCollapseUnannotatedChildNames()); }"
                    ],
                    [
                        0.9807618856430054,
                        "boolean processFunctionCall(Node node) { Preconditions.checkArgument(node.getType() == Token.CALL, \\\"Expected: CALL, Got: \\\" + Token.name(node.getType())); Node functionName = node.getFirstChild(); if (NodeUtil.isName(functionName) || NodeUtil.isGetProp(functionName)) { if (!accumulator.classDefiningCallsHaveSideEffects() && isClassDefiningCall(node)) { return true; } } if (!NodeUtil.functionCallHasSideEffects(node)) { return true; } accumulator.keepSubTree(node); return false; }"
                    ],
                    [
                        0.979397177696228,
                        "@Override protected CompilerPass createInternal(AbstractCompiler compiler) { List<Callback> callbacks = Lists.newArrayList(); if (options.checkUnreachableCode.isOn()) { callbacks.add(new CheckUnreachableCode(compiler, options.checkUnreachableCode)); } if (options.checkMissingReturn.isOn() && options.checkTypes) { callbacks.add(new CheckMissingReturn(compiler, options.checkMissingReturn)); } return combineChecks(compiler, callbacks); }"
                    ],
                    [
                        0.9784102439880371,
                        "void removeVarDeclarationsByNameOrRvalue(NodeTraversal t, Node n, Node parent) { for (Node nameNode = n.getFirstChild(); nameNode != null; nameNode = nameNode.getNext()) { String name = nameNode.getString(); if (isStripName(name) || isCallWhoseReturnValueShouldBeStripped(nameNode.getFirstChild())) { Scope scope = t.getScope(); varsToRemove.add(scope.getVar(name)); n.removeChild(nameNode); compiler.reportCodeChange(); } } if (!n.hasChildren()) { replaceWithEmpty(n, parent); compiler.reportCodeChange(); } }"
                    ],
                    [
                        0.9764784574508667,
                        "private boolean getSubTypes(FunctionType type, Set<ConcreteType> set) { if (type.getSubTypes() != null) { for (FunctionType sub : type.getSubTypes()) { ConcreteType concrete = createType(sub); if (concrete.isFunction() && concrete.toFunction().getInstanceType() != null) { concrete = concrete.toFunction().getInstanceType(); if (!set.contains(concrete)) { set.add(concrete); if (!getSubTypes(sub, set)) { return false; } } } else { set.clear(); set.add(ConcreteType.ALL); return false; } } } return true; }"
                    ],
                    [
                        0.97647625207901,
                        "private static Node findCall(Node root, @Nullable final String name, final int call) { class Find { int found = 0; Node find(Node n) { if (n.getType() == Token.CALL) { Node callee = n.getFirstChild(); if (name == null || (callee.getType() == Token.NAME && callee.getString().equals(name))) { found++; if (found == call) { return n; } } } for (Node c : n.children()) { Node result = find(c); if (result != null) { return result; } } return null; } } return (new Find()).find(root); }"
                    ],
                    [
                        0.9749941825866699,
                        "private void checkNamespaces() { for (Name name : nameMap.values()) { if (name.isNamespace() && name.refs != null && (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) { boolean initialized = name.declaration != null; for (Ref ref : name.refs) { if (ref.type == Ref.Type.SET_FROM_GLOBAL || ref.type == Ref.Type.SET_FROM_LOCAL) { if (initialized) { warnAboutNamespaceRedefinition(name, ref); } initialized = true; } else if (ref.type == Ref.Type.ALIASING_GET) { warnAboutNamespaceAliasing(name, ref); } } } } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToChildOfUncollapsibleFunctionInLocalScope",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_1",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_2",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_3",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2",
                    "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth2"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n      Preconditions.checkNotNull(declaration);\n      if (declaration.getTwin() != null) {\n        return false;\n      }\n\n      if (isClassOrEnum) {\n        return true;\n      }\n\n      // If this is a key of an aliased object literal, then it will be aliased\n      // later. So we won't be able to collapse its properties.\n      if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n      }\n\n      // If this is aliased, then its properties can't be collapsed either.\n      if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n      }\n\n      return (parent == null || parent.canCollapseUnannotatedChildNames());\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() {\n    testSame(\n        \"function a() {} a.b = {x: 0}; var c = a;\" +\n        \"(function() {a.b.y = 0;})(); a.b.y;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function a(){}a.b={x:0};var c=a;(function(){a.b.y=0})();a.b.y\nResult: function a(){}var a$b$x=0;var a$b$y;var c=a;(function(){a$b$y=0})();a$b$y\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                OBJECTLIT 1 [sourcename: expected0]\n                    STRING x 1 [sourcename: expected0]\n                        NUMBER 0.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    GETPROP 1 [sourcename: expected0]\n                                        NAME a 1 [sourcename: expected0]\n                                        STRING b 1 [sourcename: expected0]\n                                    STRING y 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                STRING y 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$x 1 [sourcename: testcode]\n                NUMBER 0.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$y 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        ASSIGN 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n            OBJECTLIT 1 [sourcename: expected0]\n                STRING x 1 [sourcename: expected0]\n                    NUMBER 0.0 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                STRING y 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n            STRING y 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$x 1 [sourcename: testcode]\n            NUMBER 0.0 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$y 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToChildOfUncollapsibleFunctionInLocalScope(CollapsePropertiesTest.java:610)  testSame(        \"function a() {} a.b = {x: 0}; var c = a;\" +        \"(function() {a.b.y = 0;})(); a.b.y;\");\n \n#Test method 2:\n```java\n  public void testAliasCreatedForFunctionDepth1_1() {\n    testSame(\"var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;var c=a;c.b=2;a.b!=c.b\nResult: var a=function(){};var a$b=1;var c=a;c.b=2;a$b!=c.b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME c 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 2.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NE 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME c 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            ASSIGN 1 [sourcename: testcode]\n                GETPROP 1 [sourcename: testcode]\n                    NAME c 1 [sourcename: testcode]\n                    STRING b 1 [sourcename: testcode]\n                NUMBER 2.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NE 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                GETPROP 1 [sourcename: testcode]\n                    NAME c 1 [sourcename: testcode]\n                    STRING b 1 [sourcename: testcode]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_1(CollapsePropertiesTest.java:279)  testSame(\"var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;\");\n \n#Test method 3:\n```java\n  public void testAliasCreatedForFunctionDepth1_2() {\n    testSame(\"var a = function(){}; a.b = 1; f(a); a.b;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;f(a);a.b\nResult: var a=function(){};var a$b=1;f(a);a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                NAME f 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                NAME f 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_2(CollapsePropertiesTest.java:295)  testSame(\"var a = function(){}; a.b = 1; f(a); a.b;\");\n \n#Test method 4:\n```java\n  public void testAliasCreatedForFunctionDepth1_3() {\n    testSame(\"var a = function(){}; a.b = 1; new f(a); a.b;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;new f(a);a.b\nResult: var a=function(){};var a$b=1;new f(a);a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NEW 1 [sourcename: expected0]\n                NAME f 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NEW 1 [sourcename: testcode]\n                NAME f 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_3(CollapsePropertiesTest.java:304)  testSame(\"var a = function(){}; a.b = 1; new f(a); a.b;\");\n \n#Test method 5:\n```java\n  public void testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1() {\n    // This technically should be collapsed, according to the rules.\n    // We don't collapse named constructors for legacy reasons\n    // (this pass has been around too long, and we don't know who's\n    // depending on this behavior).\n    testSame(\n          \"/** @constructor */ function a() {} var c = a; \" +\n          \"(function() {a.b = 0;})(); a.b;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function a(){}var c=a;(function(){a.b=0})();a.b\nResult: function a(){}var a$b;var c=a;(function(){a$b=0})();a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0] [jsdoc_info: JSDocInfo]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode] [jsdoc_info: JSDocInfo]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0] [jsdoc_info: JSDocInfo]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a 1 [sourcename: expected0]\n                                STRING b 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode] [jsdoc_info: JSDocInfo]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1(CollapsePropertiesTest.java:552)  testSame(          \"/** @constructor */ function a() {} var c = a; \" +          \"(function() {a.b = 0;})(); a.b;\");\n \n#Test method 6:\n```java\n  public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1() {\n    testSame(\"function a() {} var c = a; (function() {a.b = 0;})(); a.b;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function a(){}var c=a;(function(){a.b=0})();a.b\nResult: function a(){}var a$b;var c=a;(function(){a$b=0})();a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a 1 [sourcename: expected0]\n                                STRING b 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1(CollapsePropertiesTest.java:544)  testSame(\"function a() {} var c = a; (function() {a.b = 0;})(); a.b;\");\n \n#Test method 7:\n```java\n  public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2() {\n    test(\"var a = {}; a.b = function (){}; var d = a.b;\" +\n         \"(function() {a.b.c = 0;})(); a.b.c;\",\n         \"var a$b = function (){}; var d = a$b;\" +\n         \"(function() {a$b.c = 0;})(); a$b.c;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var a$b=function(){};var d=a$b;(function(){a$b.c=0})();a$b.c\nResult: var a$b=function(){};var a$b$c;var d=a$b;(function(){a$b$c=0})();a$b$c\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME d 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a$b 1 [sourcename: expected0]\n                                    STRING c 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n                STRING c 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME d 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    VAR 1 [sourcename: expected0]\n        NAME a$b 1 [sourcename: expected0]\n            FUNCTION  1 [sourcename: expected0]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME d 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a$b 1 [sourcename: expected0]\n                                STRING c 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n            STRING c 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n            FUNCTION  1 [sourcename: testcode]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$c 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME d 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2(CollapsePropertiesTest.java:572)  test(\"var a = {}; a.b = function (){}; var d = a.b;\" +         \"(function() {a.b.c = 0;})(); a.b.c;\",         \"var a$b = function (){}; var d = a$b;\" +         \"(function() {a$b.c = 0;})(); a$b.c;\");\n \n#Test method 8:\n```java\n  public void testAliasCreatedForFunctionDepth2() {\n    test(\n        \"var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;\" +\n        \"a.b.c != d.c;\",\n        \"var a$b = function() {}; a$b.c = 1; var d = a$b;\" +\n        \"a$b.c != d.c;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var a$b=function(){};a$b.c=1;var d=a$b;a$b.c!=d.c\nResult: var a$b=function(){};var a$b$c=1;var d=a$b;a$b$c!=d.c\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a$b 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME d 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NE 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a$b 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME d 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                NUMBER 1.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME d 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NE 1 [sourcename: testcode]\n                NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                GETPROP 1 [sourcename: testcode]\n                    NAME d 1 [sourcename: testcode]\n                    STRING c 1 [sourcename: testcode]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n            STRING c 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth2(CollapsePropertiesTest.java:313)  test(        \"var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;\" +        \"a.b.c != d.c;\",        \"var a$b = function() {}; a$b.c = 1; var d = a$b;\" +        \"a$b.c != d.c;\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // Add a check for functions being aliased that prevents us from\n  // collapsing their properties.\n  if (type == Type.FUNCTION && declaration.hasLocalSets()) {\n    return false;\n  }\n\n  if (type != Type.FUNCTION && aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    // If this is a function or a constructor with multiple sets, its properties can't be collapsed\n    // If this is aliased, then its properties can't be collapsed either.\n    if ((type == Type.FUNCTION || isConstructor) && aliasingGets > 0) {\n        return false;\n    }\n\n    if (type == Type.FUNCTION || isConstructor) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    if (type == Type.FUNCTION && aliasingGets == 0) {\n        return false;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    if (type != Type.FUNCTION && aliasingGets > 0) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  // Don't try to collapse if the one global set is a twin reference.\n  // We could theoretically handle this case in CollapseProperties, but\n  // it's probably not worth the effort.\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  // If this is a key of an aliased object literal, then it will be aliased\n  // later. So we won't be able to collapse its properties.\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // If this is aliased, then its properties can't be collapsed either.\n  if (type == Type.FUNCTION || aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // Ensure functions and constructors are not collapsed if they are aliased\n  if ((type == Type.FUNCTION || type == Type.CONSTRUCTOR) && aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  // Don't try to collapse if the one global set is a twin reference.\n  // We could theoretically handle this case in CollapseProperties, but\n  // it's probably not worth the effort.\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  // Disallow collapsing on constructors and functions when there's aliasing.\n  if ((type == Type.FUNCTION || type == Type.CONSTRUCTOR || type == Type.CLASS)\n      && aliasingGets > 0) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  // If this is a key of an aliased object literal, then it will be aliased\n  // later. So we won't be able to collapse its properties.\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // If this is aliased, then its properties can't be collapsed either.\n  if (type != Type.FUNCTION && aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    if (aliasingGets > 0) {\n        return false;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    // Update this check to not collapse properties for functions either, when aliased.\n    if (aliasingGets > 0) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  if (type != Type.FUNCTION && aliasingGets > 0) {\n    return false;\n  }\n\n  if (type == Type.FUNCTION) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  if (aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n"
                        ],
                        "plausible_patches": [
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  // Don't try to collapse if the one global set is a twin reference.\n  // We could theoretically handle this case in CollapseProperties, but\n  // it's probably not worth the effort.\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  // If this is a key of an aliased object literal, then it will be aliased\n  // later. So we won't be able to collapse its properties.\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // If this is aliased, then its properties can't be collapsed either.\n  if (type == Type.FUNCTION || aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    if (aliasingGets > 0) {\n        return false;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    // Update this check to not collapse properties for functions either, when aliased.\n    if (aliasingGets > 0) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  if (type != Type.FUNCTION && aliasingGets > 0) {\n    return false;\n  }\n\n  if (type == Type.FUNCTION) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  // Don't try to collapse if the one global set is a twin reference.\n  // We could theoretically handle this case in CollapseProperties, but\n  // it's probably not worth the effort.\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  // If this is a key of an aliased object literal, then it will be aliased\n  // later. So we won't be able to collapse its properties.\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  // If this is aliased, then its properties can't be collapsed either.\n  if (type == Type.FUNCTION || aliasingGets > 0) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    if (aliasingGets > 0) {\n        return false;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n    if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n    }\n\n    // Don't try to collapse if the one global set is a twin reference.\n    // We could theoretically handle this case in CollapseProperties, but\n    // it's probably not worth the effort.\n    Preconditions.checkNotNull(declaration);\n    if (declaration.getTwin() != null) {\n        return false;\n    }\n\n    if (isClassOrEnum) {\n        return true;\n    }\n\n    // If this is a key of an aliased object literal, then it will be aliased\n    // later. So we won't be able to collapse its properties.\n    if (parent != null && parent.shouldKeepKeys()) {\n        return false;\n    }\n\n    // If this is aliased, then its properties can't be collapsed either.\n    // Update this check to not collapse properties for functions either, when aliased.\n    if (aliasingGets > 0) {\n        return false;\n    }\n\n    return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n",
                            "\nboolean canCollapseUnannotatedChildNames() {\n  if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n    return false;\n  }\n\n  Preconditions.checkNotNull(declaration);\n  if (declaration.getTwin() != null) {\n    return false;\n  }\n\n  if (isClassOrEnum) {\n    return true;\n  }\n\n  if (parent != null && parent.shouldKeepKeys()) {\n    return false;\n  }\n\n  if (type != Type.FUNCTION && aliasingGets > 0) {\n    return false;\n  }\n\n  if (type == Type.FUNCTION) {\n    return false;\n  }\n\n  return (parent == null || parent.canCollapseUnannotatedChildNames());\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToChildOfUncollapsibleFunctionInLocalScope": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAddPropertyToChildOfUncollapsibleFunctionInLocalScope",
                "src": "  public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() {\n    testSame(\n        \"function a() {} a.b = {x: 0}; var c = a;\" +\n        \"(function() {a.b.y = 0;})(); a.b.y;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function a(){}a.b={x:0};var c=a;(function(){a.b.y=0})();a.b.y\nResult: function a(){}var a$b$x=0;var a$b$y;var c=a;(function(){a$b$y=0})();a$b$y\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                OBJECTLIT 1 [sourcename: expected0]\n                    STRING x 1 [sourcename: expected0]\n                        NUMBER 0.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    GETPROP 1 [sourcename: expected0]\n                                        NAME a 1 [sourcename: expected0]\n                                        STRING b 1 [sourcename: expected0]\n                                    STRING y 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                STRING y 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$x 1 [sourcename: testcode]\n                NUMBER 0.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$y 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        ASSIGN 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n            OBJECTLIT 1 [sourcename: expected0]\n                STRING x 1 [sourcename: expected0]\n                    NUMBER 0.0 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                STRING y 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n            STRING y 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$x 1 [sourcename: testcode]\n            NUMBER 0.0 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$y 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToChildOfUncollapsibleFunctionInLocalScope(CollapsePropertiesTest.java:610)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function a(){}a.b={x:0};var c=a;(function(){a.b.y=0})();a.b.y\nResult: function a(){}var a$b$x=0;var a$b$y;var c=a;(function(){a$b$y=0})();a$b$y\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                OBJECTLIT 1 [sourcename: expected0]\n                    STRING x 1 [sourcename: expected0]\n                        NUMBER 0.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    GETPROP 1 [sourcename: expected0]\n                                        NAME a 1 [sourcename: expected0]\n                                        STRING b 1 [sourcename: expected0]\n                                    STRING y 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                STRING y 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$x 1 [sourcename: testcode]\n                NUMBER 0.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$y 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        ASSIGN 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n            OBJECTLIT 1 [sourcename: expected0]\n                STRING x 1 [sourcename: expected0]\n                    NUMBER 0.0 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                STRING y 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n            STRING y 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$x 1 [sourcename: testcode]\n            NUMBER 0.0 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$y 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b$y 1 [sourcename: testcode] [originalname: a.b.y]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToChildOfUncollapsibleFunctionInLocalScope(CollapsePropertiesTest.java:610)  testSame(        \"function a() {} a.b = {x: 0}; var c = a;\" +        \"(function() {a.b.y = 0;})(); a.b.y;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_1": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAliasCreatedForFunctionDepth1_1",
                "src": "  public void testAliasCreatedForFunctionDepth1_1() {\n    testSame(\"var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;var c=a;c.b=2;a.b!=c.b\nResult: var a=function(){};var a$b=1;var c=a;c.b=2;a$b!=c.b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME c 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 2.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NE 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME c 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            ASSIGN 1 [sourcename: testcode]\n                GETPROP 1 [sourcename: testcode]\n                    NAME c 1 [sourcename: testcode]\n                    STRING b 1 [sourcename: testcode]\n                NUMBER 2.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NE 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                GETPROP 1 [sourcename: testcode]\n                    NAME c 1 [sourcename: testcode]\n                    STRING b 1 [sourcename: testcode]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_1(CollapsePropertiesTest.java:279)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;var c=a;c.b=2;a.b!=c.b\nResult: var a=function(){};var a$b=1;var c=a;c.b=2;a$b!=c.b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME c 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 2.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NE 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME c 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            ASSIGN 1 [sourcename: testcode]\n                GETPROP 1 [sourcename: testcode]\n                    NAME c 1 [sourcename: testcode]\n                    STRING b 1 [sourcename: testcode]\n                NUMBER 2.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NE 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                GETPROP 1 [sourcename: testcode]\n                    NAME c 1 [sourcename: testcode]\n                    STRING b 1 [sourcename: testcode]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_1(CollapsePropertiesTest.java:279)  testSame(\"var a = function(){}; a.b = 1; var c = a; c.b = 2; a.b != c.b;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_2": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAliasCreatedForFunctionDepth1_2",
                "src": "  public void testAliasCreatedForFunctionDepth1_2() {\n    testSame(\"var a = function(){}; a.b = 1; f(a); a.b;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;f(a);a.b\nResult: var a=function(){};var a$b=1;f(a);a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                NAME f 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                NAME f 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_2(CollapsePropertiesTest.java:295)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;f(a);a.b\nResult: var a=function(){};var a$b=1;f(a);a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                NAME f 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                NAME f 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_2(CollapsePropertiesTest.java:295)  testSame(\"var a = function(){}; a.b = 1; f(a); a.b;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth1_3": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAliasCreatedForFunctionDepth1_3",
                "src": "  public void testAliasCreatedForFunctionDepth1_3() {\n    testSame(\"var a = function(){}; a.b = 1; new f(a); a.b;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;new f(a);a.b\nResult: var a=function(){};var a$b=1;new f(a);a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NEW 1 [sourcename: expected0]\n                NAME f 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NEW 1 [sourcename: testcode]\n                NAME f 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_3(CollapsePropertiesTest.java:304)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: var a=function(){};a.b=1;new f(a);a.b\nResult: var a=function(){};var a$b=1;new f(a);a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    STRING b 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NEW 1 [sourcename: expected0]\n                NAME f 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                NUMBER 1.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NEW 1 [sourcename: testcode]\n                NAME f 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth1_3(CollapsePropertiesTest.java:304)  testSame(\"var a = function(){}; a.b = 1; new f(a); a.b;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1",
                "src": "  public void testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1() {\n    // This technically should be collapsed, according to the rules.\n    // We don't collapse named constructors for legacy reasons\n    // (this pass has been around too long, and we don't know who's\n    // depending on this behavior).\n    testSame(\n          \"/** @constructor */ function a() {} var c = a; \" +\n          \"(function() {a.b = 0;})(); a.b;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function a(){}var c=a;(function(){a.b=0})();a.b\nResult: function a(){}var a$b;var c=a;(function(){a$b=0})();a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0] [jsdoc_info: JSDocInfo]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode] [jsdoc_info: JSDocInfo]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0] [jsdoc_info: JSDocInfo]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a 1 [sourcename: expected0]\n                                STRING b 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode] [jsdoc_info: JSDocInfo]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1(CollapsePropertiesTest.java:552)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function a(){}var c=a;(function(){a.b=0})();a.b\nResult: function a(){}var a$b;var c=a;(function(){a$b=0})();a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0] [jsdoc_info: JSDocInfo]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode] [jsdoc_info: JSDocInfo]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0] [jsdoc_info: JSDocInfo]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a 1 [sourcename: expected0]\n                                STRING b 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode] [jsdoc_info: JSDocInfo]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleNamedCtorInLocalScopeDepth1(CollapsePropertiesTest.java:552)  testSame(          \"/** @constructor */ function a() {} var c = a; \" +          \"(function() {a.b = 0;})(); a.b;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1",
                "src": "  public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1() {\n    testSame(\"function a() {} var c = a; (function() {a.b = 0;})(); a.b;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function a(){}var c=a;(function(){a.b=0})();a.b\nResult: function a(){}var a$b;var c=a;(function(){a$b=0})();a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a 1 [sourcename: expected0]\n                                STRING b 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1(CollapsePropertiesTest.java:544)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function a(){}var c=a;(function(){a.b=0})();a.b\nResult: function a(){}var a$b;var c=a;(function(){a$b=0})();a$b\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME c 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a 1 [sourcename: expected0]\n                                    STRING b 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a 1 [sourcename: expected0]\n                STRING b 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME c 1 [sourcename: testcode]\n                NAME a 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    FUNCTION  1 [sourcename: expected0]\n        NAME a 1 [sourcename: expected0]\n        LP 1 [sourcename: expected0]\n        BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME c 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a 1 [sourcename: expected0]\n                                STRING b 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a 1 [sourcename: expected0]\n            STRING b 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    FUNCTION  1 [sourcename: testcode]\n        NAME a 1 [sourcename: testcode]\n        LP 1 [sourcename: testcode]\n        BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME c 1 [sourcename: testcode]\n            NAME a 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleFunctionInLocalScopeDepth1(CollapsePropertiesTest.java:544)  testSame(\"function a() {} var c = a; (function() {a.b = 0;})(); a.b;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2",
                "src": "  public void testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2() {\n    test(\"var a = {}; a.b = function (){}; var d = a.b;\" +\n         \"(function() {a.b.c = 0;})(); a.b.c;\",\n         \"var a$b = function (){}; var d = a$b;\" +\n         \"(function() {a$b.c = 0;})(); a$b.c;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: var a$b=function(){};var d=a$b;(function(){a$b.c=0})();a$b.c\nResult: var a$b=function(){};var a$b$c;var d=a$b;(function(){a$b$c=0})();a$b$c\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME d 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a$b 1 [sourcename: expected0]\n                                    STRING c 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n                STRING c 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME d 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    VAR 1 [sourcename: expected0]\n        NAME a$b 1 [sourcename: expected0]\n            FUNCTION  1 [sourcename: expected0]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME d 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a$b 1 [sourcename: expected0]\n                                STRING c 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n            STRING c 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n            FUNCTION  1 [sourcename: testcode]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$c 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME d 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2(CollapsePropertiesTest.java:572)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: var a$b=function(){};var d=a$b;(function(){a$b.c=0})();a$b.c\nResult: var a$b=function(){};var a$b$c;var d=a$b;(function(){a$b$c=0})();a$b$c\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME d 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            CALL 1 [sourcename: expected0] [free_call: 1]\n                FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n                        EXPR_RESULT 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0]\n                                GETPROP 1 [sourcename: expected0]\n                                    NAME a$b 1 [sourcename: expected0]\n                                    STRING c 1 [sourcename: expected0]\n                                NUMBER 0.0 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            GETPROP 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n                STRING c 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME d 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        EXPR_RESULT 1 [sourcename: testcode]\n            CALL 1 [sourcename: testcode] [free_call: 1]\n                FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n                        EXPR_RESULT 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode]\n                                NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                                NUMBER 0.0 1 [sourcename: testcode]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n\n\nSubtree1: SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n    VAR 1 [sourcename: expected0]\n        NAME a$b 1 [sourcename: expected0]\n            FUNCTION  1 [sourcename: expected0]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n    VAR 1 [sourcename: expected0]\n        NAME d 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        CALL 1 [sourcename: expected0] [free_call: 1]\n            FUNCTION  1 [sourcename: expected0] [parenthesized: true]\n                NAME  1 [sourcename: expected0]\n                LP 1 [sourcename: expected0]\n                BLOCK 1 [sourcename: expected0]\n                    EXPR_RESULT 1 [sourcename: expected0]\n                        ASSIGN 1 [sourcename: expected0]\n                            GETPROP 1 [sourcename: expected0]\n                                NAME a$b 1 [sourcename: expected0]\n                                STRING c 1 [sourcename: expected0]\n                            NUMBER 0.0 1 [sourcename: expected0]\n    EXPR_RESULT 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n            STRING c 1 [sourcename: expected0]\n\n\nSubtree2: SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n    VAR 1 [sourcename: testcode]\n        NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n            FUNCTION  1 [sourcename: testcode]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME a$b$c 1 [sourcename: testcode]\n    VAR 1 [sourcename: testcode]\n        NAME d 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n    EXPR_RESULT 1 [sourcename: testcode]\n        CALL 1 [sourcename: testcode] [free_call: 1]\n            FUNCTION  1 [sourcename: testcode] [parenthesized: true]\n                NAME  1 [sourcename: testcode]\n                LP 1 [sourcename: testcode]\n                BLOCK 1 [sourcename: testcode]\n                    EXPR_RESULT 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode]\n                            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                            NUMBER 0.0 1 [sourcename: testcode]\n    EXPR_RESULT 1 [sourcename: testcode]\n        NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToUncollapsibleFunctionInLocalScopeDepth2(CollapsePropertiesTest.java:572)  test(\"var a = {}; a.b = function (){}; var d = a.b;\" +         \"(function() {a.b.c = 0;})(); a.b.c;\",         \"var a$b = function (){}; var d = a$b;\" +         \"(function() {a$b.c = 0;})(); a$b.c;\");"
            },
            "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasCreatedForFunctionDepth2": {
                "path": "test/com/google/javascript/jscomp/CollapsePropertiesTest.java",
                "function_name": "testAliasCreatedForFunctionDepth2",
                "src": "  public void testAliasCreatedForFunctionDepth2() {\n    test(\n        \"var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;\" +\n        \"a.b.c != d.c;\",\n        \"var a$b = function() {}; a$b.c = 1; var d = a$b;\" +\n        \"a$b.c != d.c;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: var a$b=function(){};a$b.c=1;var d=a$b;a$b.c!=d.c\nResult: var a$b=function(){};var a$b$c=1;var d=a$b;a$b$c!=d.c\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a$b 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME d 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NE 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a$b 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME d 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                NUMBER 1.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME d 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NE 1 [sourcename: testcode]\n                NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                GETPROP 1 [sourcename: testcode]\n                    NAME d 1 [sourcename: testcode]\n                    STRING c 1 [sourcename: testcode]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n            STRING c 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth2(CollapsePropertiesTest.java:313)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: var a$b=function(){};a$b.c=1;var d=a$b;a$b.c!=d.c\nResult: var a$b=function(){};var a$b$c=1;var d=a$b;a$b$c!=d.c\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1 [sourcename: expected0]\n                    LP 1 [sourcename: expected0]\n                    BLOCK 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            ASSIGN 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a$b 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n                NUMBER 1.0 1 [sourcename: expected0]\n        VAR 1 [sourcename: expected0]\n            NAME d 1 [sourcename: expected0]\n                NAME a$b 1 [sourcename: expected0]\n        EXPR_RESULT 1 [sourcename: expected0]\n            NE 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME a$b 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n                GETPROP 1 [sourcename: expected0]\n                    NAME d 1 [sourcename: expected0]\n                    STRING c 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1 [sourcename: testcode]\n            NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1 [sourcename: testcode]\n                    LP 1 [sourcename: testcode]\n                    BLOCK 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                NUMBER 1.0 1 [sourcename: testcode]\n        VAR 1 [sourcename: testcode]\n            NAME d 1 [sourcename: testcode]\n                NAME a$b 1 [sourcename: testcode] [originalname: a.b]\n        EXPR_RESULT 1 [sourcename: testcode]\n            NE 1 [sourcename: testcode]\n                NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n                GETPROP 1 [sourcename: testcode]\n                    NAME d 1 [sourcename: testcode]\n                    STRING c 1 [sourcename: testcode]\n\n\nSubtree1: EXPR_RESULT 1 [sourcename: expected0]\n    ASSIGN 1 [sourcename: expected0]\n        GETPROP 1 [sourcename: expected0]\n            NAME a$b 1 [sourcename: expected0]\n            STRING c 1 [sourcename: expected0]\n        NUMBER 1.0 1 [sourcename: expected0]\n\n\nSubtree2: VAR 1 [sourcename: testcode]\n    NAME a$b$c 1 [sourcename: testcode] [originalname: a.b.c]\n        NUMBER 1.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CollapsePropertiesTest.testAliasCreatedForFunctionDepth2(CollapsePropertiesTest.java:313)  test(        \"var a = {}; a.b = function() {}; a.b.c = 1; var d = a.b;\" +        \"a.b.c != d.c;\",        \"var a$b = function() {}; a$b.c = 1; var d = a$b;\" +        \"a$b.c != d.c;\");"
            }
        },
        "evaluation_done": true,
        "generation_done_for_notest_methods": true
    }
}