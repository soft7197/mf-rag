{
    "Closure-60": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/NodeUtil.java",
                "start_loc": 74,
                "end_loc": 112,
                "buggy_function": "  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                "fixed_function": "  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                "comment": "  /**\n   * Gets the boolean value of a node that represents a expression. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function.\n   * Note: unlike getBooleanValue this function does not return UNKNOWN\n   * for expressions with side-effects.\n   */\n",
                "normalized_body": [
                    "static TernaryValue getImpureBooleanValue(Node n) { switch(n.getType()) { case Token.ASSIGN: case Token.COMMA: return getImpureBooleanValue(n.getLastChild()); case Token.NOT: TernaryValue value = getImpureBooleanValue(n.getLastChild()); return value.not(); case Token.AND: { TernaryValue lhs = getImpureBooleanValue(n.getFirstChild()); TernaryValue rhs = getImpureBooleanValue(n.getLastChild()); return lhs.and(rhs); } case Token.OR: { TernaryValue lhs = getImpureBooleanValue(n.getFirstChild()); TernaryValue rhs = getImpureBooleanValue(n.getLastChild()); return lhs.or(rhs); } case Token.HOOK: { TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext()); TernaryValue falseValue = getImpureBooleanValue(n.getLastChild()); if (trueValue.equals(falseValue)) { return trueValue; } else { return TernaryValue.UNKNOWN; } } case Token.ARRAYLIT: case Token.OBJECTLIT: return TernaryValue.TRUE; default: return getPureBooleanValue(n); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "static TernaryValue getImpureBooleanValue(Node n) { switch(n.getType()) { case Token.ASSIGN: case Token.COMMA: return getImpureBooleanValue(n.getLastChild()); case Token.NOT: TernaryValue value = getImpureBooleanValue(n.getLastChild()); return value.not(); case Token.AND: { TernaryValue lhs = getImpureBooleanValue(n.getFirstChild()); TernaryValue rhs = getImpureBooleanValue(n.getLastChild()); return lhs.and(rhs); } case Token.OR: { TernaryValue lhs = getImpureBooleanValue(n.getFirstChild()); TernaryValue rhs = getImpureBooleanValue(n.getLastChild()); return lhs.or(rhs); } case Token.HOOK: { TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext()); TernaryValue falseValue = getImpureBooleanValue(n.getLastChild()); if (trueValue.equals(falseValue)) { return trueValue; } else { return TernaryValue.UNKNOWN; } } case Token.ARRAYLIT: case Token.OBJECTLIT: return TernaryValue.TRUE; default: return getPureBooleanValue(n); } }"
                    ],
                    [
                        0.9802497625350952,
                        "private ConcreteType createTypeIntersection(ConcreteType concreteType, JSType jsType) { ConcreteJSTypePair key = new ConcreteJSTypePair(concreteType, jsType); ConcreteType ret = typeIntersectionMemos.get(key); if (ret != null) { return ret; } if (jsType == null || jsType.isUnknownType() || concreteType.isNone()) { ret = concreteType; } else if (concreteType.isUnion() || concreteType.isSingleton()) { ret = concreteType.intersectWith(createTypeWithSubTypes(jsType)); } else { Preconditions.checkState(concreteType.isAll()); ret = createTypeWithSubTypes(jsType); } ret = ret.intersectWith(ConcreteType.createForTypes(allInstantiatedTypes)); for (ConcreteFunctionType functionType : concreteType.getFunctions()) { ret = ret.unionWith(functionType); } for (ConcreteInstanceType prototype : concreteType.getPrototypeTypes()) { ret = ret.unionWith(prototype); } for (ConcreteInstanceType instance : concreteType.getInstances()) { if (!instance.instanceType.isInstanceType() && !instance.isFunctionPrototype()) { ret = ret.unionWith(instance); } } typeIntersectionMemos.put(key, ret); return ret; }"
                    ],
                    [
                        0.9767928719520569,
                        "public void testRecordMultipleAliases() { String fullJsCode = GOOG_SCOPE_START_BLOCK + \\\"var g = goog;\\n var b= g.bar;\\n var f = goog.something.foo;\\\" + \\\"g.dom.createElement(g.dom.TagName.DIV);\\n b.foo();\\\" + GOOG_SCOPE_END_BLOCK; String expectedJsCode = \\\"goog.dom.createElement(goog.dom.TagName.DIV);\\n goog.bar.foo();\\\"; TransformationHandlerSpy spy = new TransformationHandlerSpy(); transformationHandler = spy; test(fullJsCode, expectedJsCode); assertTrue(spy.observedPositions.containsKey(\\\"testcode\\\")); List<SourcePosition<AliasTransformation>> positions = spy.observedPositions.get(\\\"testcode\\\"); assertEquals(1, positions.size()); verifyAliasTransformationPosition(1, GOOG_SCOPE_LEN, 3, 1, positions.get(0)); assertEquals(1, spy.constructedAliases.size()); AliasSpy aliasSpy = (AliasSpy) spy.constructedAliases.get(0); assertEquals(\\\"goog\\\", aliasSpy.observedDefinitions.get(\\\"g\\\")); assertEquals(\\\"g.bar\\\", aliasSpy.observedDefinitions.get(\\\"b\\\")); assertEquals(\\\"goog.something.foo\\\", aliasSpy.observedDefinitions.get(\\\"f\\\")); }"
                    ],
                    [
                        0.9764546751976013,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.CALL: boolean isExpr = parent.getType() == Token.EXPR_RESULT; Node left = n.getFirstChild(); if (left.getType() == Token.GETPROP) { Node name = left.getFirstChild(); if (name.getType() == Token.NAME && GOOG.equals(name.getString())) { String methodName = name.getNext().getString(); if (\\\"base\\\".equals(methodName)) { processBaseClassCall(t, n); } else if (!isExpr) { break; } else if (\\\"require\\\".equals(methodName)) { processRequireCall(t, n, parent); } else if (\\\"provide\\\".equals(methodName)) { processProvideCall(t, n, parent); } else if (\\\"exportSymbol\\\".equals(methodName)) { Node arg = left.getNext(); if (arg.getType() == Token.STRING) { int dot = arg.getString().indexOf('.'); if (dot == -1) { exportedVariables.add(arg.getString()); } else { exportedVariables.add(arg.getString().substring(0, dot)); } } } else if (\\\"addDependency\\\".equals(methodName)) { CodingConvention convention = compiler.getCodingConvention(); List<String> typeDecls = convention.identifyTypeDeclarationCall(n); if (typeDecls != null) { for (String typeDecl : typeDecls) { compiler.getTypeRegistry().forwardDeclareType(typeDecl); } } parent.replaceChild(n, Node.newNumber(0)); compiler.reportCodeChange(); } else if (\\\"setCssNameMapping\\\".equals(methodName)) { processSetCssNameMapping(t, n, parent); } } } break; case Token.ASSIGN: case Token.NAME: handleCandidateProvideDefinition(t, n, parent); break; case Token.EXPR_RESULT: handleTypedefDefinition(t, n, parent); break; case Token.FUNCTION: if (t.inGlobalScope() && !NodeUtil.isFunctionExpression(n)) { String name = n.getFirstChild().getString(); ProvidedName pn = providedNames.get(name); if (pn != null) { compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name)); } } break; case Token.NEW: trySimplifyNewDate(t, n, parent); break; case Token.GETPROP: if (n.getFirstChild().getType() == Token.NAME && parent.getType() != Token.CALL && parent.getType() != Token.ASSIGN && \\\"goog.base\\\".equals(n.getQualifiedName())) { reportBadBaseClassUse(t, n, \\\"May only be called directly.\\\"); } break; } }"
                    ],
                    [
                        0.9758375883102417,
                        "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) { if (oldType == null) { return this; } returnType = oldType.getReturnType(); returnTypeInferred = oldType.isReturnTypeInferred(); if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false; boolean oldParamsListHitOptArgs = false; for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { Node oldParam = oldParams.next(); Node newParam = paramBuilder.newParameterFromNode(oldParam); oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg(); if (currentParam.getNext() != null && newParam.isVarArgs()) { newParam.setVarArgs(false); newParam.setOptionalArg(true); } } else { warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); } return this; }"
                    ],
                    [
                        0.9755778312683105,
                        "private Collection<Action> getImplicitActionsFromCall(Node n, JSType recvType) { Node receiver = n.getFirstChild(); if (recvType instanceof UnionType) { List<Action> actions = Lists.newArrayList(); for (JSType alt : ((UnionType) recvType).getAlternates()) { actions.addAll(getImplicitActionsFromCall(n, alt)); } return actions; } else if (!(recvType instanceof FunctionType)) { return Lists.<Action>newArrayList(); } ObjectType objType = ObjectType.cast(getJSType(receiver.getFirstChild()).restrictByNotNullOrUndefined()); String prop = receiver.getLastChild().getString(); if (objType != null && (objType.isPropertyInExterns(prop)) && ((FunctionType) recvType).getParameters() != null) { List<Action> actions = Lists.newArrayList(); Iterator<Node> paramIter = ((FunctionType) recvType).getParameters().iterator(); Iterator<Node> argumentIter = n.children().iterator(); argumentIter.next(); while (paramIter.hasNext() && argumentIter.hasNext()) { Node arg = argumentIter.next(); Node param = paramIter.next(); if (arg.getJSType() instanceof FunctionType) { actions.addAll(getImplicitActionsFromArgument(arg, ((FunctionType) arg.getJSType()).getTypeOfThis(), param.getJSType())); } } return actions; } return Lists.<Action>newArrayList(); }"
                    ],
                    [
                        0.9755321145057678,
                        "public void testLinenoMultilineEq() { AstRoot root = parse(\\\"\\nif\\n\\\" + \\\" (((a == \\n\\\" + \\\" 3) && \\n\\\" + \\\" (b == 2)) || \\n\\\" + \\\" (c == 1)) {\\n\\\" + \\\"}\\n\\\"); IfStatement ifStmt = (IfStatement) root.getFirstChild(); InfixExpression orTest = (InfixExpression) ifStmt.getCondition(); ParenthesizedExpression cTestParen = (ParenthesizedExpression) orTest.getRight(); InfixExpression cTest = (InfixExpression) cTestParen.getExpression(); ParenthesizedExpression andTestParen = (ParenthesizedExpression) orTest.getLeft(); InfixExpression andTest = (InfixExpression) andTestParen.getExpression(); AstNode aTest = andTest.getLeft(); AstNode bTest = andTest.getRight(); assertEquals(1, ifStmt.getLineno()); assertEquals(4, orTest.getLineno()); assertEquals(3, andTest.getLineno()); assertEquals(2, aTest.getLineno()); assertEquals(4, bTest.getLineno()); assertEquals(5, cTest.getLineno()); assertEquals(5, cTestParen.getLineno()); assertEquals(2, andTestParen.getLineno()); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true,
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are several buggy methods from a large Java project.\nAlthough these methods are not directly linked to any failing test cases, we suspect they may contain bugs.\nYour task is to fix these methods using your reasoning and by learning from the few-shot examples provided below.\n\n---\n\n## Few-shot Examples\n\n\n### Example 1 - Buggy:\n```java\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n\n```\n\n### Example 1 - Fixed:\n```java\n\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n\n```\n\n\n---\n\n## Buggy Methods to Fix\n\nBelow are the methods suspected to be buggy. Apply your best judgment to fix them based on patterns from the examples.\n\n\n### Method 1:\n```java\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        // For ASSIGN and COMMA the value is the value of the RHS.\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n\n```\n\n\n---\n\n## \ud83c\udf1f Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations, comments, or extra text.\n",
                        "patches": [
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        return getImpureBooleanValue(n.getLastChild()).not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK: {\n        TernaryValue condValue = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue trueValue = getImpureBooleanValue(\n            n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (condValue == TernaryValue.TRUE) {\n          return trueValue;\n        } else if (condValue == TernaryValue.FALSE) {\n          return falseValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return TernaryValue.TRUE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK: {\n        TernaryValue conditionValue = getImpureBooleanValue(n.getFirstChild());\n        if (conditionValue.equals(TernaryValue.FALSE)) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else if (conditionValue.equals(TernaryValue.TRUE)) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          if (trueValue.equals(falseValue)) {\n            return trueValue;\n          } else {\n            return TernaryValue.UNKNOWN;\n          }\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // ignoring side-effects\n        return TernaryValue.TRUE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue conditionValue = getImpureBooleanValue(n.getFirstChild());\n        if (conditionValue == TernaryValue.TRUE) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else if (conditionValue == TernaryValue.FALSE) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          if (trueValue.equals(falseValue)) {\n            return trueValue;\n          } else {\n            return TernaryValue.UNKNOWN;\n          }\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        return TernaryValue.UNKNOWN;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        return getImpureBooleanValue(n.getLastChild()).not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        if (lhs == TernaryValue.FALSE) {\n          return TernaryValue.FALSE;\n        }\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        if (lhs == TernaryValue.TRUE) {\n          return TernaryValue.TRUE;\n        }\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK: {\n        TernaryValue condValue = getImpureBooleanValue(n.getFirstChild());\n        if (condValue == TernaryValue.TRUE) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else if (condValue == TernaryValue.FALSE) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          if (trueValue.equals(falseValue)) {\n            return trueValue;\n          } else {\n            return TernaryValue.UNKNOWN;\n          }\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return TernaryValue.TRUE;\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue condValue = getImpureBooleanValue(n.getFirstChild());\n        if (condValue.equals(TernaryValue.TRUE)) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else if (condValue.equals(TernaryValue.FALSE)) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          return trueValue.equals(falseValue) ? trueValue : TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return mayHaveSideEffects(n) ? TernaryValue.UNKNOWN : TernaryValue.TRUE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        if (lhs == TernaryValue.FALSE) {\n          return TernaryValue.FALSE;\n        }\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        if (lhs == TernaryValue.TRUE) {\n          return TernaryValue.TRUE;\n        }\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK: {\n        TernaryValue condition = getImpureBooleanValue(n.getFirstChild());\n        if (condition == TernaryValue.TRUE) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else if (condition == TernaryValue.FALSE) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          if (trueValue.equals(falseValue)) {\n            return trueValue;\n          } else {\n            return TernaryValue.UNKNOWN;\n          }\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n\n      case Token.OR: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n\n      case Token.HOOK: {\n        TernaryValue condValue = getImpureBooleanValue(n.getFirstChild());\n        if (condValue.equals(TernaryValue.TRUE)) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else if (condValue.equals(TernaryValue.FALSE)) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          return trueValue.equals(falseValue) ? trueValue : TernaryValue.UNKNOWN;\n        }\n      }\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return TernaryValue.TRUE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK:  {\n        TernaryValue condition = getImpureBooleanValue(n.getFirstChild());\n        if (condition == TernaryValue.TRUE) {\n          return getImpureBooleanValue(n.getFirstChild().getNext());\n        } else if (condition == TernaryValue.FALSE) {\n          return getImpureBooleanValue(n.getLastChild());\n        } else {\n          TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n          TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n          return trueValue.equals(falseValue) ? trueValue : TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return TernaryValue.TRUE;\n      \n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n      case Token.OR: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n      case Token.HOOK: {\n        TernaryValue condition = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n        if (condition == TernaryValue.TRUE) {\n          return trueValue;\n        } else if (condition == TernaryValue.FALSE) {\n          return falseValue;\n        } else if (trueValue.equals(falseValue)) {\n          return trueValue;\n        } else {\n          return TernaryValue.UNKNOWN;\n        }\n      }\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        return TernaryValue.UNKNOWN;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n",
                            "\n  static TernaryValue getImpureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n      case Token.COMMA:\n        return getImpureBooleanValue(n.getLastChild());\n\n      case Token.NOT:\n        TernaryValue value = getImpureBooleanValue(n.getLastChild());\n        return value.not();\n\n      case Token.AND: {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.and(rhs);\n      }\n\n      case Token.OR:  {\n        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n        return lhs.or(rhs);\n      }\n\n      case Token.HOOK:  {\n        TernaryValue conditionValue = getImpureBooleanValue(n.getFirstChild());\n        if (conditionValue.equals(TernaryValue.UNKNOWN)) {\n          return TernaryValue.UNKNOWN;\n        }\n        \n        TernaryValue trueValue = getImpureBooleanValue(n.getFirstChild().getNext());\n        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n\n        return trueValue.equals(falseValue) ? trueValue : TernaryValue.UNKNOWN;\n      }\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return mayHaveSideEffects(n) ? TernaryValue.UNKNOWN : TernaryValue.TRUE;\n\n      default:\n        return getPureBooleanValue(n);\n    }\n  }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/NodeUtil.java",
                "start_loc": 120,
                "end_loc": 163,
                "buggy_function": "  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                "fixed_function": "  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                "comment": "  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n",
                "normalized_body": [
                    "static TernaryValue getPureBooleanValue(Node n) { switch(n.getType()) { case Token.STRING: return TernaryValue.forBoolean(n.getString().length() > 0); case Token.NUMBER: return TernaryValue.forBoolean(n.getDouble() != 0); case Token.NOT: return getPureBooleanValue(n.getLastChild()).not(); case Token.NULL: case Token.FALSE: return TernaryValue.FALSE; case Token.VOID: return TernaryValue.FALSE; case Token.NAME: String name = n.getString(); if (\\\"undefined\\\".equals(name) || \\\"NaN\\\".equals(name)) { return TernaryValue.FALSE; } else if (\\\"Infinity\\\".equals(name)) { return TernaryValue.TRUE; } break; case Token.TRUE: case Token.REGEXP: return TernaryValue.TRUE; case Token.ARRAYLIT: case Token.OBJECTLIT: if (!mayHaveSideEffects(n)) { return TernaryValue.TRUE; } break; } return TernaryValue.UNKNOWN; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999999403953552,
                        "static TernaryValue getPureBooleanValue(Node n) { switch(n.getType()) { case Token.STRING: return TernaryValue.forBoolean(n.getString().length() > 0); case Token.NUMBER: return TernaryValue.forBoolean(n.getDouble() != 0); case Token.NOT: return getPureBooleanValue(n.getLastChild()).not(); case Token.NULL: case Token.FALSE: return TernaryValue.FALSE; case Token.VOID: return TernaryValue.FALSE; case Token.NAME: String name = n.getString(); if (\\\"undefined\\\".equals(name) || \\\"NaN\\\".equals(name)) { return TernaryValue.FALSE; } else if (\\\"Infinity\\\".equals(name)) { return TernaryValue.TRUE; } break; case Token.TRUE: case Token.REGEXP: return TernaryValue.TRUE; case Token.ARRAYLIT: case Token.OBJECTLIT: if (!mayHaveSideEffects(n)) { return TernaryValue.TRUE; } break; } return TernaryValue.UNKNOWN; }"
                    ],
                    [
                        0.9754072427749634,
                        "private void scanVars(Node n, Node parent) { switch(n.getType()) { case Token.VAR: for (Node child = n.getFirstChild(); child != null; ) { Node next = child.getNext(); declareVar(child); child = next; } return; case Token.FUNCTION: if (NodeUtil.isFunctionExpression(n)) { return; } String fnName = n.getFirstChild().getString(); if (fnName.isEmpty()) { return; } declareVar(n.getFirstChild()); return; case Token.CATCH: Preconditions.checkState(n.getChildCount() == 2); Preconditions.checkState(n.getFirstChild().getType() == Token.NAME); final Node var = n.getFirstChild(); final Node block = var.getNext(); declareVar(var); scanVars(block, n); return; case Token.SCRIPT: sourceName = n.getSourceFileName(); break; } if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) { for (Node child = n.getFirstChild(); child != null; ) { Node next = child.getNext(); scanVars(child, n); child = next; } } }"
                    ],
                    [
                        0.9721875190734863,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { attachLiteralTypes(t, n); switch(n.getType()) { case Token.CALL: checkForClassDefiningCalls(t, n, parent); break; case Token.FUNCTION: if (t.getInput() == null || !t.getInput().isExtern()) { nonExternFunctions.add(n); } if (!NodeUtil.isHoistedFunctionDeclaration(n)) { defineFunctionLiteral(n, parent); } break; case Token.ASSIGN: Node firstChild = n.getFirstChild(); if (firstChild.getType() == Token.GETPROP && firstChild.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), firstChild, n, firstChild.getNext()); } break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; case Token.GETPROP: if (parent.getType() == Token.EXPR_RESULT && n.isQualifiedName()) { maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null); } break; } }"
                    ],
                    [
                        0.9700243473052979,
                        "private Node trySimplifyUnusedResult(Node n, boolean removeUnused) { Node result = n; switch(n.getType()) { case Token.HOOK: Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext()); Node falseNode = trySimplifyUnusedResult(n.getLastChild()); if (trueNode == null && falseNode != null) { n.setType(Token.OR); Preconditions.checkState(n.getChildCount() == 2); } else if (trueNode != null && falseNode == null) { n.setType(Token.AND); Preconditions.checkState(n.getChildCount() == 2); } else if (trueNode == null && falseNode == null) { result = trySimplifyUnusedResult(n.getFirstChild()); } else { result = n; } break; case Token.AND: case Token.OR: Node conditionalResultNode = trySimplifyUnusedResult(n.getLastChild()); if (conditionalResultNode == null) { Preconditions.checkState(n.hasOneChild()); result = trySimplifyUnusedResult(n.getFirstChild()); } break; case Token.FUNCTION: result = null; break; case Token.COMMA: Node left = trySimplifyUnusedResult(n.getFirstChild()); Node right = trySimplifyUnusedResult(n.getLastChild()); if (left == null && right == null) { result = null; } else if (left == null) { result = right; } else if (right == null) { result = left; } else { result = n; } break; default: if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) { Node resultList = null; for (Node next, c = n.getFirstChild(); c != null; c = next) { next = c.getNext(); c = trySimplifyUnusedResult(c); if (c != null) { c.detachFromParent(); if (resultList == null) { resultList = c; } else { resultList = new Node(Token.COMMA, resultList, c).copyInformationFrom(c); } } } result = resultList; } } if (n != result) { Node parent = n.getParent(); if (result == null) { if (removeUnused) { parent.removeChild(n); } else { result = new Node(Token.EMPTY).copyInformationFrom(n); parent.replaceChild(n, result); } } else { if (result.getParent() != null) { result.detachFromParent(); } n.getParent().replaceChild(n, result); } reportCodeChange(); } return result; }"
                    ],
                    [
                        0.9690524339675903,
                        "private Node tryFoldTypeof(Node originalTypeofNode) { Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF); Node argumentNode = originalTypeofNode.getFirstChild(); if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode, true)) { return originalTypeofNode; } String typeNameString = null; switch(argumentNode.getType()) { case Token.FUNCTION: typeNameString = \\\"function\\\"; break; case Token.STRING: typeNameString = \\\"string\\\"; break; case Token.NUMBER: typeNameString = \\\"number\\\"; break; case Token.TRUE: case Token.FALSE: typeNameString = \\\"boolean\\\"; break; case Token.NULL: case Token.OBJECTLIT: case Token.ARRAYLIT: typeNameString = \\\"object\\\"; break; case Token.VOID: typeNameString = \\\"undefined\\\"; break; case Token.NAME: if (\\\"undefined\\\".equals(argumentNode.getString())) { typeNameString = \\\"undefined\\\"; } break; } if (typeNameString != null) { Node newNode = Node.newString(typeNameString); originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode); reportCodeChange(); return newNode; } return originalTypeofNode; }"
                    ],
                    [
                        0.9667955636978149,
                        "private void processStringNode(NodeTraversal t, Node n) { String name = n.getString(); String[] parts = name.split(\\\"-\\\"); if (symbolMap != null) { String replacement = null; switch(symbolMap.getStyle()) { case BY_WHOLE: replacement = symbolMap.get(name); if (replacement == null) { compiler.report(t.makeError(n, UNKNOWN_SYMBOL_WARNING, name, name)); return; } break; case BY_PART: String[] replaced = new String[parts.length]; for (int i = 0; i < parts.length; i++) { String part = symbolMap.get(parts[i]); if (part == null) { compiler.report(t.makeError(n, UNKNOWN_SYMBOL_WARNING, parts[i], name)); return; } replaced[i] = part; } replacement = Joiner.on(\\\"-\\\").join(replaced); break; default: throw new IllegalStateException(\\\"Unknown replacement style: \\\" + symbolMap.getStyle()); } n.setString(replacement); } if (cssNames != null) { for (int i = 0; i < parts.length; i++) { Integer count = cssNames.get(parts[i]); if (count == null) { count = Integer.valueOf(0); } cssNames.put(parts[i], count.intValue() + 1); } } }"
                    ],
                    [
                        0.9661349058151245,
                        "private AstNode statementHelper() throws IOException { if (currentLabel != null && currentLabel.getStatement() != null) currentLabel = null; AstNode pn = null; int tt = peekToken(), pos = ts.tokenBeg; switch(tt) { case Token.IF: return ifStatement(); case Token.SWITCH: return switchStatement(); case Token.WHILE: return whileLoop(); case Token.DO: return doLoop(); case Token.FOR: return forLoop(); case Token.TRY: return tryStatement(); case Token.THROW: pn = throwStatement(); break; case Token.BREAK: pn = breakStatement(); break; case Token.CONTINUE: pn = continueStatement(); break; case Token.WITH: if (this.inUseStrictDirective) { reportError(\\\"msg.no.with.strict\\\"); } return withStatement(); case Token.CONST: case Token.VAR: consumeToken(); int lineno = ts.lineno; pn = variables(currentToken, ts.tokenBeg); pn.setLineno(lineno); break; case Token.LET: pn = letStatement(); if (pn instanceof VariableDeclaration && peekToken() == Token.SEMI) break; return pn; case Token.RETURN: case Token.YIELD: pn = returnOrYield(tt, false); break; case Token.DEBUGGER: consumeToken(); pn = new KeywordLiteral(ts.tokenBeg, ts.tokenEnd - ts.tokenBeg, tt); pn.setLineno(ts.lineno); break; case Token.LC: return block(); case Token.ERROR: consumeToken(); return makeErrorNode(); case Token.SEMI: consumeToken(); pos = ts.tokenBeg; pn = new EmptyExpression(pos, ts.tokenEnd - pos); pn.setLineno(ts.lineno); return pn; case Token.FUNCTION: consumeToken(); return function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT); case Token.DEFAULT: pn = defaultXmlNamespace(); break; case Token.NAME: pn = nameOrLabel(); if (pn instanceof ExpressionStatement) break; return pn; default: lineno = ts.lineno; pn = new ExpressionStatement(expr(), !insideFunction()); pn.setLineno(lineno); break; } autoInsertSemicolon(pn); return pn; }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.CommandLineRunnerTest::testIssue504",
                    "com.google.javascript.jscomp.NodeUtilTest::testGetBooleanValue"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue504() {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"void function() { alert('hi'); }();\",\n         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: alert(\"hi\")\nResult: \nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: input0]\n        EXPR_RESULT 1 [source_file: input0]\n            CALL 1 [free_call: 1] [source_file: input0]\n                NAME alert 1 [source_file: input0]\n                STRING hi 1 [source_file: input0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: input0]\n\n\nSubtree1: SCRIPT 1 [synthetic: 1] [source_file: input0]\n    EXPR_RESULT 1 [source_file: input0]\n        CALL 1 [free_call: 1] [source_file: input0]\n            NAME alert 1 [source_file: input0]\n            STRING hi 1 [source_file: input0]\n\n\nSubtree2: SCRIPT 1 [synthetic: 1] [source_file: input0]\n\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:861)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +          \"\\nResult: \" + compiler.toSource(root) +          \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:875)  test(new String[] { original }, new String[] { expected }, warning);\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.testIssue504(CommandLineRunnerTest.java:365)  test(\"void function() { alert('hi'); }();\",         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n \n#Test method 2:\n```java\n  public void testGetBooleanValue() {\n    assertPureBooleanTrue(\"true\");\n    assertPureBooleanTrue(\"10\");\n    assertPureBooleanTrue(\"'0'\");\n    assertPureBooleanTrue(\"/a/\");\n    assertPureBooleanTrue(\"{}\");\n    assertPureBooleanTrue(\"[]\");\n    assertPureBooleanFalse(\"false\");\n    assertPureBooleanFalse(\"null\");\n    assertPureBooleanFalse(\"0\");\n    assertPureBooleanFalse(\"''\");\n    assertPureBooleanFalse(\"undefined\");\n    assertPureBooleanFalse(\"void 0\");\n    assertPureBooleanUnknown(\"void foo()\");\n    assertPureBooleanUnknown(\"b\");\n    assertPureBooleanUnknown(\"-'0.0'\");\n\n    // Known but getBooleanValue return false for expressions with side-effects\n    assertPureBooleanUnknown(\"{a:foo()}\");\n    assertPureBooleanUnknown(\"[foo()]\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<unknown> but was:<false>\n\tat com.google.javascript.jscomp.NodeUtilTest.assertPureBooleanUnknown(NodeUtilTest.java:123)  assertEquals(        TernaryValue.UNKNOWN, NodeUtil.getPureBooleanValue(getNode(val)));\n\tat com.google.javascript.jscomp.NodeUtilTest.testGetBooleanValue(NodeUtilTest.java:104)  assertPureBooleanUnknown(\"void foo()\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (n.hasOneChild() && n.getFirstChild().getType() == Token.FUNCTION) {\n          return TernaryValue.UNKNOWN;\n        }\n        return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (n.hasChildren()) { // Check for side-effects in void expressions\n          return TernaryValue.UNKNOWN;\n        }\n        return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        return TernaryValue.UNKNOWN; // Changed from FALSE to UNKNOWN\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (n.getFirstChild() != null) {\n          // If void has an expression with side-effects, its boolean value is unknown\n          return TernaryValue.UNKNOWN;\n        }\n        return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name) || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.FUNCTION:\n        return TernaryValue.UNKNOWN; // Functions can have side effects\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          Node child = n.getFirstChild();\n          if (child != null && mayHaveSideEffects(child)) {\n            return TernaryValue.UNKNOWN;\n          }\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  /**\n   * Gets the boolean value of a node that represents a literal. This method\n   * effectively emulates the <code>Boolean()</code> JavaScript cast function\n   * except it return UNKNOWN for known values with side-effects, use\n   * getExpressionBooleanValue if you don't care about side-effects.\n   */\n\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.VOID_TYPE:\n      case Token.FUNCTION:\n        return TernaryValue.UNKNOWN;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n"
                        ],
                        "plausible_patches": [
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          Node child = n.getFirstChild();\n          if (child != null && mayHaveSideEffects(child)) {\n            return TernaryValue.UNKNOWN;\n          }\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n          Node child = n.getFirstChild();\n          if (child != null && mayHaveSideEffects(child)) {\n            return TernaryValue.UNKNOWN;\n          }\n          return TernaryValue.FALSE;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n",
                            "\n  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.CommandLineRunnerTest::testIssue504": {
                "path": "test/com/google/javascript/jscomp/CommandLineRunnerTest.java",
                "function_name": "testIssue504",
                "src": "  public void testIssue504() {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"void function() { alert('hi'); }();\",\n         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: alert(\"hi\")\nResult: \nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: input0]\n        EXPR_RESULT 1 [source_file: input0]\n            CALL 1 [free_call: 1] [source_file: input0]\n                NAME alert 1 [source_file: input0]\n                STRING hi 1 [source_file: input0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: input0]\n\n\nSubtree1: SCRIPT 1 [synthetic: 1] [source_file: input0]\n    EXPR_RESULT 1 [source_file: input0]\n        CALL 1 [free_call: 1] [source_file: input0]\n            NAME alert 1 [source_file: input0]\n            STRING hi 1 [source_file: input0]\n\n\nSubtree2: SCRIPT 1 [synthetic: 1] [source_file: input0]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:861)\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:875)\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.testIssue504(CommandLineRunnerTest.java:365)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: alert(\"hi\")\nResult: \nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: input0]\n        EXPR_RESULT 1 [source_file: input0]\n            CALL 1 [free_call: 1] [source_file: input0]\n                NAME alert 1 [source_file: input0]\n                STRING hi 1 [source_file: input0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [synthetic: 1] [source_file: input0]\n\n\nSubtree1: SCRIPT 1 [synthetic: 1] [source_file: input0]\n    EXPR_RESULT 1 [source_file: input0]\n        CALL 1 [free_call: 1] [source_file: input0]\n            NAME alert 1 [source_file: input0]\n            STRING hi 1 [source_file: input0]\n\n\nSubtree2: SCRIPT 1 [synthetic: 1] [source_file: input0]\n\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:861)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +          \"\\nResult: \" + compiler.toSource(root) +          \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:875)  test(new String[] { original }, new String[] { expected }, warning);\n\tat com.google.javascript.jscomp.CommandLineRunnerTest.testIssue504(CommandLineRunnerTest.java:365)  test(\"void function() { alert('hi'); }();\",         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);"
            },
            "com.google.javascript.jscomp.NodeUtilTest::testGetBooleanValue": {
                "path": "test/com/google/javascript/jscomp/NodeUtilTest.java",
                "function_name": "testGetBooleanValue",
                "src": "  public void testGetBooleanValue() {\n    assertPureBooleanTrue(\"true\");\n    assertPureBooleanTrue(\"10\");\n    assertPureBooleanTrue(\"'0'\");\n    assertPureBooleanTrue(\"/a/\");\n    assertPureBooleanTrue(\"{}\");\n    assertPureBooleanTrue(\"[]\");\n    assertPureBooleanFalse(\"false\");\n    assertPureBooleanFalse(\"null\");\n    assertPureBooleanFalse(\"0\");\n    assertPureBooleanFalse(\"''\");\n    assertPureBooleanFalse(\"undefined\");\n    assertPureBooleanFalse(\"void 0\");\n    assertPureBooleanUnknown(\"void foo()\");\n    assertPureBooleanUnknown(\"b\");\n    assertPureBooleanUnknown(\"-'0.0'\");\n\n    // Known but getBooleanValue return false for expressions with side-effects\n    assertPureBooleanUnknown(\"{a:foo()}\");\n    assertPureBooleanUnknown(\"[foo()]\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<unknown> but was:<false>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:86)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:253)\n\tat com.google.javascript.jscomp.NodeUtilTest.assertPureBooleanUnknown(NodeUtilTest.java:123)\n\tat com.google.javascript.jscomp.NodeUtilTest.testGetBooleanValue(NodeUtilTest.java:104)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<unknown> but was:<false>\n\tat com.google.javascript.jscomp.NodeUtilTest.assertPureBooleanUnknown(NodeUtilTest.java:123)  assertEquals(        TernaryValue.UNKNOWN, NodeUtil.getPureBooleanValue(getNode(val)));\n\tat com.google.javascript.jscomp.NodeUtilTest.testGetBooleanValue(NodeUtilTest.java:104)  assertPureBooleanUnknown(\"void foo()\");"
            }
        },
        "evaluation_done": true,
        "generation_done_for_notest_methods": true
    }
}