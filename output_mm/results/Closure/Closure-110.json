{
    "Closure-110": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/ScopedAliases.java",
                "start_loc": 352,
                "end_loc": 422,
                "buggy_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n",
                "fixed_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n          Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n              null;\n          Node varNode = null;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n          if (isFunctionDecl) {\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            Node existingName = v.getNameNode();\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n              grandparent.addChildBefore(newDecl, varNode);\n            }\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \\\"$jscomp.scope.\\\" + name + (nameCount == 0 ? \\\"\\\" : (\\\"$\\\" + nameCount)); compiler.ensureLibraryInjected(\\\"base\\\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVar = parent.isVar(); if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVar) { Node grandparent = parent.getParent(); Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null; Node varNode = parent; String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \\\"$jscomp.scope.\\\" + name + (nameCount == 0 ? \\\"\\\" : (\\\"$\\\" + nameCount)); compiler.ensureLibraryInjected(\\\"base\\\"); if (value != null || v.getJSDocInfo() != null) { Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name); grandparent.addChildBefore(newDecl, varNode); } v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }"
                    ],
                    [
                        0.9934110045433044,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } }"
                    ],
                    [
                        0.9930992126464844,
                        "private void transformCompilationUnit_r(final ScriptNode tree, final Node parent, Scope scope, boolean createScopeObjects, boolean inStrictMode) { Node node = null; siblingLoop: for (; ; ) { Node previous = null; if (node == null) { node = parent.getFirstChild(); } else { previous = node; node = node.getNext(); } if (node == null) { break; } int type = node.getType(); if (createScopeObjects && (type == Token.BLOCK || type == Token.LOOP || type == Token.ARRAYCOMP) && (node instanceof Scope)) { Scope newScope = (Scope) node; if (newScope.getSymbolTable() != null) { Node let = new Node(type == Token.ARRAYCOMP ? Token.LETEXPR : Token.LET); Node innerLet = new Node(Token.LET); let.addChildToBack(innerLet); for (String name : newScope.getSymbolTable().keySet()) { innerLet.addChildToBack(Node.newString(Token.NAME, name)); } newScope.setSymbolTable(null); Node oldNode = node; node = replaceCurrent(parent, previous, node, let); type = node.getType(); let.addChildToBack(oldNode); } } switch(type) { case Token.LABEL: case Token.SWITCH: case Token.LOOP: loops.push(node); loopEnds.push(((Jump) node).target); break; case Token.WITH: { loops.push(node); Node leave = node.getNext(); if (leave.getType() != Token.LEAVEWITH) { Kit.codeBug(); } loopEnds.push(leave); break; } case Token.TRY: { Jump jump = (Jump) node; Node finallytarget = jump.getFinally(); if (finallytarget != null) { hasFinally = true; loops.push(node); loopEnds.push(finallytarget); } break; } case Token.TARGET: case Token.LEAVEWITH: if (!loopEnds.isEmpty() && loopEnds.peek() == node) { loopEnds.pop(); loops.pop(); } break; case Token.YIELD: ((FunctionNode) tree).addResumptionPoint(node); break; case Token.RETURN: { boolean isGenerator = tree.getType() == Token.FUNCTION && ((FunctionNode) tree).isGenerator(); if (isGenerator) { node.putIntProp(Node.GENERATOR_END_PROP, 1); } if (!hasFinally) break; Node unwindBlock = null; for (int i = loops.size() - 1; i >= 0; i--) { Node n = (Node) loops.get(i); int elemtype = n.getType(); if (elemtype == Token.TRY || elemtype == Token.WITH) { Node unwind; if (elemtype == Token.TRY) { Jump jsrnode = new Jump(Token.JSR); Node jsrtarget = ((Jump) n).getFinally(); jsrnode.target = jsrtarget; unwind = jsrnode; } else { unwind = new Node(Token.LEAVEWITH); } if (unwindBlock == null) { unwindBlock = new Node(Token.BLOCK, node.getLineno()); } unwindBlock.addChildToBack(unwind); } } if (unwindBlock != null) { Node returnNode = node; Node returnExpr = returnNode.getFirstChild(); node = replaceCurrent(parent, previous, node, unwindBlock); if (returnExpr == null || isGenerator) { unwindBlock.addChildToBack(returnNode); } else { Node store = new Node(Token.EXPR_RESULT, returnExpr); unwindBlock.addChildToFront(store); returnNode = new Node(Token.RETURN_RESULT); unwindBlock.addChildToBack(returnNode); transformCompilationUnit_r(tree, store, scope, createScopeObjects, inStrictMode); } continue siblingLoop; } break; } case Token.BREAK: case Token.CONTINUE: { Jump jump = (Jump) node; Jump jumpStatement = jump.getJumpStatement(); if (jumpStatement == null) Kit.codeBug(); for (int i = loops.size(); ; ) { if (i == 0) { throw Kit.codeBug(); } --i; Node n = (Node) loops.get(i); if (n == jumpStatement) { break; } int elemtype = n.getType(); if (elemtype == Token.WITH) { Node leave = new Node(Token.LEAVEWITH); previous = addBeforeCurrent(parent, previous, node, leave); } else if (elemtype == Token.TRY) { Jump tryNode = (Jump) n; Jump jsrFinally = new Jump(Token.JSR); jsrFinally.target = tryNode.getFinally(); previous = addBeforeCurrent(parent, previous, node, jsrFinally); } } if (type == Token.BREAK) { jump.target = jumpStatement.target; } else { jump.target = jumpStatement.getContinue(); } jump.setType(Token.GOTO); break; } case Token.CALL: visitCall(node, tree); break; case Token.NEW: visitNew(node, tree); break; case Token.LETEXPR: case Token.LET: { Node child = node.getFirstChild(); if (child.getType() == Token.LET) { boolean createWith = tree.getType() != Token.FUNCTION || ((FunctionNode) tree).requiresActivation(); node = visitLet(createWith, parent, previous, node); break; } else { } } case Token.CONST: case Token.VAR: { Node result = new Node(Token.BLOCK); for (Node cursor = node.getFirstChild(); cursor != null; ) { Node n = cursor; cursor = cursor.getNext(); if (n.getType() == Token.NAME) { if (!n.hasChildren()) continue; Node init = n.getFirstChild(); n.removeChild(init); n.setType(Token.BINDNAME); n = new Node(type == Token.CONST ? Token.SETCONST : Token.SETNAME, n, init); } else { if (n.getType() != Token.LETEXPR) throw Kit.codeBug(); } Node pop = new Node(Token.EXPR_VOID, n, node.getLineno()); result.addChildToBack(pop); } node = replaceCurrent(parent, previous, node, result); break; } case Token.TYPEOFNAME: { Scope defining = scope.getDefiningScope(node.getString()); if (defining != null) { node.setScope(defining); } } break; case Token.TYPEOF: case Token.IFNE: { Node child = node.getFirstChild(); if (type == Token.IFNE) { while (child.getType() == Token.NOT) { child = child.getFirstChild(); } if (child.getType() == Token.EQ || child.getType() == Token.NE) { Node first = child.getFirstChild(); Node last = child.getLastChild(); if (first.getType() == Token.NAME && first.getString().equals(\\\"undefined\\\")) child = last; else if (last.getType() == Token.NAME && last.getString().equals(\\\"undefined\\\")) child = first; } } if (child.getType() == Token.GETPROP) child.setType(Token.GETPROPNOWARN); break; } case Token.SETNAME: if (inStrictMode) { node.setType(Token.STRICT_SETNAME); } case Token.NAME: case Token.SETCONST: case Token.DELPROP: { if (createScopeObjects) { break; } Node nameSource; if (type == Token.NAME) { nameSource = node; } else { nameSource = node.getFirstChild(); if (nameSource.getType() != Token.BINDNAME) { if (type == Token.DELPROP) { break; } throw Kit.codeBug(); } } if (nameSource.getScope() != null) { break; } String name = nameSource.getString(); Scope defining = scope.getDefiningScope(name); if (defining != null) { nameSource.setScope(defining); if (type == Token.NAME) { node.setType(Token.GETVAR); } else if (type == Token.SETNAME || type == Token.STRICT_SETNAME) { node.setType(Token.SETVAR); nameSource.setType(Token.STRING); } else if (type == Token.SETCONST) { node.setType(Token.SETCONSTVAR); nameSource.setType(Token.STRING); } else if (type == Token.DELPROP) { Node n = new Node(Token.FALSE); node = replaceCurrent(parent, previous, node, n); } else { throw Kit.codeBug(); } } break; } } transformCompilationUnit_r(tree, node, node instanceof Scope ? (Scope) node : scope, createScopeObjects, inStrictMode); } }"
                    ],
                    [
                        0.9923907518386841,
                        "static XML createFromJS(XMLLibImpl lib, Object inputObject) { XmlObject xo; boolean isText = false; String frag; if (inputObject == null || inputObject == Undefined.instance) { frag = \\\"\\\"; } else if (inputObject instanceof XMLObjectImpl) { frag = ((XMLObjectImpl) inputObject).toXMLString(0); } else { if (inputObject instanceof Wrapper) { Object wrapped = ((Wrapper) inputObject).unwrap(); if (wrapped instanceof XmlObject) { return createFromXmlObject(lib, (XmlObject) wrapped); } } frag = ScriptRuntime.toString(inputObject); } if (frag.trim().startsWith(\\\"<>\\\")) { throw ScriptRuntime.typeError(\\\"Invalid use of XML object anonymous tags <></>.\\\"); } if (frag.indexOf(\\\"<\\\") == -1) { isText = true; frag = \\\"<textFragment>\\\" + frag + \\\"</textFragment>\\\"; } XmlOptions options = new XmlOptions(); if (lib.ignoreComments) { options.put(XmlOptions.LOAD_STRIP_COMMENTS); } if (lib.ignoreProcessingInstructions) { options.put(XmlOptions.LOAD_STRIP_PROCINSTS); } if (lib.ignoreWhitespace) { options.put(XmlOptions.LOAD_STRIP_WHITESPACE); } try { xo = XmlObject.Factory.parse(frag, options); Context cx = Context.getCurrentContext(); String defaultURI = lib.getDefaultNamespaceURI(cx); if (defaultURI.length() > 0) { XmlCursor cursor = xo.newCursor(); boolean isRoot = true; while (!cursor.toNextToken().isEnddoc()) { if (!cursor.isStart()) continue; boolean defaultNSDeclared = false; cursor.push(); while (cursor.toNextToken().isAnyAttr()) { if (cursor.isNamespace()) { if (cursor.getName().getLocalPart().length() == 0) { defaultNSDeclared = true; break; } } } cursor.pop(); if (defaultNSDeclared) { cursor.toEndToken(); continue; } javax.xml.namespace.QName qname = cursor.getName(); if (qname.getNamespaceURI().length() == 0) { qname = new javax.xml.namespace.QName(defaultURI, qname.getLocalPart()); cursor.setName(qname); } if (isRoot) { cursor.push(); cursor.toNextToken(); cursor.insertNamespace(\\\"\\\", defaultURI); cursor.pop(); isRoot = false; } } cursor.dispose(); } } catch (XmlException xe) { String errMsg = xe.getMessage(); if (errMsg.equals(\\\"error: Unexpected end of file after null\\\")) { xo = XmlObject.Factory.newInstance(); } else { throw ScriptRuntime.typeError(xe.getMessage()); } } catch (Throwable e) { throw ScriptRuntime.typeError(\\\"Not Parsable as XML\\\"); } XmlCursor curs = xo.newCursor(); if (curs.currentTokenType().isStartdoc()) { curs.toFirstContentToken(); } if (isText) { curs.toFirstContentToken(); } XScriptAnnotation anno; try { anno = new XScriptAnnotation(curs); curs.setBookmark(anno); } finally { curs.dispose(); } return new XML(lib, anno); }"
                    ],
                    [
                        0.9920725226402283,
                        "private void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild(); Node rvalue = assign.getLastChild(); if (lvalue.isGetProp()) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); Node property = lvalue.getLastChild(); String pname = property.getString(); if (object.isGetProp()) { JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\\\"prototype\\\")) { visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue); } } checkEnumAlias(t, info, rvalue); checkPropCreation(t, lvalue); if (pname.equals(\\\"prototype\\\")) { if (objectJsType != null && objectJsType.isFunctionType()) { FunctionType functionType = objectJsType.toMaybeFunctionType(); if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); if (functionType.makesStructs() && !rvalueType.isStruct()) { String funName = functionType.getTypeOfThis().toString(); compiler.report(t.makeError(assign, CONFLICTING_SHAPE_TYPE, \\\"struct\\\", funName)); } return; } } } ObjectType type = ObjectType.cast(objectJsType.restrictByNotNullOrUndefined()); if (type != null) { if (type.hasProperty(pname) && !type.isPropertyTypeInferred(pname) && !propertyIsImplicitCast(type, pname)) { JSType expectedType = type.getPropertyType(pname); if (!expectedType.isUnknownType()) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), expectedType, object, pname); checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, expectedType); return; } } } checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE)); } JSType leftType = getJSType(lvalue); if (lvalue.isQualifiedName()) { Var var = t.getScope().getVar(lvalue.getQualifiedName()); if (var != null) { if (var.isTypeInferred()) { return; } if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() && t.getScope() != var.getScope()) { return; } if (var.getType() != null) { leftType = var.getType(); } } } Node rightChild = assign.getLastChild(); JSType rightType = getJSType(rightChild); if (validator.expectCanAssignTo(t, assign, rightType, leftType, \\\"assignment\\\")) { ensureTyped(t, assign, rightType); } else { ensureTyped(t, assign); } }"
                    ],
                    [
                        0.9920347929000854,
                        "@Override public void visit(NodeTraversal traversal, Node node, Node parent) { String messageKey; boolean isVar; Node msgNode, msgNodeParent; switch(node.getType()) { case Token.NAME: if ((parent != null) && (parent.isVar())) { messageKey = node.getString(); isVar = true; } else { return; } msgNode = node.getFirstChild(); msgNodeParent = node; break; case Token.ASSIGN: isVar = false; Node getProp = node.getFirstChild(); if (!getProp.isGetProp()) { return; } Node propNode = getProp.getLastChild(); messageKey = propNode.getString(); msgNode = node.getLastChild(); msgNodeParent = node; break; case Token.CALL: String fnName = node.getFirstChild().getQualifiedName(); if (MSG_FUNCTION_NAME.equals(fnName)) { googMsgNodes.put(node, traversal.getSourceName()); } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) { visitFallbackFunctionCall(traversal, node); } return; default: return; } boolean isNewStyleMessage = msgNode != null && msgNode.isCall(); if (!isMessageName(messageKey, isNewStyleMessage)) { return; } if (msgNode == null) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey)); return; } if (isNewStyleMessage) { googMsgNodes.remove(msgNode); } else if (style != JsMessage.Style.LEGACY) { compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX)); } boolean isUnnamedMsg = isUnnamedMessageName(messageKey); Builder builder = new Builder(isUnnamedMsg ? null : messageKey); builder.setSourceName(traversal.getSourceName()); try { if (isVar) { extractMessageFromVariable(builder, node, parent, parent.getParent()); } else { extractMessageFromProperty(builder, node.getFirstChild(), node); } } catch (MalformedException ex) { compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage())); return; } JsMessage extractedMessage = builder.build(idGenerator); if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) { checkIfMessageDuplicated(messageKey, msgNode); } trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg); if (extractedMessage.isEmpty()) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey)); } String desc = extractedMessage.getDesc(); if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey)); } JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent); processJsMessage(extractedMessage, msgDefinition); }"
                    ],
                    [
                        0.9918299913406372,
                        "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined(); case Token.QMARK: Node firstChild = n.getFirstChild(); if (firstChild == null) { return getNativeType(UNKNOWN_TYPE); } return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope)); case Token.EQUALS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if ((namedType instanceof ObjectType) && !(namedType instanceof NamespaceType) && !(nonNullableTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); int nAllowedTypes = namedType.getTemplateTypeMap().numUnfilledTemplateKeys(); if (typeList != null && nAllowedTypes > 0) { ImmutableList.Builder<JSType> templateTypes = ImmutableList.builder(); if (n.getString().equals(\\\"Object\\\") && typeList.getFirstChild() == typeList.getLastChild()) { templateTypes.add(getNativeType(UNKNOWN_TYPE)); } int templateNodeIndex = 0; for (Node templateNode : typeList.getFirstChild().siblings()) { if (++templateNodeIndex > nAllowedTypes) { break; } templateTypes.add(createFromTypeNodesInternal(templateNode, sourceName, scope)); } namedType = createTemplatizedType((ObjectType) namedType, templateTypes.build()); Preconditions.checkNotNull(namedType); } return createDefaultObjectUnion(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; boolean isConstructor = false; Node current = n.getFirstChild(); if (current.getType() == Token.THIS || current.getType() == Token.NEW) { Node contextNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(SimpleErrorReporter.getMessage0(current.getType() == Token.THIS ? \\\"msg.jsdoc.function.thisnotobject\\\" : \\\"msg.jsdoc.function.newnotobject\\\"), sourceName, contextNode.getLineno(), contextNode.getCharno()); } isConstructor = current.getType() == Token.NEW; current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.PARAM_LIST) { for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope)); } } else { JSType type = createFromTypeNodesInternal(arg, sourceName, scope); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(SimpleErrorReporter.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodesInternal(current, sourceName, scope); return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build(); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.ScopedAliasesTest::testHoistedFunctionDeclaration",
                    "com.google.javascript.jscomp.ScopedAliasesTest::testFunctionDeclaration"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)  test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testHoistedFunctionDeclaration(ScopedAliasesTest.java:522)  testScoped(\" g(f); function f() {} \",               SCOPE_NAMESPACE +               \" $jscomp.scope.f = function () {}; \" +               \"g($jscomp.scope.f); \");\n \n#Test method 2:\n```java\n  public void testFunctionDeclaration() {\n    testScoped(\"if (x) { function f() {} } g(f)\",\n               SCOPE_NAMESPACE +\n               \"if (x) { $jscomp.scope.f = function () {}; } \" +\n               \"g($jscomp.scope.f); \");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)  test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testFunctionDeclaration(ScopedAliasesTest.java:515)  testScoped(\"if (x) { function f() {} } g(f)\",               SCOPE_NAMESPACE +               \"if (x) { $jscomp.scope.f = function () {}; } \" +               \"g($jscomp.scope.f); \");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    boolean isFunctionDeclaration = parent.isFunction();\n    \n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar || isFunctionDeclaration) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n      Node currentNode = isVar ? parent : n;\n      \n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, currentNode);\n      }\n\n      if (isVar) {\n        v.getNameNode().addChildToFront(\n            NodeUtil.newQualifiedNameNode(\n                compiler.getCodingConvention(), globalName, n, name));\n      } else {\n        parent.replaceChild(n, NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(), globalName, n, name));\n      }\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    boolean isFunction = n.isFunction();\n\n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS error.\n    } else if (isVar || isFunction) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ? v.getInitialValue() : null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (isFunction) {\n        // Detach the function if it's declared inside an expression.\n        value = value.detachFromParent();\n      } else if (value != null) {\n        // Detach the value for other VAR declarations.\n        value = value.detachFromParent();\n      }\n\n      // Add $jscomp.scope.name = EXPR;\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    \n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar || NodeUtil.isStatement(parent)) {\n      // Allow function declarations to be handled as aliases.\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // Add $jscomp.scope.name = EXPR;\n      // Make sure we copy over all the jsdoc and debug info.\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not handle other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n\n    if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.isFunction()) {\n      // Handle function declarations.\n      // Record an alias for function declarations, since these need to be\n      // rewritten in goog.scope to prevent scope leakage.\n      recordAlias(v);\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // Parent is the function node, we want to detach it but keep the name.\n      if (parent.isFunction()) {\n        Node grandparent = parent.getParent();\n        Node value = parent.detachFromParent();\n        Node varNode = parent;\n\n        if (value != null || v.getJSDocInfo() != null) {\n          Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n              compiler.getCodingConvention(),\n              globalName,\n              value,\n              v.getJSDocInfo())\n              .useSourceInfoIfMissingFromForTree(n);\n          NodeUtil.setDebugInformation(\n              newDecl.getFirstChild().getFirstChild(), n, name);\n\n          grandparent.addChildBefore(newDecl, varNode);\n        }\n        \n        // Rewrite the function declaration to an alias.\n        Node alias = NodeUtil.newQualifiedNameNode(\n            compiler.getCodingConvention(), globalName, n, name);\n        NodeUtil.replaceDeclarationChildWithAlias(v, n, alias);\n        grandparent.replaceChild(n, new Node(Token.EXPR_RESULT, alias));\n      }\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS error.\n    } else if (parent.isVar() && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (parent.isVar()) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        \n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || n.getType() == Token.FUNCTION && parent.getType() == Token.SCRIPT) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ?\n                v.getInitialValue().detachFromParent() :\n                null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value,\n                    v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                    newDecl.getFirstChild().getFirstChild(), n, name);\n\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    boolean isFunctionDecl = parent.isFunction() && parent.getChildAtIndex(0) == n;\n\n    if ((isVar || isFunctionDecl) && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar || isFunctionDecl) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (parent.isFunction()) {\n            // Handle function declarations as aliases\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                        compiler.getCodingConvention(),\n                        globalName,\n                        value,\n                        v.getJSDocInfo())\n                        .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                        newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, parent);\n            }\n\n            parent.getFirstChild().addChildToFront(\n                    NodeUtil.newQualifiedNameNode(\n                            compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren()\n                    ? v.getInitialValue().detachFromParent()\n                    : null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                    \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                        compiler.getCodingConvention(),\n                        globalName,\n                        value,\n                        v.getJSDocInfo())\n                        .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                        newDecl.getFirstChild().getFirstChild(), n, name);\n\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            v.getNameNode().addChildToFront(\n                    NodeUtil.newQualifiedNameNode(\n                            compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    \n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS error.\n    } else if (isVar || NodeUtil.isFunctionDeclaration(n)) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not process other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (parent.isFunction() || (isVar && v.getInitialValue() != null && v.getInitialValue().isFunction())) {\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                        compiler.getCodingConvention(),\n                        globalName,\n                        value,\n                        v.getJSDocInfo())\n                        .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                        newDecl.getFirstChild().getFirstChild(), n, name);\n\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            // Rewrite \"var name = EXPR;\" or \"function name() {}\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                    NodeUtil.newQualifiedNameNode(\n                            compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // If it's a function declaration, convert it to a function expression\n      if (value != null && value.isFunction()) {\n        value.putProp(Node.FUNCTION_PROP, null); // Clear any function prop\n      }\n\n      // Add $jscomp.scope.name = EXPR;\n      // Make sure we copy over all the jsdoc and debug info.\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)  test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testHoistedFunctionDeclaration(ScopedAliasesTest.java:522)  testScoped(\" g(f); function f() {} \",               SCOPE_NAMESPACE +               \" $jscomp.scope.f = function () {}; \" +               \"g($jscomp.scope.f); \");\n \n#Test method 2:\n```java\n  public void testFunctionDeclaration() {\n    testScoped(\"if (x) { function f() {} } g(f)\",\n               SCOPE_NAMESPACE +\n               \"if (x) { $jscomp.scope.f = function () {}; } \" +\n               \"g($jscomp.scope.f); \");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)  test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testFunctionDeclaration(ScopedAliasesTest.java:515)  testScoped(\"if (x) { function f() {} } g(f)\",               SCOPE_NAMESPACE +               \"if (x) { $jscomp.scope.f = function () {}; } \" +               \"g($jscomp.scope.f); \");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\n@Override public void visit(NodeTraversal t, Node n, Node parent) { if (isCallToScopeMethod(n)) { validateScopeCall(t, n, n.getParent()); } if (t.getScopeDepth() < 2) { return; } int type = n.getType(); Var aliasVar = null; if (type == Token.NAME) { String name = n.getString(); Var lexicalVar = t.getScope().getVar(n.getString()); if (lexicalVar != null && lexicalVar == aliases.get(name)) { aliasVar = lexicalVar; } } if (t.getScopeDepth() == 2) { if (aliasVar != null && NodeUtil.isLValue(n)) { if (aliasVar.getNode() == n) { aliasDefinitionsInOrder.add(n); return; } else { report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString()); } } if (type == Token.RETURN) { report(t, n, GOOG_SCOPE_USES_RETURN); } else if (type == Token.THIS) { report(t, n, GOOG_SCOPE_REFERENCES_THIS); } else if (type == Token.THROW) { report(t, n, GOOG_SCOPE_USES_THROW); } } if (t.getScopeDepth() >= 2) { if (aliasVar != null) { aliasUsages.add(new AliasedNode(aliasVar, n)); } JSDocInfo info = n.getJSDocInfo(); if (info != null) { for (Node node : info.getTypeNodes()) { fixTypeNode(node); } } } }\n```\n\n            \n```java\nprivate void transformCompilationUnit_r(final ScriptNode tree, final Node parent, Scope scope, boolean createScopeObjects, boolean inStrictMode) { Node node = null; siblingLoop: for (; ; ) { Node previous = null; if (node == null) { node = parent.getFirstChild(); } else { previous = node; node = node.getNext(); } if (node == null) { break; } int type = node.getType(); if (createScopeObjects && (type == Token.BLOCK || type == Token.LOOP || type == Token.ARRAYCOMP) && (node instanceof Scope)) { Scope newScope = (Scope) node; if (newScope.getSymbolTable() != null) { Node let = new Node(type == Token.ARRAYCOMP ? Token.LETEXPR : Token.LET); Node innerLet = new Node(Token.LET); let.addChildToBack(innerLet); for (String name : newScope.getSymbolTable().keySet()) { innerLet.addChildToBack(Node.newString(Token.NAME, name)); } newScope.setSymbolTable(null); Node oldNode = node; node = replaceCurrent(parent, previous, node, let); type = node.getType(); let.addChildToBack(oldNode); } } switch(type) { case Token.LABEL: case Token.SWITCH: case Token.LOOP: loops.push(node); loopEnds.push(((Jump) node).target); break; case Token.WITH: { loops.push(node); Node leave = node.getNext(); if (leave.getType() != Token.LEAVEWITH) { Kit.codeBug(); } loopEnds.push(leave); break; } case Token.TRY: { Jump jump = (Jump) node; Node finallytarget = jump.getFinally(); if (finallytarget != null) { hasFinally = true; loops.push(node); loopEnds.push(finallytarget); } break; } case Token.TARGET: case Token.LEAVEWITH: if (!loopEnds.isEmpty() && loopEnds.peek() == node) { loopEnds.pop(); loops.pop(); } break; case Token.YIELD: ((FunctionNode) tree).addResumptionPoint(node); break; case Token.RETURN: { boolean isGenerator = tree.getType() == Token.FUNCTION && ((FunctionNode) tree).isGenerator(); if (isGenerator) { node.putIntProp(Node.GENERATOR_END_PROP, 1); } if (!hasFinally) break; Node unwindBlock = null; for (int i = loops.size() - 1; i >= 0; i--) { Node n = (Node) loops.get(i); int elemtype = n.getType(); if (elemtype == Token.TRY || elemtype == Token.WITH) { Node unwind; if (elemtype == Token.TRY) { Jump jsrnode = new Jump(Token.JSR); Node jsrtarget = ((Jump) n).getFinally(); jsrnode.target = jsrtarget; unwind = jsrnode; } else { unwind = new Node(Token.LEAVEWITH); } if (unwindBlock == null) { unwindBlock = new Node(Token.BLOCK, node.getLineno()); } unwindBlock.addChildToBack(unwind); } } if (unwindBlock != null) { Node returnNode = node; Node returnExpr = returnNode.getFirstChild(); node = replaceCurrent(parent, previous, node, unwindBlock); if (returnExpr == null || isGenerator) { unwindBlock.addChildToBack(returnNode); } else { Node store = new Node(Token.EXPR_RESULT, returnExpr); unwindBlock.addChildToFront(store); returnNode = new Node(Token.RETURN_RESULT); unwindBlock.addChildToBack(returnNode); transformCompilationUnit_r(tree, store, scope, createScopeObjects, inStrictMode); } continue siblingLoop; } break; } case Token.BREAK: case Token.CONTINUE: { Jump jump = (Jump) node; Jump jumpStatement = jump.getJumpStatement(); if (jumpStatement == null) Kit.codeBug(); for (int i = loops.size(); ; ) { if (i == 0) { throw Kit.codeBug(); } --i; Node n = (Node) loops.get(i); if (n == jumpStatement) { break; } int elemtype = n.getType(); if (elemtype == Token.WITH) { Node leave = new Node(Token.LEAVEWITH); previous = addBeforeCurrent(parent, previous, node, leave); } else if (elemtype == Token.TRY) { Jump tryNode = (Jump) n; Jump jsrFinally = new Jump(Token.JSR); jsrFinally.target = tryNode.getFinally(); previous = addBeforeCurrent(parent, previous, node, jsrFinally); } } if (type == Token.BREAK) { jump.target = jumpStatement.target; } else { jump.target = jumpStatement.getContinue(); } jump.setType(Token.GOTO); break; } case Token.CALL: visitCall(node, tree); break; case Token.NEW: visitNew(node, tree); break; case Token.LETEXPR: case Token.LET: { Node child = node.getFirstChild(); if (child.getType() == Token.LET) { boolean createWith = tree.getType() != Token.FUNCTION || ((FunctionNode) tree).requiresActivation(); node = visitLet(createWith, parent, previous, node); break; } else { } } case Token.CONST: case Token.VAR: { Node result = new Node(Token.BLOCK); for (Node cursor = node.getFirstChild(); cursor != null; ) { Node n = cursor; cursor = cursor.getNext(); if (n.getType() == Token.NAME) { if (!n.hasChildren()) continue; Node init = n.getFirstChild(); n.removeChild(init); n.setType(Token.BINDNAME); n = new Node(type == Token.CONST ? Token.SETCONST : Token.SETNAME, n, init); } else { if (n.getType() != Token.LETEXPR) throw Kit.codeBug(); } Node pop = new Node(Token.EXPR_VOID, n, node.getLineno()); result.addChildToBack(pop); } node = replaceCurrent(parent, previous, node, result); break; } case Token.TYPEOFNAME: { Scope defining = scope.getDefiningScope(node.getString()); if (defining != null) { node.setScope(defining); } } break; case Token.TYPEOF: case Token.IFNE: { Node child = node.getFirstChild(); if (type == Token.IFNE) { while (child.getType() == Token.NOT) { child = child.getFirstChild(); } if (child.getType() == Token.EQ || child.getType() == Token.NE) { Node first = child.getFirstChild(); Node last = child.getLastChild(); if (first.getType() == Token.NAME && first.getString().equals(\\\"undefined\\\")) child = last; else if (last.getType() == Token.NAME && last.getString().equals(\\\"undefined\\\")) child = first; } } if (child.getType() == Token.GETPROP) child.setType(Token.GETPROPNOWARN); break; } case Token.SETNAME: if (inStrictMode) { node.setType(Token.STRICT_SETNAME); } case Token.NAME: case Token.SETCONST: case Token.DELPROP: { if (createScopeObjects) { break; } Node nameSource; if (type == Token.NAME) { nameSource = node; } else { nameSource = node.getFirstChild(); if (nameSource.getType() != Token.BINDNAME) { if (type == Token.DELPROP) { break; } throw Kit.codeBug(); } } if (nameSource.getScope() != null) { break; } String name = nameSource.getString(); Scope defining = scope.getDefiningScope(name); if (defining != null) { nameSource.setScope(defining); if (type == Token.NAME) { node.setType(Token.GETVAR); } else if (type == Token.SETNAME || type == Token.STRICT_SETNAME) { node.setType(Token.SETVAR); nameSource.setType(Token.STRING); } else if (type == Token.SETCONST) { node.setType(Token.SETCONSTVAR); nameSource.setType(Token.STRING); } else if (type == Token.DELPROP) { Node n = new Node(Token.FALSE); node = replaceCurrent(parent, previous, node, n); } else { throw Kit.codeBug(); } } break; } } transformCompilationUnit_r(tree, node, node instanceof Scope ? (Scope) node : scope, createScopeObjects, inStrictMode); } }\n```\n\n            \n```java\nstatic XML createFromJS(XMLLibImpl lib, Object inputObject) { XmlObject xo; boolean isText = false; String frag; if (inputObject == null || inputObject == Undefined.instance) { frag = \\\"\\\"; } else if (inputObject instanceof XMLObjectImpl) { frag = ((XMLObjectImpl) inputObject).toXMLString(0); } else { if (inputObject instanceof Wrapper) { Object wrapped = ((Wrapper) inputObject).unwrap(); if (wrapped instanceof XmlObject) { return createFromXmlObject(lib, (XmlObject) wrapped); } } frag = ScriptRuntime.toString(inputObject); } if (frag.trim().startsWith(\\\"<>\\\")) { throw ScriptRuntime.typeError(\\\"Invalid use of XML object anonymous tags <></>.\\\"); } if (frag.indexOf(\\\"<\\\") == -1) { isText = true; frag = \\\"<textFragment>\\\" + frag + \\\"</textFragment>\\\"; } XmlOptions options = new XmlOptions(); if (lib.ignoreComments) { options.put(XmlOptions.LOAD_STRIP_COMMENTS); } if (lib.ignoreProcessingInstructions) { options.put(XmlOptions.LOAD_STRIP_PROCINSTS); } if (lib.ignoreWhitespace) { options.put(XmlOptions.LOAD_STRIP_WHITESPACE); } try { xo = XmlObject.Factory.parse(frag, options); Context cx = Context.getCurrentContext(); String defaultURI = lib.getDefaultNamespaceURI(cx); if (defaultURI.length() > 0) { XmlCursor cursor = xo.newCursor(); boolean isRoot = true; while (!cursor.toNextToken().isEnddoc()) { if (!cursor.isStart()) continue; boolean defaultNSDeclared = false; cursor.push(); while (cursor.toNextToken().isAnyAttr()) { if (cursor.isNamespace()) { if (cursor.getName().getLocalPart().length() == 0) { defaultNSDeclared = true; break; } } } cursor.pop(); if (defaultNSDeclared) { cursor.toEndToken(); continue; } javax.xml.namespace.QName qname = cursor.getName(); if (qname.getNamespaceURI().length() == 0) { qname = new javax.xml.namespace.QName(defaultURI, qname.getLocalPart()); cursor.setName(qname); } if (isRoot) { cursor.push(); cursor.toNextToken(); cursor.insertNamespace(\\\"\\\", defaultURI); cursor.pop(); isRoot = false; } } cursor.dispose(); } } catch (XmlException xe) { String errMsg = xe.getMessage(); if (errMsg.equals(\\\"error: Unexpected end of file after null\\\")) { xo = XmlObject.Factory.newInstance(); } else { throw ScriptRuntime.typeError(xe.getMessage()); } } catch (Throwable e) { throw ScriptRuntime.typeError(\\\"Not Parsable as XML\\\"); } XmlCursor curs = xo.newCursor(); if (curs.currentTokenType().isStartdoc()) { curs.toFirstContentToken(); } if (isText) { curs.toFirstContentToken(); } XScriptAnnotation anno; try { anno = new XScriptAnnotation(curs); curs.setBookmark(anno); } finally { curs.dispose(); } return new XML(lib, anno); }\n```\n\n            \n```java\nprivate void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild(); Node rvalue = assign.getLastChild(); if (lvalue.isGetProp()) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); Node property = lvalue.getLastChild(); String pname = property.getString(); if (object.isGetProp()) { JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\\\"prototype\\\")) { visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue); } } checkEnumAlias(t, info, rvalue); checkPropCreation(t, lvalue); if (pname.equals(\\\"prototype\\\")) { if (objectJsType != null && objectJsType.isFunctionType()) { FunctionType functionType = objectJsType.toMaybeFunctionType(); if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); if (functionType.makesStructs() && !rvalueType.isStruct()) { String funName = functionType.getTypeOfThis().toString(); compiler.report(t.makeError(assign, CONFLICTING_SHAPE_TYPE, \\\"struct\\\", funName)); } return; } } } ObjectType type = ObjectType.cast(objectJsType.restrictByNotNullOrUndefined()); if (type != null) { if (type.hasProperty(pname) && !type.isPropertyTypeInferred(pname) && !propertyIsImplicitCast(type, pname)) { JSType expectedType = type.getPropertyType(pname); if (!expectedType.isUnknownType()) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), expectedType, object, pname); checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, expectedType); return; } } } checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE)); } JSType leftType = getJSType(lvalue); if (lvalue.isQualifiedName()) { Var var = t.getScope().getVar(lvalue.getQualifiedName()); if (var != null) { if (var.isTypeInferred()) { return; } if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() && t.getScope() != var.getScope()) { return; } if (var.getType() != null) { leftType = var.getType(); } } } Node rightChild = assign.getLastChild(); JSType rightType = getJSType(rightChild); if (validator.expectCanAssignTo(t, assign, rightType, leftType, \\\"assignment\\\")) { ensureTyped(t, assign, rightType); } else { ensureTyped(t, assign); } }\n```\n\n            \n```java\n@Override public void visit(NodeTraversal traversal, Node node, Node parent) { String messageKey; boolean isVar; Node msgNode, msgNodeParent; switch(node.getType()) { case Token.NAME: if ((parent != null) && (parent.isVar())) { messageKey = node.getString(); isVar = true; } else { return; } msgNode = node.getFirstChild(); msgNodeParent = node; break; case Token.ASSIGN: isVar = false; Node getProp = node.getFirstChild(); if (!getProp.isGetProp()) { return; } Node propNode = getProp.getLastChild(); messageKey = propNode.getString(); msgNode = node.getLastChild(); msgNodeParent = node; break; case Token.CALL: String fnName = node.getFirstChild().getQualifiedName(); if (MSG_FUNCTION_NAME.equals(fnName)) { googMsgNodes.put(node, traversal.getSourceName()); } else if (MSG_FALLBACK_FUNCTION_NAME.equals(fnName)) { visitFallbackFunctionCall(traversal, node); } return; default: return; } boolean isNewStyleMessage = msgNode != null && msgNode.isCall(); if (!isMessageName(messageKey, isNewStyleMessage)) { return; } if (msgNode == null) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey)); return; } if (isNewStyleMessage) { googMsgNodes.remove(msgNode); } else if (style != JsMessage.Style.LEGACY) { compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX)); } boolean isUnnamedMsg = isUnnamedMessageName(messageKey); Builder builder = new Builder(isUnnamedMsg ? null : messageKey); builder.setSourceName(traversal.getSourceName()); try { if (isVar) { extractMessageFromVariable(builder, node, parent, parent.getParent()); } else { extractMessageFromProperty(builder, node.getFirstChild(), node); } } catch (MalformedException ex) { compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage())); return; } JsMessage extractedMessage = builder.build(idGenerator); if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) { checkIfMessageDuplicated(messageKey, msgNode); } trackMessage(traversal, extractedMessage, messageKey, msgNode, isUnnamedMsg); if (extractedMessage.isEmpty()) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey)); } String desc = extractedMessage.getDesc(); if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey)); } JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent); processJsMessage(extractedMessage, msgDefinition); }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (parent.isBlock() && NodeUtil.isFunctionDeclaration(n)) {\n            // Hoisted function declarations within blocks should be considered\n            // aliases.\n            String name = n.getString();\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name;\n            compiler.ensureLibraryInjected(\"base\");\n\n            // Move the function declaration to an assignment expression\n            Node functionParent = parent;\n            functionParent.detachFromParent();\n\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                functionParent,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            n.getGrandparent().addChildBefore(newDecl, parent);\n                    \n            recordAlias(v);\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ?\n                v.getInitialValue().detachFromParent() :\n                null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value,\n                    v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                    newDecl.getFirstChild().getFirstChild(), n, name);\n\n                  grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    \n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // If this is a VAR, we can just detach the expression and\n      // the tree will still be valid.\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else if (parent.isFunction()) {\n      // Handle function declarations in the current scope\n      Node grandparent = parent.getParent();\n      Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n          compiler.getCodingConvention(),\n          \"$jscomp.scope.\" + parent.getFirstChild().getString(),\n          null,\n          v.getJSDocInfo())\n          .useSourceInfoIfMissingFromForTree(n);\n      \n      grandparent.addChildBefore(newDecl, parent);\n      NodeUtil.setDebugInformation(\n          newDecl.getFirstChild().getFirstChild(), parent.getFirstChild(), parent.getFirstChild().getString());\n\n      parent.getFirstChild().setString(\"$jscomp.scope.\" + parent.getFirstChild().getString());\n      \n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    boolean isFunctionDeclaration = n.isFunction() && parent.isBlock();\n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (isFunctionDeclaration || v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // First, we need to free up the function expression (EXPR)\n      // to be used in another expression.\n        // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n        // We can't keep the local name on the function expression,\n        // because IE is buggy and will leak the name into the global\n        // scope. This is covered in more detail here:\n        // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n        //\n        // This will only cause problems if this is a hoisted, recursive\n        // function, and the programmer is using the hoisting.\n\n          // If this is a VAR, we can just detach the expression and\n          // the tree will still be valid.\n\n      // Add $jscomp.scope.name = EXPR;\n      // Make sure we copy over all the jsdoc and debug info.\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n          grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ?\n                v.getInitialValue().detachFromParent() :\n                null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value,\n                    v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                    newDecl.getFirstChild().getFirstChild(), n, name);\n\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.getParent().replaceChild(n, \n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else if (parent.isFunction()) {\n            assert parent.getFirstChild() == n;\n            // Handle bleeding function names.\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            Node functionBlock = parent.getLastChild();\n            Node fnDecl = new Node(Token.EXPR_RESULT,\n                new Node(Token.ASSIGN,\n                    NodeUtil.newQualifiedNameNode(\n                        compiler.getCodingConvention(), globalName, n, name),\n                    new Node(Token.FUNCTION,\n                        new Node(Token.EMPTY),\n                        Node.newEmpty(),\n                        functionBlock.cloneTree())));\n\n            functionBlock.getParent().addChildBefore(fnDecl, functionBlock);\n            parent.removeChild(functionBlock);\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (!v.isExtern()) {\n        // Handle hoisted function declarations.\n        Node newDecl = new Node(Token.EXPR_RESULT,\n            NodeUtil.newQualifiedNameNode(\n                compiler.getCodingConvention(), globalName, n, name))\n            .useSourceInfoIfMissingFromForTree(n);\n\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild(), n, name);\n\n        if (value != null || v.getJSDocInfo() != null) {\n          Node assignment = IR.assign(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(),\n                  globalName, n, name),\n              value\n          )\n              .useSourceInfoIfMissingFromForTree(n);\n\n          if (v.getJSDocInfo() != null) {\n            assignment.setJSDocInfo(v.getJSDocInfo());\n          }\n\n          newDecl.addChildToBack(assignment);\n        }\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    boolean isFunction = n.isFunction();\n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar || isFunction) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ? v.getInitialValue() : null;\n      if (value != null) {\n        value.detachFromParent();\n      }\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      if (isVar) {\n        // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n        v.getNameNode().addChildToFront(\n            NodeUtil.newQualifiedNameNode(\n                compiler.getCodingConvention(), globalName, n, name));\n      } else if (isFunction) {\n        // Remove original function declaration since we're replacing it with a scoped alias\n        grandparent.removeChild(varNode);\n      }\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent.isVar();\n    boolean isHoistedFunction = n.isFunction() && parent.isBlock() && !NodeUtil.isFunctionBlock(parent);\n    \n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVar || isHoistedFunction) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // Add $jscomp.scope.name = EXPR;\n      // Make sure we copy over all the jsdoc and debug info.\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n\n        if (isHoistedFunction) {\n          // For hoisted functions in blocks, add to the start of the block.\n          parent.addChildToFront(newDecl);\n        } else {\n          grandparent.addChildBefore(newDecl, varNode);\n        }\n      }\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      // Do not other kinds of local symbols, like catch params.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVar = parent != null && parent.isVar();\n    if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent != null && parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (parent != null && parent.getType() == Token.FUNCTION) {\n      // Handle function declarations: treat them as aliases if they need to be hoisted\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // Create scoped alias for function\n      Node functionValue = v.getInitialValue().detachFromParent();\n      Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n          compiler.getCodingConvention(),\n          globalName,\n          functionValue,\n          v.getJSDocInfo())\n          .useSourceInfoIfMissingFromForTree(n);\n      NodeUtil.setDebugInformation(\n          newDecl.getFirstChild().getFirstChild(), n, name);\n      parent.getParent().addChildBefore(newDecl, parent);\n\n      // Add alias reference for function\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else if (isVar) {\n      Node grandparent = parent.getParent();\n      Node value = n.hasChildren() ?\n          v.getInitialValue().detachFromParent() :\n          null;\n      Node varNode = parent;\n\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      if (value != null || v.getJSDocInfo() != null) {\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n        grandparent.addChildBefore(newDecl, varNode);\n      }\n\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else {\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent != null && parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent != null && parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ?\n                    v.getInitialValue().detachFromParent() :\n                    null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                    \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                        compiler.getCodingConvention(),\n                        globalName,\n                        value,\n                        v.getJSDocInfo())\n                        .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                        newDecl.getFirstChild().getFirstChild(), n, name);\n\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                    NodeUtil.newQualifiedNameNode(\n                            compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue() : null;\n            Node varNode = parent;\n\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value != null ? value.detachFromParent() : null,\n                    v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                    newDecl.getFirstChild().getFirstChild(), n, name);\n\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else if (parent.isFunction()) {\n            // Treat function declarations as aliases when in local scope\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/rhino/Node.java",
                "start_loc": 549,
                "end_loc": 562,
                "buggy_function": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }\n",
                "fixed_function": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n    if (n == null) {\n      throw new RuntimeException(\"node is not a child\");\n    }\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }\n",
                "comment": "",
                "normalized_body": [
                    "public Node getChildBefore(Node child) { if (child == first) { return null; } Node n = first; while (n.next != child) { n = n.next; if (n == null) { throw new RuntimeException(\\\"node is not a child\\\"); } } return n; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public Node getChildBefore(Node child) { if (child == first) { return null; } Node n = first; while (n.next != child) { n = n.next; if (n == null) { throw new RuntimeException(\\\"node is not a child\\\"); } } return n; }"
                    ],
                    [
                        0.986770749092102,
                        "public Node getChildBefore(Node child) { if (child == first) return null; Node n = first; while (n.next != child) { n = n.next; if (n == null) throw new RuntimeException(\\\"node is not a child\\\"); } return n; }"
                    ],
                    [
                        0.9838794469833374,
                        "public Node removeChildAfter(Node prev) { Preconditions.checkArgument(prev.parent == this, \\\"prev is not a child of this node.\\\"); Preconditions.checkArgument(prev.next != null, \\\"no next sibling.\\\"); Node child = prev.next; prev.next = child.next; if (child == last) { last = prev; } child.next = null; child.parent = null; return child; }"
                    ],
                    [
                        0.9819250106811523,
                        "public Node useSourceInfoIfMissingFromForTree(Node other) { useSourceInfoIfMissingFrom(other); for (Node child = getFirstChild(); child != null; child = child.getNext()) { child.useSourceInfoIfMissingFromForTree(other); } return this; }"
                    ],
                    [
                        0.9810391664505005,
                        "public boolean addOptionalParams(JSType... types) { if (hasVarArgs()) { return false; } for (JSType type : types) { newParameter(registry.createOptionalType(type)).setOptionalArg(true); } return true; }"
                    ],
                    [
                        0.9800160527229309,
                        "public static ClassCache get(Scriptable scope) { ClassCache cache = (ClassCache) ScriptableObject.getTopScopeValue(scope, AKEY); if (cache == null) { throw new RuntimeException(\\\"Can't find top level scope for \\\" + \\\"ClassCache.get\\\"); } return cache; }"
                    ],
                    [
                        0.9795206785202026,
                        "public void addChildAfter(Node newChild, Node node) { if (newChild.next != null) throw new RuntimeException(\\\"newChild had siblings in addChildAfter\\\"); newChild.next = node.next; node.next = newChild; if (last == node) last = newChild; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.ScopedAliasesTest::testHoistedFunctionDeclaration": {
                "path": "test/com/google/javascript/jscomp/ScopedAliasesTest.java",
                "function_name": "testHoistedFunctionDeclaration",
                "src": "  public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:401)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testHoistedFunctionDeclaration(ScopedAliasesTest.java:522)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)  test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testHoistedFunctionDeclaration(ScopedAliasesTest.java:522)  testScoped(\" g(f); function f() {} \",               SCOPE_NAMESPACE +               \" $jscomp.scope.f = function () {}; \" +               \"g($jscomp.scope.f); \");"
            },
            "com.google.javascript.jscomp.ScopedAliasesTest::testFunctionDeclaration": {
                "path": "test/com/google/javascript/jscomp/ScopedAliasesTest.java",
                "function_name": "testFunctionDeclaration",
                "src": "  public void testFunctionDeclaration() {\n    testScoped(\"if (x) { function f() {} } g(f)\",\n               SCOPE_NAMESPACE +\n               \"if (x) { $jscomp.scope.f = function () {}; } \" +\n               \"g($jscomp.scope.f); \");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:401)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testFunctionDeclaration(ScopedAliasesTest.java:515)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)  test(GOOG_SCOPE_START_BLOCK + code + GOOG_SCOPE_END_BLOCK, expected);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testFunctionDeclaration(ScopedAliasesTest.java:515)  testScoped(\"if (x) { function f() {} } g(f)\",               SCOPE_NAMESPACE +               \"if (x) { $jscomp.scope.f = function () {}; } \" +               \"g($jscomp.scope.f); \");"
            }
        },
        "evaluation_done": true,
        "context_generation_done": true,
        "evaluation_done2": true
    }
}