{
    "Closure-54": {
        "function_num": 3,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/TypedScopeCreator.java",
                "start_loc": 1373,
                "end_loc": 1489,
                "buggy_function": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
                "fixed_function": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.getType() == Token.OBJECTLIT) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
                "comment": "    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n",
                "normalized_body": [
                    "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (\\\"prototype\\\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) { return; } if (qVar.getScope() == scope) { scope.undeclare(qVar); } } } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName)); } return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, n); } } defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) { FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName)); if (ownerType != null) { JSType ownerTypeOfThis = ownerType.getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); } } } }",
                    "@Override void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { checkForTypedef(t, n, info); super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001788139343,
                        "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) { Node ownerNode = n.getFirstChild(); String ownerName = ownerNode.getQualifiedName(); String qName = n.getQualifiedName(); String propName = n.getLastChild().getString(); Preconditions.checkArgument(qName != null && ownerName != null); JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue); if (valueType == null && rhsValue != null) { valueType = rhsValue.getJSType(); } if (\\\"prototype\\\".equals(propName)) { Var qVar = scope.getVar(qName); if (qVar != null) { if (!qVar.isTypeInferred()) { return; } if (qVar.getScope() == scope) { scope.undeclare(qVar); } } } if (valueType == null) { if (parent.getType() == Token.EXPR_RESULT) { stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName)); } return; } boolean inferred = true; if (info != null) { inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info)); } if (inferred) { inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false))); } if (!inferred) { ObjectType ownerType = getObjectSlot(ownerName); if (ownerType != null) { boolean isExtern = t.getInput() != null && t.getInput().isExtern(); if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) { ownerType.defineDeclaredProperty(propName, valueType, n); } } defineSlot(n, parent, valueType, inferred); } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) { FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName)); if (ownerType != null) { JSType ownerTypeOfThis = ownerType.getTypeOfThis(); String delegateName = codingConvention.getDelegateSuperclassName(); JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName); if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) { defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true); } } } }"
                    ],
                    [
                        0.991188645362854,
                        "private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!NodeUtil.isName(lhs)) { return; } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; } if (rhs != null && NodeUtil.isName(rhs) && rhs.getString().equals(var.name) && NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (NodeUtil.isAssign(n)) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.getType() == Token.INC || n.getType() == Token.DEC) { if (NodeUtil.isExpressionNode(parent)) { parent.replaceChild(n, new Node(Token.VOID, Node.newNumber(0).copyInformationFrom(n))); } else if (n.getType() == Token.COMMA && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.getType() == Token.FOR && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, new Node(Token.EMPTY)); } else { return; } } else { Preconditions.checkState(false, \\\"Unknown statement\\\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } }"
                    ],
                    [
                        0.9893857836723328,
                        "private void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\\\"Missing BLOCK child.\\\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } } if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); } } }"
                    ],
                    [
                        0.9883316457271576,
                        "private void moveMethods(Collection<NameInfo> allNameInfo) { boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds(); for (NameInfo nameInfo : allNameInfo) { if (!nameInfo.isReferenced()) { continue; } if (nameInfo.readsClosureVariables()) { continue; } JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef(); if (deepestCommonModuleRef == null) { compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR)); continue; } Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator(); while (declarations.hasNext()) { Symbol symbol = declarations.next(); if (!(symbol instanceof Property)) { continue; } Property prop = (Property) symbol; Node value = prop.getValue(); if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.getType() == Token.FUNCTION) { Node valueParent = value.getParent(); if (valueParent.getType() == Token.GET || valueParent.getType() == Token.SET) { continue; } Node proto = prop.getPrototype(); int stubId = idGenerator.newId(); Node stubCall = new Node(Token.CALL, Node.newString(Token.NAME, STUB_METHOD_NAME), Node.newNumber(stubId)).copyInformationFromForTree(value); stubCall.putBooleanProp(Node.FREE_CALL, true); valueParent.replaceChild(value, stubCall); Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef); Node unstubCall = new Node(Token.CALL, Node.newString(Token.NAME, UNSTUB_METHOD_NAME), Node.newNumber(stubId), value); unstubCall.putBooleanProp(Node.FREE_CALL, true); unstubParent.addChildToFront(new Node(Token.EXPR_RESULT, new Node(Token.ASSIGN, new Node(Token.GETPROP, proto.cloneTree(), Node.newString(Token.STRING, nameInfo.name)), unstubCall)).copyInformationFromForTree(value)); compiler.reportCodeChange(); logger.fine(\\\"Moved method: \\\" + proto.getQualifiedName() + \\\".\\\" + nameInfo.name + \\\" from module \\\" + prop.getModule() + \\\" to module \\\" + deepestCommonModuleRef); } } } if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) { Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS); compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren()); } }"
                    ],
                    [
                        0.9879598021507263,
                        "@Override public void onRedeclaration(Scope s, String name, Node n, CompilerInput input) { Preconditions.checkState(n.getType() == Token.NAME); Node parent = n.getParent(); Var v = s.getVar(name); if (v != null && s.isGlobal()) { if (v.isExtern() && !input.isExtern()) { if (hasOkDuplicateDeclaration.add(v)) { return; } } } if (v != null && v.getParentNode().getType() == Token.CATCH) { name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name); compiler.report(JSError.make(input.getName(), n, CATCH_BLOCK_VAR_ERROR, name)); } else if (v != null && parent.getType() == Token.FUNCTION) { if (v.getParentNode().getType() == Token.VAR) { s.undeclare(v); s.declare(name, n, n.getJSType(), v.input); replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent()); } } else if (parent.getType() == Token.VAR) { Preconditions.checkState(parent.hasOneChild()); replaceVarWithAssignment(n, parent, parent.getParent()); } }"
                    ],
                    [
                        0.9872683584690094,
                        "private void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild(); Node rvalue = assign.getLastChild(); if (lvalue.getType() == Token.GETPROP) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); String property = lvalue.getLastChild().getString(); if (object.getType() == Token.GETPROP) { JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\\\"prototype\\\")) { visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue); } } if (info != null && info.hasType()) { visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue); return; } if (info != null && info.hasEnumParameterType()) { checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry)); return; } if (property.equals(\\\"prototype\\\")) { if (objectJsType != null && objectJsType.isFunctionType()) { FunctionType functionType = objectJsType.toMaybeFunctionType(); if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); } } else { } return; } if (object.getType() == Token.GETPROP) { Node object2 = object.getFirstChild(); String property2 = NodeUtil.getStringValue(object.getLastChild()); if (\\\"prototype\\\".equals(property2)) { JSType jsType = getJSType(object2); if (jsType.isFunctionType()) { FunctionType functionType = jsType.toMaybeFunctionType(); if (functionType.isConstructor() || functionType.isInterface()) { checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue)); } } else { } return; } } ObjectType type = ObjectType.cast(objectJsType.restrictByNotNullOrUndefined()); if (type != null) { if (type.hasProperty(property) && !type.isPropertyTypeInferred(property) && !propertyIsImplicitCast(type, property)) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property); } return; } } else if (lvalue.getType() == Token.NAME) { JSType rvalueType = getJSType(assign.getLastChild()); Var var = t.getScope().getVar(lvalue.getString()); if (var != null) { if (var.isTypeInferred()) { return; } } } JSType leftType = getJSType(lvalue); Node rightChild = assign.getLastChild(); JSType rightType = getJSType(rightChild); if (validator.expectCanAssignTo(t, assign, rightType, leftType, \\\"assignment\\\")) { ensureTyped(t, assign, rightType); } else { ensureTyped(t, assign); } }"
                    ],
                    [
                        0.9868181049823761,
                        "private Node transformFunction(FunctionNode fn) { int functionType = fn.getFunctionType(); int start = decompiler.markFunctionStart(functionType); Node mexpr = decompileFunctionHeader(fn); int index = currentScriptOrFn.addFunction(fn); PerFunctionVariables savedVars = new PerFunctionVariables(fn); try { Node destructuring = (Node) fn.getProp(Node.DESTRUCTURING_PARAMS); fn.removeProp(Node.DESTRUCTURING_PARAMS); int lineno = fn.getBody().getLineno(); ++nestingOfFunction; Node body = transform(fn.getBody()); if (!fn.isExpressionClosure()) { decompiler.addToken(Token.RC); } fn.setEncodedSourceBounds(start, decompiler.markFunctionEnd(start)); if (functionType != FunctionNode.FUNCTION_EXPRESSION && !fn.isExpressionClosure()) { decompiler.addToken(Token.EOL); } if (destructuring != null) { body.addChildToFront(new Node(Token.EXPR_VOID, destructuring, lineno)); } int syntheticType = fn.getFunctionType(); Node pn = initFunction(fn, index, body, syntheticType); if (mexpr != null) { pn = createAssignment(Token.ASSIGN, mexpr, pn); if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) { pn = createExprStatementNoReturn(pn, fn.getLineno()); } } return pn; } finally { --nestingOfFunction; savedVars.restore(); } }"
                    ],
                    [
                        0.9867455363273621,
                        "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined(); case Token.QMARK: Node firstChild = n.getFirstChild(); if (firstChild == null) { return getNativeType(UNKNOWN_TYPE); } return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope)); case Token.EQUALS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if (resolveMode != ResolveMode.LAZY_NAMES) { namedType = namedType.resolveInternal(reporter, scope); } if ((namedType instanceof ObjectType) && !(nonNullableTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); if (typeList != null && (\\\"Array\\\".equals(n.getString()) || \\\"Object\\\".equals(n.getString()))) { JSType parameterType = createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope); namedType = new ParameterizedType(this, (ObjectType) namedType, parameterType); if (typeList.hasMoreThanOneChild()) { JSType indexType = createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope); namedType = new IndexedType(this, (ObjectType) namedType, indexType); } } return createDefaultObjectUnion(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; boolean isConstructor = false; Node current = n.getFirstChild(); if (current.getType() == Token.THIS || current.getType() == Token.NEW) { Node contextNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(ScriptRuntime.getMessage0(current.getType() == Token.THIS ? \\\"msg.jsdoc.function.thisnotobject\\\" : \\\"msg.jsdoc.function.newnotobject\\\"), sourceName, contextNode.getLineno(), \\\"\\\", contextNode.getCharno()); } isConstructor = current.getType() == Token.NEW; current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.LP) { Node args = current.getFirstChild(); for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope)); } } else { JSType type = createFromTypeNodesInternal(arg, sourceName, scope); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), \\\"\\\", arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodesInternal(current, sourceName, scope); return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build(); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.TypeCheckTest::testIssue537a",
                    "com.google.javascript.jscomp.TypeCheckTest::testIssue537b"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Declare the symbol for a qualified name in the global scope.\n     *\n     * @param info The doc info for this property.\n     * @param n A top-level GETPROP node (it should not be contained inside\n     *     another GETPROP).\n     * @param parent The parent of {@code n}.\n     * @param rhsValue The node that {@code n} is being initialized to,\n     *     or {@code null} if this is a stub declaration.\n     */\n\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          if (!qVar.isTypeInferred()) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to some arbitrary expression,\n            // there's not much we can do. We just ignore the expression,\n            // and hope they've annotated their code in a way to tell us\n            // what props are going to be on that prototype.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n```\n#Error message: junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)  assertEquals(description, warnings[0].description);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue537a(TypeCheckTest.java:5264)  testTypes(        \"/** @constructor */ function Foo() {}\" +        \"Foo.prototype = {method: function() {}};\" +        \"/**\\n\" +        \" * @constructor\\n\" +        \" * @extends {Foo}\\n\" +        \" */\\n\" +        \"function Bar() {\" +        \"  Foo.call(this);\" +        \"  if (this.baz()) this.method(1);\" +        \"}\" +        \"Bar.prototype = {\" +        \"  baz: function() {\" +        \"    return true;\" +        \"  }\" +        \"};\" +        \"Bar.prototype.__proto__ = Foo.prototype;\",        \"Function Foo.prototype.method: called with 1 argument(s). \" +        \"Function requires at least 0 argument(s) \" +        \"and no more than 0 argument(s).\");\n \n#Test method 2:\n```java\n  public void testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n```\n#Error message: junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)  assertEquals(description, warnings[0].description);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue537b(TypeCheckTest.java:5287)  testTypes(        \"/** @constructor */ function Foo() {}\" +        \"Foo.prototype = {method: function() {}};\" +        \"/**\\n\" +        \" * @constructor\\n\" +        \" * @extends {Foo}\\n\" +        \" */\\n\" +        \"function Bar() {\" +        \"  Foo.call(this);\" +        \"  if (this.baz(1)) this.method();\" +        \"}\" +        \"Bar.prototype = {\" +        \"  baz: function() {\" +        \"    return true;\" +        \"  }\" +        \"};\" +        \"Bar.prototype.__proto__ = Foo.prototype;\",        \"Function Bar.prototype.baz: called with 1 argument(s). \" +        \"Function requires at least 0 argument(s) \" +        \"and no more than 0 argument(s).\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      // Function prototypes are special.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      } else {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      } else {\n        // Ensure that the property is defined even if it is inferred\n        defineSlot(n, parent, valueType, true);\n      }\n    }\n",
                            "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.getType() == Token.EXPR_RESULT) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.getType() == Token.FUNCTION &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && \n             rhsValue.getType() == Token.TRUE) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n\n  // Added logic for failing test case\n  if (\"__proto__\".equals(propName)) {\n    return;\n  }\n}\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          // If the programmer has declared that F inherits from Super,\n          // and they assign F.prototype to an object literal,\n          // then they are responsible for making sure that the object literal's\n          // implicit prototype is set up appropriately. We just obey\n          // the @extends tag.\n          if (!qVar.isTypeInferred()) {\n            if (rhsValue == null || rhsValue.getType() != Token.OBJECTLIT) {\n              return;\n            }\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null && !qVar.isTypeInferred() && qVar.getScope() == scope) {\n          return;\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getToken() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getToken() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getToken() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      \n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred || \"prototype\".equals(propName)) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n      \n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n\n      if (n.isGetProp() && rhsValue != null && rhsValue.isFunction()) {\n        FunctionType functionType = (FunctionType) rhsValue.getJSType();\n        if (functionType != null && !functionType.isInstanceType()) {\n          if (!scope.isDeclared(qName, false)) {\n            ObjectType ownerType = (ObjectType) ownerNode.getJSType();\n            if (ownerType != null) {\n              ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n          }\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n\n      // Ensure properties in object literals are declared\n      if (parent.getType() == Token.OBJECTLIT) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          ownerType.defineDeclaredProperty(propName, valueType, n);\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n    }\n",
                            "\n    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n      }\n\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      }\n\n      // Ensure that prototype chain assignments are handled \n      if (rhsValue != null && rhsValue.getType() == Token.OBJECTLIT \n          && \"prototype\".equals(propName)) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null && ownerType.isConstructor()) {\n          Node getPropNode = n;\n          while (getPropNode != null && getPropNode.isGetProp()) {\n            ownerType.defineDeclaredProperty(\n                getPropNode.getLastChild().getString(), null, getPropNode);\n            getPropNode = getPropNode.getFirstChild();\n          }\n        }\n      }\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
                "start_loc": 322,
                "end_loc": 350,
                "buggy_function": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                "fixed_function": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                "comment": "  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n",
                "normalized_body": [
                    "public void setPrototypeBasedOn(ObjectType baseType) { if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) { baseType = new PrototypeObjectType(registry, this.getReferenceName() + \\\".prototype\\\", baseType); } setPrototype((PrototypeObjectType) baseType); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public void setPrototypeBasedOn(ObjectType baseType) { if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) { baseType = new PrototypeObjectType(registry, this.getReferenceName() + \\\".prototype\\\", baseType); } setPrototype((PrototypeObjectType) baseType); }"
                    ],
                    [
                        0.9634340405464172,
                        "Node processName(Name nameNode, boolean asString) { if (asString) { return newStringNode(Token.STRING, nameNode.getIdentifier()); } else { if (isReservedKeyword(nameNode.getIdentifier())) { errorReporter.error(\\\"identifier is a reserved word\\\", sourceName, nameNode.getLineno(), \\\"\\\", 0); } return newStringNode(Token.NAME, nameNode.getIdentifier()); } }"
                    ],
                    [
                        0.9540109634399414,
                        "private Boolean readFalse() throws ParseException { if (length - pos < 4 || src.charAt(pos) != 'a' || src.charAt(pos + 1) != 'l' || src.charAt(pos + 2) != 's' || src.charAt(pos + 3) != 'e') { throw new ParseException(\\\"Unexpected token: f\\\"); } pos += 4; return Boolean.FALSE; }"
                    ],
                    [
                        0.9510334134101868,
                        "public void testPropertyOnManyTypes() { JSTypeRegistry typeRegistry = new JSTypeRegistry(null); JSType type = null; for (int i = 0; i < 100; i++) { type = typeRegistry.createObjectType(\\\"type: \\\" + i, null, null); typeRegistry.registerPropertyOnType(\\\"foo\\\", type); } assertFalse(typeRegistry.getGreatestSubtypeWithProperty(type, \\\"foo\\\").isUnknownType()); }"
                    ],
                    [
                        0.9506326913833618,
                        "private Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) { String methodName = isApply ? \\\"apply\\\" : \\\"call\\\"; if (!(thisObj instanceof XMLList) || ((XMLList) thisObj).targetProperty == null) throw ScriptRuntime.typeError1(\\\"msg.isnt.function\\\", methodName); return ScriptRuntime.applyOrCall(isApply, cx, scope, thisObj, args); }"
                    ],
                    [
                        0.9506326913833618,
                        "private Object applyOrCall(boolean isApply, Context cx, Scriptable scope, Scriptable thisObj, Object[] args) { String methodName = isApply ? \\\"apply\\\" : \\\"call\\\"; if (!(thisObj instanceof XMLList) || ((XMLList) thisObj).targetProperty == null) throw ScriptRuntime.typeError1(\\\"msg.isnt.function\\\", methodName); return ScriptRuntime.applyOrCall(isApply, cx, scope, thisObj, args); }"
                    ],
                    [
                        0.9472480416297913,
                        "private static Node createAliasFunctionNode(String aliasName) { Node parameterName = Node.newString(Token.NAME, \\\"jscomp_throw_param\\\"); List<Node> parameters = Lists.newArrayList(parameterName.cloneNode()); Node throwStatement = new Node(Token.THROW, parameterName); Node body = new Node(Token.BLOCK, throwStatement); return NodeUtil.newFunctionNode(aliasName, parameters, body, -1, -1); }"
                    ],
                    [
                        0.946259617805481,
                        "public Object jsFunction_readLines() throws IOException { List<String> list = new ArrayList<String>(); String s; while ((s = jsFunction_readLine()) != null) { list.add(s); } String[] lines = list.toArray(new String[list.size()]); Scriptable scope = ScriptableObject.getTopLevelScope(this); Context cx = Context.getCurrentContext(); return cx.newObject(scope, \\\"Array\\\", lines); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n\n```\n\n```java\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n```\n#Error message from the test method 1: junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n \n#Test method 2:\n```java\n  public void testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n```\n#Error message from the test method 2: junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n \n#Test method 3:\n```java\n  public void testPropertyOnUnknownSuperClass2() {\n    testSame(\n        \"var goog = this.foo();\" +\n        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n        \"function Foo() {}\" +\n        \"Foo.prototype = {bar: 1};\" +\n        \"var x = new Foo();\",\n        RhinoErrorReporter.TYPE_PARSE_ERROR);\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Foo\", x.toString());\n    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n  }\n```\n#Error message from the test method 3: junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) {\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if ((baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) &&\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (!baseType.hasReferenceName() &&\n        !baseType.isUnknownType() &&\n        !isNativeObjectType() &&\n        !baseType.isFunctionPrototypeType() &&\n        baseType instanceof PrototypeObjectType) {\n      setPrototype((PrototypeObjectType) baseType);\n    } else {\n      PrototypeObjectType prototypeObjectType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n      setPrototype(prototypeObjectType);\n    }\n  }\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType) ||\n        baseType.isFunctionType()) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n\n",
                            "\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        baseType instanceof PrototypeObjectType) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        (baseType instanceof PrototypeObjectType &&\n         !((PrototypeObjectType) baseType).isAnonymous())) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (!baseType.hasReferenceName() &&\n        !baseType.isUnknownType() &&\n        !isNativeObjectType() &&\n        !baseType.isFunctionPrototypeType() &&\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n",
                            "\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n\n    if (this.prototype != null) {\n      for (String property : baseType.getOwnPropertyNames()) {\n        if (!this.prototype.hasOwnProperty(property)) {\n          this.prototype.defineDeclaredProperty(\n              property, baseType.getPropertyType(property), baseType.getPropertyNode(property));\n        }\n      }\n    }\n  }\n",
                            "\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (!(baseType.hasReferenceName() ||\n          baseType.isUnknownType() ||\n          isNativeObjectType() ||\n          baseType.isFunctionPrototypeType() ||\n          baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/rhino/jstype/FunctionType.java",
                "start_loc": 357,
                "end_loc": 395,
                "buggy_function": "  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                "fixed_function": "  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    PrototypeObjectType oldPrototype = this.prototype;\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                "comment": "  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n",
                "normalized_body": [
                    "public boolean setPrototype(PrototypeObjectType prototype) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot(\\\"prototype\\\", prototype, true); this.prototype.setOwnerFunction(this); if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) { clearCachedValues(); } return true; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "public boolean setPrototype(PrototypeObjectType prototype) { if (prototype == null) { return false; } if (isConstructor() && prototype == getInstanceType()) { return false; } boolean replacedPrototype = prototype != null; this.prototype = prototype; this.prototypeSlot = new SimpleSlot(\\\"prototype\\\", prototype, true); this.prototype.setOwnerFunction(this); if (isConstructor() || isInterface()) { FunctionType superClass = getSuperClassConstructor(); if (superClass != null) { superClass.addSubType(this); } if (isInterface()) { for (ObjectType interfaceType : getExtendedInterfaces()) { if (interfaceType.getConstructor() != null) { interfaceType.getConstructor().addSubType(this); } } } } if (replacedPrototype) { clearCachedValues(); } return true; }"
                    ],
                    [
                        0.9835863709449768,
                        "private AstNode expr() throws IOException { AstNode pn = assignExpr(); int pos = pn.getPosition(); while (matchToken(Token.COMMA)) { int lineno = ts.lineno; int opPos = ts.tokenBeg; if (compilerEnv.isStrictMode() && !pn.hasSideEffects()) addStrictWarning(\\\"msg.no.side.effects\\\", \\\"\\\", pos, nodeEnd(pn) - pos); if (peekToken() == Token.YIELD) reportError(\\\"msg.yield.parenthesized\\\"); pn = new InfixExpression(Token.COMMA, pn, assignExpr(), opPos); pn.setLineno(lineno); } return pn; }"
                    ],
                    [
                        0.9816271066665649,
                        "Node tryFoldDo(Node n) { Preconditions.checkArgument(n.getType() == Token.DO); Node cond = NodeUtil.getConditionExpression(n); if (NodeUtil.getImpureBooleanValue(cond) != TernaryValue.FALSE) { return n; } if (hasBreakOrContinue(n)) { return n; } Preconditions.checkState(NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild())); Node block = n.removeFirstChild(); Node parent = n.getParent(); parent.replaceChild(n, block); if (mayHaveSideEffects(cond)) { Node condStatement = new Node(Token.EXPR_RESULT, cond.detachFromParent()).copyInformationFrom(cond); parent.addChildAfter(condStatement, block); } reportCodeChange(); return n; }"
                    ],
                    [
                        0.9811205863952637,
                        "public static Callable getValueFunctionAndThis(Object value, Context cx) { if (!(value instanceof Callable)) { throw notFunctionError(value); } Callable f = (Callable) value; Scriptable thisObj = null; if (f instanceof Scriptable) { thisObj = ((Scriptable) f).getParentScope(); } if (thisObj == null) { if (cx.topCallScope == null) throw new IllegalStateException(); thisObj = cx.topCallScope; } if (thisObj.getParentScope() != null) { if (thisObj instanceof NativeWith) { } else if (thisObj instanceof NativeCall) { thisObj = ScriptableObject.getTopLevelScope(thisObj); } } storeScriptable(cx, thisObj); return f; }"
                    ],
                    [
                        0.980862021446228,
                        "public Symbol getSymbolForScope(SymbolScope scope) { if (scope.isPropertyScope()) { JSType type = scope.getTypeOfThis(); if (type != null) { if (type.isNominalConstructor()) { return getSymbolDeclaredBy(type.toMaybeFunctionType()); } else if (type.isFunctionPrototypeType()) { return getSymbolForInstancesOf(((ObjectType) type).getOwnerFunction()); } } return null; } Node rootNode = scope.getRootNode(); if (rootNode.getType() != Token.FUNCTION) { return null; } String name = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rootNode)); return name == null ? null : scope.getParentScope().getSlot(name); }"
                    ],
                    [
                        0.9807516932487488,
                        "public static Object callSpecial(Context cx, Callable fun, Scriptable thisObj, Object[] args, Scriptable scope, Scriptable callerThis, int callType, String filename, int lineNumber) { if (callType == Node.SPECIALCALL_EVAL) { if (thisObj.getParentScope() == null && NativeGlobal.isEvalFunction(fun)) { return evalSpecial(cx, scope, callerThis, args, filename, lineNumber); } } else if (callType == Node.SPECIALCALL_WITH) { if (NativeWith.isWithFunction(fun)) { throw Context.reportRuntimeError1(\\\"msg.only.from.new\\\", \\\"With\\\"); } } else { throw Kit.codeBug(); } return fun.call(cx, scope, thisObj, args); }"
                    ],
                    [
                        0.980708122253418,
                        "private ConcreteType maybeAddAutoboxes(ConcreteType cType, Node node, String prop) { JSType jsType = node.getJSType(); if (jsType == null) { return cType; } else if (jsType.isUnknownType()) { for (JSTypeNative nativeType : nativeTypes) { ConcreteType concrete = tt.getConcreteInstance(tt.getTypeRegistry().getNativeObjectType(nativeType)); if (concrete != null && !concrete.getPropertyType(prop).isNone()) { cType = cType.unionWith(concrete); } } return cType; } return maybeAddAutoboxes(cType, jsType, prop); }"
                    ],
                    [
                        0.9805488586425781,
                        "public JsonML getElementPreOrder(int n) { Preconditions.checkState(jsonml != null); if (n == 0) { return jsonml; } Deque<WalkHelper> stack = new ArrayDeque<WalkHelper>(); stack.push(new WalkHelper(jsonml, 0)); int i = 0; while (i <= n && !stack.isEmpty()) { WalkHelper current = stack.pop(); JsonML element = current.element; Integer childno = current.childno; if (childno < element.childrenSize()) { stack.push(new WalkHelper(element, childno + 1)); i++; element = element.getChild(childno); if (i == n) { return element; } stack.push(new WalkHelper(element, 0)); } } return null; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n  /**\n   * Sets the prototype, creating the prototype object from the given\n   * base type.\n   * @param baseType The base type.\n   */\n\n  public void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        baseType.isUnknownType() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n  }\n\n```\n\n```java\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n```\n#Error message from the test method 1: junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n \n#Test method 2:\n```java\n  public void testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }\n```\n#Error message from the test method 2: junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n \n#Test method 3:\n```java\n  public void testPropertyOnUnknownSuperClass2() {\n    testSame(\n        \"var goog = this.foo();\" +\n        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n        \"function Foo() {}\" +\n        \"Foo.prototype = {bar: 1};\" +\n        \"var x = new Foo();\",\n        RhinoErrorReporter.TYPE_PARSE_ERROR);\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Foo\", x.toString());\n    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n  }\n```\n#Error message from the test method 3: junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    clearCachedValues();\n    return true;\n  }\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = (this.prototype != prototype);\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = this.prototype != null && !this.prototype.equals(prototype);\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = this.prototype != prototype;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = this.prototype != prototype;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n\n",
                            "\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    // Check if the new prototype is the same as the current prototype\n    boolean replacedPrototype = this.prototype != prototype;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = this.prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype.equals(getInstanceType())) {\n      return false;\n    }\n\n    boolean replacedPrototype = !prototype.equals(this.prototype);\n\n    if (replacedPrototype) {\n      this.prototype = prototype;\n      this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n      this.prototype.setOwnerFunction(this);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return replacedPrototype;\n  }\n",
                            "\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n",
                            "\n  /**\n   * Sets the prototype.\n   * @param prototype the prototype. If this value is {@code null} it will\n   *        silently be discarded.\n   */\n\n  public boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = this.prototype != null;\n\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.TypeCheckTest::testIssue537a": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testIssue537a",
                "src": "  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue537a(TypeCheckTest.java:5264)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)  assertEquals(description, warnings[0].description);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue537a(TypeCheckTest.java:5264)  testTypes(        \"/** @constructor */ function Foo() {}\" +        \"Foo.prototype = {method: function() {}};\" +        \"/**\\n\" +        \" * @constructor\\n\" +        \" * @extends {Foo}\\n\" +        \" */\\n\" +        \"function Bar() {\" +        \"  Foo.call(this);\" +        \"  if (this.baz()) this.method(1);\" +        \"}\" +        \"Bar.prototype = {\" +        \"  baz: function() {\" +        \"    return true;\" +        \"  }\" +        \"};\" +        \"Bar.prototype.__proto__ = Foo.prototype;\",        \"Function Foo.prototype.method: called with 1 argument(s). \" +        \"Function requires at least 0 argument(s) \" +        \"and no more than 0 argument(s).\");"
            },
            "com.google.javascript.jscomp.TypeCheckTest::testIssue537b": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testIssue537b",
                "src": "  public void testIssue537b() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz(1)) this.method();\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\");\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue537b(TypeCheckTest.java:5287)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[Function Bar.prototype.baz: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)  assertEquals(description, warnings[0].description);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue537b(TypeCheckTest.java:5287)  testTypes(        \"/** @constructor */ function Foo() {}\" +        \"Foo.prototype = {method: function() {}};\" +        \"/**\\n\" +        \" * @constructor\\n\" +        \" * @extends {Foo}\\n\" +        \" */\\n\" +        \"function Bar() {\" +        \"  Foo.call(this);\" +        \"  if (this.baz(1)) this.method();\" +        \"}\" +        \"Bar.prototype = {\" +        \"  baz: function() {\" +        \"    return true;\" +        \"  }\" +        \"};\" +        \"Bar.prototype.__proto__ = Foo.prototype;\",        \"Function Bar.prototype.baz: called with 1 argument(s). \" +        \"Function requires at least 0 argument(s) \" +        \"and no more than 0 argument(s).\");"
            },
            "com.google.javascript.jscomp.TypedScopeCreatorTest::testPropertyOnUnknownSuperClass2": {
                "path": "test/com/google/javascript/jscomp/TypedScopeCreatorTest.java",
                "function_name": "testPropertyOnUnknownSuperClass2",
                "src": "  public void testPropertyOnUnknownSuperClass2() {\n    testSame(\n        \"var goog = this.foo();\" +\n        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n        \"function Foo() {}\" +\n        \"Foo.prototype = {bar: 1};\" +\n        \"var x = new Foo();\",\n        RhinoErrorReporter.TYPE_PARSE_ERROR);\n    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n    assertEquals(\"Foo\", x.toString());\n    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n    assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.TypedScopeCreatorTest.testPropertyOnUnknownSuperClass2(TypedScopeCreatorTest.java:377)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[?]> but was:<[number]>\n\tat com.google.javascript.jscomp.TypedScopeCreatorTest.testPropertyOnUnknownSuperClass2(TypedScopeCreatorTest.java:377)  assertEquals(\"?\", x.getPropertyType(\"bar\").toString());"
            }
        },
        "evaluation_done": true
    }
}