{
    "Closure-9": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/ProcessCommonJSModules.java",
                "start_loc": 116,
                "end_loc": 125,
                "buggy_function": "  private String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n",
                "fixed_function": "  private String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n    filename = filename.replace(\"\\\\\", \"/\");\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n",
                "comment": "",
                "normalized_body": [
                    "private String normalizeSourceName(String filename) { if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length()); } return filename; }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "private String normalizeSourceName(String filename) { if (filename.indexOf(filenamePrefix) == 0) { filename = filename.substring(filenamePrefix.length()); } return filename; }"
                    ],
                    [
                        0.9821661114692688,
                        "private String getReplacementName(String oldName) { for (Renamer names : nameStack) { String newName = names.getReplacementName(oldName); if (newName != null) { return newName; } } return null; }"
                    ],
                    [
                        0.9818220138549805,
                        "private int getSourceInfoOffset(Node provideStringNode) { if (provideStringNode == null) { return 0; } int indexOfLastDot = namespace.lastIndexOf('.'); return 2 + indexOfLastDot; }"
                    ],
                    [
                        0.9813292026519775,
                        "private Collection<SymbolInfo> parseReader(String filePath, Reader fileContents) { symbols = Lists.newArrayList(); logger.fine(\\\"Parsing Source: \\\" + filePath); doParse(filePath, fileContents); return symbols; }"
                    ],
                    [
                        0.980168342590332,
                        "private List<String> sourceNames(List<CompilerInput> inputs) { List<String> inputNames = Lists.newArrayList(); for (CompilerInput input : inputs) { inputNames.add(input.getName()); } return inputNames; }"
                    ],
                    [
                        0.978723406791687,
                        "private int getNormalizedNodeType(Node n) { int type = n.getType(); if (type == Token.NOT) { TernaryValue value = NodeUtil.getPureBooleanValue(n); switch(value) { case TRUE: return Token.TRUE; case FALSE: return Token.FALSE; } } return type; }"
                    ],
                    [
                        0.9782389402389526,
                        "private boolean isGlobalScope(Scope s) { return s.getParent() == null; }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.ProcessCommonJSModulesTest::testGuessModuleName"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are several buggy methods from a large Java project.\nAlthough these methods are not directly linked to any failing test cases, we suspect they may contain bugs.\nYour task is to fix these methods using your reasoning and by learning from the few-shot examples provided below.\n\n---\n\n## Few-shot Examples\n\n\n### Example 1 - Buggy:\n```java\n  private String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n\n```\n\n### Example 1 - Fixed:\n```java\n\nprivate String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    // Replace backslashes with forward slashes for normalization\n    filename = filename.replace('\\\\', '/');\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n}\n\n```\n\n\n---\n\n## Buggy Methods to Fix\n\nBelow are the methods suspected to be buggy. Apply your best judgment to fix them based on patterns from the examples.\n\n\n### Method 1:\n```java\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n\n```\n\n\n---\n\n## \ud83c\udf1f Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations, comments, or extra text.\n",
                        "patches": [
                            "\nprivate void visitScript(NodeTraversal t, Node script) {\n    Preconditions.checkArgument(scriptNodeCount == 1,\n        \"ProcessCommonJSModules supports only one invocation per \" +\n        \"CompilerInput / script node\");\n    String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n    script.addChildToFront(IR.var(IR.name(\"MODULE$\" + moduleName), IR.objectlit())\n        .copyInformationFromForTree(script));\n    if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n    }\n    script.addChildToFront(IR.exprResult(\n        IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n            IR.string(moduleName))).copyInformationFromForTree(script));\n  \n    emitOptionalModuleExportsOverride(script, moduleName);\n  \n    // Rename vars to not conflict in global scope.\n    NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n        moduleName));\n\n    compiler.reportCodeChange();\n}\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String normalizedSourceName = normalizeSourceName(script.getSourceFileName());\n      String moduleName = guessCJSModuleName(normalizedSourceName);\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        ci.addProvide(moduleName);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        ci.getModule().addAndOverrideModule(m);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        if (module == null || !module.getName().equals(moduleName)) {\n          JSModule m = new JSModule(moduleName);\n          m.addAndOverrideModule(ci);\n          module = m;\n        }\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(\"exports\"), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci.getModule());\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount >= 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        ci.getModule().addAndOverrideModule(ci);\n        module = ci.getModule();\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String sourceName = script.getSourceFileName();\n      if (sourceName != null) {\n        sourceName = normalizeSourceName(sourceName);\n      }\n      String moduleName = guessCJSModuleName(sourceName);\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n\n      // Ensure that the source file name is normalized properly\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n\n      if (script.hasChildren()) {\n        script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n            .copyInformationFromForTree(script));\n      }\n\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n"
                        ],
                        "plausible_patches": [
                            "\nprivate String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    // Replace backslashes with forward slashes for normalization\n    filename = filename.replace('\\\\', '/');\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n}\n",
                            "\nprivate String normalizeSourceName(String filename) {\n  // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n  // wrestle it back.\n\n  // Normalize all slash variants to '/'\n  filename = filename.replace(\"\\\\\", \"/\");\n\n  if (filename.indexOf(filenamePrefix) == 0) {\n    filename = filename.substring(filenamePrefix.length());\n  }\n\n  return filename;\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/ProcessCommonJSModules.java",
                "start_loc": 179,
                "end_loc": 204,
                "buggy_function": "    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                "fixed_function": "    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(script.getSourceFileName());\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                "comment": "    /**\n     * Emit goog.provide and add suffix to all global vars to avoid conflicts\n     * with other modules.\n     */\n",
                "normalized_body": [
                    "private void visitScript(NodeTraversal t, Node script) { Preconditions.checkArgument(scriptNodeCount == 1, \\\"ProcessCommonJSModules supports only one invocation per \\\" + \\\"CompilerInput / script node\\\"); String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()).copyInformationFromForTree(script)); if (reportDependencies) { CompilerInput ci = t.getInput(); ci.addProvide(moduleName); JSModule m = new JSModule(moduleName); m.addAndOverrideModule(ci); module = m; } script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(\\\"goog\\\"), IR.string(\\\"provide\\\")), IR.string(moduleName))).copyInformationFromForTree(script)); emitOptionalModuleExportsOverride(script, moduleName); NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName)); compiler.reportCodeChange(); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "private void visitScript(NodeTraversal t, Node script) { Preconditions.checkArgument(scriptNodeCount == 1, \\\"ProcessCommonJSModules supports only one invocation per \\\" + \\\"CompilerInput / script node\\\"); String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName())); script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit()).copyInformationFromForTree(script)); if (reportDependencies) { CompilerInput ci = t.getInput(); ci.addProvide(moduleName); JSModule m = new JSModule(moduleName); m.addAndOverrideModule(ci); module = m; } script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(\\\"goog\\\"), IR.string(\\\"provide\\\")), IR.string(moduleName))).copyInformationFromForTree(script)); emitOptionalModuleExportsOverride(script, moduleName); NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName)); compiler.reportCodeChange(); }"
                    ],
                    [
                        0.9728357791900635,
                        "private void replaceOriginalJqueryEachCall(Node n, Node expandedBlock) { if (n.getParent().isExprResult()) { Node parent = n.getParent(); Node grandparent = parent.getParent(); Node insertAfter = parent; while (expandedBlock.hasChildren()) { Node child = expandedBlock.getFirstChild().detachFromParent(); grandparent.addChildAfter(child, insertAfter); insertAfter = child; } grandparent.removeChild(parent); } else { Node callTarget = n.getFirstChild(); Node objectToLoopOver = callTarget.getNext(); objectToLoopOver.detachFromParent(); Node ret = IR.returnNode(objectToLoopOver).srcref(callTarget); expandedBlock.addChildToBack(ret); Node fnc = IR.function(IR.name(\\\"\\\").srcref(callTarget), IR.paramList().srcref(callTarget), expandedBlock); n.replaceChild(callTarget, fnc); n.putBooleanProp(Node.FREE_CALL, true); while (fnc.getNext() != null) { n.removeChildAfter(fnc); } } compiler.reportCodeChange(); }"
                    ],
                    [
                        0.9679456949234009,
                        "private void test(String[] original, String[] compiled, DiagnosticType warning) { Compiler compiler = compile(original); if (warning == null) { assertEquals(\\\"Expected no warnings or errors\\n\\\" + \\\"Errors: \\n\\\" + Joiner.on(\\\"\\n\\\").join(compiler.getErrors()) + \\\"Warnings: \\n\\\" + Joiner.on(\\\"\\n\\\").join(compiler.getWarnings()), 0, compiler.getErrors().length + compiler.getWarnings().length); } else { assertEquals(1, compiler.getWarnings().length); assertEquals(warning, compiler.getWarnings()[0].getType()); } Node root = compiler.getRoot().getLastChild(); if (useStringComparison) { assertEquals(Joiner.on(\\\"\\\").join(compiled), compiler.toSource()); } else { Node expectedRoot = parse(compiled); String explanation = expectedRoot.checkTreeEquals(root); assertNull(\\\"\\nExpected: \\\" + compiler.toSource(expectedRoot) + \\\"\\nResult: \\\" + compiler.toSource(root) + \\\"\\n\\\" + explanation, explanation); } }"
                    ],
                    [
                        0.9648065567016602,
                        "private Node tryMinimizeStringArrayLiteral(Node n) { if (!late) { return n; } int numElements = n.getChildCount(); int saving = numElements * 2 - STRING_SPLIT_OVERHEAD; if (saving <= 0) { return n; } String[] strings = new String[n.getChildCount()]; int idx = 0; for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) { strings[idx++] = cur.getString(); } String delimiter = pickDelimiter(strings); if (delimiter != null) { String template = Joiner.on(delimiter).join(strings); Node call = IR.call(IR.getprop(IR.string(template), IR.string(\\\"split\\\")), IR.string(\\\"\\\" + delimiter)); call.copyInformationFromForTree(n); n.getParent().replaceChild(n, call); reportCodeChange(); return call; } return n; }"
                    ],
                    [
                        0.9630486369132996,
                        "private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot, FlowState<LiveVariableLattice> state) { Node parent = n.getParent(); if (NodeUtil.isAssignmentOp(n) || n.isInc() || n.isDec()) { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (rhs != null) { tryRemoveAssignment(t, rhs, exprRoot, state); rhs = lhs.getNext(); } Scope scope = t.getScope(); if (!lhs.isName()) { return; } String name = lhs.getString(); if (!scope.isDeclared(name, false)) { return; } Var var = scope.getVar(name); if (liveness.getEscapedLocals().contains(var)) { return; } if (rhs != null && rhs.isName() && rhs.getString().equals(var.name) && n.isAssign()) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); compiler.reportCodeChange(); return; } if (state.getOut().isLive(var)) { return; } if (state.getIn().isLive(var) && isVariableStillLiveWithinExpression(n, exprRoot, var.name)) { return; } if (n.isAssign()) { n.removeChild(rhs); n.getParent().replaceChild(n, rhs); } else if (NodeUtil.isAssignmentOp(n)) { n.removeChild(rhs); n.removeChild(lhs); Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs); parent.replaceChild(n, op); } else if (n.isInc() || n.isDec()) { if (parent.isExprResult()) { parent.replaceChild(n, IR.voidNode(IR.number(0).srcref(n))); } else if (n.isComma() && n != parent.getLastChild()) { parent.removeChild(n); } else if (parent.isFor() && !NodeUtil.isForIn(parent) && NodeUtil.getConditionExpression(parent) != n) { parent.replaceChild(n, IR.empty()); } else { return; } } else { Preconditions.checkState(false, \\\"Unknown statement\\\"); } compiler.reportCodeChange(); return; } else { for (Node c = n.getFirstChild(); c != null; ) { Node next = c.getNext(); if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { tryRemoveAssignment(t, c, exprRoot, state); } c = next; } return; } }"
                    ],
                    [
                        0.9617558121681213,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.isFor() && n.getChildCount() == 3) { Node body = n.getLastChild(); n.removeChild(body); Node key = n.getFirstChild(); n.removeChild(key); Node tmp = IR.name(\\\"JSCompiler_IgnoreCajaProperties_\\\" + counter++); n.addChildToFront(IR.var(tmp)); Node assignment; Node ifBody; if (key.isVar()) { ifBody = IR.block(key, IR.exprResult(IR.assign(key.getFirstChild().cloneNode(), tmp.cloneTree())), body); } else { ifBody = IR.block(IR.exprResult(IR.assign(key, tmp.cloneTree())), body); } Node newBody = IR.block(IR.ifNode(IR.not(IR.call(IR.getprop(tmp.cloneTree(), IR.string(\\\"match\\\")), IR.regexp(IR.string(\\\"___$\\\")))), ifBody)); n.addChildToBack(newBody); compiler.reportCodeChange(); } }"
                    ],
                    [
                        0.9601624011993408,
                        "public void testFlowScopeBug2() throws Exception { Node n = parseAndTypeCheck(\\\"/** @constructor */ function Foo() {};\\n\\\" + \\\"Foo.prototype.hi = false;\\\" + \\\"function foo(a, b) {\\n\\\" + \\\" /** @type Array */\\\" + \\\" var arr;\\\" + \\\" /** @type number */\\\" + \\\" var iter;\\\" + \\\" for (iter = 0; iter < arr.length; ++ iter) {\\\" + \\\" /** @type Foo */\\\" + \\\" var afoo = arr[iter];\\\" + \\\" afoo;\\\" + \\\" }\\\" + \\\"}\\\"); assertTypeEquals(registry.createOptionalType(registry.createNullableType(registry.getType(\\\"Foo\\\"))), n.getLastChild().getLastChild().getLastChild().getLastChild().getLastChild().getLastChild().getJSType()); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true,
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are several buggy methods from a large Java project.\nAlthough these methods are not directly linked to any failing test cases, we suspect they may contain bugs.\nYour task is to fix these methods using your reasoning and by learning from the few-shot examples provided below.\n\n---\n\n## Few-shot Examples\n\n\n### Example 1 - Buggy:\n```java\n  private String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n  }\n\n```\n\n### Example 1 - Fixed:\n```java\n\nprivate String normalizeSourceName(String filename) {\n    // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n    // wrestle it back.\n\n    // Replace backslashes with forward slashes for normalization\n    filename = filename.replace('\\\\', '/');\n\n    if (filename.indexOf(filenamePrefix) == 0) {\n      filename = filename.substring(filenamePrefix.length());\n    }\n\n    return filename;\n}\n\n```\n\n\n---\n\n## Buggy Methods to Fix\n\nBelow are the methods suspected to be buggy. Apply your best judgment to fix them based on patterns from the examples.\n\n\n### Method 1:\n```java\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n\n```\n\n\n---\n\n## \ud83c\udf1f Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations, comments, or extra text.\n",
                        "patches": [
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      if (compiler != null) {\n          compiler.reportCodeChange();\n      }\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        ci.getModule().addDependency(m);\n        module = m;\n      }\n\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n\n      String originalFileName = script.getSourceFileName();\n      if (originalFileName == null) {\n        throw new IllegalArgumentException(\"Source file name cannot be null\");\n      }\n      String moduleName = guessCJSModuleName(normalizeSourceName(originalFileName));\n\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        if (ci != null) {\n          ci.addProvide(moduleName);\n          JSModule m = new JSModule(moduleName);\n          m.addAndOverrideModule(ci);\n          module = m;\n        } else {\n          throw new IllegalStateException(\"CompilerInput cannot be null\");\n        }\n      }\n\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n        Preconditions.checkArgument(scriptNodeCount == 1,\n            \"ProcessCommonJSModules supports only one invocation per \" +\n            \"CompilerInput / script node\");\n        String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n        script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n            .copyInformationFromForTree(script));\n        if (reportDependencies) {\n            CompilerInput ci = t.getInput();\n            ci.addProvide(moduleName);\n            JSModule m = new JSModule(moduleName);\n            ci.getModule().addAndOverrideModule(m);\n            module = m;\n        }\n        script.addChildToFront(IR.exprResult(\n            IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n                IR.string(moduleName))).copyInformationFromForTree(script));\n\n        emitOptionalModuleExportsOverride(script, moduleName);\n\n        NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n            moduleName));\n\n        compiler.reportCodeChange();\n    }\n",
                            "\nprivate void visitScript(NodeTraversal t, Node script) {\n  Preconditions.checkArgument(scriptNodeCount <= 1,\n      \"ProcessCommonJSModules supports only one invocation per \" +\n      \"CompilerInput / script node\");\n  String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n  script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n      .copyInformationFromForTree(script));\n  if (reportDependencies) {\n    CompilerInput ci = t.getInput();\n    ci.addProvide(moduleName);\n    JSModule m = new JSModule(moduleName);\n    ci.getModule().addAndOverrideModule(m);\n    module = m;\n  }\n  script.addChildToFront(IR.exprResult(\n      IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n          IR.string(moduleName))).copyInformationFromForTree(script));\n\n  emitOptionalModuleExportsOverride(script, moduleName);\n\n  // Rename vars to not conflict in global scope.\n  NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(moduleName));\n\n  compiler.reportCodeChange();\n}\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n\n      String sourceFileName = script.getSourceFileName();\n      if (sourceFileName == null) {\n        throw new IllegalArgumentException(\"Script source file name cannot be null\");\n      }\n      \n      String moduleName = guessCJSModuleName(normalizeSourceName(sourceFileName));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      \n      // Ensure the moduleName is a valid identifier\n      moduleName = moduleName.replaceAll(\"[^a-zA-Z0-9_]\", \"_\");\n\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String sourceFileName = script.getSourceFileName();\n      if (sourceFileName == null) {\n        throw new IllegalArgumentException(\"Source file name is null.\");\n      }\n      String moduleName = guessCJSModuleName(normalizeSourceName(sourceFileName));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.add(ci); // Use `add` instead of `addAndOverrideModule` for correct functionality\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n",
                            "\n    private void visitScript(NodeTraversal t, Node script) {\n      Preconditions.checkArgument(scriptNodeCount == 1,\n          \"ProcessCommonJSModules supports only one invocation per \" +\n          \"CompilerInput / script node\");\n\n      String sourceFileName = script.getSourceFileName();\n      if (sourceFileName == null) {\n        throw new IllegalArgumentException(\"Source file name cannot be null\");\n      }\n\n      String moduleName = guessCJSModuleName(normalizeSourceName(sourceFileName));\n      script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n          .copyInformationFromForTree(script));\n      if (reportDependencies) {\n        CompilerInput ci = t.getInput();\n        ci.addProvide(moduleName);\n        JSModule m = new JSModule(moduleName);\n        m.addAndOverrideModule(ci);\n        module = m;\n      }\n      script.addChildToFront(IR.exprResult(\n          IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n              IR.string(moduleName))).copyInformationFromForTree(script));\n\n      emitOptionalModuleExportsOverride(script, moduleName);\n\n      // Rename vars to not conflict in global scope.\n      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n          moduleName));\n\n      compiler.reportCodeChange();\n    }\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.ProcessCommonJSModulesTest::testGuessModuleName": {
                "path": "test/com/google/javascript/jscomp/ProcessCommonJSModulesTest.java",
                "function_name": "testGuessModuleName",
                "src": "  public void testGuessModuleName() {\n    ProcessCommonJSModules pass = new ProcessCommonJSModules(null, \"foo\");\n    assertEquals(\"module$baz\",\n        pass.guessCJSModuleName(\"foo/baz.js\"));\n    assertEquals(\"module$baz\",\n        pass.guessCJSModuleName(\"foo\\\\baz.js\"));\n    assertEquals(\"module$bar$baz\",\n        pass.guessCJSModuleName(\"foo\\\\bar\\\\baz.js\"));\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<module$[]baz> but was:<module$[foo\\]baz>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.ProcessCommonJSModulesTest.testGuessModuleName(ProcessCommonJSModulesTest.java:132)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<module$[]baz> but was:<module$[foo\\]baz>\n\tat com.google.javascript.jscomp.ProcessCommonJSModulesTest.testGuessModuleName(ProcessCommonJSModulesTest.java:132)  assertEquals(\"module$baz\",        pass.guessCJSModuleName(\"foo\\\\baz.js\"));"
            }
        },
        "evaluation_done": true
    }
}