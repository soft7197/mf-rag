{
    "Closure-136": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/MethodCompilerPass.java",
                "start_loc": 101,
                "end_loc": 128,
                "buggy_function": "  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                "fixed_function": "  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n    } else {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                "comment": "  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n",
                "normalized_body": [
                    "private void addPossibleSignature(String name, Node node, NodeTraversal t) { boolean signatureAdded = false; if (node.getType() == Token.FUNCTION) { addSignature(name, node, t.getSourceName()); signatureAdded = true; } else if (node.getType() == Token.NAME) { String functionName = node.getString(); Scope.Var v = t.getScope().getVar(functionName); if (v == null) { if (compiler.isIdeMode()) { return; } else { throw new IllegalStateException(\\\"VarCheck should have caught this undefined function\\\"); } } Node function = v.getInitialValue(); if (function != null && function.getType() == Token.FUNCTION) { addSignature(name, function, v.getInputName()); signatureAdded = true; } } if (!signatureAdded) { nonMethodProperties.add(name); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "private void addPossibleSignature(String name, Node node, NodeTraversal t) { boolean signatureAdded = false; if (node.getType() == Token.FUNCTION) { addSignature(name, node, t.getSourceName()); signatureAdded = true; } else if (node.getType() == Token.NAME) { String functionName = node.getString(); Scope.Var v = t.getScope().getVar(functionName); if (v == null) { if (compiler.isIdeMode()) { return; } else { throw new IllegalStateException(\\\"VarCheck should have caught this undefined function\\\"); } } Node function = v.getInitialValue(); if (function != null && function.getType() == Token.FUNCTION) { addSignature(name, function, v.getInputName()); signatureAdded = true; } } if (!signatureAdded) { nonMethodProperties.add(name); } }"
                    ],
                    [
                        0.9676299095153809,
                        "private void exposeExpression(Node expressionRoot, Node subExpression) { Node nonconditionalExpr = findNonconditionalParent(subExpression, expressionRoot); boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects(nonconditionalExpr); Node exprInjectionPoint = findInjectionPoint(nonconditionalExpr); DecompositionState state = new DecompositionState(); state.sideEffects = hasFollowingSideEffects; state.extractBeforeStatement = exprInjectionPoint; for (Node child = nonconditionalExpr, parent = child.getParent(); parent != expressionRoot; child = parent, parent = child.getParent()) { int parentType = parent.getType(); Preconditions.checkState(!isConditionalOp(parent) || child == parent.getFirstChild()); if (parentType == Token.ASSIGN) { if (isSafeAssign(parent, state.sideEffects)) { } else { Node left = parent.getFirstChild(); int type = left.getType(); if (left != child) { Preconditions.checkState(NodeUtil.isGet(left)); if (type == Token.GETELEM) { decomposeSubExpressions(left.getLastChild(), null, state); } decomposeSubExpressions(left.getFirstChild(), null, state); } } } else if (parentType == Token.CALL && NodeUtil.isGet(parent.getFirstChild())) { if (!maybeExternMethod(parent.getFirstChild())) { throw new IllegalStateException(\\\"External object method calls can not be decomposed.\\\"); } else { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) { state.sideEffects = true; Node replacement = rewriteCallExpression(parent, state); parent = replacement; } } } else { decomposeSubExpressions(parent.getFirstChild(), child, state); } } if (nonconditionalExpr == subExpression) { } else { Node parent = nonconditionalExpr.getParent(); boolean needResult = parent.getType() != Token.EXPR_RESULT; Node extractedConditional = extractConditional(nonconditionalExpr, exprInjectionPoint, needResult); } }"
                    ],
                    [
                        0.9675748944282532,
                        "public void visit(NodeTraversal traversal, Node node, Node parent) { Collection<Definition> defs = passUnderTest.getDefinitionsReferencedAt(node); if (defs != null) { StringBuffer sb = new StringBuffer(); sb.append(\\\"USE \\\"); sb.append(Token.name(node.getType())); sb.append(\\\" \\\"); sb.append(node.getQualifiedName()); sb.append(\\\" -> \\\"); Multiset<String> defstrs = TreeMultiset.create(); for (Definition def : defs) { Node rValue = def.getRValue(); if (rValue != null) { defstrs.add(Token.name(rValue.getType())); } else { defstrs.add(\\\"<null>\\\"); } } sb.append(defstrs.toString()); found.add(sb.toString()); } }"
                    ],
                    [
                        0.9670738577842712,
                        "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); Scope.Var var = t.getScope().getVar(name); if (var != null && var.isLocal()) { return; } Property global = globals.get(name); if (global != null) { if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.getType() == Token.INC || parent.getType() == Token.DEC || parent.getType() == Token.NEW) { global.recordMutator(t); } else { global.recordAccessor(t); } globalUses.add(n); } } }"
                    ],
                    [
                        0.9658878445625305,
                        "private void visitFunctionNode(Node n, Node parent) { Node name = null; JSDocInfo info = parent.getJSDocInfo(); if (info != null && info.isConstructor()) { name = parent.getFirstChild(); } else { info = n.getJSDocInfo(); if (info != null && info.isConstructor()) { name = n.getFirstChild(); } } if (name != null && name.isQualifiedName()) { String qualifiedName = name.getQualifiedName(); if (!this.convention.isPrivate(qualifiedName)) { Visibility visibility = info.getVisibility(); if (!visibility.equals(JSDocInfo.Visibility.PRIVATE)) { ctors.put(qualifiedName, name); } } } }"
                    ],
                    [
                        0.9657694101333618,
                        "private void referenceParentNames() { Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values()); for (JsName name : allNamesCopy) { String curName = name.name; JsName curJsName = name; while (curName.indexOf('.') != -1) { String parentName = curName.substring(0, curName.lastIndexOf('.')); if (!globalNames.contains(parentName)) { JsName parentJsName = getName(parentName, true); recordReference(curJsName.name, parentJsName.name, RefType.REGULAR); recordReference(parentJsName.name, curJsName.name, RefType.REGULAR); curJsName = parentJsName; } curName = parentName; } } }"
                    ],
                    [
                        0.9656496047973633,
                        "private void normalizeBlocks(Node n) { if (NodeUtil.isControlStructure(n) && n.getType() != Token.LABEL && n.getType() != Token.SWITCH) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (NodeUtil.isControlStructureCodeBlock(n, c) && c.getType() != Token.BLOCK) { Node newBlock = new Node(Token.BLOCK); n.replaceChild(c, newBlock); if (c.getType() != Token.EMPTY) { newBlock.addChildrenToFront(c); } else { newBlock.setWasEmptyNode(true); } c = newBlock; reportChange(); } } } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_1",
                    "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_3",
                    "com.google.javascript.jscomp.MethodCheckTest::testSeparateMethods"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue2508576_1() {\n    // Method defined by an extern should be left alone.\n    String externs = \"function alert(a) {}\";\n    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n  }\n```\n#Error message: junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(\"a\")]> but was:<[]>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:786)  assertEquals(            Joiner.on(\"\").join(expected), compiler.toSource(mainRoot));\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:544)  test(externsInputs, js, js, null, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:525)  testSame(externs, js, warning, null);\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_1(InlineGettersTest.java:238)  testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n \n#Test method 2:\n```java\n  public void testIssue2508576_3() {\n    // Anonymous object definition without side-effect should be removed.\n    test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n  }  \n```\n#Error message: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nVarCheck should have caught this undefined function\n  Node(OBJECTLIT): testcode:1:1\n[source unknown]\n  Parent(GETPROP): testcode:1:1\n[source unknown]\n\n\tat com.google.javascript.jscomp.MethodCompilerPass.addPossibleSignature(MethodCompilerPass.java:114)  throw new IllegalStateException(              \"VarCheck should have caught this undefined function\");\n\tat com.google.javascript.jscomp.MethodCompilerPass.access$300(MethodCompilerPass.java:38)  abstract class MethodCompilerPass implements CompilerPass {  /** List of methods defined in externs */  final Set<String> externMethods = Sets.newHashSet();  /** List of extern methods without signatures that we can't warn about */  final Set<String> externMethodsWithoutSignatures = Sets.newHashSet();  /** List of property names that may not be methods */  final Set<String> nonMethodProperties = Sets.newHashSet();  final Multimap<String, Node> methodDefinitions =      HashMultimap.create();  final AbstractCompiler compiler;  /**   * The signature storage is provided by the implementing class.   */  interface SignatureStore {    public void reset();    public void addSignature(        String functionName, Node functionNode, String sourceFile);    public void removeSignature(String functionName);  }  MethodCompilerPass(AbstractCompiler compiler) {    this.compiler = compiler;  }  public void process(Node externs, Node root) {    externMethods.clear();    externMethodsWithoutSignatures.clear();    getSignatureStore().reset();    methodDefinitions.clear();    if (externs != null) {      NodeTraversal.traverse(compiler, externs, new GetExternMethods());    }    List<Node> externsAndJs = Lists.newArrayList(externs, root);    NodeTraversal.traverseRoots(        compiler, Lists.newArrayList(externs, root), new GatherSignatures());    NodeTraversal.traverseRoots(        compiler, externsAndJs, getActingCallback());  }  /**   * Subclasses should return a callback that does the actual work they   * want to perform given the computed list of method signatures   */  abstract Callback getActingCallback();  /**   * Subclasses should return a SignatureStore for storing discovered   * signatures.   */  abstract SignatureStore getSignatureStore();  /**   * Adds a node that may represent a function signature (if it's a function   * itself or the name of a function).   */  private void addPossibleSignature(String name, Node node, NodeTraversal t) {    boolean signatureAdded = false;    if (node.getType() == Token.FUNCTION) {      // The node we're looking at is a function, so we can add it directly      addSignature(name, node, t.getSourceName());      signatureAdded = true;    } else if (node.getType() == Token.NAME) {      String functionName = node.getString();      Scope.Var v = t.getScope().getVar(functionName);      if (v == null) {        if (compiler.isIdeMode()) {          return;        } else {          throw new IllegalStateException(              \"VarCheck should have caught this undefined function\");        }      }      Node function = v.getInitialValue();      if (function != null &&          function.getType() == Token.FUNCTION) {        addSignature(name, function, v.getInputName());        signatureAdded = true;      }    }    if (!signatureAdded) {      nonMethodProperties.add(name);    }  }  private void addSignature(String name, Node function, String fnSourceName) {    if (externMethodsWithoutSignatures.contains(name)) {      return;    }    getSignatureStore().addSignature(name, function, fnSourceName);    methodDefinitions.put(name, function);  }  /**   * Gathers methods from the externs file. Methods that are listed there but   * do not have a signature are flagged to be ignored when doing arity checks.   * Methods that do include signatures will be checked.   */  private class GetExternMethods extends AbstractPostOrderCallback {    public void visit(NodeTraversal t, Node n, Node parent) {      switch (n.getType()) {        case Token.GETPROP:        case Token.GETELEM: {          Node dest = n.getFirstChild().getNext();          if (dest.getType() != Token.STRING) {            return;          }          String name = dest.getString();          // We have a signature. Parse tree of the form:          // assign                       <- parent          //      getprop                 <- n          //          name methods          //          string setTimeout          //      function          if (parent.getType() == Token.ASSIGN &&              parent.getFirstChild() == n &&              n.getNext().getType() == Token.FUNCTION) {            addSignature(name, n.getNext(), t.getSourceName());          } else {            getSignatureStore().removeSignature(name);            externMethodsWithoutSignatures.add(name);          }          externMethods.add(name);        } break;        case Token.OBJECTLIT: {          // assumes the object literal is well formed          // (has an even number of children)          for (Node key = n.getFirstChild();               key != null; key = key.getNext().getNext()) {            if (key.getType() == Token.STRING) {              Node value = key.getNext();              String name = key.getString();              if (value.getType() == Token.FUNCTION) {                addSignature(name, value, t.getSourceName());              } else {                getSignatureStore().removeSignature(name);                externMethodsWithoutSignatures.add(name);              }              externMethods.add(name);            }          }        } break;      }    }  }  /**   * Gather signatures from the source to be compiled.   */  private class GatherSignatures extends AbstractPostOrderCallback {    public void visit(NodeTraversal t, Node n, Node parent) {      switch (n.getType()) {        case Token.GETPROP:        case Token.GETELEM:          Node dest = n.getFirstChild().getNext();          if (dest.getType() == Token.STRING) {            if (dest.getString().equals(\"prototype\")) {              processPrototypeParent(t, parent);            } else {              // Static methods of the form Foo.bar = function() {} or              // Static methods of the form Foo.bar = baz (where baz is a              // function name). Parse tree looks like:              // assign                 <- parent              //      getprop           <- n              //          name Foo              //          string bar              //      function or name  <- n.getNext()              if (parent.getType() == Token.ASSIGN &&                  parent.getFirstChild() == n) {                addPossibleSignature(dest.getString(), n.getNext(), t);              }            }          }          break;        case Token.OBJECTLIT:          // assumes the object literal is well formed          // (has an even number of children)          for (Node key = n.getFirstChild();               key != null; key = key.getNext().getNext()) {            if (key.getType() == Token.STRING) {              Node value = key.getNext();              addPossibleSignature(key.getString(), value, t);            }          }          break;      }    }    /**     * Processes the parent of a GETPROP prototype, which can either be     * another GETPROP (in the case of Foo.prototype.bar), or can be     * an assignment (in the case of Foo.prototype = ...).     */    private void processPrototypeParent(NodeTraversal t, Node n) {      switch (n.getType()) {        // Foo.prototype.getBar = function() { ... } or        // Foo.prototype.getBar = getBaz (where getBaz is a function)        // parse tree looks like:        // assign                          <- parent        //     getprop                     <- n        //         getprop        //             name Foo        //             string prototype        //         string getBar        //     function or name            <- assignee        case Token.GETPROP:        case Token.GETELEM:          Node dest = n.getFirstChild().getNext();          Node parent = n.getParent().getParent();          if (dest.getType() == Token.STRING &&              parent.getType() == Token.ASSIGN) {            Node assignee = parent.getFirstChild().getNext();            addPossibleSignature(dest.getString(), assignee, t);          }          break;      }    }  }}\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:477)  callback.visit(this, n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:279)  traverseBranch(root, scopeRoot);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:435)  t.traverseRoots(roots);\n\tat com.google.javascript.jscomp.MethodCompilerPass.process(MethodCompilerPass.java:79)  NodeTraversal.traverseRoots(        compiler, Lists.newArrayList(externs, root), new GatherSignatures());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:694)  getProcessor(compiler).process(externsRoot, mainRoot);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_3(InlineGettersTest.java:248)  test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\nCaused by: java.lang.IllegalStateException: VarCheck should have caught this undefined function\n\t... 52 more\n \n#Test method 3:\n```java\n  public void testSeparateMethods() {\n    testSame(\"var f = new Foo();f.oneOrTwoArg2(1);\");\n    testSame(\"var f = new Baz();f.oneOrTwoArg2(1, 2);\");\n    testSame(\"Boz.staticMethod1(1);\");\n    testSame(\"Boz.staticMethod2(1, 2);\");\n\n    // Can't detect these incorrect usuages as they are defined indirectly.\n    testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n    testSame(\"Boz.staticMethod1(1, 2);\");\n    testSame(\"Boz.staticMethod2(1);\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_WRONG_ARGUMENT_COUNT. Function oneOrTwoArg2: called with 3 argument(s). All definitions of this function require at least 1 argument(s) and no more than 2 argument(s). at testcode line 1 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:712)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:486)  test(js, js);\n\tat com.google.javascript.jscomp.MethodCheckTest.testSame(MethodCheckTest.java:61)  super.testSame(METHOD_DEFS + js);\n\tat com.google.javascript.jscomp.MethodCheckTest.testSeparateMethods(MethodCheckTest.java:101)  testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode() || t.getScope().isGlobal()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME || node.getType() == Token.FUNCTION) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          return; // Fix: Disallow throwing exception; just return\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          // Instead of throwing an exception, just return\n          return;\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode() || t.getScope().isDeclaredInExportedNamespace(node)) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        nonMethodProperties.add(name);\n        return;\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        return; // Allow undefined functions if they are not critical, avoiding runtime exceptions\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        return;\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          if (!t.getScope().isDeclared(functionName, false)) {\n            return;\n          }\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope() != null ? t.getScope().getVar(functionName) : null;\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          nonMethodProperties.add(name);\n          return; // Instead of throwing an exception, exit the method.\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null && function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue2508576_1() {\n    // Method defined by an extern should be left alone.\n    String externs = \"function alert(a) {}\";\n    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n  }\n```\n#Error message: junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(\"a\")]> but was:<[]>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:786)  assertEquals(            Joiner.on(\"\").join(expected), compiler.toSource(mainRoot));\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:544)  test(externsInputs, js, js, null, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:525)  testSame(externs, js, warning, null);\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_1(InlineGettersTest.java:238)  testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n \n#Test method 2:\n```java\n  public void testIssue2508576_3() {\n    // Anonymous object definition without side-effect should be removed.\n    test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n  }  \n```\n#Error message: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nVarCheck should have caught this undefined function\n  Node(OBJECTLIT): testcode:1:1\n[source unknown]\n  Parent(GETPROP): testcode:1:1\n[source unknown]\n\n\tat com.google.javascript.jscomp.MethodCompilerPass.addPossibleSignature(MethodCompilerPass.java:114)  throw new IllegalStateException(              \"VarCheck should have caught this undefined function\");\n\tat com.google.javascript.jscomp.MethodCompilerPass.access$300(MethodCompilerPass.java:38)  abstract class MethodCompilerPass implements CompilerPass {  /** List of methods defined in externs */  final Set<String> externMethods = Sets.newHashSet();  /** List of extern methods without signatures that we can't warn about */  final Set<String> externMethodsWithoutSignatures = Sets.newHashSet();  /** List of property names that may not be methods */  final Set<String> nonMethodProperties = Sets.newHashSet();  final Multimap<String, Node> methodDefinitions =      HashMultimap.create();  final AbstractCompiler compiler;  /**   * The signature storage is provided by the implementing class.   */  interface SignatureStore {    public void reset();    public void addSignature(        String functionName, Node functionNode, String sourceFile);    public void removeSignature(String functionName);  }  MethodCompilerPass(AbstractCompiler compiler) {    this.compiler = compiler;  }  public void process(Node externs, Node root) {    externMethods.clear();    externMethodsWithoutSignatures.clear();    getSignatureStore().reset();    methodDefinitions.clear();    if (externs != null) {      NodeTraversal.traverse(compiler, externs, new GetExternMethods());    }    List<Node> externsAndJs = Lists.newArrayList(externs, root);    NodeTraversal.traverseRoots(        compiler, Lists.newArrayList(externs, root), new GatherSignatures());    NodeTraversal.traverseRoots(        compiler, externsAndJs, getActingCallback());  }  /**   * Subclasses should return a callback that does the actual work they   * want to perform given the computed list of method signatures   */  abstract Callback getActingCallback();  /**   * Subclasses should return a SignatureStore for storing discovered   * signatures.   */  abstract SignatureStore getSignatureStore();  /**   * Adds a node that may represent a function signature (if it's a function   * itself or the name of a function).   */  private void addPossibleSignature(String name, Node node, NodeTraversal t) {    boolean signatureAdded = false;    if (node.getType() == Token.FUNCTION) {      // The node we're looking at is a function, so we can add it directly      addSignature(name, node, t.getSourceName());      signatureAdded = true;    } else if (node.getType() == Token.NAME) {      String functionName = node.getString();      Scope.Var v = t.getScope().getVar(functionName);      if (v == null) {        if (compiler.isIdeMode()) {          return;        } else {          throw new IllegalStateException(              \"VarCheck should have caught this undefined function\");        }      }      Node function = v.getInitialValue();      if (function != null &&          function.getType() == Token.FUNCTION) {        addSignature(name, function, v.getInputName());        signatureAdded = true;      }    }    if (!signatureAdded) {      nonMethodProperties.add(name);    }  }  private void addSignature(String name, Node function, String fnSourceName) {    if (externMethodsWithoutSignatures.contains(name)) {      return;    }    getSignatureStore().addSignature(name, function, fnSourceName);    methodDefinitions.put(name, function);  }  /**   * Gathers methods from the externs file. Methods that are listed there but   * do not have a signature are flagged to be ignored when doing arity checks.   * Methods that do include signatures will be checked.   */  private class GetExternMethods extends AbstractPostOrderCallback {    public void visit(NodeTraversal t, Node n, Node parent) {      switch (n.getType()) {        case Token.GETPROP:        case Token.GETELEM: {          Node dest = n.getFirstChild().getNext();          if (dest.getType() != Token.STRING) {            return;          }          String name = dest.getString();          // We have a signature. Parse tree of the form:          // assign                       <- parent          //      getprop                 <- n          //          name methods          //          string setTimeout          //      function          if (parent.getType() == Token.ASSIGN &&              parent.getFirstChild() == n &&              n.getNext().getType() == Token.FUNCTION) {            addSignature(name, n.getNext(), t.getSourceName());          } else {            getSignatureStore().removeSignature(name);            externMethodsWithoutSignatures.add(name);          }          externMethods.add(name);        } break;        case Token.OBJECTLIT: {          // assumes the object literal is well formed          // (has an even number of children)          for (Node key = n.getFirstChild();               key != null; key = key.getNext().getNext()) {            if (key.getType() == Token.STRING) {              Node value = key.getNext();              String name = key.getString();              if (value.getType() == Token.FUNCTION) {                addSignature(name, value, t.getSourceName());              } else {                getSignatureStore().removeSignature(name);                externMethodsWithoutSignatures.add(name);              }              externMethods.add(name);            }          }        } break;      }    }  }  /**   * Gather signatures from the source to be compiled.   */  private class GatherSignatures extends AbstractPostOrderCallback {    public void visit(NodeTraversal t, Node n, Node parent) {      switch (n.getType()) {        case Token.GETPROP:        case Token.GETELEM:          Node dest = n.getFirstChild().getNext();          if (dest.getType() == Token.STRING) {            if (dest.getString().equals(\"prototype\")) {              processPrototypeParent(t, parent);            } else {              // Static methods of the form Foo.bar = function() {} or              // Static methods of the form Foo.bar = baz (where baz is a              // function name). Parse tree looks like:              // assign                 <- parent              //      getprop           <- n              //          name Foo              //          string bar              //      function or name  <- n.getNext()              if (parent.getType() == Token.ASSIGN &&                  parent.getFirstChild() == n) {                addPossibleSignature(dest.getString(), n.getNext(), t);              }            }          }          break;        case Token.OBJECTLIT:          // assumes the object literal is well formed          // (has an even number of children)          for (Node key = n.getFirstChild();               key != null; key = key.getNext().getNext()) {            if (key.getType() == Token.STRING) {              Node value = key.getNext();              addPossibleSignature(key.getString(), value, t);            }          }          break;      }    }    /**     * Processes the parent of a GETPROP prototype, which can either be     * another GETPROP (in the case of Foo.prototype.bar), or can be     * an assignment (in the case of Foo.prototype = ...).     */    private void processPrototypeParent(NodeTraversal t, Node n) {      switch (n.getType()) {        // Foo.prototype.getBar = function() { ... } or        // Foo.prototype.getBar = getBaz (where getBaz is a function)        // parse tree looks like:        // assign                          <- parent        //     getprop                     <- n        //         getprop        //             name Foo        //             string prototype        //         string getBar        //     function or name            <- assignee        case Token.GETPROP:        case Token.GETELEM:          Node dest = n.getFirstChild().getNext();          Node parent = n.getParent().getParent();          if (dest.getType() == Token.STRING &&              parent.getType() == Token.ASSIGN) {            Node assignee = parent.getFirstChild().getNext();            addPossibleSignature(dest.getString(), assignee, t);          }          break;      }    }  }}\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:477)  callback.visit(this, n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:279)  traverseBranch(root, scopeRoot);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:435)  t.traverseRoots(roots);\n\tat com.google.javascript.jscomp.MethodCompilerPass.process(MethodCompilerPass.java:79)  NodeTraversal.traverseRoots(        compiler, Lists.newArrayList(externs, root), new GatherSignatures());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:694)  getProcessor(compiler).process(externsRoot, mainRoot);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_3(InlineGettersTest.java:248)  test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\nCaused by: java.lang.IllegalStateException: VarCheck should have caught this undefined function\n\t... 52 more\n \n#Test method 3:\n```java\n  public void testSeparateMethods() {\n    testSame(\"var f = new Foo();f.oneOrTwoArg2(1);\");\n    testSame(\"var f = new Baz();f.oneOrTwoArg2(1, 2);\");\n    testSame(\"Boz.staticMethod1(1);\");\n    testSame(\"Boz.staticMethod2(1, 2);\");\n\n    // Can't detect these incorrect usuages as they are defined indirectly.\n    testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n    testSame(\"Boz.staticMethod1(1, 2);\");\n    testSame(\"Boz.staticMethod2(1);\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_WRONG_ARGUMENT_COUNT. Function oneOrTwoArg2: called with 3 argument(s). All definitions of this function require at least 1 argument(s) and no more than 2 argument(s). at testcode line 1 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:712)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:486)  test(js, js);\n\tat com.google.javascript.jscomp.MethodCheckTest.testSame(MethodCheckTest.java:61)  super.testSame(METHOD_DEFS + js);\n\tat com.google.javascript.jscomp.MethodCheckTest.testSeparateMethods(MethodCheckTest.java:101)  testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprivate void exposeExpression(Node expressionRoot, Node subExpression) { Node nonconditionalExpr = findNonconditionalParent(subExpression, expressionRoot); boolean hasFollowingSideEffects = NodeUtil.mayHaveSideEffects(nonconditionalExpr); Node exprInjectionPoint = findInjectionPoint(nonconditionalExpr); DecompositionState state = new DecompositionState(); state.sideEffects = hasFollowingSideEffects; state.extractBeforeStatement = exprInjectionPoint; for (Node child = nonconditionalExpr, parent = child.getParent(); parent != expressionRoot; child = parent, parent = child.getParent()) { int parentType = parent.getType(); Preconditions.checkState(!isConditionalOp(parent) || child == parent.getFirstChild()); if (parentType == Token.ASSIGN) { if (isSafeAssign(parent, state.sideEffects)) { } else { Node left = parent.getFirstChild(); int type = left.getType(); if (left != child) { Preconditions.checkState(NodeUtil.isGet(left)); if (type == Token.GETELEM) { decomposeSubExpressions(left.getLastChild(), null, state); } decomposeSubExpressions(left.getFirstChild(), null, state); } } } else if (parentType == Token.CALL && NodeUtil.isGet(parent.getFirstChild())) { if (!maybeExternMethod(parent.getFirstChild())) { throw new IllegalStateException(\\\"External object method calls can not be decomposed.\\\"); } else { Node functionExpression = parent.getFirstChild(); decomposeSubExpressions(functionExpression.getNext(), child, state); if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)) { state.sideEffects = true; Node replacement = rewriteCallExpression(parent, state); parent = replacement; } } } else { decomposeSubExpressions(parent.getFirstChild(), child, state); } } if (nonconditionalExpr == subExpression) { } else { Node parent = nonconditionalExpr.getParent(); boolean needResult = parent.getType() != Token.EXPR_RESULT; Node extractedConditional = extractConditional(nonconditionalExpr, exprInjectionPoint, needResult); } }\n```\n\n            \n```java\npublic void visit(NodeTraversal traversal, Node node, Node parent) { Collection<Definition> defs = passUnderTest.getDefinitionsReferencedAt(node); if (defs != null) { StringBuffer sb = new StringBuffer(); sb.append(\\\"USE \\\"); sb.append(Token.name(node.getType())); sb.append(\\\" \\\"); sb.append(node.getQualifiedName()); sb.append(\\\" -> \\\"); Multiset<String> defstrs = TreeMultiset.create(); for (Definition def : defs) { Node rValue = def.getRValue(); if (rValue != null) { defstrs.add(Token.name(rValue.getType())); } else { defstrs.add(\\\"<null>\\\"); } } sb.append(defstrs.toString()); found.add(sb.toString()); } }\n```\n\n            \n```java\npublic void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.NAME) { String name = n.getString(); Scope.Var var = t.getScope().getVar(name); if (var != null && var.isLocal()) { return; } Property global = globals.get(name); if (global != null) { if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) || parent.getType() == Token.INC || parent.getType() == Token.DEC || parent.getType() == Token.NEW) { global.recordMutator(t); } else { global.recordAccessor(t); } globalUses.add(n); } } }\n```\n\n            \n```java\nprivate void visitFunctionNode(Node n, Node parent) { Node name = null; JSDocInfo info = parent.getJSDocInfo(); if (info != null && info.isConstructor()) { name = parent.getFirstChild(); } else { info = n.getJSDocInfo(); if (info != null && info.isConstructor()) { name = n.getFirstChild(); } } if (name != null && name.isQualifiedName()) { String qualifiedName = name.getQualifiedName(); if (!this.convention.isPrivate(qualifiedName)) { Visibility visibility = info.getVisibility(); if (!visibility.equals(JSDocInfo.Visibility.PRIVATE)) { ctors.put(qualifiedName, name); } } } }\n```\n\n            \n```java\nprivate void referenceParentNames() { Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values()); for (JsName name : allNamesCopy) { String curName = name.name; JsName curJsName = name; while (curName.indexOf('.') != -1) { String parentName = curName.substring(0, curName.lastIndexOf('.')); if (!globalNames.contains(parentName)) { JsName parentJsName = getName(parentName, true); recordReference(curJsName.name, parentJsName.name, RefType.REGULAR); recordReference(parentJsName.name, curJsName.name, RefType.REGULAR); curJsName = parentJsName; } curName = parentName; } } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          nonMethodProperties.add(name); // Add it as a non-method property for IDE mode\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode() || t.getInput().isExtern()) {\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n/**\n * Adds a node that may represent a function signature (if it's a function\n * itself or the name of a function).\n */\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v != null) {\n            Node function = v.getInitialValue();\n            if (function != null && function.getType() == Token.FUNCTION) {\n                addSignature(name, function, v.getInputName());\n                signatureAdded = true;\n            }\n        } else if (compiler.isIdeMode()) {\n            return;\n        }\n    } else if (node.getType() == Token.STRING) {\n        // Handle case where the string directly references an external function.\n        if (externMethods.contains(name)) {\n            signatureAdded = true; // Treat as a valid external method.\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n",
                            "\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode() || t.getScope().isGlobal()) { // Check if it is a global scope\n          return;\n        } else {\n          throw new IllegalStateException(\n              \"VarCheck should have caught this undefined function\");\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n  /**\n   * Adds a node that may represent a function signature (if it's a function\n   * itself or the name of a function).\n   */\n\n  private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n      // The node we're looking at is a function, so we can add it directly\n      addSignature(name, node, t.getSourceName());\n      signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n      String functionName = node.getString();\n      Scope.Var v = t.getScope().getVar(functionName);\n      if (v == null) {\n        if (compiler.isIdeMode()) {\n          return;\n        } else {\n          // Do not throw an exception here; instead, simply return\n          return;\n        }\n      }\n      Node function = v.getInitialValue();\n      if (function != null &&\n          function.getType() == Token.FUNCTION) {\n        addSignature(name, function, v.getInputName());\n        signatureAdded = true;\n      }\n    }\n    if (!signatureAdded) {\n      nonMethodProperties.add(name);\n    }\n  }\n",
                            "\n/**\n * Adds a node that may represent a function signature (if it's a function\n * itself or the name of a function).\n */\n\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                // Instead of throwing an error, we continue execution\n                return; \n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null &&\n                function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n",
                            "\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                // Don't throw if the function is an extern method\n                if (!externMethods.contains(functionName)) {\n                    throw new IllegalStateException(\n                        \"VarCheck should have caught this undefined function\");\n                }\n                return;\n            }\n        }\n        Node function = v.getInitialValue();\n        if (function != null &&\n            function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n",
                            "\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            if (compiler.isIdeMode()) {\n                return;\n            } else {\n                if (!nameAlreadyInExterns(name)) {\n                    throw new IllegalStateException(\n                        \"VarCheck should have caught this undefined function\");\n                }\n            }\n        } else {\n            Node function = v.getInitialValue();\n            if (function != null &&\n                    function.getType() == Token.FUNCTION) {\n                addSignature(name, function, v.getInputName());\n                signatureAdded = true;\n            }\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n\nprivate boolean nameAlreadyInExterns(String name) {\n    return externMethods.contains(name) || externMethodsWithoutSignatures.contains(name);\n}\n",
                            "\n/**\n * Adds a node that may represent a function signature (if it's a function\n * itself or the name of a function).\n */\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v == null) {\n            return;  // Allow undefined functions to be handled gracefully\n        }\n        Node function = v.getInitialValue();\n        if (function != null &&\n            function.getType() == Token.FUNCTION) {\n            addSignature(name, function, v.getInputName());\n            signatureAdded = true;\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n",
                            "\nprivate void addPossibleSignature(String name, Node node, NodeTraversal t) {\n    boolean signatureAdded = false;\n    if (node.getType() == Token.FUNCTION) {\n        // The node we're looking at is a function, so we can add it directly\n        addSignature(name, node, t.getSourceName());\n        signatureAdded = true;\n    } else if (node.getType() == Token.NAME) {\n        String functionName = node.getString();\n        Scope.Var v = t.getScope().getVar(functionName);\n        if (v != null) {\n            Node function = v.getInitialValue();\n            if (function != null && function.getType() == Token.FUNCTION) {\n                addSignature(name, function, v.getInputName());\n                signatureAdded = true;\n            }\n        }\n    }\n    if (!signatureAdded) {\n        nonMethodProperties.add(name);\n    }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/RenameVars.java",
                "start_loc": 170,
                "end_loc": 226,
                "buggy_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }\n",
                "fixed_function": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n        if (local) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n          String newName =\n            MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n                name);\n          if (!newName.equals(name)) {\n            n.setString(newName);\n          }\n        }\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() != Token.NAME) { return; } String name = n.getString(); if (name.length() == 0) { return; } Scope.Var var = t.getScope().getVar(name); boolean local = (var != null) && var.isLocal(); if (!local && localRenamingOnly) { reservedNames.add(name); return; } if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) { reservedNames.add(name); return; } if (!okToRenameVar(name, local)) { return; } if (isExternsPass_) { if (!local) { externNames.add(name); } return; } if (local) { String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex(); incCount(tempName, null); localNameNodes.add(n); localTempNames.add(tempName); } else if (var != null) { incCount(name, var.input); globalNameNodes.add(n); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() != Token.NAME) { return; } String name = n.getString(); if (name.length() == 0) { return; } Scope.Var var = t.getScope().getVar(name); boolean local = (var != null) && var.isLocal(); if (!local && localRenamingOnly) { reservedNames.add(name); return; } if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) { reservedNames.add(name); return; } if (!okToRenameVar(name, local)) { return; } if (isExternsPass_) { if (!local) { externNames.add(name); } return; } if (local) { String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex(); incCount(tempName, null); localNameNodes.add(n); localTempNames.add(tempName); } else if (var != null) { incCount(name, var.input); globalNameNodes.add(n); } }"
                    ],
                    [
                        0.9759161472320557,
                        "public void visit(NodeTraversal t, Node n, Node parent) { if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) && !NodeUtil.isGetProp(parent))) { return; } NameInformation nameInfo = createNameInformation(t, n, parent); if (nameInfo == null) { return; } if (nameInfo.onlyAffectsClassDef) { recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE); String nodeName = n.getQualifiedName(); if (nodeName != null) { recordReference(nameInfo.name, nodeName, RefType.REGULAR); } return; } if (parent.getType() == Token.INSTANCEOF && parent.getLastChild() == n) { JsName checkedClass = getName(nameInfo.name, true); refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent())); return; } NameInformation referring = getDependencyScope(n); String referringName = \\\"\\\"; if (referring != null) { referringName = referring.isPrototype ? referring.prototypeClass : referring.name; } String name = nameInfo.name; if (nameInfo.isExternallyReferenceable) { recordReference(WINDOW, name, RefType.REGULAR); return; } if (NodeUtil.isLhs(n, parent)) { if (referring != null) { recordReference(referringName, name, RefType.REGULAR); } return; } if (nodesToKeep.contains(n)) { NameInformation functionScope = getEnclosingFunctionDependencyScope(t); if (functionScope != null) { recordReference(functionScope.name, name, RefType.REGULAR); } else { recordReference(WINDOW, name, RefType.REGULAR); } } else if (referring != null) { recordReference(referringName, name, RefType.REGULAR); } else { for (Node ancestor : n.getAncestors()) { if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) { recordReference(WINDOW, name, RefType.REGULAR); break; } } } }"
                    ],
                    [
                        0.9746585488319397,
                        "private void removeUnreferencedVars(Scope scope) { CodingConvention convention = compiler_.getCodingConvention(); for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) { Var var = it.next(); if (!referenced.contains(var) && (var.isLocal() || !convention.isExported(var.name))) { compiler_.addToDebugLog(\\\"Unreferenced var: \\\" + var.name); Node nameNode = var.nameNode; Node toRemove = nameNode.getParent(); Node parent = toRemove.getParent(); Preconditions.checkState(toRemove.getType() == Token.VAR || toRemove.getType() == Token.FUNCTION || toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION, \\\"We should only declare vars and functions and function args\\\"); if (toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION) { } else if (toRemove.getType() == Token.FUNCTION && NodeUtil.isFunctionAnonymous(toRemove)) { if (!preserveAnonymousFunctionNames) { toRemove.getFirstChild().setString(\\\"\\\"); compiler_.reportCodeChange(); } } else if (parent != null && parent.getType() == Token.FOR && parent.getChildCount() < 4) { } else if (toRemove.getType() == Token.VAR && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) { if (!warnedVars_.contains(var)) { warnedVars_.add(var); String inputName = var.input != null ? var.input.getName() : \\\"<unknown>\\\"; logger_.info(\\\"Unused var \\\" + var.name + \\\" declared in \\\" + inputName + \\\" at line \\\" + toRemove.getLineno() + \\\" may have side effects and can't be removed\\\"); } if (toRemove.getChildCount() == 1) { parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild())); numRemoved_++; } } else if (toRemove.getType() == Token.VAR && toRemove.getChildCount() > 1) { toRemove.removeChild(nameNode); numRemoved_++; } else if (parent != null) { NodeUtil.removeChild(parent, toRemove); numRemoved_++; } } } }"
                    ],
                    [
                        0.9746149778366089,
                        "private void propagateSideEffects() { DiGraph<FunctionInformation, Node> sideEffectGraph = new LinkedDirectedGraph<FunctionInformation, Node>(); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { sideEffectGraph.createNode(functionInfo); } for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (!functionInfo.mayHaveSideEffects()) { continue; } for (Node callSite : functionInfo.getCallsInFunctionBody()) { Node callee = callSite.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, callee); if (defs == null) { functionInfo.setTaintsUnknown(); break; } for (Definition def : defs) { Node defValue = def.getRValue(); FunctionInformation dep = functionSideEffectMap.get(defValue); Preconditions.checkNotNull(dep); sideEffectGraph.connect(dep, callSite, functionInfo); } } } FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback()).computeFixedPoint(sideEffectGraph); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (functionInfo.mayBePure()) { functionInfo.setIsPure(); } } }"
                    ],
                    [
                        0.9743517637252808,
                        "private void computeMayUse(Node n, Node cfgNode, ReachingUses output, boolean conditional) { switch(n.getType()) { case Token.BLOCK: case Token.FUNCTION: return; case Token.NAME: addToUseIfLocal(n.getString(), cfgNode, output); return; case Token.WHILE: case Token.DO: case Token.IF: computeMayUse(NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMayUse(NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (NodeUtil.isVar(lhs)) { lhs = lhs.getLastChild(); } if (NodeUtil.isName(lhs) && !conditional) { removeFromUseIfLocal(lhs.getString(), output); } computeMayUse(rhs, cfgNode, output, conditional); } return; case Token.AND: case Token.OR: computeMayUse(n.getLastChild(), cfgNode, output, true); computeMayUse(n.getFirstChild(), cfgNode, output, conditional); return; case Token.HOOK: computeMayUse(n.getLastChild(), cfgNode, output, true); computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true); computeMayUse(n.getFirstChild(), cfgNode, output, conditional); return; case Token.VAR: Node varName = n.getFirstChild(); Preconditions.checkState(n.hasChildren(), \\\"AST should be normalized\\\"); if (varName.hasChildren()) { computeMayUse(varName.getFirstChild(), cfgNode, output, conditional); if (!conditional) { removeFromUseIfLocal(varName.getString(), output); } } return; default: if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) { Node name = n.getFirstChild(); if (!conditional) { removeFromUseIfLocal(name.getString(), output); } if (!NodeUtil.isAssign(n)) { addToUseIfLocal(name.getString(), cfgNode, output); } computeMayUse(name.getNext(), cfgNode, output, conditional); } else { for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) { computeMayUse(c, cfgNode, output, conditional); } } } }"
                    ],
                    [
                        0.9742658734321594,
                        "private Node assignExpr(boolean inForInit) throws IOException, ParserException { Node pn = condExpr(inForInit); int tt = peekToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) { consumeToken(); JSDocInfo info = ts.getAndResetJSDocInfo(); decompiler.addToken(tt); Node right = assignExpr(inForInit); pn = nf.createBinary(tt, pn, right, lineno, charno); if (info != null) { pn.setJSDocInfo(info); if (info.hasEnumParameterType() && pn.getFirstChild().isUnscopedQualifiedName()) { typeRegistry.identifyEnumName(pn.getFirstChild().getQualifiedName()); } } } else if (tt == Token.SEMI && pn.getType() == Token.GETPROP) { if (ts.isPopulated()) { pn.setJSDocInfo(ts.getAndResetJSDocInfo()); } } return pn; }"
                    ],
                    [
                        0.9742116928100586,
                        "private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) { if (fnType.getTemplateTypeName() == null) { return; } int i = 0; for (Node iParameter : fnType.getParameters()) { JSType iParameterType = getJSType(iParameter); iParameterType = iParameterType.restrictByNotNullOrUndefined(); if (iParameterType.isTemplateType()) { if (i + 1 >= n.getChildCount()) { return; } Node iArgument = n.getChildAtIndex(i + 1); JSType iArgumentType = getJSType(iArgument); if (iArgumentType != null) { iArgumentType = iArgumentType.restrictByNotNullOrUndefined(); if (!(iArgumentType instanceof ObjectType)) { compiler.report(JSError.make(NodeUtil.getSourceName(iArgument), iArgument, TEMPLATE_TYPE_NOT_OBJECT_TYPE)); return; } boolean foundTemplateTypeOfThisParameter = false; int j = 0; for (Node jParameter : fnType.getParameters()) { JSType jParameterType = getJSType(jParameter); if (jParameterType instanceof FunctionType) { FunctionType jParameterFnType = (FunctionType) jParameterType; if (jParameterFnType.getTypeOfThis().equals(iParameterType)) { foundTemplateTypeOfThisParameter = true; if (j + 1 >= n.getChildCount()) { return; } Node jArgument = n.getChildAtIndex(j + 1); JSType jArgumentType = getJSType(jArgument); if (jArgument.getType() == Token.FUNCTION && jArgumentType instanceof FunctionType) { FunctionType jArgumentFnType = (FunctionType) jArgumentType; if (jArgumentFnType.getTypeOfThis().isUnknownType()) { jArgument.setJSType(new FunctionType(registry, jArgumentFnType.getReferenceName(), jArgumentFnType.getSource(), jArgumentFnType.getParametersNode(), jArgumentFnType.getReturnType(), (ObjectType) iArgumentType)); } } } } j++; } if (!foundTemplateTypeOfThisParameter) { Node source = fnType.getSource(); compiler.report(JSError.make(NodeUtil.getSourceName(source), source, TEMPLATE_TYPE_OF_THIS_EXPECTED)); return; } } } i++; } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.RenameVarsTest::testDollarSignSuperExport2"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testDollarSignSuperExport2() {\n    boolean normalizedExpectedJs = false;\n    super.enableNormalize(false);\n\n    useGoogleCodingConvention = false;\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var c = function($super,    a,         b){};\" +\n            \"var d = function($super,    a){};\");\n\n    localRenamingOnly = false;\n    test(\"var $super = 1\", \"var a = 1\");\n\n    useGoogleCodingConvention = true;\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var d = function(a,     b,    c         ){};\" +\n            \"var e = function(     a,    b){};\");\n\n    super.disableNormalize();\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var c=function($super,a,b){};var d=function($super,a){}\nResult: var c=function($super,a,b){};var d=function($super$$1,a){}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super$$1 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.RenameVarsTest.testDollarSignSuperExport2(RenameVarsTest.java:465)  test(\"var x = function($super,duper,$fantastic){};\" +            \"var y = function($super,duper){};\",         \"var c = function($super,    a,         b){};\" +            \"var d = function($super,    a){};\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n\n    String name = n.getString();\n\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames\n        && var != null\n        && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null && !name.equals(\"$super\")) {  // Not an extern and not $super\n        // If it's global and not $super, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    if (!\"$super\".equals(name)) { // Preserve the $super variable name\n      String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n      incCount(tempName, null);\n      localNameNodes.add(n);\n      localTempNames.add(tempName);\n    } else {\n      localNameNodes.add(n);\n      localTempNames.add(name);\n    }\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we preserving super names?\n  if ((\"$super\".equals(name)) && !useGoogleCodingConvention) {\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n      // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    if (var.isExtern()) {\n      reservedNames.add(name);\n    } else {\n      incCount(name, var.input);\n      globalNameNodes.add(n);\n    }\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(parent)) { // Use 'parent' instead of 'var.getParentNode()'\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n\n    String name = n.getString();\n\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames\n            && var != null\n            && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null && !name.equals(\"$super\")) { // Not an extern and not $super\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) { // Not an extern\n    // special case for $super when using non-google coding convention\n    if (!useGoogleCodingConvention && \"$super\".equals(name)) {\n      reservedNames.add(name);\n      return;\n    }\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Check if this is part of a renamed function parameter \n  if (parent != null && parent.isFunction() && !local) {\n    if (NodeUtil.isFormalParameter(parent, n)) {\n      reservedNames.add(name);\n      return;\n    }\n  }\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null && !reservedNames.contains(name)) { // Check that the name is not reserved\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // Ensure $super is handled in a special way\n    if (useGoogleCodingConvention && \"$super\".equals(name)) {\n      reservedNames.add(name);\n      return;\n    }\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testDollarSignSuperExport2() {\n    boolean normalizedExpectedJs = false;\n    super.enableNormalize(false);\n\n    useGoogleCodingConvention = false;\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var c = function($super,    a,         b){};\" +\n            \"var d = function($super,    a){};\");\n\n    localRenamingOnly = false;\n    test(\"var $super = 1\", \"var a = 1\");\n\n    useGoogleCodingConvention = true;\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var d = function(a,     b,    c         ){};\" +\n            \"var e = function(     a,    b){};\");\n\n    super.disableNormalize();\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: var c=function($super,a,b){};var d=function($super,a){}\nResult: var c=function($super,a,b){};var d=function($super$$1,a){}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super$$1 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.RenameVarsTest.testDollarSignSuperExport2(RenameVarsTest.java:465)  test(\"var x = function($super,duper,$fantastic){};\" +            \"var y = function($super,duper){};\",         \"var c = function($super,    a,         b){};\" +            \"var d = function($super,    a){};\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic void visit(NodeTraversal t, Node n, Node parent) { if (!(NodeUtil.isName(n) || NodeUtil.isGet(n) && !NodeUtil.isGetProp(parent))) { return; } NameInformation nameInfo = createNameInformation(t, n, parent); if (nameInfo == null) { return; } if (nameInfo.onlyAffectsClassDef) { recordReference(nameInfo.name, nameInfo.superclass, RefType.INHERITANCE); String nodeName = n.getQualifiedName(); if (nodeName != null) { recordReference(nameInfo.name, nodeName, RefType.REGULAR); } return; } if (parent.getType() == Token.INSTANCEOF && parent.getLastChild() == n) { JsName checkedClass = getName(nameInfo.name, true); refNodes.add(new InstanceOfCheckNode(checkedClass, n, parent, parent.getParent())); return; } NameInformation referring = getDependencyScope(n); String referringName = \\\"\\\"; if (referring != null) { referringName = referring.isPrototype ? referring.prototypeClass : referring.name; } String name = nameInfo.name; if (nameInfo.isExternallyReferenceable) { recordReference(WINDOW, name, RefType.REGULAR); return; } if (NodeUtil.isLhs(n, parent)) { if (referring != null) { recordReference(referringName, name, RefType.REGULAR); } return; } if (nodesToKeep.contains(n)) { NameInformation functionScope = getEnclosingFunctionDependencyScope(t); if (functionScope != null) { recordReference(functionScope.name, name, RefType.REGULAR); } else { recordReference(WINDOW, name, RefType.REGULAR); } } else if (referring != null) { recordReference(referringName, name, RefType.REGULAR); } else { for (Node ancestor : n.getAncestors()) { if (NodeUtil.isAssignmentOp(ancestor) || NodeUtil.isFunction(ancestor)) { recordReference(WINDOW, name, RefType.REGULAR); break; } } } }\n```\n\n            \n```java\nprivate void removeUnreferencedVars(Scope scope) { CodingConvention convention = compiler_.getCodingConvention(); for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) { Var var = it.next(); if (!referenced.contains(var) && (var.isLocal() || !convention.isExported(var.name))) { compiler_.addToDebugLog(\\\"Unreferenced var: \\\" + var.name); Node nameNode = var.nameNode; Node toRemove = nameNode.getParent(); Node parent = toRemove.getParent(); Preconditions.checkState(toRemove.getType() == Token.VAR || toRemove.getType() == Token.FUNCTION || toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION, \\\"We should only declare vars and functions and function args\\\"); if (toRemove.getType() == Token.LP && parent.getType() == Token.FUNCTION) { } else if (toRemove.getType() == Token.FUNCTION && NodeUtil.isFunctionAnonymous(toRemove)) { if (!preserveAnonymousFunctionNames) { toRemove.getFirstChild().setString(\\\"\\\"); compiler_.reportCodeChange(); } } else if (parent != null && parent.getType() == Token.FOR && parent.getChildCount() < 4) { } else if (toRemove.getType() == Token.VAR && nameNode.hasChildren() && NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) { if (!warnedVars_.contains(var)) { warnedVars_.add(var); String inputName = var.input != null ? var.input.getName() : \\\"<unknown>\\\"; logger_.info(\\\"Unused var \\\" + var.name + \\\" declared in \\\" + inputName + \\\" at line \\\" + toRemove.getLineno() + \\\" may have side effects and can't be removed\\\"); } if (toRemove.getChildCount() == 1) { parent.replaceChild(toRemove, new Node(Token.EXPR_RESULT, nameNode.removeFirstChild())); numRemoved_++; } } else if (toRemove.getType() == Token.VAR && toRemove.getChildCount() > 1) { toRemove.removeChild(nameNode); numRemoved_++; } else if (parent != null) { NodeUtil.removeChild(parent, toRemove); numRemoved_++; } } } }\n```\n\n            \n```java\nprivate void propagateSideEffects() { DiGraph<FunctionInformation, Node> sideEffectGraph = new LinkedDirectedGraph<FunctionInformation, Node>(); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { sideEffectGraph.createNode(functionInfo); } for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (!functionInfo.mayHaveSideEffects()) { continue; } for (Node callSite : functionInfo.getCallsInFunctionBody()) { Node callee = callSite.getFirstChild(); Collection<Definition> defs = getCallableDefinitions(definitionProvider, callee); if (defs == null) { functionInfo.setTaintsUnknown(); break; } for (Definition def : defs) { Node defValue = def.getRValue(); FunctionInformation dep = functionSideEffectMap.get(defValue); Preconditions.checkNotNull(dep); sideEffectGraph.connect(dep, callSite, functionInfo); } } } FixedPointGraphTraversal.newTraversal(new SideEffectPropagationCallback()).computeFixedPoint(sideEffectGraph); for (FunctionInformation functionInfo : functionSideEffectMap.values()) { if (functionInfo.mayBePure()) { functionInfo.setIsPure(); } } }\n```\n\n            \n```java\nprivate void computeMayUse(Node n, Node cfgNode, ReachingUses output, boolean conditional) { switch(n.getType()) { case Token.BLOCK: case Token.FUNCTION: return; case Token.NAME: addToUseIfLocal(n.getString(), cfgNode, output); return; case Token.WHILE: case Token.DO: case Token.IF: computeMayUse(NodeUtil.getConditionExpression(n), cfgNode, output, conditional); return; case Token.FOR: if (!NodeUtil.isForIn(n)) { computeMayUse(NodeUtil.getConditionExpression(n), cfgNode, output, conditional); } else { Node lhs = n.getFirstChild(); Node rhs = lhs.getNext(); if (NodeUtil.isVar(lhs)) { lhs = lhs.getLastChild(); } if (NodeUtil.isName(lhs) && !conditional) { removeFromUseIfLocal(lhs.getString(), output); } computeMayUse(rhs, cfgNode, output, conditional); } return; case Token.AND: case Token.OR: computeMayUse(n.getLastChild(), cfgNode, output, true); computeMayUse(n.getFirstChild(), cfgNode, output, conditional); return; case Token.HOOK: computeMayUse(n.getLastChild(), cfgNode, output, true); computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true); computeMayUse(n.getFirstChild(), cfgNode, output, conditional); return; case Token.VAR: Node varName = n.getFirstChild(); Preconditions.checkState(n.hasChildren(), \\\"AST should be normalized\\\"); if (varName.hasChildren()) { computeMayUse(varName.getFirstChild(), cfgNode, output, conditional); if (!conditional) { removeFromUseIfLocal(varName.getString(), output); } } return; default: if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) { Node name = n.getFirstChild(); if (!conditional) { removeFromUseIfLocal(name.getString(), output); } if (!NodeUtil.isAssign(n)) { addToUseIfLocal(name.getString(), cfgNode, output); } computeMayUse(name.getNext(), cfgNode, output, conditional); } else { for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) { computeMayUse(c, cfgNode, output, conditional); } } } }\n```\n\n            \n```java\nprivate Node assignExpr(boolean inForInit) throws IOException, ParserException { Node pn = condExpr(inForInit); int tt = peekToken(); int lineno = ts.getLineno(); int charno = ts.getCharno(); if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) { consumeToken(); JSDocInfo info = ts.getAndResetJSDocInfo(); decompiler.addToken(tt); Node right = assignExpr(inForInit); pn = nf.createBinary(tt, pn, right, lineno, charno); if (info != null) { pn.setJSDocInfo(info); if (info.hasEnumParameterType() && pn.getFirstChild().isUnscopedQualifiedName()) { typeRegistry.identifyEnumName(pn.getFirstChild().getQualifiedName()); } } } else if (tt == Token.SEMI && pn.getType() == Token.GETPROP) { if (ts.isPopulated()) { pn.setJSDocInfo(ts.getAndResetJSDocInfo()); } } return pn; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Ensure $super is preserved unless overridden \n  if (name.equals(\"$super\")) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n      // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Do not rename if it's \"$super\" and should be preserved\n  if (name.equals(\"$super\") && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name, but don't rename parameter $super\n    if (!\"$super\".equals(name) || useGoogleCodingConvention) {\n      String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n      incCount(tempName, null);\n      localNameNodes.add(n);\n      localTempNames.add(tempName);\n    }\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n\n    String name = n.getString();\n\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n\n    // Check if $super should be preserved\n    if (name.equals(\"$super\") && !useGoogleCodingConvention) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames\n            && var != null\n            && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  } else {\n    // Fix for test failure: do not rename parameter named $super\n    if (\"$super\".equals(name)) {\n      reservedNames.add(name);\n    }\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, check specific cases for $super\n    if (\"$super\".equals(name) && !useGoogleCodingConvention) {\n      reservedNames.add(name);\n      return;\n    }\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, assign a new name ensuring it respects conventions\n    if (useGoogleCodingConvention && name.equals(\"$super\")) {\n      reservedNames.add(name);\n    } else {\n      incCount(name, var.input);\n    }\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Fix: Ensure we do not rename '$super'\n  if (\"$super\".equals(name)) {\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  // Modify this section to avoid renaming parameters that start with $\n  if (local && !name.startsWith(\"$\")) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n",
                            "\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() != Token.NAME) {\n    return;\n  }\n\n  String name = n.getString();\n\n  // Ignore anonymous functions\n  if (name.length() == 0) {\n    return;\n  }\n\n  // Is this local or Global?\n  Scope.Var var = t.getScope().getVar(name);\n  boolean local = (var != null) && var.isLocal();\n\n  // Check if $super should be preserved based on coding convention\n  if (!local && !useGoogleCodingConvention && name.equals(\"$super\")) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming global variables?\n  if (!local && localRenamingOnly) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Are we renaming anonymous function names?\n  if (preserveAnonymousFunctionNames\n      && var != null\n      && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n    reservedNames.add(name);\n    return;\n  }\n\n  // Check if we can rename this.\n  if (!okToRenameVar(name, local)) {\n    // Blindly de-uniquify for the Prototype library for issue 103.\n    return;\n  }\n\n  if (isExternsPass_) {\n    // Keep track of extern globals.\n    if (!local) {\n      externNames.add(name);\n    }\n    return;\n  }\n\n  if (local) {\n    // Local var: assign a new name\n    String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n    incCount(tempName, null);\n    localNameNodes.add(n);\n    localTempNames.add(tempName);\n  } else if (var != null) {  // Not an extern\n    // If it's global, increment global count\n    incCount(name, var.input);\n    globalNameNodes.add(n);\n  }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_1": {
                "path": "test/com/google/javascript/jscomp/InlineGettersTest.java",
                "function_name": "testIssue2508576_1",
                "src": "  public void testIssue2508576_1() {\n    // Method defined by an extern should be left alone.\n    String externs = \"function alert(a) {}\";\n    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(\"a\")]> but was:<[]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:786)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:544)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:525)\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_1(InlineGettersTest.java:238)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(\"a\")]> but was:<[]>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:786)  assertEquals(            Joiner.on(\"\").join(expected), compiler.toSource(mainRoot));\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:544)  test(externsInputs, js, js, null, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:525)  testSame(externs, js, warning, null);\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_1(InlineGettersTest.java:238)  testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null);"
            },
            "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_3": {
                "path": "test/com/google/javascript/jscomp/InlineGettersTest.java",
                "function_name": "testIssue2508576_3",
                "src": "  public void testIssue2508576_3() {\n    // Anonymous object definition without side-effect should be removed.\n    test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\n  }  ",
                "error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nVarCheck should have caught this undefined function\n  Node(OBJECTLIT): testcode:1:1\n[source unknown]\n  Parent(GETPROP): testcode:1:1\n[source unknown]\n\n\tat com.google.javascript.jscomp.MethodCompilerPass.addPossibleSignature(MethodCompilerPass.java:114)\n\tat com.google.javascript.jscomp.MethodCompilerPass.access$300(MethodCompilerPass.java:38)\n\tat com.google.javascript.jscomp.MethodCompilerPass$GatherSignatures.visit(MethodCompilerPass.java:236)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:477)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:279)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:435)\n\tat com.google.javascript.jscomp.MethodCompilerPass.process(MethodCompilerPass.java:79)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:694)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_3(InlineGettersTest.java:248)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: java.lang.IllegalStateException: VarCheck should have caught this undefined function\n\t... 52 more",
                "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nVarCheck should have caught this undefined function\n  Node(OBJECTLIT): testcode:1:1\n[source unknown]\n  Parent(GETPROP): testcode:1:1\n[source unknown]\n\n\tat com.google.javascript.jscomp.MethodCompilerPass.addPossibleSignature(MethodCompilerPass.java:114)  throw new IllegalStateException(              \"VarCheck should have caught this undefined function\");\n\tat com.google.javascript.jscomp.MethodCompilerPass.access$300(MethodCompilerPass.java:38)  abstract class MethodCompilerPass implements CompilerPass {  /** List of methods defined in externs */  final Set<String> externMethods = Sets.newHashSet();  /** List of extern methods without signatures that we can't warn about */  final Set<String> externMethodsWithoutSignatures = Sets.newHashSet();  /** List of property names that may not be methods */  final Set<String> nonMethodProperties = Sets.newHashSet();  final Multimap<String, Node> methodDefinitions =      HashMultimap.create();  final AbstractCompiler compiler;  /**   * The signature storage is provided by the implementing class.   */  interface SignatureStore {    public void reset();    public void addSignature(        String functionName, Node functionNode, String sourceFile);    public void removeSignature(String functionName);  }  MethodCompilerPass(AbstractCompiler compiler) {    this.compiler = compiler;  }  public void process(Node externs, Node root) {    externMethods.clear();    externMethodsWithoutSignatures.clear();    getSignatureStore().reset();    methodDefinitions.clear();    if (externs != null) {      NodeTraversal.traverse(compiler, externs, new GetExternMethods());    }    List<Node> externsAndJs = Lists.newArrayList(externs, root);    NodeTraversal.traverseRoots(        compiler, Lists.newArrayList(externs, root), new GatherSignatures());    NodeTraversal.traverseRoots(        compiler, externsAndJs, getActingCallback());  }  /**   * Subclasses should return a callback that does the actual work they   * want to perform given the computed list of method signatures   */  abstract Callback getActingCallback();  /**   * Subclasses should return a SignatureStore for storing discovered   * signatures.   */  abstract SignatureStore getSignatureStore();  /**   * Adds a node that may represent a function signature (if it's a function   * itself or the name of a function).   */  private void addPossibleSignature(String name, Node node, NodeTraversal t) {    boolean signatureAdded = false;    if (node.getType() == Token.FUNCTION) {      // The node we're looking at is a function, so we can add it directly      addSignature(name, node, t.getSourceName());      signatureAdded = true;    } else if (node.getType() == Token.NAME) {      String functionName = node.getString();      Scope.Var v = t.getScope().getVar(functionName);      if (v == null) {        if (compiler.isIdeMode()) {          return;        } else {          throw new IllegalStateException(              \"VarCheck should have caught this undefined function\");        }      }      Node function = v.getInitialValue();      if (function != null &&          function.getType() == Token.FUNCTION) {        addSignature(name, function, v.getInputName());        signatureAdded = true;      }    }    if (!signatureAdded) {      nonMethodProperties.add(name);    }  }  private void addSignature(String name, Node function, String fnSourceName) {    if (externMethodsWithoutSignatures.contains(name)) {      return;    }    getSignatureStore().addSignature(name, function, fnSourceName);    methodDefinitions.put(name, function);  }  /**   * Gathers methods from the externs file. Methods that are listed there but   * do not have a signature are flagged to be ignored when doing arity checks.   * Methods that do include signatures will be checked.   */  private class GetExternMethods extends AbstractPostOrderCallback {    public void visit(NodeTraversal t, Node n, Node parent) {      switch (n.getType()) {        case Token.GETPROP:        case Token.GETELEM: {          Node dest = n.getFirstChild().getNext();          if (dest.getType() != Token.STRING) {            return;          }          String name = dest.getString();          // We have a signature. Parse tree of the form:          // assign                       <- parent          //      getprop                 <- n          //          name methods          //          string setTimeout          //      function          if (parent.getType() == Token.ASSIGN &&              parent.getFirstChild() == n &&              n.getNext().getType() == Token.FUNCTION) {            addSignature(name, n.getNext(), t.getSourceName());          } else {            getSignatureStore().removeSignature(name);            externMethodsWithoutSignatures.add(name);          }          externMethods.add(name);        } break;        case Token.OBJECTLIT: {          // assumes the object literal is well formed          // (has an even number of children)          for (Node key = n.getFirstChild();               key != null; key = key.getNext().getNext()) {            if (key.getType() == Token.STRING) {              Node value = key.getNext();              String name = key.getString();              if (value.getType() == Token.FUNCTION) {                addSignature(name, value, t.getSourceName());              } else {                getSignatureStore().removeSignature(name);                externMethodsWithoutSignatures.add(name);              }              externMethods.add(name);            }          }        } break;      }    }  }  /**   * Gather signatures from the source to be compiled.   */  private class GatherSignatures extends AbstractPostOrderCallback {    public void visit(NodeTraversal t, Node n, Node parent) {      switch (n.getType()) {        case Token.GETPROP:        case Token.GETELEM:          Node dest = n.getFirstChild().getNext();          if (dest.getType() == Token.STRING) {            if (dest.getString().equals(\"prototype\")) {              processPrototypeParent(t, parent);            } else {              // Static methods of the form Foo.bar = function() {} or              // Static methods of the form Foo.bar = baz (where baz is a              // function name). Parse tree looks like:              // assign                 <- parent              //      getprop           <- n              //          name Foo              //          string bar              //      function or name  <- n.getNext()              if (parent.getType() == Token.ASSIGN &&                  parent.getFirstChild() == n) {                addPossibleSignature(dest.getString(), n.getNext(), t);              }            }          }          break;        case Token.OBJECTLIT:          // assumes the object literal is well formed          // (has an even number of children)          for (Node key = n.getFirstChild();               key != null; key = key.getNext().getNext()) {            if (key.getType() == Token.STRING) {              Node value = key.getNext();              addPossibleSignature(key.getString(), value, t);            }          }          break;      }    }    /**     * Processes the parent of a GETPROP prototype, which can either be     * another GETPROP (in the case of Foo.prototype.bar), or can be     * an assignment (in the case of Foo.prototype = ...).     */    private void processPrototypeParent(NodeTraversal t, Node n) {      switch (n.getType()) {        // Foo.prototype.getBar = function() { ... } or        // Foo.prototype.getBar = getBaz (where getBaz is a function)        // parse tree looks like:        // assign                          <- parent        //     getprop                     <- n        //         getprop        //             name Foo        //             string prototype        //         string getBar        //     function or name            <- assignee        case Token.GETPROP:        case Token.GETELEM:          Node dest = n.getFirstChild().getNext();          Node parent = n.getParent().getParent();          if (dest.getType() == Token.STRING &&              parent.getType() == Token.ASSIGN) {            Node assignee = parent.getFirstChild().getNext();            addPossibleSignature(dest.getString(), assignee, t);          }          break;      }    }  }}\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:477)  callback.visit(this, n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:470)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:279)  traverseBranch(root, scopeRoot);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:435)  t.traverseRoots(roots);\n\tat com.google.javascript.jscomp.MethodCompilerPass.process(MethodCompilerPass.java:79)  NodeTraversal.traverseRoots(        compiler, Lists.newArrayList(externs, root), new GatherSignatures());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:694)  getProcessor(compiler).process(externsRoot, mainRoot);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.InlineGettersTest.testIssue2508576_3(InlineGettersTest.java:248)  test(\"({a:function(){},b:alert}).a(\\\"a\\\")\", \"\");\nCaused by: java.lang.IllegalStateException: VarCheck should have caught this undefined function\n\t... 52 more"
            },
            "com.google.javascript.jscomp.MethodCheckTest::testSeparateMethods": {
                "path": "test/com/google/javascript/jscomp/MethodCheckTest.java",
                "function_name": "testSeparateMethods",
                "src": "  public void testSeparateMethods() {\n    testSame(\"var f = new Foo();f.oneOrTwoArg2(1);\");\n    testSame(\"var f = new Baz();f.oneOrTwoArg2(1, 2);\");\n    testSame(\"Boz.staticMethod1(1);\");\n    testSame(\"Boz.staticMethod2(1, 2);\");\n\n    // Can't detect these incorrect usuages as they are defined indirectly.\n    testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");\n    testSame(\"Boz.staticMethod1(1, 2);\");\n    testSame(\"Boz.staticMethod2(1);\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_WRONG_ARGUMENT_COUNT. Function oneOrTwoArg2: called with 3 argument(s). All definitions of this function require at least 1 argument(s) and no more than 2 argument(s). at testcode line 1 expected:<0> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:401)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:712)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:486)\n\tat com.google.javascript.jscomp.MethodCheckTest.testSame(MethodCheckTest.java:61)\n\tat com.google.javascript.jscomp.MethodCheckTest.testSeparateMethods(MethodCheckTest.java:101)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_WRONG_ARGUMENT_COUNT. Function oneOrTwoArg2: called with 3 argument(s). All definitions of this function require at least 1 argument(s) and no more than 2 argument(s). at testcode line 1 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:712)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:486)  test(js, js);\n\tat com.google.javascript.jscomp.MethodCheckTest.testSame(MethodCheckTest.java:61)  super.testSame(METHOD_DEFS + js);\n\tat com.google.javascript.jscomp.MethodCheckTest.testSeparateMethods(MethodCheckTest.java:101)  testSame(\"var f = new Bar();f.oneOrTwoArg2(1, 2, 3);\");"
            },
            "com.google.javascript.jscomp.RenameVarsTest::testDollarSignSuperExport2": {
                "path": "test/com/google/javascript/jscomp/RenameVarsTest.java",
                "function_name": "testDollarSignSuperExport2",
                "src": "  public void testDollarSignSuperExport2() {\n    boolean normalizedExpectedJs = false;\n    super.enableNormalize(false);\n\n    useGoogleCodingConvention = false;\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var c = function($super,    a,         b){};\" +\n            \"var d = function($super,    a){};\");\n\n    localRenamingOnly = false;\n    test(\"var $super = 1\", \"var a = 1\");\n\n    useGoogleCodingConvention = true;\n    test(\"var x = function($super,duper,$fantastic){};\" +\n            \"var y = function($super,duper){};\",\n         \"var d = function(a,     b,    c         ){};\" +\n            \"var e = function(     a,    b){};\");\n\n    super.disableNormalize();\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: var c=function($super,a,b){};var d=function($super,a){}\nResult: var c=function($super,a,b){};var d=function($super$$1,a){}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super$$1 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tat com.google.javascript.jscomp.RenameVarsTest.testDollarSignSuperExport2(RenameVarsTest.java:465)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: var c=function($super,a,b){};var d=function($super,a){}\nResult: var c=function($super,a,b){};var d=function($super$$1,a){}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: expected0] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: expected0]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT [source name: null] [encoded source length: 0] [base line: -1] [end line: -1] 1 [sourcename: testcode] [synthetic: 1]\n        VAR 1\n            NAME c 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super 1 [is_optional_param: 1]\n                        NAME a 1 [is_optional_param: 1]\n                        NAME b 1 [is_var_args_param: 1]\n                    BLOCK 1\n        VAR 1\n            NAME d 1\n                FUNCTION  1 [sourcename: testcode]\n                    NAME  1\n                    LP 1\n                        NAME $super$$1 1 [is_optional_param: 1]\n                        NAME a 1 [is_var_args_param: 1]\n                    BLOCK 1\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.RenameVarsTest.testDollarSignSuperExport2(RenameVarsTest.java:465)  test(\"var x = function($super,duper,$fantastic){};\" +            \"var y = function($super,duper){};\",         \"var c = function($super,    a,         b){};\" +            \"var d = function($super,    a){};\");"
            }
        },
        "evaluation_done": true,
        "context_generation_done": true,
        "evaluation_done2": true
    }
}