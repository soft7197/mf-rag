{
    "Closure-34": {
        "function_num": 3,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
                "start_loc": 85,
                "end_loc": 732,
                "buggy_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
                "fixed_function": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
                "comment": "",
                "normalized_body": [
                    "void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState(childCount == 2, \\\"Bad binary operator \\\\\"%s\\\\\": expected 2 arguments but got %s\\\", opstr, childCount); int p = NodeUtil.precedence(type); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch(type) { case Token.TRY: { Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\\\"try\\\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\\\"finally\\\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\\\"catch(\\\"); add(first); add(\\\")\\\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\\\"throw\\\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\\\"return\\\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\\\"var \\\"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.isEmpty()) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\\\"=\\\", true); if (first.isComma()) { addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\\\"[\\\"); addArrayList(first); add(\\\"]\\\"); break; case Token.PARAM_LIST: add(\\\"(\\\"); addList(first); add(\\\")\\\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); unrollBinaryOperator(n, Token.COMMA, \\\",\\\", context, Context.OTHER, 0, 0); break; case Token.NUMBER: Preconditions.checkState(childCount == 0); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().isNumber()) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addExpr(first, p + 1, context); cc.addOp(\\\"?\\\", true); addExpr(first.getNext(), 1, Context.OTHER); cc.addOp(\\\":\\\", true); addExpr(last, 1, Context.OTHER); break; } case Token.REGEXP: if (!first.isString() || !last.isString()) { throw new Error(\\\"Expected children to be strings\\\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\\\"Unexpected Node subclass.\\\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\\\"(\\\"); } add(\\\"function\\\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\\\")\\\"); } break; case Token.GETTER_DEF: case Token.SETTER_DEF: Preconditions.checkState(n.getParent().isObjectLit()); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.isFunction()); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GETTER_DEF) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\\\"get \\\"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\\\"set \\\"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addJsString(n); } } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\\\"Unexpected Node subclass.\\\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript()); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.isVar()) { cc.endStatement(); } if (c.isFunction()) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\\\"for(\\\"); if (first.isVar()) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\\\";\\\"); add(first.getNext()); add(\\\";\\\"); add(first.getNext().getNext()); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\\\"for(\\\"); add(first); add(\\\"in\\\"); add(first.getNext()); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\\\"do\\\"); addNonEmptyStatement(first, Context.OTHER, false); add(\\\"while(\\\"); add(last); add(\\\")\\\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\\\"while(\\\"); add(first); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState(childCount == 2, \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount); Preconditions.checkState(last.isString(), \\\"Bad GETPROP: RHS should be STRING\\\"); boolean needsParens = (first.isNumber()); if (needsParens) { add(\\\"(\\\"); } addExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\\\")\\\"); } add(\\\".\\\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState(childCount == 2, \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount); addExpr(first, NodeUtil.precedence(type), context); add(\\\"[\\\"); add(first.getNext()); add(\\\"]\\\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\\\"with(\\\"); add(first); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\\\"(0,\\\"); addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER); add(\\\")\\\"); } else { addExpr(first, NodeUtil.precedence(type), context); } add(\\\"(\\\"); addList(first.getNext()); add(\\\")\\\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\\\"if(\\\"); add(first); add(\\\")\\\"); if (hasElse) { addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\\\"else\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: Preconditions.checkState(childCount == 0); add(\\\"null\\\"); break; case Token.THIS: Preconditions.checkState(childCount == 0); add(\\\"this\\\"); break; case Token.FALSE: Preconditions.checkState(childCount == 0); add(\\\"false\\\"); break; case Token.TRUE: Preconditions.checkState(childCount == 0); add(\\\"true\\\"); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\\\"continue\\\"); if (childCount == 1) { if (!first.isLabelName()) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\\\"debugger\\\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\\\"break\\\"); if (childCount == 1) { if (!first.isLabelName()) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\\\"new \\\"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence, Context.OTHER); Node next = first.getNext(); if (next != null) { add(\\\"(\\\"); addList(next); add(\\\")\\\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) { throw new IllegalStateException(\\\"Unexpected String children: \\\" + n.getParent().toStringTree()); } addJsString(n); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\\\"delete \\\"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\\\"(\\\"); } add(\\\"{\\\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.isGetterDef() || c.isSetterDef()) { add(c); } else { Preconditions.checkState(c.isString()); String key = c.getString(); if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { add(key); } else { double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1, Context.OTHER); } } add(\\\":\\\"); addExpr(c.getFirstChild(), 1, Context.OTHER); } } add(\\\"}\\\"); if (needsParens) { add(\\\")\\\"); } break; } case Token.SWITCH: add(\\\"switch(\\\"); add(first); add(\\\")\\\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\\\"case \\\"); add(first); addCaseBody(last); break; case Token.DEFAULT_CASE: Preconditions.checkState(childCount == 1); add(\\\"default\\\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (!first.isLabelName()) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(first); add(\\\":\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true); break; default: throw new Error(\\\"Unknown type \\\" + type + \\\"\\n\\\" + n.toStringTree()); } cc.endSourceMapping(n); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000000298023224,
                        "void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState(childCount == 2, \\\"Bad binary operator \\\\\"%s\\\\\": expected 2 arguments but got %s\\\", opstr, childCount); int p = NodeUtil.precedence(type); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p + 1, rhsContext); } return; } cc.startSourceMapping(n); switch(type) { case Token.TRY: { Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\\\"try\\\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\\\"finally\\\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\\\"catch(\\\"); add(first); add(\\\")\\\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\\\"throw\\\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\\\"return\\\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\\\"var \\\"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.isEmpty()) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\\\"=\\\", true); if (first.isComma()) { addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\\\"[\\\"); addArrayList(first); add(\\\"]\\\"); break; case Token.PARAM_LIST: add(\\\"(\\\"); addList(first); add(\\\")\\\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); unrollBinaryOperator(n, Token.COMMA, \\\",\\\", context, Context.OTHER, 0, 0); break; case Token.NUMBER: Preconditions.checkState(childCount == 0); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().isNumber()) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); addExpr(first, p + 1, context); cc.addOp(\\\"?\\\", true); addExpr(first.getNext(), 1, Context.OTHER); cc.addOp(\\\":\\\", true); addExpr(last, 1, Context.OTHER); break; } case Token.REGEXP: if (!first.isString() || !last.isString()) { throw new Error(\\\"Expected children to be strings\\\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\\\"Unexpected Node subclass.\\\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\\\"(\\\"); } add(\\\"function\\\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\\\")\\\"); } break; case Token.GETTER_DEF: case Token.SETTER_DEF: Preconditions.checkState(n.getParent().isObjectLit()); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.isFunction()); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GETTER_DEF) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\\\"get \\\"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\\\"set \\\"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addJsString(n); } } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\\\"Unexpected Node subclass.\\\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript()); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.isVar()) { cc.endStatement(); } if (c.isFunction()) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\\\"for(\\\"); if (first.isVar()) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\\\";\\\"); add(first.getNext()); add(\\\";\\\"); add(first.getNext().getNext()); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\\\"for(\\\"); add(first); add(\\\"in\\\"); add(first.getNext()); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\\\"do\\\"); addNonEmptyStatement(first, Context.OTHER, false); add(\\\"while(\\\"); add(last); add(\\\")\\\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\\\"while(\\\"); add(first); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState(childCount == 2, \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount); Preconditions.checkState(last.isString(), \\\"Bad GETPROP: RHS should be STRING\\\"); boolean needsParens = (first.isNumber()); if (needsParens) { add(\\\"(\\\"); } addExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\\\")\\\"); } add(\\\".\\\"); addIdentifier(last.getString()); break; } case Token.GETELEM: Preconditions.checkState(childCount == 2, \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount); addExpr(first, NodeUtil.precedence(type), context); add(\\\"[\\\"); add(first.getNext()); add(\\\"]\\\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\\\"with(\\\"); add(first); add(\\\")\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\\\"(0,\\\"); addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER); add(\\\")\\\"); } else { addExpr(first, NodeUtil.precedence(type), context); } add(\\\"(\\\"); addList(first.getNext()); add(\\\")\\\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\\\"if(\\\"); add(first); add(\\\")\\\"); if (hasElse) { addNonEmptyStatement(first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\\\"else\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: Preconditions.checkState(childCount == 0); add(\\\"null\\\"); break; case Token.THIS: Preconditions.checkState(childCount == 0); add(\\\"this\\\"); break; case Token.FALSE: Preconditions.checkState(childCount == 0); add(\\\"false\\\"); break; case Token.TRUE: Preconditions.checkState(childCount == 0); add(\\\"true\\\"); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\\\"continue\\\"); if (childCount == 1) { if (!first.isLabelName()) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\\\"debugger\\\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\\\"break\\\"); if (childCount == 1) { if (!first.isLabelName()) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(\\\" \\\"); add(first); } cc.endStatement(); break; case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\\\"new \\\"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence, Context.OTHER); Node next = first.getNext(); if (next != null) { add(\\\"(\\\"); addList(next); add(\\\")\\\"); } break; case Token.STRING: if (childCount != ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) { throw new IllegalStateException(\\\"Unexpected String children: \\\" + n.getParent().toStringTree()); } addJsString(n); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\\\"delete \\\"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\\\"(\\\"); } add(\\\"{\\\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.isGetterDef() || c.isSetterDef()) { add(c); } else { Preconditions.checkState(c.isString()); String key = c.getString(); if (!c.isQuotedString() && !TokenStream.isKeyword(key) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { add(key); } else { double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1, Context.OTHER); } } add(\\\":\\\"); addExpr(c.getFirstChild(), 1, Context.OTHER); } } add(\\\"}\\\"); if (needsParens) { add(\\\")\\\"); } break; } case Token.SWITCH: add(\\\"switch(\\\"); add(first); add(\\\")\\\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\\\"case \\\"); add(first); addCaseBody(last); break; case Token.DEFAULT_CASE: Preconditions.checkState(childCount == 1); add(\\\"default\\\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (!first.isLabelName()) { throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\"); } add(first); add(\\\":\\\"); addNonEmptyStatement(last, getContextForNonEmptyExpression(context), true); break; default: throw new Error(\\\"Unknown type \\\" + type + \\\"\\n\\\" + n.toStringTree()); } cc.endSourceMapping(n); }"
                    ],
                    [
                        0.9931221231818199,
                        "boolean parse() { int lineno; int charno; JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { jsdocBuilder.recordBlockDescription(\\\"\\\"); } } retry: for (; ; ) { switch(token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch(annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\\\"msg.jsdoc.consistidgen\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\\\"msg.jsdoc.const\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\", stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = \\\"\\\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\", stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\\\"number\\\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\\\"msg.jsdoc.export\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\\\"msg.jsdoc.expose\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\\\"msg.jsdoc.externs\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState(annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\\\"msg.end.annotation.expected\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\\\"msg.jsdoc.hidden\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\", stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\\\"msg.jsdoc.noalias\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\\\"msg.jsdoc.override\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordParamTypeNode(token)); if (type == null) { token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\\\"msg.missing.variable.name\\\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name, lineno, charno); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.private\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.protected\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.public\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName(templateTypeName)) { parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning(\\\"msg.jsdoc.idgen\\\", stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { } else { switch(annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\\\"msg.jsdoc.define\\\", lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription(returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; } } token = eatTokensUntilEOL(); continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: jsdocBuilder.build(null); parser.addParserWarning(\\\"msg.unexpected.eof\\\", stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } token = next(); } }"
                    ],
                    [
                        0.9926779493689537,
                        "private void visitExpression(Node node, int contextFlags) { int type = node.getType(); Node child = node.getFirstChild(); int savedStackDepth = stackDepth; switch(type) { case Token.FUNCTION: { int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP); FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex); if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) { throw Kit.codeBug(); } addIndexOp(Icode_CLOSURE_EXPR, fnIndex); stackChange(1); } break; case Token.LOCAL_LOAD: { int localIndex = getLocalBlockRef(node); addIndexOp(Token.LOCAL_LOAD, localIndex); stackChange(1); } break; case Token.COMMA: { Node lastChild = node.getLastChild(); while (child != lastChild) { visitExpression(child, 0); addIcode(Icode_POP); stackChange(-1); child = child.getNext(); } visitExpression(child, contextFlags & ECF_TAIL); } break; case Token.USE_STACK: stackChange(1); break; case Token.REF_CALL: case Token.CALL: case Token.NEW: { if (type == Token.NEW) { visitExpression(child, 0); } else { generateCallFunAndThis(child); } int argCount = 0; while ((child = child.getNext()) != null) { visitExpression(child, 0); ++argCount; } int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL); if (callType != Node.NON_SPECIALCALL) { addIndexOp(Icode_CALLSPECIAL, argCount); addUint8(callType); addUint8(type == Token.NEW ? 1 : 0); addUint16(lineNumber & 0xFFFF); } else { if (type == Token.CALL && (contextFlags & ECF_TAIL) != 0 && !compilerEnv.isGenerateDebugInfo() && !itsInTryFlag) { type = Icode_TAIL_CALL; } addIndexOp(type, argCount); } if (type == Token.NEW) { stackChange(-argCount); } else { stackChange(-1 - argCount); } if (argCount > itsData.itsMaxCalleeArgs) { itsData.itsMaxCalleeArgs = argCount; } } break; case Token.AND: case Token.OR: { visitExpression(child, 0); addIcode(Icode_DUP); stackChange(1); int afterSecondJumpStart = iCodeTop; int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ; addGotoOp(jump); stackChange(-1); addIcode(Icode_POP); stackChange(-1); child = child.getNext(); visitExpression(child, contextFlags & ECF_TAIL); resolveForwardGoto(afterSecondJumpStart); } break; case Token.HOOK: { Node ifThen = child.getNext(); Node ifElse = ifThen.getNext(); visitExpression(child, 0); int elseJumpStart = iCodeTop; addGotoOp(Token.IFNE); stackChange(-1); visitExpression(ifThen, contextFlags & ECF_TAIL); int afterElseJumpStart = iCodeTop; addGotoOp(Token.GOTO); resolveForwardGoto(elseJumpStart); stackDepth = savedStackDepth; visitExpression(ifElse, contextFlags & ECF_TAIL); resolveForwardGoto(afterElseJumpStart); } break; case Token.GETPROP: case Token.GETPROPNOWARN: visitExpression(child, 0); child = child.getNext(); addStringOp(type, child.getString()); break; case Token.DELPROP: boolean isName = child.getType() == Token.BINDNAME; visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); if (isName) { addIcode(Icode_DELNAME); } else { addToken(Token.DELPROP); } stackChange(-1); break; case Token.GETELEM: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); addToken(type); stackChange(-1); break; case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0); if (type == Token.VOID) { addIcode(Icode_POP); addIcode(Icode_UNDEF); } else { addToken(type); } break; case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0); addToken(type); break; case Token.SETPROP: case Token.SETPROP_OP: { visitExpression(child, 0); child = child.getNext(); String property = child.getString(); child = child.getNext(); if (type == Token.SETPROP_OP) { addIcode(Icode_DUP); stackChange(1); addStringOp(Token.GETPROP, property); stackChange(-1); } visitExpression(child, 0); addStringOp(Token.SETPROP, property); stackChange(-1); } break; case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); child = child.getNext(); if (type == Token.SETELEM_OP) { addIcode(Icode_DUP2); stackChange(2); addToken(Token.GETELEM); stackChange(-1); stackChange(-1); } visitExpression(child, 0); addToken(Token.SETELEM); stackChange(-2); break; case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0); child = child.getNext(); if (type == Token.SET_REF_OP) { addIcode(Icode_DUP); stackChange(1); addToken(Token.GET_REF); stackChange(-1); } visitExpression(child, 0); addToken(Token.SET_REF); stackChange(-1); break; case Token.STRICT_SETNAME: case Token.SETNAME: { String name = child.getString(); visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); addStringOp(type, name); stackChange(-1); } break; case Token.SETCONST: { String name = child.getString(); visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); addStringOp(Icode_SETCONST, name); stackChange(-1); } break; case Token.TYPEOFNAME: { int index = -1; if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getIndexForNameNode(node); if (index == -1) { addStringOp(Icode_TYPEOFNAME, node.getString()); stackChange(1); } else { addVarOp(Token.GETVAR, index); stackChange(1); addToken(Token.TYPEOF); } } break; case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString()); stackChange(1); break; case Token.INC: case Token.DEC: visitIncDec(node, child); break; case Token.NUMBER: { double num = node.getDouble(); int inum = (int) num; if (inum == num) { if (inum == 0) { addIcode(Icode_ZERO); if (1.0 / num < 0.0) { addToken(Token.NEG); } } else if (inum == 1) { addIcode(Icode_ONE); } else if ((short) inum == inum) { addIcode(Icode_SHORTNUMBER); addUint16(inum & 0xFFFF); } else { addIcode(Icode_INTNUMBER); addInt(inum); } } else { int index = getDoubleIndex(num); addIndexOp(Token.NUMBER, index); } stackChange(1); } break; case Token.GETVAR: { if (itsData.itsNeedsActivation) Kit.codeBug(); int index = scriptOrFn.getIndexForNameNode(node); addVarOp(Token.GETVAR, index); stackChange(1); } break; case Token.SETVAR: { if (itsData.itsNeedsActivation) Kit.codeBug(); int index = scriptOrFn.getIndexForNameNode(child); child = child.getNext(); visitExpression(child, 0); addVarOp(Token.SETVAR, index); } break; case Token.SETCONSTVAR: { if (itsData.itsNeedsActivation) Kit.codeBug(); int index = scriptOrFn.getIndexForNameNode(child); child = child.getNext(); visitExpression(child, 0); addVarOp(Token.SETCONSTVAR, index); } break; case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type); stackChange(1); break; case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node)); stackChange(1); break; case Token.REGEXP: { int index = node.getExistingIntProp(Node.REGEXP_PROP); addIndexOp(Token.REGEXP, index); stackChange(1); } break; case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child); break; case Token.ARRAYCOMP: visitArrayComprehension(node, child, child.getNext()); break; case Token.REF_SPECIAL: visitExpression(child, 0); addStringOp(type, (String) node.getProp(Node.NAME_PROP)); break; case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: { int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0); int childCount = 0; do { visitExpression(child, 0); ++childCount; child = child.getNext(); } while (child != null); addIndexOp(type, memberTypeFlags); stackChange(1 - childCount); } break; case Token.DOTQUERY: { int queryPC; updateLineNumber(node); visitExpression(child, 0); addIcode(Icode_ENTERDQ); stackChange(-1); queryPC = iCodeTop; visitExpression(child.getNext(), 0); addBackwardGoto(Icode_LEAVEDQ, queryPC); } break; case Token.DEFAULTNAMESPACE: case Token.ESCXMLATTR: case Token.ESCXMLTEXT: visitExpression(child, 0); addToken(type); break; case Token.YIELD: if (child != null) { visitExpression(child, 0); } else { addIcode(Icode_UNDEF); stackChange(1); } addToken(Token.YIELD); addUint16(node.getLineno() & 0xFFFF); break; case Token.WITHEXPR: { Node enterWith = node.getFirstChild(); Node with = enterWith.getNext(); visitExpression(enterWith.getFirstChild(), 0); addToken(Token.ENTERWITH); stackChange(-1); visitExpression(with.getFirstChild(), 0); addToken(Token.LEAVEWITH); break; } default: throw badTree(node); } if (savedStackDepth + 1 != stackDepth) { Kit.codeBug(); } }"
                    ],
                    [
                        0.9926643222570419,
                        "private void generateNativeFunctionOverrides(ClassFileWriter cfw, String encodedSource) { cfw.startMethod(\\\"getLanguageVersion\\\", \\\"()I\\\", ClassFileWriter.ACC_PUBLIC); cfw.addPush(compilerEnv.getLanguageVersion()); cfw.add(ByteCode.IRETURN); cfw.stopMethod((short) 1); final int Do_getFunctionName = 0; final int Do_getParamCount = 1; final int Do_getParamAndVarCount = 2; final int Do_getParamOrVarName = 3; final int Do_getEncodedSource = 4; final int Do_getParamOrVarConst = 5; final int SWITCH_COUNT = 6; for (int methodIndex = 0; methodIndex != SWITCH_COUNT; ++methodIndex) { if (methodIndex == Do_getEncodedSource && encodedSource == null) { continue; } short methodLocals; switch(methodIndex) { case Do_getFunctionName: methodLocals = 1; cfw.startMethod(\\\"getFunctionName\\\", \\\"()Ljava/lang/String;\\\", ClassFileWriter.ACC_PUBLIC); break; case Do_getParamCount: methodLocals = 1; cfw.startMethod(\\\"getParamCount\\\", \\\"()I\\\", ClassFileWriter.ACC_PUBLIC); break; case Do_getParamAndVarCount: methodLocals = 1; cfw.startMethod(\\\"getParamAndVarCount\\\", \\\"()I\\\", ClassFileWriter.ACC_PUBLIC); break; case Do_getParamOrVarName: methodLocals = 1 + 1; cfw.startMethod(\\\"getParamOrVarName\\\", \\\"(I)Ljava/lang/String;\\\", ClassFileWriter.ACC_PUBLIC); break; case Do_getParamOrVarConst: methodLocals = 1 + 1 + 1; cfw.startMethod(\\\"getParamOrVarConst\\\", \\\"(I)Z\\\", ClassFileWriter.ACC_PUBLIC); break; case Do_getEncodedSource: methodLocals = 1; cfw.startMethod(\\\"getEncodedSource\\\", \\\"()Ljava/lang/String;\\\", ClassFileWriter.ACC_PUBLIC); cfw.addPush(encodedSource); break; default: throw Kit.codeBug(); } int count = scriptOrFnNodes.length; int switchStart = 0; int switchStackTop = 0; if (count > 1) { cfw.addLoadThis(); cfw.add(ByteCode.GETFIELD, cfw.getClassName(), ID_FIELD_NAME, \\\"I\\\"); switchStart = cfw.addTableSwitch(1, count - 1); } for (int i = 0; i != count; ++i) { ScriptNode n = scriptOrFnNodes[i]; if (i == 0) { if (count > 1) { cfw.markTableSwitchDefault(switchStart); switchStackTop = cfw.getStackTop(); } } else { cfw.markTableSwitchCase(switchStart, i - 1, switchStackTop); } switch(methodIndex) { case Do_getFunctionName: if (n.getType() == Token.SCRIPT) { cfw.addPush(\\\"\\\"); } else { String name = ((FunctionNode) n).getName(); cfw.addPush(name); } cfw.add(ByteCode.ARETURN); break; case Do_getParamCount: cfw.addPush(n.getParamCount()); cfw.add(ByteCode.IRETURN); break; case Do_getParamAndVarCount: cfw.addPush(n.getParamAndVarCount()); cfw.add(ByteCode.IRETURN); break; case Do_getParamOrVarName: int paramAndVarCount = n.getParamAndVarCount(); if (paramAndVarCount == 0) { cfw.add(ByteCode.ACONST_NULL); cfw.add(ByteCode.ARETURN); } else if (paramAndVarCount == 1) { cfw.addPush(n.getParamOrVarName(0)); cfw.add(ByteCode.ARETURN); } else { cfw.addILoad(1); int paramSwitchStart = cfw.addTableSwitch(1, paramAndVarCount - 1); for (int j = 0; j != paramAndVarCount; ++j) { if (cfw.getStackTop() != 0) Kit.codeBug(); String s = n.getParamOrVarName(j); if (j == 0) { cfw.markTableSwitchDefault(paramSwitchStart); } else { cfw.markTableSwitchCase(paramSwitchStart, j - 1, 0); } cfw.addPush(s); cfw.add(ByteCode.ARETURN); } } break; case Do_getParamOrVarConst: paramAndVarCount = n.getParamAndVarCount(); boolean[] constness = n.getParamAndVarConst(); if (paramAndVarCount == 0) { cfw.add(ByteCode.ICONST_0); cfw.add(ByteCode.IRETURN); } else if (paramAndVarCount == 1) { cfw.addPush(constness[0]); cfw.add(ByteCode.IRETURN); } else { cfw.addILoad(1); int paramSwitchStart = cfw.addTableSwitch(1, paramAndVarCount - 1); for (int j = 0; j != paramAndVarCount; ++j) { if (cfw.getStackTop() != 0) Kit.codeBug(); if (j == 0) { cfw.markTableSwitchDefault(paramSwitchStart); } else { cfw.markTableSwitchCase(paramSwitchStart, j - 1, 0); } cfw.addPush(constness[j]); cfw.add(ByteCode.IRETURN); } } break; case Do_getEncodedSource: cfw.addPush(n.getEncodedSourceStart()); cfw.addPush(n.getEncodedSourceEnd()); cfw.addInvoke(ByteCode.INVOKEVIRTUAL, \\\"java/lang/String\\\", \\\"substring\\\", \\\"(II)Ljava/lang/String;\\\"); cfw.add(ByteCode.ARETURN); break; default: throw Kit.codeBug(); } } cfw.stopMethod(methodLocals); } }"
                    ],
                    [
                        0.992540679872036,
                        "private void generateStatement(Node node) { updateLineNumber(node); int type = node.getType(); Node child = node.getFirstChild(); switch(type) { case Token.LOOP: case Token.LABEL: case Token.WITH: case Token.SCRIPT: case Token.BLOCK: case Token.EMPTY: if (compilerEnv.isGenerateObserverCount()) { addInstructionCount(1); } while (child != null) { generateStatement(child); child = child.getNext(); } break; case Token.LOCAL_BLOCK: { int local = getNewWordLocal(); if (isGenerator) { cfw.add(ByteCode.ACONST_NULL); cfw.addAStore(local); } node.putIntProp(Node.LOCAL_PROP, local); while (child != null) { generateStatement(child); child = child.getNext(); } releaseWordLocal((short) local); node.removeProp(Node.LOCAL_PROP); break; } case Token.FUNCTION: { int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP); OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex); int t = ofn.fnode.getFunctionType(); if (t == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) { visitFunction(ofn, t); } else { if (t != FunctionNode.FUNCTION_STATEMENT) { throw Codegen.badTree(); } } break; } case Token.TRY: visitTryCatchFinally((Jump) node, child); break; case Token.CATCH_SCOPE: { cfw.setStackTop((short) 0); int local = getLocalBlockRegister(node); int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP); String name = child.getString(); child = child.getNext(); generateExpression(child, node); if (scopeIndex == 0) { cfw.add(ByteCode.ACONST_NULL); } else { cfw.addALoad(local); } cfw.addPush(name); cfw.addALoad(contextLocal); cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"newCatchScope\\\", \\\"(Ljava/lang/Throwable;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"Ljava/lang/String;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); cfw.addAStore(local); } break; case Token.THROW: generateExpression(child, node); if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); generateThrowJavaScriptException(); break; case Token.RETHROW: if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); cfw.addALoad(getLocalBlockRegister(node)); cfw.add(ByteCode.ATHROW); break; case Token.RETURN_RESULT: case Token.RETURN: if (!isGenerator) { if (child != null) { generateExpression(child, node); } else if (type == Token.RETURN) { Codegen.pushUndefined(cfw); } else { if (popvLocal < 0) throw Codegen.badTree(); cfw.addALoad(popvLocal); } } if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); if (epilogueLabel == -1) { if (!hasVarsInRegs) throw Codegen.badTree(); epilogueLabel = cfw.acquireLabel(); } cfw.add(ByteCode.GOTO, epilogueLabel); break; case Token.SWITCH: if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); visitSwitch((Jump) node, child); break; case Token.ENTERWITH: generateExpression(child, node); cfw.addALoad(contextLocal); cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"enterWith\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); cfw.addAStore(variableObjectLocal); incReferenceWordLocal(variableObjectLocal); break; case Token.LEAVEWITH: cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"leaveWith\\\", \\\"(Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); cfw.addAStore(variableObjectLocal); decReferenceWordLocal(variableObjectLocal); break; case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES: case Token.ENUM_INIT_ARRAY: generateExpression(child, node); cfw.addALoad(contextLocal); int enumType = type == Token.ENUM_INIT_KEYS ? ScriptRuntime.ENUMERATE_KEYS : type == Token.ENUM_INIT_VALUES ? ScriptRuntime.ENUMERATE_VALUES : ScriptRuntime.ENUMERATE_ARRAY; cfw.addPush(enumType); addScriptRuntimeInvoke(\\\"enumInit\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"I\\\" + \\\")Ljava/lang/Object;\\\"); cfw.addAStore(getLocalBlockRegister(node)); break; case Token.EXPR_VOID: if (child.getType() == Token.SETVAR) { visitSetVar(child, child.getFirstChild(), false); } else if (child.getType() == Token.SETCONSTVAR) { visitSetConstVar(child, child.getFirstChild(), false); } else if (child.getType() == Token.YIELD) { generateYieldPoint(child, false); } else { generateExpression(child, node); if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) cfw.add(ByteCode.POP2); else cfw.add(ByteCode.POP); } break; case Token.EXPR_RESULT: generateExpression(child, node); if (popvLocal < 0) { popvLocal = getNewWordLocal(); } cfw.addAStore(popvLocal); break; case Token.TARGET: { if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); int label = getTargetLabel(node); cfw.markLabel(label); if (compilerEnv.isGenerateObserverCount()) saveCurrentCodeOffset(); } break; case Token.JSR: case Token.GOTO: case Token.IFEQ: case Token.IFNE: if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); visitGoto((Jump) node, type, child); break; case Token.FINALLY: { if (!isGenerator) { break; } if (compilerEnv.isGenerateObserverCount()) saveCurrentCodeOffset(); cfw.setStackTop((short) 1); int finallyRegister = getNewWordLocal(); int finallyStart = cfw.acquireLabel(); int finallyEnd = cfw.acquireLabel(); cfw.markLabel(finallyStart); generateIntegerWrap(); cfw.addAStore(finallyRegister); while (child != null) { generateStatement(child); child = child.getNext(); } cfw.addALoad(finallyRegister); cfw.add(ByteCode.CHECKCAST, \\\"java/lang/Integer\\\"); generateIntegerUnwrap(); FinallyReturnPoint ret = finallys.get(node); ret.tableLabel = cfw.acquireLabel(); cfw.add(ByteCode.GOTO, ret.tableLabel); releaseWordLocal((short) finallyRegister); cfw.markLabel(finallyEnd); } break; case Token.DEBUGGER: break; default: throw Codegen.badTree(); } }"
                    ],
                    [
                        0.9924882724881172,
                        "private void parseFunctionParams(FunctionNode fnNode) throws IOException { if (matchToken(Token.RP)) { fnNode.setRp(ts.tokenBeg - fnNode.getPosition()); return; } Map<String, Node> destructuring = null; Set<String> paramNames = new HashSet<String>(); do { int tt = peekToken(); if (tt == Token.LB || tt == Token.LC) { AstNode expr = destructuringPrimaryExpr(); markDestructuring(expr); fnNode.addParam(expr); if (destructuring == null) { destructuring = new HashMap<String, Node>(); } String pname = currentScriptOrFn.getNextTempName(); defineSymbol(Token.LP, pname, false); destructuring.put(pname, expr); } else { if (mustMatchToken(Token.NAME, \\\"msg.no.parm\\\")) { fnNode.addParam(createNameNode()); String paramName = ts.getString(); defineSymbol(Token.LP, paramName); if (this.inUseStrictDirective) { if (\\\"eval\\\".equals(paramName) || \\\"arguments\\\".equals(paramName)) { reportError(\\\"msg.bad.id.strict\\\", paramName); } if (paramNames.contains(paramName)) addError(\\\"msg.dup.param.strict\\\", paramName); paramNames.add(paramName); } } else { fnNode.addParam(makeErrorNode()); } } } while (matchToken(Token.COMMA)); if (destructuring != null) { Node destructuringNode = new Node(Token.COMMA); for (Map.Entry<String, Node> param : destructuring.entrySet()) { Node assign = createDestructuringAssignment(Token.VAR, param.getValue(), createName(param.getKey())); destructuringNode.addChildToBack(assign); } fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode); } if (mustMatchToken(Token.RP, \\\"msg.no.paren.after.parms\\\")) { fnNode.setRp(ts.tokenBeg - fnNode.getPosition()); } }"
                    ],
                    [
                        0.9924065619707108,
                        "private void generateExpression(Node node, Node parent) { int type = node.getType(); Node child = node.getFirstChild(); switch(type) { case Token.USE_STACK: break; case Token.FUNCTION: if (fnCurrent != null || parent.getType() != Token.SCRIPT) { int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP); OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex); int t = ofn.fnode.getFunctionType(); if (t != FunctionNode.FUNCTION_EXPRESSION) { throw Codegen.badTree(); } visitFunction(ofn, t); } break; case Token.NAME: { cfw.addALoad(contextLocal); cfw.addALoad(variableObjectLocal); cfw.addPush(node.getString()); addScriptRuntimeInvoke(\\\"name\\\", \\\"(Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"Ljava/lang/String;\\\" + \\\")Ljava/lang/Object;\\\"); } break; case Token.CALL: case Token.NEW: { int specialType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL); if (specialType == Node.NON_SPECIALCALL) { OptFunctionNode target; target = (OptFunctionNode) node.getProp(Node.DIRECTCALL_PROP); if (target != null) { visitOptimizedCall(node, target, type, child); } else if (type == Token.CALL) { visitStandardCall(node, child); } else { visitStandardNew(node, child); } } else { visitSpecialCall(node, type, specialType, child); } } break; case Token.REF_CALL: generateFunctionAndThisObj(child, node); child = child.getNext(); generateCallArgArray(node, child, false); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"callRef\\\", \\\"(Lorg/mozilla/javascript/Callable;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"[Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Lorg/mozilla/javascript/Ref;\\\"); break; case Token.NUMBER: { double num = node.getDouble(); if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) { cfw.addPush(num); } else { codegen.pushNumberAsObject(cfw, num); } } break; case Token.STRING: cfw.addPush(node.getString()); break; case Token.THIS: cfw.addALoad(thisObjLocal); break; case Token.THISFN: cfw.add(ByteCode.ALOAD_0); break; case Token.NULL: cfw.add(ByteCode.ACONST_NULL); break; case Token.TRUE: cfw.add(ByteCode.GETSTATIC, \\\"java/lang/Boolean\\\", \\\"TRUE\\\", \\\"Ljava/lang/Boolean;\\\"); break; case Token.FALSE: cfw.add(ByteCode.GETSTATIC, \\\"java/lang/Boolean\\\", \\\"FALSE\\\", \\\"Ljava/lang/Boolean;\\\"); break; case Token.REGEXP: { int i = node.getExistingIntProp(Node.REGEXP_PROP); if (fnCurrent == null) { cfw.addALoad(scriptRegexpLocal); } else { cfw.addALoad(funObjLocal); cfw.add(ByteCode.GETFIELD, codegen.mainClassName, Codegen.REGEXP_ARRAY_FIELD_NAME, Codegen.REGEXP_ARRAY_FIELD_TYPE); } cfw.addPush(i); cfw.add(ByteCode.AALOAD); } break; case Token.COMMA: { Node next = child.getNext(); while (next != null) { generateExpression(child, node); cfw.add(ByteCode.POP); child = next; next = next.getNext(); } generateExpression(child, node); break; } case Token.ENUM_NEXT: case Token.ENUM_ID: { int local = getLocalBlockRegister(node); cfw.addALoad(local); if (type == Token.ENUM_NEXT) { addScriptRuntimeInvoke(\\\"enumNext\\\", \\\"(Ljava/lang/Object;)Ljava/lang/Boolean;\\\"); } else { cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"enumId\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); } break; } case Token.ARRAYLIT: visitArrayLiteral(node, child); break; case Token.OBJECTLIT: visitObjectLiteral(node, child); break; case Token.NOT: { int trueTarget = cfw.acquireLabel(); int falseTarget = cfw.acquireLabel(); int beyond = cfw.acquireLabel(); generateIfJump(child, node, trueTarget, falseTarget); cfw.markLabel(trueTarget); cfw.add(ByteCode.GETSTATIC, \\\"java/lang/Boolean\\\", \\\"FALSE\\\", \\\"Ljava/lang/Boolean;\\\"); cfw.add(ByteCode.GOTO, beyond); cfw.markLabel(falseTarget); cfw.add(ByteCode.GETSTATIC, \\\"java/lang/Boolean\\\", \\\"TRUE\\\", \\\"Ljava/lang/Boolean;\\\"); cfw.markLabel(beyond); cfw.adjustStackTop(-1); break; } case Token.BITNOT: generateExpression(child, node); addScriptRuntimeInvoke(\\\"toInt32\\\", \\\"(Ljava/lang/Object;)I\\\"); cfw.addPush(-1); cfw.add(ByteCode.IXOR); cfw.add(ByteCode.I2D); addDoubleWrap(); break; case Token.VOID: generateExpression(child, node); cfw.add(ByteCode.POP); Codegen.pushUndefined(cfw); break; case Token.TYPEOF: generateExpression(child, node); addScriptRuntimeInvoke(\\\"typeof\\\", \\\"(Ljava/lang/Object;\\\" + \\\")Ljava/lang/String;\\\"); break; case Token.TYPEOFNAME: visitTypeofname(node); break; case Token.INC: case Token.DEC: visitIncDec(node); break; case Token.OR: case Token.AND: { generateExpression(child, node); cfw.add(ByteCode.DUP); addScriptRuntimeInvoke(\\\"toBoolean\\\", \\\"(Ljava/lang/Object;)Z\\\"); int falseTarget = cfw.acquireLabel(); if (type == Token.AND) cfw.add(ByteCode.IFEQ, falseTarget); else cfw.add(ByteCode.IFNE, falseTarget); cfw.add(ByteCode.POP); generateExpression(child.getNext(), node); cfw.markLabel(falseTarget); } break; case Token.HOOK: { Node ifThen = child.getNext(); Node ifElse = ifThen.getNext(); generateExpression(child, node); addScriptRuntimeInvoke(\\\"toBoolean\\\", \\\"(Ljava/lang/Object;)Z\\\"); int elseTarget = cfw.acquireLabel(); cfw.add(ByteCode.IFEQ, elseTarget); short stack = cfw.getStackTop(); generateExpression(ifThen, node); int afterHook = cfw.acquireLabel(); cfw.add(ByteCode.GOTO, afterHook); cfw.markLabel(elseTarget, stack); generateExpression(ifElse, node); cfw.markLabel(afterHook); } break; case Token.ADD: { generateExpression(child, node); generateExpression(child.getNext(), node); switch(node.getIntProp(Node.ISNUMBER_PROP, -1)) { case Node.BOTH: cfw.add(ByteCode.DADD); break; case Node.LEFT: addOptRuntimeInvoke(\\\"add\\\", \\\"(DLjava/lang/Object;)Ljava/lang/Object;\\\"); break; case Node.RIGHT: addOptRuntimeInvoke(\\\"add\\\", \\\"(Ljava/lang/Object;D)Ljava/lang/Object;\\\"); break; default: if (child.getType() == Token.STRING) { addScriptRuntimeInvoke(\\\"add\\\", \\\"(Ljava/lang/CharSequence;\\\" + \\\"Ljava/lang/Object;\\\" + \\\")Ljava/lang/CharSequence;\\\"); } else if (child.getNext().getType() == Token.STRING) { addScriptRuntimeInvoke(\\\"add\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/CharSequence;\\\" + \\\")Ljava/lang/CharSequence;\\\"); } else { cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"add\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); } } } break; case Token.MUL: visitArithmetic(node, ByteCode.DMUL, child, parent); break; case Token.SUB: visitArithmetic(node, ByteCode.DSUB, child, parent); break; case Token.DIV: case Token.MOD: visitArithmetic(node, type == Token.DIV ? ByteCode.DDIV : ByteCode.DREM, child, parent); break; case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.LSH: case Token.RSH: case Token.URSH: visitBitOp(node, type, child); break; case Token.POS: case Token.NEG: generateExpression(child, node); addObjectToDouble(); if (type == Token.NEG) { cfw.add(ByteCode.DNEG); } addDoubleWrap(); break; case Token.TO_DOUBLE: generateExpression(child, node); addObjectToDouble(); break; case Token.TO_OBJECT: { int prop = -1; if (child.getType() == Token.NUMBER) { prop = child.getIntProp(Node.ISNUMBER_PROP, -1); } if (prop != -1) { child.removeProp(Node.ISNUMBER_PROP); generateExpression(child, node); child.putIntProp(Node.ISNUMBER_PROP, prop); } else { generateExpression(child, node); addDoubleWrap(); } break; } case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: { int trueGOTO = cfw.acquireLabel(); int falseGOTO = cfw.acquireLabel(); visitIfJumpRelOp(node, child, trueGOTO, falseGOTO); addJumpedBooleanWrap(trueGOTO, falseGOTO); break; } case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: { int trueGOTO = cfw.acquireLabel(); int falseGOTO = cfw.acquireLabel(); visitIfJumpEqOp(node, child, trueGOTO, falseGOTO); addJumpedBooleanWrap(trueGOTO, falseGOTO); break; } case Token.GETPROP: case Token.GETPROPNOWARN: visitGetProp(node, child); break; case Token.GETELEM: generateExpression(child, node); generateExpression(child.getNext(), node); cfw.addALoad(contextLocal); if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) { addScriptRuntimeInvoke(\\\"getObjectIndex\\\", \\\"(Ljava/lang/Object;D\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); } else { cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"getObjectElem\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Ljava/lang/Object;\\\"); } break; case Token.GET_REF: generateExpression(child, node); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"refGet\\\", \\\"(Lorg/mozilla/javascript/Ref;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); break; case Token.GETVAR: visitGetVar(node); break; case Token.SETVAR: visitSetVar(node, child, true); break; case Token.SETNAME: visitSetName(node, child); break; case Token.STRICT_SETNAME: visitStrictSetName(node, child); break; case Token.SETCONST: visitSetConst(node, child); break; case Token.SETCONSTVAR: visitSetConstVar(node, child, true); break; case Token.SETPROP: case Token.SETPROP_OP: visitSetProp(type, node, child); break; case Token.SETELEM: case Token.SETELEM_OP: visitSetElem(type, node, child); break; case Token.SET_REF: case Token.SET_REF_OP: { generateExpression(child, node); child = child.getNext(); if (type == Token.SET_REF_OP) { cfw.add(ByteCode.DUP); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"refGet\\\", \\\"(Lorg/mozilla/javascript/Ref;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); } generateExpression(child, node); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"refSet\\\", \\\"(Lorg/mozilla/javascript/Ref;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); } break; case Token.DEL_REF: generateExpression(child, node); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"refDel\\\", \\\"(Lorg/mozilla/javascript/Ref;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); break; case Token.DELPROP: boolean isName = child.getType() == Token.BINDNAME; generateExpression(child, node); child = child.getNext(); generateExpression(child, node); cfw.addALoad(contextLocal); cfw.addPush(isName); addScriptRuntimeInvoke(\\\"delete\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Z)Ljava/lang/Object;\\\"); break; case Token.BINDNAME: { while (child != null) { generateExpression(child, node); child = child.getNext(); } cfw.addALoad(contextLocal); cfw.addALoad(variableObjectLocal); cfw.addPush(node.getString()); addScriptRuntimeInvoke(\\\"bind\\\", \\\"(Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"Ljava/lang/String;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); } break; case Token.LOCAL_LOAD: cfw.addALoad(getLocalBlockRegister(node)); break; case Token.REF_SPECIAL: { String special = (String) node.getProp(Node.NAME_PROP); generateExpression(child, node); cfw.addPush(special); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"specialRef\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/String;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Lorg/mozilla/javascript/Ref;\\\"); } break; case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: { int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0); do { generateExpression(child, node); child = child.getNext(); } while (child != null); cfw.addALoad(contextLocal); String methodName, signature; switch(type) { case Token.REF_MEMBER: methodName = \\\"memberRef\\\"; signature = \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"I\\\" + \\\")Lorg/mozilla/javascript/Ref;\\\"; break; case Token.REF_NS_MEMBER: methodName = \\\"memberRef\\\"; signature = \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"I\\\" + \\\")Lorg/mozilla/javascript/Ref;\\\"; break; case Token.REF_NAME: methodName = \\\"nameRef\\\"; signature = \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"I\\\" + \\\")Lorg/mozilla/javascript/Ref;\\\"; cfw.addALoad(variableObjectLocal); break; case Token.REF_NS_NAME: methodName = \\\"nameRef\\\"; signature = \\\"(Ljava/lang/Object;\\\" + \\\"Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"I\\\" + \\\")Lorg/mozilla/javascript/Ref;\\\"; cfw.addALoad(variableObjectLocal); break; default: throw Kit.codeBug(); } cfw.addPush(memberTypeFlags); addScriptRuntimeInvoke(methodName, signature); } break; case Token.DOTQUERY: visitDotQuery(node, child); break; case Token.ESCXMLATTR: generateExpression(child, node); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"escapeAttributeValue\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/String;\\\"); break; case Token.ESCXMLTEXT: generateExpression(child, node); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"escapeTextValue\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/String;\\\"); break; case Token.DEFAULTNAMESPACE: generateExpression(child, node); cfw.addALoad(contextLocal); addScriptRuntimeInvoke(\\\"setDefaultNamespace\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\")Ljava/lang/Object;\\\"); break; case Token.YIELD: generateYieldPoint(node, true); break; case Token.WITHEXPR: { Node enterWith = child; Node with = enterWith.getNext(); Node leaveWith = with.getNext(); generateStatement(enterWith); generateExpression(with.getFirstChild(), with); generateStatement(leaveWith); break; } case Token.ARRAYCOMP: { Node initStmt = child; Node expr = child.getNext(); generateStatement(initStmt); generateExpression(expr, node); break; } default: throw new RuntimeException(\\\"Unexpected node type \\\" + type); } }"
                    ],
                    [
                        0.9921604245901108,
                        "private void visitSetVar(Node node, Node child, boolean needValue) { if (!hasVarsInRegs) Kit.codeBug(); int varIndex = fnCurrent.getVarIndex(node); generateExpression(child.getNext(), node); boolean isNumber = (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1); short reg = varRegisters[varIndex]; boolean[] constDeclarations = fnCurrent.fnode.getParamAndVarConst(); if (constDeclarations[varIndex]) { if (!needValue) { if (isNumber) cfw.add(ByteCode.POP2); else cfw.add(ByteCode.POP); } } else if (varIsDirectCallParameter(varIndex)) { if (isNumber) { if (needValue) cfw.add(ByteCode.DUP2); cfw.addALoad(reg); cfw.add(ByteCode.GETSTATIC, \\\"java/lang/Void\\\", \\\"TYPE\\\", \\\"Ljava/lang/Class;\\\"); int isNumberLabel = cfw.acquireLabel(); int beyond = cfw.acquireLabel(); cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel); short stack = cfw.getStackTop(); addDoubleWrap(); cfw.addAStore(reg); cfw.add(ByteCode.GOTO, beyond); cfw.markLabel(isNumberLabel, stack); cfw.addDStore(reg + 1); cfw.markLabel(beyond); } else { if (needValue) cfw.add(ByteCode.DUP); cfw.addAStore(reg); } } else { boolean isNumberVar = fnCurrent.isNumberVar(varIndex); if (isNumber) { if (isNumberVar) { cfw.addDStore(reg); if (needValue) cfw.addDLoad(reg); } else { if (needValue) cfw.add(ByteCode.DUP2); addDoubleWrap(); cfw.addAStore(reg); } } else { if (isNumberVar) Kit.codeBug(); cfw.addAStore(reg); if (needValue) cfw.addALoad(reg); } } }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.CodePrinterTest::testManyAdds"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n```\n\n```java\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }\n\n```\n\n```java\n\n    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }\n```\n#Error message from the test method 1: java.lang.StackOverflowError\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS: {\n          // All of these unary operators are right-associative\n          Preconditions.checkState(childCount == 1);\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n          break;\n        }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
                            "\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
                            "\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
                            "\nvoid add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    if (opstr != null && NodeUtil.isBinaryOperator(type)) {\n        Preconditions.checkState(\n                childCount >= 2,\n                \"Bad binary operator \\\"%s\\\": expected at least 2 arguments but got %s\",\n                opstr, childCount);\n        int p = NodeUtil.precedence(type);\n\n        Context rhsContext = getContextForNoInOperator(context);\n        Node current = first;\n        while (current.getNext() != null) {\n            if (NodeUtil.isAssociative(type) && current.getNext().getType() == type) {\n                addExpr(current, p, context);\n                cc.addOp(opstr, true);\n                current = current.getNext();\n            } else {\n                addExpr(current, p, context);\n                cc.addOp(opstr, true);\n                addExpr(current.getNext(), p + 1, rhsContext);\n                break;\n            }\n        }\n        return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n        case Token.TRY: {\n            Preconditions.checkState(first.getNext().isBlock() &&\n                    !first.getNext().hasMoreThanOneChild());\n            Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n            add(\"try\");\n            add(first, Context.PRESERVE_BLOCK);\n\n            Node catchblock = first.getNext().getFirstChild();\n            if (catchblock != null) {\n                add(catchblock);\n            }\n\n            if (childCount == 3) {\n                add(\"finally\");\n                add(last, Context.PRESERVE_BLOCK);\n            }\n            break;\n        }\n\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n            cc.endStatement(true);\n            break;\n\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n\n        case Token.NAME:\n            if (first == null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == 0);\n            cc.addNumber(n.getDouble());\n            break;\n\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS: {\n            Preconditions.checkState(childCount == 1);\n            cc.addOp(NodeUtil.opToStrNoFail(type), false);\n            addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n            break;\n        }\n\n        case Token.NEG: {\n            Preconditions.checkState(childCount == 1);\n\n            if (n.getFirstChild().isNumber()) {\n                cc.addNumber(-n.getFirstChild().getDouble());\n            } else {\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n            }\n\n            break;\n        }\n\n        case Token.HOOK: {\n            Preconditions.checkState(childCount == 3);\n            int p = NodeUtil.precedence(type);\n            addExpr(first, p + 1, context);\n            cc.addOp(\"?\", true);\n            addExpr(first.getNext(), 1, Context.OTHER);\n            cc.addOp(\":\", true);\n            addExpr(last, 1, Context.OTHER);\n            break;\n        }\n\n        case Token.REGEXP:\n            if (!first.isString() || !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n            if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n\n            add(\"function\");\n            add(first);\n\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.isFunction());\n\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GETTER_DEF) {\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n\n            String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n\n            if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) &&\n                    NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                double d = getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n\n        case Token.SCRIPT:\n        case Token.BLOCK: {\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n            if (preserveBlock) {\n                cc.beginBlock();\n            }\n\n            boolean preferLineBreaks = type == Token.SCRIPT || \n                (type == Token.BLOCK &&\n                !preserveBlock && \n                n.getParent() != null && \n                n.getParent().isScript());\n\n            for (Node c = first; c != null; c = c.getNext()) {\n                add(c, Context.STATEMENT);\n\n                if (c.isVar()) {\n                    cc.endStatement();\n                }\n\n                if (c.isFunction()) {\n                    cc.maybeLineBreak();\n                }\n\n                if (preferLineBreaks) {\n                    cc.notePreferredLineBreak();\n                }\n            }\n            if (preserveBlock) {\n                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n            }\n            break;\n        }\n\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(\n                        last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(\n                        last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            break;\n\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n\n        case Token.GETPROP: {\n            Preconditions.checkState(\n                    childCount == 2,\n                    \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n            Preconditions.checkState(\n                    last.isString(),\n                    \"Bad GETPROP: RHS should be STRING\");\n            boolean needsParens = (first.isNumber());\n            if (needsParens) {\n                add(\"(\");\n            }\n            addExpr(first, NodeUtil.precedence(type), context);\n            if (needsParens) {\n                add(\")\");\n            }\n            add(\".\");\n            addIdentifier(last.getString());\n            break;\n        }\n\n        case Token.GETELEM:\n            Preconditions.checkState(\n                    childCount == 2,\n                    \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            break;\n\n        case Token.INC:\n        case Token.DEC: {\n            Preconditions.checkState(childCount == 1);\n            String o = type == Token.INC ? \"++\" : \"--\";\n            int postProp = n.getIntProp(Node.INCRDECR_PROP);\n            if (postProp != 0) {\n                addExpr(first, NodeUtil.precedence(type), context);\n                cc.addOp(o, false);\n            } else {\n                cc.addOp(o, false);\n                add(first);\n            }\n            break;\n        }\n\n        case Token.CALL:\n            if (isIndirectEval(first)\n                    || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause =\n                    context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n\n            add(\"if(\");\n            add(first);\n            add(\")\");\n\n            if (hasElse) {\n                addNonEmptyStatement(\n                        first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(\n                        last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n\n        case Token.NULL:\n            Preconditions.checkState(childCount == 0);\n            add(\"null\");\n            break;\n\n        case Token.THIS:\n            Preconditions.checkState(childCount == 0);\n            add(\"this\");\n            break;\n\n        case Token.FALSE:\n            Preconditions.checkState(childCount == 0);\n            add(\"false\");\n            break;\n\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(\"true\");\n            break;\n\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n\n            if (NodeUtil.containsType(first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n\n            Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n\n        case Token.STRING:\n            if (childCount !=\n                    ((n.getParent() != null && n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\n                        \"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n);\n            break;\n\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n\n        case Token.OBJECTLIT: {\n            boolean needsParens = (context == Context.START_OF_EXPR);\n            if (needsParens) {\n                add(\"(\");\n            }\n            add(\"{\");\n            for (Node c = first; c != null; c = c.getNext()) {\n                if (c != first) {\n                    cc.listSeparator();\n                }\n\n                if (c.isGetterDef() || c.isSetterDef()) {\n                    add(c);\n                } else {\n                    Preconditions.checkState(c.isString());\n                    String key = c.getString();\n                    if (!c.isQuotedString() &&\n                            !TokenStream.isKeyword(key) &&\n                            TokenStream.isJSIdentifier(key) &&\n                            NodeUtil.isLatin(key)) {\n                        add(key);\n                    } else {\n                        double d = getSimpleNumber(key);\n                        if (!Double.isNaN(d)) {\n                            cc.addNumber(d);\n                        } else {\n                            addExpr(c, 1, Context.OTHER);\n                        }\n                    }\n                    add(\":\");\n                    addExpr(c.getFirstChild(), 1, Context.OTHER);\n                }\n            }\n            add(\"}\");\n            if (needsParens) {\n                add(\")\");\n            }\n            break;\n        }\n\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), true);\n            break;\n\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n}\n",
                            "\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n",
                            "\nvoid add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n        return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n            opstr, childCount);\n        int p = NodeUtil.precedence(type);\n\n        // For right-hand-side of operations, only pass context if it's\n        // the IN_FOR_INIT_CLAUSE one.\n        Context rhsContext = getContextForNoInOperator(context);\n\n        // Handle associativity.\n        // e.g. if the parse tree is a * (b * c),\n        // we can simply generate a * b * c.\n        if (last.getType() == type &&\n            NodeUtil.isAssociative(type)) {\n            unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p);\n        } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n            // Assignments are the only right-associative binary operators\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p, rhsContext);\n        } else {\n            addExpr(first, p, context);\n            cc.addOp(opstr, true);\n            addExpr(last, p + 1, rhsContext);\n        }\n        return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n        case Token.TRY: {\n            Preconditions.checkState(first.getNext().isBlock() &&\n                    !first.getNext().hasMoreThanOneChild());\n            Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n            add(\"try\");\n            add(first, Context.PRESERVE_BLOCK);\n\n            // second child contains the catch block, or nothing if there\n            // isn't a catch block\n            Node catchblock = first.getNext().getFirstChild();\n            if (catchblock != null) {\n                add(catchblock);\n            }\n\n            if (childCount == 3) {\n                add(\"finally\");\n                add(last, Context.PRESERVE_BLOCK);\n            }\n            break;\n        }\n\n        case Token.CATCH:\n            Preconditions.checkState(childCount == 2);\n            add(\"catch(\");\n            add(first);\n            add(\")\");\n            add(last, Context.PRESERVE_BLOCK);\n            break;\n\n        case Token.THROW:\n            Preconditions.checkState(childCount == 1);\n            add(\"throw\");\n            add(first);\n\n            // Must have a ';' after a throw statement, otherwise safari can't\n            // parse this.\n            cc.endStatement(true);\n            break;\n\n        case Token.RETURN:\n            add(\"return\");\n            if (childCount == 1) {\n                add(first);\n            } else {\n                Preconditions.checkState(childCount == 0);\n            }\n            cc.endStatement();\n            break;\n\n        case Token.VAR:\n            if (first != null) {\n                add(\"var \");\n                addList(first, false, getContextForNoInOperator(context));\n            }\n            break;\n\n        case Token.LABEL_NAME:\n            Preconditions.checkState(!n.getString().isEmpty());\n            addIdentifier(n.getString());\n            break;\n\n        case Token.NAME:\n            if (first == null || first.isEmpty()) {\n                addIdentifier(n.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                addIdentifier(n.getString());\n                cc.addOp(\"=\", true);\n                if (first.isComma()) {\n                    addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n                } else {\n                    // Add expression, consider nearby code at lowest level of\n                    // precedence.\n                    addExpr(first, 0, getContextForNoInOperator(context));\n                }\n            }\n            break;\n\n        case Token.ARRAYLIT:\n            add(\"[\");\n            addArrayList(first);\n            add(\"]\");\n            break;\n\n        case Token.PARAM_LIST:\n            add(\"(\");\n            addList(first);\n            add(\")\");\n            break;\n\n        case Token.COMMA:\n            Preconditions.checkState(childCount == 2);\n            unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n            break;\n\n        case Token.NUMBER:\n            Preconditions.checkState(childCount == 0);\n            cc.addNumber(n.getDouble());\n            break;\n\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.POS: {\n            // All of these unary operators are right-associative\n            Preconditions.checkState(childCount == 1);\n            cc.addOp(NodeUtil.opToStrNoFail(type), false);\n            addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n            break;\n        }\n\n        case Token.NEG: {\n            Preconditions.checkState(childCount == 1);\n\n            // It's important to our sanity checker that the code\n            // we print produces the same AST as the code we parse back.\n            // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n            if (n.getFirstChild().isNumber()) {\n                cc.addNumber(-n.getFirstChild().getDouble());\n            } else {\n                cc.addOp(NodeUtil.opToStrNoFail(type), false);\n                addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n            }\n\n            break;\n        }\n\n        case Token.HOOK: {\n            Preconditions.checkState(childCount == 3);\n            int p = NodeUtil.precedence(type);\n            addExpr(first, p + 1, context);\n            cc.addOp(\"?\", true);\n            addExpr(first.getNext(), 1, Context.OTHER);\n            cc.addOp(\":\", true);\n            addExpr(last, 1, Context.OTHER);\n            break;\n        }\n\n        case Token.REGEXP:\n            if (!first.isString() ||\n                !last.isString()) {\n                throw new Error(\"Expected children to be strings\");\n            }\n\n            String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n            // I only use one .add because whitespace matters\n            if (childCount == 2) {\n                add(regexp + last.getString());\n            } else {\n                Preconditions.checkState(childCount == 1);\n                add(regexp);\n            }\n            break;\n\n        case Token.FUNCTION:\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            Preconditions.checkState(childCount == 3);\n            boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n            if (funcNeedsParens) {\n                add(\"(\");\n            }\n\n            add(\"function\");\n            add(first);\n\n            add(first.getNext());\n            add(last, Context.PRESERVE_BLOCK);\n            cc.endFunction(context == Context.STATEMENT);\n\n            if (funcNeedsParens) {\n                add(\")\");\n            }\n            break;\n\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n            Preconditions.checkState(n.getParent().isObjectLit());\n            Preconditions.checkState(childCount == 1);\n            Preconditions.checkState(first.isFunction());\n\n            // Get methods are unnamed\n            Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n            if (type == Token.GETTER_DEF) {\n                // Get methods have no parameters.\n                Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n                add(\"get \");\n            } else {\n                // Set methods have one parameter.\n                Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n                add(\"set \");\n            }\n\n            // The name is on the GET or SET node.\n            String name = n.getString();\n            Node fn = first;\n            Node parameters = fn.getChildAtIndex(1);\n            Node body = fn.getLastChild();\n\n            // Add the property name.\n            if (!n.isQuotedString() &&\n                TokenStream.isJSIdentifier(name) &&\n                // do not encode literally any non-literal characters that were\n                // unicode escaped.\n                NodeUtil.isLatin(name)) {\n                add(name);\n            } else {\n                // Determine if the string is a simple number.\n                double d = getSimpleNumber(name);\n                if (!Double.isNaN(d)) {\n                    cc.addNumber(d);\n                } else {\n                    addJsString(n);\n                }\n            }\n\n            add(parameters);\n            add(body, Context.PRESERVE_BLOCK);\n            break;\n\n        case Token.SCRIPT:\n        case Token.BLOCK: {\n            if (n.getClass() != Node.class) {\n                throw new Error(\"Unexpected Node subclass.\");\n            }\n            boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n            if (preserveBlock) {\n                cc.beginBlock();\n            }\n\n            boolean preferLineBreaks =\n                type == Token.SCRIPT ||\n                (type == Token.BLOCK &&\n                    !preserveBlock &&\n                    n.getParent() != null &&\n                    n.getParent().isScript());\n            for (Node c = first; c != null; c = c.getNext()) {\n                add(c, Context.STATEMENT);\n\n                // VAR doesn't include ';' since it gets used in expressions\n                if (c.isVar()) {\n                    cc.endStatement();\n                }\n\n                if (c.isFunction()) {\n                    cc.maybeLineBreak();\n                }\n\n                // Prefer to break lines in between top-level statements\n                // because top level statements are more homogeneous.\n                if (preferLineBreaks) {\n                    cc.notePreferredLineBreak();\n                }\n            }\n            if (preserveBlock) {\n                cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n            }\n            break;\n        }\n\n        case Token.FOR:\n            if (childCount == 4) {\n                add(\"for(\");\n                if (first.isVar()) {\n                    add(first, Context.IN_FOR_INIT_CLAUSE);\n                } else {\n                    addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n                }\n                add(\";\");\n                add(first.getNext());\n                add(\";\");\n                add(first.getNext().getNext());\n                add(\")\");\n                addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            } else {\n                Preconditions.checkState(childCount == 3);\n                add(\"for(\");\n                add(first);\n                add(\"in\");\n                add(first.getNext());\n                add(\")\");\n                addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            }\n            break;\n\n        case Token.DO:\n            Preconditions.checkState(childCount == 2);\n            add(\"do\");\n            addNonEmptyStatement(first, Context.OTHER, false);\n            add(\"while(\");\n            add(last);\n            add(\")\");\n            cc.endStatement();\n            break;\n\n        case Token.WHILE:\n            Preconditions.checkState(childCount == 2);\n            add(\"while(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(\n                last, getContextForNonEmptyExpression(context), false);\n            break;\n\n        case Token.EMPTY:\n            Preconditions.checkState(childCount == 0);\n            break;\n\n        case Token.GETPROP: {\n            Preconditions.checkState(\n                childCount == 2,\n                \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n            Preconditions.checkState(\n                last.isString(),\n                \"Bad GETPROP: RHS should be STRING\");\n            boolean needsParens = (first.isNumber());\n            if (needsParens) {\n                add(\"(\");\n            }\n            addExpr(first, NodeUtil.precedence(type), context);\n            if (needsParens) {\n                add(\")\");\n            }\n            add(\".\");\n            addIdentifier(last.getString());\n            break;\n        }\n\n        case Token.GETELEM:\n            Preconditions.checkState(\n                childCount == 2,\n                \"Bad GETELEM: expected 2 children but got %s\", childCount);\n            addExpr(first, NodeUtil.precedence(type), context);\n            add(\"[\");\n            add(first.getNext());\n            add(\"]\");\n            break;\n\n        case Token.WITH:\n            Preconditions.checkState(childCount == 2);\n            add(\"with(\");\n            add(first);\n            add(\")\");\n            addNonEmptyStatement(\n                last, getContextForNonEmptyExpression(context), false);\n            break;\n\n        case Token.INC:\n        case Token.DEC: {\n            Preconditions.checkState(childCount == 1);\n            String o = type == Token.INC ? \"++\" : \"--\";\n            int postProp = n.getIntProp(Node.INCRDECR_PROP);\n            // A non-zero post-prop value indicates a post inc/dec, default of zero\n            // is a pre-inc/dec.\n            if (postProp != 0) {\n                addExpr(first, NodeUtil.precedence(type), context);\n                cc.addOp(o, false);\n            } else {\n                cc.addOp(o, false);\n                add(first);\n            }\n            break;\n        }\n\n        case Token.CALL:\n            // We have two special cases here:\n            // 1) If the left hand side of the call is a direct reference to eval,\n            // then it must have a DIRECT_EVAL annotation. If it does not, then\n            // that means it was originally an indirect call to eval, and that\n            // indirectness must be preserved.\n            // 2) If the left hand side of the call is a property reference,\n            // then the call must not a FREE_CALL annotation. If it does, then\n            // that means it was originally an call without an explicit this and\n            // that must be preserved.\n            if (isIndirectEval(first)\n                || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n                add(\"(0,\");\n                addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n                add(\")\");\n            } else {\n                addExpr(first, NodeUtil.precedence(type), context);\n            }\n            add(\"(\");\n            addList(first.getNext());\n            add(\")\");\n            break;\n\n        case Token.IF:\n            boolean hasElse = childCount == 3;\n            boolean ambiguousElseClause =\n                context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n            if (ambiguousElseClause) {\n                cc.beginBlock();\n            }\n\n            add(\"if(\");\n            add(first);\n            add(\")\");\n\n            if (hasElse) {\n                addNonEmptyStatement(\n                    first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n                add(\"else\");\n                addNonEmptyStatement(\n                    last, getContextForNonEmptyExpression(context), false);\n            } else {\n                addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n                Preconditions.checkState(childCount == 2);\n            }\n\n            if (ambiguousElseClause) {\n                cc.endBlock();\n            }\n            break;\n\n        case Token.NULL:\n            Preconditions.checkState(childCount == 0);\n            add(\"null\");\n            break;\n\n        case Token.THIS:\n            Preconditions.checkState(childCount == 0);\n            add(\"this\");\n            break;\n\n        case Token.FALSE:\n            Preconditions.checkState(childCount == 0);\n            add(\"false\");\n            break;\n\n        case Token.TRUE:\n            Preconditions.checkState(childCount == 0);\n            add(\"true\");\n            break;\n\n        case Token.CONTINUE:\n            Preconditions.checkState(childCount <= 1);\n            add(\"continue\");\n            if (childCount == 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n\n        case Token.DEBUGGER:\n            Preconditions.checkState(childCount == 0);\n            add(\"debugger\");\n            cc.endStatement();\n            break;\n\n        case Token.BREAK:\n            Preconditions.checkState(childCount <= 1);\n            add(\"break\");\n            if (childCount == 1) {\n                if (!first.isLabelName()) {\n                    throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n                }\n                add(\" \");\n                add(first);\n            }\n            cc.endStatement();\n            break;\n\n        case Token.EXPR_RESULT:\n            Preconditions.checkState(childCount == 1);\n            add(first, Context.START_OF_EXPR);\n            cc.endStatement();\n            break;\n\n        case Token.NEW:\n            add(\"new \");\n            int precedence = NodeUtil.precedence(type);\n\n            // If the first child contains a CALL, then claim higher precedence\n            // to force parentheses. Otherwise, when parsed, NEW will bind to the\n            // first viable parentheses (don't traverse into functions).\n            if (NodeUtil.containsType(\n                first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n                precedence = NodeUtil.precedence(first.getType()) + 1;\n            }\n            addExpr(first, precedence, Context.OTHER);\n\n            // '()' is optional when no arguments are present\n            Node next = first.getNext();\n            if (next != null) {\n                add(\"(\");\n                addList(next);\n                add(\")\");\n            }\n            break;\n\n        case Token.STRING:\n            if (childCount !=\n                ((n.getParent() != null &&\n                  n.getParent().isObjectLit()) ? 1 : 0)) {\n                throw new IllegalStateException(\n                    \"Unexpected String children: \" + n.getParent().toStringTree());\n            }\n            addJsString(n);\n            break;\n\n        case Token.DELPROP:\n            Preconditions.checkState(childCount == 1);\n            add(\"delete \");\n            add(first);\n            break;\n\n        case Token.OBJECTLIT: {\n            boolean needsParens = (context == Context.START_OF_EXPR);\n            if (needsParens) {\n                add(\"(\");\n            }\n            add(\"{\");\n            for (Node c = first; c != null; c = c.getNext()) {\n                if (c != first) {\n                    cc.listSeparator();\n                }\n\n                if (c.isGetterDef() || c.isSetterDef()) {\n                    add(c);\n                } else {\n                    Preconditions.checkState(c.isString());\n                    String key = c.getString();\n                    // Object literal property names don't have to be quoted if they\n                    // are not JavaScript keywords\n                    if (!c.isQuotedString() &&\n                        !TokenStream.isKeyword(key) &&\n                        TokenStream.isJSIdentifier(key) &&\n                        // do not encode literally any non-literal characters that\n                        // were unicode escaped.\n                        NodeUtil.isLatin(key)) {\n                        add(key);\n                    } else {\n                        // Determine if the string is a simple number.\n                        double d = getSimpleNumber(key);\n                        if (!Double.isNaN(d)) {\n                            cc.addNumber(d);\n                        } else {\n                            addExpr(c, 1, Context.OTHER);\n                        }\n                    }\n                    add(\":\");\n                    addExpr(c.getFirstChild(), 1, Context.OTHER);\n                }\n            }\n            add(\"}\");\n            if (needsParens) {\n                add(\")\");\n            }\n            break;\n        }\n\n        case Token.SWITCH:\n            add(\"switch(\");\n            add(first);\n            add(\")\");\n            cc.beginBlock();\n            addAllSiblings(first.getNext());\n            cc.endBlock(context == Context.STATEMENT);\n            break;\n\n        case Token.CASE:\n            Preconditions.checkState(childCount == 2);\n            add(\"case \");\n            add(first);\n            addCaseBody(last);\n            break;\n\n        case Token.DEFAULT_CASE:\n            Preconditions.checkState(childCount == 1);\n            add(\"default\");\n            addCaseBody(first);\n            break;\n\n        case Token.LABEL:\n            Preconditions.checkState(childCount == 2);\n            if (!first.isLabelName()) {\n                throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n            }\n            add(first);\n            add(\":\");\n            addNonEmptyStatement(\n                last, getContextForNonEmptyExpression(context), true);\n            break;\n\n        default:\n            throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n}\n",
                            "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p + 1, rhsContext);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, Context.OTHER);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, Context.OTHER);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      add(\".\");\n      addIdentifier(last.getString());\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      add(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      add(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      add(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING:\n      if (childCount !=\n          ((n.getParent() != null &&\n            n.getParent().isObjectLit()) ? 1 : 0)) {\n        throw new IllegalStateException(\n            \"Unexpected String children: \" + n.getParent().toStringTree());\n      }\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isString());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString() &&\n              !TokenStream.isKeyword(key) &&\n              TokenStream.isJSIdentifier(key) &&\n              // do not encode literally any non-literal characters that\n              // were unicode escaped.\n              NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n",
                            "\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n;\n    List<Node> nodes = new ArrayList<>();\n    \n    while (firstNonOperator.getType() == op) {\n      nodes.add(firstNonOperator.getFirstChild().getNext());\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n    \n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    for (int i = nodes.size() - 1; i >= 0; i--) {\n      cc.addOp(opStr, true);\n      addExpr(nodes.get(i), rightPrecedence, rhsContext);\n    }\n  }\n\n    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ' && getLastChar() != '(') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n",
                            "\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Deque<Node> stack = new ArrayDeque<>();\n    Node current = n;\n    while (current.getType() == op) {\n      stack.push(current);\n      current = current.getFirstChild();\n    }\n\n    addExpr(current, leftPrecedence, context);\n\n    while (!stack.isEmpty()) {\n      current = stack.pop();\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    }\n  }\n",
                            "\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node current = n;\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node addNode = firstNonOperator.getParent();\n    while (addNode != current) {\n      cc.listSeparator();\n      addExpr(addNode.getFirstChild().getNext(), rightPrecedence, rhsContext);\n      addNode = addNode.getParent();\n    }\n\n    do {\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n      current = current.getParent();\n    } while (current != n);\n  }\n\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/CodeGenerator.java",
                "start_loc": 741,
                "end_loc": 757,
                "buggy_function": "  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }\n",
                "fixed_function": "  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.addOp(opStr, true);\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }\n",
                "comment": "  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n",
                "normalized_body": [
                    "private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) { Node firstNonOperator = n.getFirstChild(); while (firstNonOperator.getType() == op) { firstNonOperator = firstNonOperator.getFirstChild(); } addExpr(firstNonOperator, leftPrecedence, context); Node current = firstNonOperator; do { current = current.getParent(); cc.listSeparator(); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "private void unrollBinaryOperator(Node n, int op, String opStr, Context context, Context rhsContext, int leftPrecedence, int rightPrecedence) { Node firstNonOperator = n.getFirstChild(); while (firstNonOperator.getType() == op) { firstNonOperator = firstNonOperator.getFirstChild(); } addExpr(firstNonOperator, leftPrecedence, context); Node current = firstNonOperator; do { current = current.getParent(); cc.listSeparator(); addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext); } while (current != n); }"
                    ],
                    [
                        0.9886447191238403,
                        "private Node trySplitComma(Node n) { if (late) { return n; } Node parent = n.getParent(); Node left = n.getFirstChild(); Node right = n.getLastChild(); if (parent.isExprResult() && !parent.getParent().isLabel()) { n.detachChildren(); parent.replaceChild(n, left); Node newStatement = IR.exprResult(right); newStatement.copyInformationFrom(n); parent.getParent().addChildAfter(newStatement, parent); reportCodeChange(); return left; } else { return n; } }"
                    ],
                    [
                        0.9882656335830688,
                        "private static Node fuseExpressionIntoExpression(Node exp1, Node exp2) { Node comma = new Node(Token.COMMA, exp1); comma.copyInformationFrom(exp2); if (exp2.isComma()) { Node leftMostChild = exp2; while (leftMostChild.isComma()) { leftMostChild = leftMostChild.getFirstChild(); } Node parent = leftMostChild.getParent(); comma.addChildToBack(leftMostChild.detachFromParent()); parent.addChildToFront(comma); return exp2; } else { comma.addChildToBack(exp2); return comma; } }"
                    ],
                    [
                        0.9864534139633179,
                        "private Node transformParenExpr(ParenthesizedExpression node) { AstNode expr = node.getExpression(); decompiler.addToken(Token.LP); int count = 1; while (expr instanceof ParenthesizedExpression) { decompiler.addToken(Token.LP); count++; expr = ((ParenthesizedExpression) expr).getExpression(); } Node result = transform(expr); for (int i = 0; i < count; i++) { decompiler.addToken(Token.RP); } result.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return result; }"
                    ],
                    [
                        0.9852482676506042,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (NodeUtil.isExprAssign(n)) { Node assign = n.getFirstChild(); Node lhs = assign.getFirstChild(); if (lhs.isGetProp() && isMarkedExpose(assign)) { exposedProperties.add(lhs.getLastChild().getString()); } } else if (NodeUtil.isObjectLitKey(n, parent) && n.isString() && isMarkedExpose(n)) { exposedProperties.add(n.getString()); } }"
                    ],
                    [
                        0.9849882125854492,
                        "private Node eliminateCallParamAt(SimpleDefinitionFinder defFinder, Parameter p, Node call, int argIndex) { Preconditions.checkArgument(NodeUtil.isCallOrNew(call), \\\"Node must be a call or new.\\\"); Node formalArgPtr = NodeUtil.getArgumentForCallOrNew(call, argIndex); if (formalArgPtr != null) { call.removeChild(formalArgPtr); if (p.getArg() != formalArgPtr) { removedNodes.add(formalArgPtr); } compiler.reportCodeChange(); } return formalArgPtr; }"
                    ],
                    [
                        0.9838315844535828,
                        "private boolean findFixedParameters(List<Parameter> parameters, Node cur) { boolean anyMovable = false; int index = 0; while ((cur = cur.getNext()) != null) { Parameter p; if (index >= parameters.size()) { p = new Parameter(cur, false); parameters.add(p); } else { p = parameters.get(index); if (p.shouldRemove()) { Node value = p.getArg(); if (!cur.isEquivalentTo(value)) { p.setShouldRemove(false); } else { anyMovable = true; } } } setParameterSideEffectInfo(p, cur); index++; } for (; index < parameters.size(); index++) { parameters.get(index).setShouldRemove(false); } return anyMovable; }"
                    ],
                    [
                        0.9837020635604858,
                        "private int getLocalVarIndex(Var v) { int num = v.index; Scope s = v.scope.getParent(); if (s == null) { throw new IllegalArgumentException(\\\"Var is not local\\\"); } boolean isBleedingIntoScope = s.getParent() != null && localBleedingFunctions.contains(v); while (s.getParent() != null) { if (isBleedingIntoScope) { num += localBleedingFunctionsPerScope.get(s).indexOf(v) + 1; isBleedingIntoScope = false; } else { num += localBleedingFunctionsPerScope.get(s).size(); } num += s.getVarCount(); s = s.getParent(); } return num; }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.CodePrinterTest::testManyAdds"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n```\n\n```java\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }\n\n```\n\n```java\n\n    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }\n```\n#Error message from the test method 1: java.lang.StackOverflowError\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    ArrayList<Node> operators = new ArrayList<>();\n    Node current = firstNonOperator;\n\n    do {\n      operators.add(current);\n      current = current.getParent();\n    } while (current != n);\n\n    Collections.reverse(operators);\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    for (int i = 1; i < operators.size(); i++) {\n      cc.addOp(opStr, true);\n      addExpr(operators.get(i).getFirstChild().getNext(), rightPrecedence, rhsContext);\n    }\n  }\n",
                            "\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node current = n;\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      current = firstNonOperator;\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    while (current != n) {\n      cc.listSeparator();\n      addExpr(current.getNext(), rightPrecedence, rhsContext);\n      current = current.getParent();\n    }\n  }\n",
                            "\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Deque<Node> stack = new ArrayDeque<>();\n    Node current = n;\n    while (current.getType() == op) {\n      stack.push(current);\n      current = current.getFirstChild();\n    }\n    addExpr(current, leftPrecedence, context);\n\n    while (!stack.isEmpty()) {\n      current = stack.pop();\n      cc.listSeparator();\n      addExpr(current.getSecondChild(), rightPrecedence, rhsContext);\n    }\n  }\n",
                            "\nprivate void unrollBinaryOperator(\n    Node n, int op, String opStr, Context context,\n    Context rhsContext, int leftPrecedence, int rightPrecedence) {\n\n    Node firstNonOperator = n;\n    while (firstNonOperator.getType() == op) {\n        firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    Node current = firstNonOperator.getParent();\n    if (current != null) {\n        addExpr(firstNonOperator, leftPrecedence, context);\n    }\n\n    while (current != null) {\n        cc.addOp(opStr, true);\n        Node nextNonOperator = current.getFirstChild().getNext();\n        addExpr(nextNonOperator, rightPrecedence, rhsContext);\n        current = current.getParent();\n    }\n}\n",
                            "\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node current = n;\n    Deque<Node> stack = new ArrayDeque<>();\n\n    while (current != null && current.getType() == op) {\n      stack.push(current.getFirstChild().getNext());\n      current = current.getFirstChild();\n    }\n\n    addExpr(current, leftPrecedence, context);\n    while (!stack.isEmpty()) {\n      cc.addOp(opStr, true);\n      addExpr(stack.pop(), rightPrecedence, rhsContext);\n    }\n  }\n",
                            "\n/**\n * We could use addList recursively here, but sometimes we produce\n * very deeply nested operators and run out of stack space, so we\n * just unroll the recursion when possible.\n *\n * We assume nodes are left-recursive.\n */\n\nprivate void unrollBinaryOperator(\n    Node n, int op, String opStr, Context context,\n    Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n;\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.addOp(opStr, true);\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n}\n",
                            "\nprivate void unrollBinaryOperator(\n    Node n, int op, String opStr, Context context,\n    Context rhsContext, int leftPrecedence, int rightPrecedence) {\n  Node firstNonOperator = n.getFirstChild();\n  while (firstNonOperator.getType() == op) {\n    firstNonOperator = firstNonOperator.getFirstChild();\n  }\n\n  addExpr(firstNonOperator, leftPrecedence, context);\n\n  Node current = firstNonOperator;\n  while (current != n) {\n    current = current.getParent();\n    cc.addOp(opStr, true);\n    addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n  }\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/CodePrinter.java",
                "start_loc": 331,
                "end_loc": 342,
                "buggy_function": "    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n",
                "fixed_function": "    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override void appendOp(String op, boolean binOp) { if (binOp) { if (getLastChar() != ' ') { append(\\\" \\\"); } append(op); append(\\\" \\\"); } else { append(op); } }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "@Override void appendOp(String op, boolean binOp) { if (binOp) { if (getLastChar() != ' ') { append(\\\" \\\"); } append(op); append(\\\" \\\"); } else { append(op); } }"
                    ],
                    [
                        0.9784355163574219,
                        "@Override public void visit(NodeVisitor v) { if (v.visit(this)) { target.visit(v); for (AstNode arg : getArguments()) { arg.visit(v); } } }"
                    ],
                    [
                        0.9762158393859863,
                        "@Override public void error(String message, String sourceName, int line, int lineOffset) { if (errors != null && errorsIndex < errors.length) { assertEquals(errors[errorsIndex++], message); } else { fail(\\\"extra error: \\\" + message); } }"
                    ],
                    [
                        0.973616361618042,
                        "@Override public void internalFrameActivated(InternalFrameEvent e) { if (consoleTextArea.hasFocus()) { consoleTextArea.getCaret().setVisible(false); consoleTextArea.getCaret().setVisible(true); } }"
                    ],
                    [
                        0.9725428223609924,
                        "@Override public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) { if (info != null) { if (!properties.containsKey(propertyName)) { defineInferredProperty(propertyName, getPropertyType(propertyName), null); } Property property = properties.get(propertyName); if (property != null) { property.setJSDocInfo(info); } } }"
                    ],
                    [
                        0.9709979295730591,
                        "@Override public void visit(NodeVisitor v) { if (v.visit(this)) { initializer.visit(v); condition.visit(v); increment.visit(v); body.visit(v); } }"
                    ],
                    [
                        0.9707175493240356,
                        "@Override public void visit(NodeVisitor v) { if (v.visit(this)) { for (AstNode e : getElements()) { e.visit(v); } } }"
                    ],
                    [
                        0.9704219102859497,
                        "@Override public void enterScope(NodeTraversal t) { Node n = t.getScope().getRootNode(); BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek(); blockStack.push(new BasicBlock(parent, n)); }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.CodePrinterTest::testManyAdds"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        add(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        add(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().isObjectLit()) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isString());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }\n\n```\n\n```java\n  /**\n   * We could use addList recursively here, but sometimes we produce\n   * very deeply nested operators and run out of stack space, so we\n   * just unroll the recursion when possible.\n   *\n   * We assume nodes are left-recursive.\n   */\n\n  private void unrollBinaryOperator(\n      Node n, int op, String opStr, Context context,\n      Context rhsContext, int leftPrecedence, int rightPrecedence) {\n    Node firstNonOperator = n.getFirstChild();\n    while (firstNonOperator.getType() == op) {\n      firstNonOperator = firstNonOperator.getFirstChild();\n    }\n\n    addExpr(firstNonOperator, leftPrecedence, context);\n\n    Node current = firstNonOperator;\n    do {\n      current = current.getParent();\n      cc.listSeparator();\n      addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n    } while (current != n);\n  }\n\n```\n\n```java\n\n    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }\n```\n#Error message from the test method 1: java.lang.StackOverflowError\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    @Override\n    void appendOp(String op, boolean binOp) {\n      if (binOp) {\n        if (getLastChar() != ' ' && getLastChar() != '(') {\n          append(\" \");\n        }\n        append(op);\n        append(\" \");\n      } else {\n        append(op);\n      }\n    }\n",
                            "\n@Override\nvoid appendOp(String op, boolean binOp) {\n  if (binOp) {\n    if (getLastChar() != ' ') {\n      append(\" \");\n    }\n    append(op);\n    append(\" \");\n  } else {\n    append(op);\n  }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.CodePrinterTest::testManyAdds": {
                "path": "test/com/google/javascript/jscomp/CodePrinterTest.java",
                "function_name": "testManyAdds",
                "src": "  public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }",
                "error_msg": "java.lang.StackOverflowError\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:102)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)",
                "clean_error_msg": "java.lang.StackOverflowError\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:102)  int p = NodeUtil.precedence(type);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);\n\tat com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)  addExpr(first, p, context);\n\tat com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)  add(n, context);"
            }
        },
        "evaluation_done": true
    }
}