{
    "Closure-174": {
        "function_num": 3,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/JsAst.java",
                "start_loc": 81,
                "end_loc": 108,
                "buggy_function": "  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null || compiler.hasHaltingErrors()) {\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                "fixed_function": "  private void parse(AbstractCompiler compiler) {\n    int startErrorCount = compiler.getErrorManager().getErrorCount();\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null ||\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n        (compiler.getErrorManager().getErrorCount() > startErrorCount && !compiler.isIdeMode())) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                "comment": "",
                "normalized_body": [
                    "private void parse(AbstractCompiler compiler) { try { ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(), compiler.getDefaultErrorReporter(), logger_); root = result.ast; compiler.setOldParseTree(sourceFile.getName(), result.oldAst); } catch (IOException e) { compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName())); } if (root == null || compiler.hasHaltingErrors()) { root = IR.script(); } else { compiler.prepareAst(root); } root.setStaticSourceFile(sourceFile); }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "private void parse(AbstractCompiler compiler) { try { ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(), compiler.getParserConfig(), compiler.getDefaultErrorReporter(), logger_); root = result.ast; compiler.setOldParseTree(sourceFile.getName(), result.oldAst); } catch (IOException e) { compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName())); } if (root == null || compiler.hasHaltingErrors()) { root = IR.script(); } else { compiler.prepareAst(root); } root.setStaticSourceFile(sourceFile); }"
                    ],
                    [
                        0.9886499047279358,
                        "private void exportTestFunctionAsSymbol(String testFunctionName, Node node, Node scriptNode) { Node exportCallTarget = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), exportSymbolFunction, node, testFunctionName); Node call = IR.call(exportCallTarget); if (exportCallTarget.isName()) { call.putBooleanProp(Node.FREE_CALL, true); } call.addChildToBack(IR.string(testFunctionName)); call.addChildToBack(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), testFunctionName, node, testFunctionName)); Node expression = IR.exprResult(call); scriptNode.addChildAfter(expression, node); compiler.reportCodeChange(); }"
                    ],
                    [
                        0.9880121946334839,
                        "private void transformCompilationUnit(ScriptNode tree) { loops = new ObjArray(); loopEnds = new ObjArray(); hasFinally = false; boolean createScopeObjects = tree.getType() != Token.FUNCTION || ((FunctionNode) tree).requiresActivation(); tree.flattenSymbolTable(!createScopeObjects); if (Token.printTrees) System.out.println(tree.toStringTree(tree)); boolean inStrictMode = tree instanceof AstRoot && ((AstRoot) tree).isInStrictMode(); transformCompilationUnit_r(tree, tree, tree, createScopeObjects, inStrictMode); }"
                    ],
                    [
                        0.9871882200241089,
                        "private ObjectProperty getterSetterProperty(int pos, AstNode propName, boolean isGetter) throws IOException { FunctionNode fn = function(FunctionNode.FUNCTION_EXPRESSION); Name name = fn.getFunctionName(); if (name != null && name.length() != 0) { reportError(\\\"msg.bad.prop\\\"); } ObjectProperty pn = new ObjectProperty(pos); if (isGetter) { pn.setIsGetter(); } else { pn.setIsSetter(); } int end = getNodeEnd(fn); pn.setLeft(propName); pn.setRight(fn); pn.setLength(end - pos); return pn; }"
                    ],
                    [
                        0.9870779514312744,
                        "private void visitRequireCall(NodeTraversal t, Node require, Node parent) { String moduleName = toModuleName(require.getChildAtIndex(1).getString(), normalizeSourceName(t.getSourceName())); Node moduleRef = IR.name(moduleName).srcref(require); parent.replaceChild(require, moduleRef); Node script = getCurrentScriptNode(parent); if (reportDependencies) { t.getInput().addRequire(moduleName); } script.addChildToFront(IR.exprResult(IR.call(IR.getprop(IR.name(\\\"goog\\\"), IR.string(\\\"require\\\")), IR.string(moduleName))).copyInformationFromForTree(require)); compiler.reportCodeChange(); }"
                    ],
                    [
                        0.9859796762466431,
                        "private void processIncrDecrExpr(Node node, JsonML currentParent, String op) { JsonML element = new JsonML(TagType.CountExpr); currentParent.appendChild(element); if (op.equals(\\\"++\\\")) { element.setAttribute(TagAttr.OP, \\\"++\\\"); } else { element.setAttribute(TagAttr.OP, \\\"--\\\"); } if (node.getIntProp(Node.INCRDECR_PROP) == 1) { element.setAttribute(TagAttr.IS_PREFIX, false); } else { element.setAttribute(TagAttr.IS_PREFIX, true); } processNode(node.getFirstChild(), element); }"
                    ],
                    [
                        0.9859553575515747,
                        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } reconcileOptionsWithGuards(); List<WarningsGuard> guards = Lists.newArrayList(); guards.add(new SuppressDocWarningsGuard(getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); this.warningsGuard = new ComposeWarningsGuard(guards); }"
                    ],
                    [
                        0.9854979515075684,
                        "public ScriptNode transformTree(AstRoot root) { currentScriptOrFn = root; this.inUseStrictDirective = root.isInStrictMode(); int sourceStartOffset = decompiler.getCurrentOffset(); if (Token.printTrees) { System.out.println(\\\"IRFactory.transformTree\\\"); System.out.println(root.debugPrint()); } ScriptNode script = (ScriptNode) transform(root); int sourceEndOffset = decompiler.getCurrentOffset(); script.setEncodedSourceBounds(sourceStartOffset, sourceEndOffset); if (compilerEnv.isGeneratingSource()) { script.setEncodedSource(decompiler.getEncodedSource()); } decompiler = null; return script; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null || compiler.hasHaltingErrors()) {\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n\n```\n\n```java\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>\n \n#Test method 2:\n```java\n  public void testIssue1103b() {\n    test(\"goog.scope(function () {\" +\n         \"  var a = foo, b, c = 1;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\n  }\n```\n#Error message from the test method 2: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\n \n#Test method 3:\n```java\n  public void testIssue1103c() {\n    test(\"goog.scope(function () {\" +\n         \"  /** @type {number} */ var a;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"/** @type {number} */ $jscomp.scope.a;\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 52 expected:<0> but was:<1>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(\n          sourceFile,\n          sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    }\n\n    // Only prepare AST if there were no errors\n    if (root != null && !compiler.hasHaltingErrors()) {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    if (root != null) {\n      root.setStaticSourceFile(sourceFile);\n    }\n  }\n\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n\n      if (root != null && !compiler.hasHaltingErrors()) {\n        compiler.prepareAst(root);\n      }\n\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    }\n    \n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n      root = IR.script(); // Move setting the dummy block here to ensure the root is not null.\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or some other error, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n      \n      if (root == null) {\n        // There was a parse error, so use a dummy block.\n        root = IR.script();\n      } else {\n        compiler.prepareAst(root);\n      }\n      \n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n      root = IR.script();\n    }\n\n    if (compiler.hasHaltingErrors()) {\n      // Halting errors encountered. Use a dummy block.\n      root = IR.script();\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n      root = IR.script(); // Ensure root is initialized to a dummy script on exception\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // Ensure dummy block is used when there is a parse error\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n\n      if (root == null || compiler.hasHaltingErrors()) {\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n        // There was a parse error or IOException, so use a dummy block.\n        root = IR.script();\n      } else {\n        compiler.prepareAst(root);\n      }\n\n      // Set the source name so that the compiler passes can track\n      // the source file and module.\n      root.setStaticSourceFile(sourceFile);\n\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n      root = IR.script(); // Ensure 'root' is set on IOException to prevent further issues\n    }\n  }\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(\n          sourceFile,\n          sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_\n      );\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n\n      if (root != null && !compiler.hasHaltingErrors()) {\n        compiler.prepareAst(root);\n        root.setStaticSourceFile(sourceFile);\n        return;\n      }\n    } catch (IOException e) {\n      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      root = IR.script();\n      root.setStaticSourceFile(sourceFile);\n    }\n  }\n",
                            "\nprivate void parse(AbstractCompiler compiler) {\n    try {\n        ParserRunner.ParseResult result = ParserRunner.parse(\n            sourceFile, sourceFile.getCode(),\n            compiler.getParserConfig(),\n            compiler.getDefaultErrorReporter(),\n            logger_);\n        root = result.ast;\n        compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n        compiler.report(\n            JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n        root = IR.script(); // Ensuring root is assigned in error case\n        return; // Exit the method after handling error\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n        // There was a parse error or IOException, so use a dummy block.\n        root = IR.script();\n    } else {\n        compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n}\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n      root = IR.script(); // Fix: Ensure root is set to a dummy block on IOException\n      return; // Exit early since root is set to a dummy block\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    root.setStaticSourceFile(sourceFile);\n  }\n",
                            "\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n      \n      if (root != null && !compiler.hasHaltingErrors()) {\n          compiler.prepareAst(root);\n      } else {\n          // There was a parse error or IOException, so use a dummy block.\n          root = IR.script();\n      }\n\n      // Set the source name so that the compiler passes can track\n      // the source file and module.\n      root.setStaticSourceFile(sourceFile);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n      \n      // In case of IOException, set a dummy block.\n      root = IR.script();\n      root.setStaticSourceFile(sourceFile);\n    }\n  }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/NodeUtil.java",
                "start_loc": 2360,
                "end_loc": 2372,
                "buggy_function": "  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n",
                "fixed_function": "  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else if (value != null) {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(nameNode);\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n",
                "comment": "  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n",
                "normalized_body": [
                    "public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) { Node result; Node nameNode = newQualifiedNameNode(convention, name); if (nameNode.isName()) { result = IR.var(nameNode, value); result.setJSDocInfo(info); } else { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); } return result; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "public static Node newQualifiedNameNodeDeclaration(CodingConvention convention, String name, Node value, JSDocInfo info) { Node result; Node nameNode = newQualifiedNameNode(convention, name); if (nameNode.isName()) { result = IR.var(nameNode, value); result.setJSDocInfo(info); } else { result = IR.exprResult(IR.assign(nameNode, value)); result.getFirstChild().setJSDocInfo(info); } return result; }"
                    ],
                    [
                        0.9767287373542786,
                        "private Node parse(String string, String... warnings) { TestErrorReporter testErrorReporter = new TestErrorReporter(null, warnings); Node script = null; try { StaticSourceFile file = new SimpleSourceFile(\\\"input\\\", false); script = ParserRunner.parse(file, string, ParserRunner.createConfig(true, mode, false), testErrorReporter, Logger.getAnonymousLogger()).ast; } catch (IOException e) { throw new RuntimeException(e); } assertTrue(testErrorReporter.hasEncounteredAllErrors()); assertTrue(testErrorReporter.hasEncounteredAllWarnings()); return script; }"
                    ],
                    [
                        0.9751232862472534,
                        "private Node parseError(String string, String... errors) { TestErrorReporter testErrorReporter = new TestErrorReporter(errors, null); Node script = null; try { StaticSourceFile file = new SimpleSourceFile(\\\"input\\\", false); script = ParserRunner.parse(file, string, ParserRunner.createConfig(isIdeMode, mode, false), testErrorReporter, Logger.getAnonymousLogger()).ast; } catch (IOException e) { throw new RuntimeException(e); } assertTrue(testErrorReporter.hasEncounteredAllErrors()); assertTrue(testErrorReporter.hasEncounteredAllWarnings()); return script; }"
                    ],
                    [
                        0.9737170934677124,
                        "@Override public JSType caseUnionType(UnionType type) { boolean changed = false; List<JSType> results = Lists.newArrayList(); for (JSType alternative : type.getAlternates()) { JSType replacement = alternative.visit(this); if (replacement != alternative) { changed = true; } results.add(replacement); } if (changed) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : results) { builder.addAlternate(alternate); } return builder.build(); } return type; }"
                    ],
                    [
                        0.9737057685852051,
                        "private Node transformParenExpr(ParenthesizedExpression node) { AstNode expr = node.getExpression(); decompiler.addToken(Token.LP); int count = 1; while (expr instanceof ParenthesizedExpression) { decompiler.addToken(Token.LP); count++; expr = ((ParenthesizedExpression) expr).getExpression(); } Node result = transform(expr); for (int i = 0; i < count; i++) { decompiler.addToken(Token.RP); } result.putProp(Node.PARENTHESIZED_PROP, Boolean.TRUE); return result; }"
                    ],
                    [
                        0.9726742506027222,
                        "private SourcePosition<AliasTransformation> getSourceRegion(Node n) { Node testNode = n; Node next = null; for (; next != null || testNode.isScript(); ) { next = testNode.getNext(); testNode = testNode.getParent(); } int endLine = next == null ? Integer.MAX_VALUE : next.getLineno(); int endChar = next == null ? Integer.MAX_VALUE : next.getCharno(); SourcePosition<AliasTransformation> pos = new SourcePosition<AliasTransformation>() { }; pos.setPositionInformation(n.getLineno(), n.getCharno(), endLine, endChar); return pos; }"
                    ],
                    [
                        0.9722467064857483,
                        "private Node eliminateCallParamAt(SimpleDefinitionFinder defFinder, Parameter p, Node call, int argIndex) { Preconditions.checkArgument(NodeUtil.isCallOrNew(call), \\\"Node must be a call or new.\\\"); Node formalArgPtr = NodeUtil.getArgumentForCallOrNew(call, argIndex); if (formalArgPtr != null) { call.removeChild(formalArgPtr); if (p.getArg() != formalArgPtr) { removedNodes.add(formalArgPtr); } compiler.reportCodeChange(); } return formalArgPtr; }"
                    ],
                    [
                        0.9721850156784058,
                        "public static CharRanges expandToAllMatched(CharRanges ranges) { CharRanges caseSensitive = ranges.intersection(CASE_SENSITIVE); if (caseSensitive.isEmpty()) { return ranges; } CharRanges expanded = CharRanges.EMPTY; for (DeltaSet ds : DELTA_SETS) { expanded = expanded.union(caseSensitive.intersection(ds.codeUnits).shift(-ds.delta)); } return ranges.union(expanded); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n  private void parse(AbstractCompiler compiler) {\n    try {\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n      root = result.ast;\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n\n    if (root == null || compiler.hasHaltingErrors()) {\n        // Most passes try to report as many errors as possible,\n        // so there may already be errors. We only care if there were\n        // errors in the code we just parsed.\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }\n\n```\n\n```java\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>\n \n#Test method 2:\n```java\n  public void testIssue1103b() {\n    test(\"goog.scope(function () {\" +\n         \"  var a = foo, b, c = 1;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\n  }\n```\n#Error message from the test method 2: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\n \n#Test method 3:\n```java\n  public void testIssue1103c() {\n    test(\"goog.scope(function () {\" +\n         \"  /** @type {number} */ var a;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"/** @type {number} */ $jscomp.scope.a;\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 52 expected:<0> but was:<1>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n    }\n\n    // Always set JSDoc info on the outer result node\n    result.setJSDocInfo(info);\n\n    return result;\n  }\n",
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      if (info != null) {\n        result.getFirstChild().setJSDocInfo(info);\n      }\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      if (info != null) {\n        result.getFirstChild().getFirstChild().setJSDocInfo(info);\n      }\n    }\n    return result;\n  }\n",
                            "\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.setJSDocInfo(info); // Set JSDocInfo on the result node, not its child\n    }\n    return result;\n  }\n",
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      if (info != null) {\n        nameNode.setJSDocInfo(info);\n      }\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      if (info != null) {\n        result.getFirstChild().setJSDocInfo(info);\n      }\n    }\n    return result;\n  }\n",
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n    }\n    result.setJSDocInfo(info); // Set JSDocInfo on the resulting node, not its child\n    return result;\n  }\n",
                            "\n  /**\n   * Creates a node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value != null ? value : IR.nullNode()); // Ensure a non-null 'value'\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value != null ? value : IR.nullNode()));\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n\n",
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    if (value == null) {\n      Node nameNode = newQualifiedNameNode(convention, name);\n      result = IR.declaration(nameNode, IR.nullNode(), Token.VAR);\n      result.setJSDocInfo(info);\n    } else {\n      Node nameNode = newQualifiedNameNode(convention, name);\n      if (nameNode.isName()) {\n        result = IR.var(nameNode, value);\n        result.setJSDocInfo(info);\n      } else {\n        result = IR.exprResult(IR.assign(nameNode, value));\n        result.getFirstChild().setJSDocInfo(info);\n      }\n    }\n    return result;\n  }\n",
                            "\npublic static Node newQualifiedNameNodeDeclaration(\n    CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n        result = IR.var(nameNode, value);\n        nameNode.setJSDocInfo(info); // Ensure JSDoc is set on the nameNode\n    } else {\n        result = IR.exprResult(IR.assign(nameNode, value));\n        nameNode.setJSDocInfo(info); // Ensure JSDoc is set on the nameNode\n    }\n    return result;\n}\n",
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      result.setJSDocInfo(info);\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      if (result.getFirstChild().isAssign()) { // Fix: Check if the child is an assignment\n        result.getFirstChild().getSecondChild().setJSDocInfo(info); // Assign JSDocInfo to the RHS\n      }\n    }\n    return result;\n  }\n",
                            "\n  public static Node newQualifiedNameNodeDeclaration(\n      CodingConvention convention, String name, Node value, JSDocInfo info) {\n    Node result;\n    Node nameNode = newQualifiedNameNode(convention, name);\n    if (nameNode.isName()) {\n      result = IR.var(nameNode, value);\n      if (info != null) {\n        result.getFirstChild().setJSDocInfo(info);\n      }\n    } else {\n      result = IR.exprResult(IR.assign(nameNode, value));\n      result.getFirstChild().setJSDocInfo(info);\n    }\n    return result;\n  }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/ScopedAliases.java",
                "start_loc": 351,
                "end_loc": 398,
                "buggy_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVarAssign) {\n          Node value = v.getInitialValue().detachFromParent();\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not allow hoisted functions or other kinds of local symbols.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n",
                "fixed_function": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not allow hoisted functions or other kinds of local symbols.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVarAssign = parent.isVar() && n.hasChildren(); if (isVarAssign && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVarAssign) { Node value = v.getInitialValue().detachFromParent(); String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \\\"$jscomp.scope.\\\" + name + (nameCount == 0 ? \\\"\\\" : (\\\"$\\\" + nameCount)); compiler.ensureLibraryInjected(\\\"base\\\"); Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name); parent.getParent().addChildBefore(newDecl, parent); v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "private void findAliases(NodeTraversal t) { Scope scope = t.getScope(); for (Var v : scope.getVarIterable()) { Node n = v.getNode(); Node parent = n.getParent(); boolean isVarAssign = parent.isVar() && n.hasChildren(); if (isVarAssign && n.getFirstChild().isQualifiedName()) { recordAlias(v); } else if (v.isBleedingFunction()) { } else if (parent.getType() == Token.LP) { } else if (isVarAssign) { Node value = v.getInitialValue().detachFromParent(); String name = n.getString(); int nameCount = scopedAliasNames.count(name); scopedAliasNames.add(name); String globalName = \\\"$jscomp.scope.\\\" + name + (nameCount == 0 ? \\\"\\\" : (\\\"$\\\" + nameCount)); compiler.ensureLibraryInjected(\\\"base\\\"); Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n); NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name); parent.getParent().addChildBefore(newDecl, parent); v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name)); recordAlias(v); } else { report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } } }"
                    ],
                    [
                        0.9913744926452637,
                        "@Override public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.VAR: Node name; for (name = n.getFirstChild(); name != null; name = name.getNext()) { if (inExterns) { scope.declareSlot(name.getString(), n, createType(name, scope)); } else { scope.declareSlot(name.getString(), n); if (name.getFirstChild() != null) { addActions(createAssignmentActions(name, name.getFirstChild(), n)); } } } break; case Token.GETPROP: if (inExterns) { ConcreteType type = inferConcreteType(getTopScope(), n); if (type.isNone()) { ConcreteScope scope = (ConcreteScope) inferConcreteType(getTopScope(), n.getFirstChild()).getScope(); if (scope != null) { type = createType(n.getJSType()); if (type.isNone() || type.isAll()) { break; } type = createUnionWithSubTypes(type); Node nameNode = n.getLastChild(); scope.declareSlot(nameNode.getString(), n, type); } } } break; case Token.FUNCTION: if (NodeUtil.isFunctionDeclaration(n)) { if (!n.getJSType().isNoObjectType()) { ConcreteFunctionType type = createConcreteFunction(n, scope); scope.declareSlot(n.getFirstChild().getString(), n, type); if (inExterns && type.getInstanceType() != null) { allInstantiatedTypes.add(type.getInstanceType()); } } } break; case Token.ASSIGN: Node lhs = n.getFirstChild(); if (inExterns) { ConcreteScope scope; if (lhs.isGetProp()) { ConcreteType type = inferConcreteType(getTopScope(), lhs.getFirstChild()); scope = (ConcreteScope) type.getScope(); } else { scope = getTopScope(); } if (scope == null) { break; } ConcreteType type = inferConcreteType(getTopScope(), n); if (type.isNone() || type.isAll()) { break; } if (type.isFunction()) { JSType lhsType = lhs.getJSType(); if (lhsType == null) { break; } FunctionType funType = lhsType.restrictByNotNullOrUndefined().toMaybeFunctionType(); if (funType == null) { break; } ConcreteType retType = createType(funType.getReturnType()); retType = createUnionWithSubTypes(retType); ConcreteType newret = type.toFunction().getReturnSlot().getType().unionWith(retType); ((ConcreteScope) type.getScope()).declareSlot(ConcreteFunctionType.RETURN_SLOT_NAME, n, newret); } scope.declareSlot(lhs.getLastChild().getString(), n, type); } else { addActions(createAssignmentActions(lhs, n.getLastChild(), n)); } break; case Token.NEW: case Token.CALL: Node receiver = n.getFirstChild(); if (receiver.isGetProp()) { Node first = receiver.getFirstChild(); if (\\\"call\\\".equals(first.getNext().getString())) { if (first.isGetProp()) { addAction(new FunctionCallBuilder(first, receiver.getNext()).setPropName(first.getFirstChild().getNext().getString()).setIsCallFunction().build()); } else { addAction(new FunctionCallBuilder(first, receiver.getNext()).setIsCallFunction().build()); } } else { addAction(new FunctionCallBuilder(first, receiver.getNext()).setPropName(first.getNext().getString()).build()); } } else { addAction(new FunctionCallBuilder(receiver, receiver.getNext()).setIsNewCall(n.isNew()).build()); } break; case Token.NAME: if (parent.isCatch() && parent.getFirstChild() == n) { scope.declareSlot(n.getString(), n, createUnionWithSubTypes(createType(getTypeRegistry().getType(\\\"Error\\\")).toInstance())); } break; case Token.RETURN: if (n.getFirstChild() != null) { addAction(new VariableAssignAction((ConcreteSlot) scope.getOwnSlot(ConcreteFunctionType.RETURN_SLOT_NAME), n.getFirstChild())); } break; } Collection<Action> actions = getImplicitActions(n); if (actions != null) { for (Action action : actions) { addAction(action); } } }"
                    ],
                    [
                        0.9911495447158813,
                        "private JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined(); case Token.QMARK: Node firstChild = n.getFirstChild(); if (firstChild == null) { return getNativeType(UNKNOWN_TYPE); } return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope)); case Token.EQUALS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if ((namedType instanceof ObjectType) && !(namedType instanceof NamespaceType) && !(nonNullableTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); int nAllowedTypes = namedType.getTemplateTypeMap().numUnfilledTemplateKeys(); if (typeList != null && nAllowedTypes > 0) { ImmutableList.Builder<JSType> templateTypes = ImmutableList.builder(); if (n.getString().equals(\\\"Object\\\") && typeList.getFirstChild() == typeList.getLastChild()) { templateTypes.add(getNativeType(UNKNOWN_TYPE)); } int templateNodeIndex = 0; for (Node templateNode : typeList.getFirstChild().siblings()) { if (++templateNodeIndex > nAllowedTypes) { break; } templateTypes.add(createFromTypeNodesInternal(templateNode, sourceName, scope)); } namedType = createTemplatizedType((ObjectType) namedType, templateTypes.build()); Preconditions.checkNotNull(namedType); } return createDefaultObjectUnion(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; boolean isConstructor = false; Node current = n.getFirstChild(); if (current.getType() == Token.THIS || current.getType() == Token.NEW) { Node contextNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(SimpleErrorReporter.getMessage0(current.getType() == Token.THIS ? \\\"msg.jsdoc.function.thisnotobject\\\" : \\\"msg.jsdoc.function.newnotobject\\\"), sourceName, contextNode.getLineno(), contextNode.getCharno()); } isConstructor = current.getType() == Token.NEW; current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.PARAM_LIST) { for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope)); } } else { JSType type = createFromTypeNodesInternal(arg, sourceName, scope); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(SimpleErrorReporter.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodesInternal(current, sourceName, scope); return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build(); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }"
                    ],
                    [
                        0.9900400638580322,
                        "public void helperInlineReferenceToFunction(String code, final String expectedResult, final String fnName, final InliningMode mode, final boolean decompose) { final Compiler compiler = new Compiler(); final FunctionInjector injector = new FunctionInjector(compiler, compiler.getUniqueNameIdSupplier(), decompose, assumeStrictThis, assumeMinimumCapture); List<SourceFile> externsInputs = Lists.newArrayList(SourceFile.fromCode(\\\"externs\\\", \\\"\\\")); CompilerOptions options = new CompilerOptions(); options.setCodingConvention(new GoogleCodingConvention()); compiler.init(externsInputs, Lists.newArrayList(SourceFile.fromCode(\\\"code\\\", code)), options); Node parseRoot = compiler.parseInputs(); Node externsRoot = parseRoot.getFirstChild(); final Node tree = parseRoot.getLastChild(); assertNotNull(tree); assertTrue(tree != externsRoot); final Node expectedRoot = parseExpected(new Compiler(), expectedResult); Node mainRoot = tree; MarkNoSideEffectCalls mark = new MarkNoSideEffectCalls(compiler); mark.process(externsRoot, mainRoot); Normalize normalize = new Normalize(compiler, false); normalize.process(externsRoot, mainRoot); compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED); final Node fnNode = findFunction(tree, fnName); assertNotNull(fnNode); final Set<String> unsafe = FunctionArgumentInjector.findModifiedParameters(fnNode); assertNotNull(fnNode); Method tester = new Method() { @Override public boolean call(NodeTraversal t, Node n, Node parent) { CanInlineResult canInline = injector.canInlineReferenceToFunction(t, n, fnNode, unsafe, mode, NodeUtil.referencesThis(fnNode), NodeUtil.containsFunction(NodeUtil.getFunctionBody(fnNode))); assertTrue(\\\"canInlineReferenceToFunction should not be CAN_NOT_INLINE\\\", CanInlineResult.NO != canInline); if (decompose) { assertTrue(\\\"canInlineReferenceToFunction \\\" + \\\"should be CAN_INLINE_AFTER_DECOMPOSITION\\\", CanInlineResult.AFTER_PREPARATION == canInline); Set<String> knownConstants = Sets.newHashSet(); injector.setKnownConstants(knownConstants); injector.maybePrepareCall(n); assertTrue(\\\"canInlineReferenceToFunction \\\" + \\\"should be CAN_INLINE\\\", CanInlineResult.YES != canInline); } Node result = injector.inline(n, fnName, fnNode, mode); validateSourceInfo(compiler, result); String explanation = expectedRoot.checkTreeEquals(tree.getFirstChild()); assertNull(\\\"\\nExpected: \\\" + toSource(expectedRoot) + \\\"\\nResult: \\\" + toSource(tree.getFirstChild()) + \\\"\\n\\\" + explanation, explanation); return true; } }; compiler.resetUniqueNameId(); TestCallback test = new TestCallback(fnName, tester); NodeTraversal.traverse(compiler, tree, test); }"
                    ],
                    [
                        0.990032434463501,
                        "private void visitAssign(NodeTraversal t, Node assign) { JSDocInfo info = assign.getJSDocInfo(); Node lvalue = assign.getFirstChild(); Node rvalue = assign.getLastChild(); if (lvalue.isGetProp()) { Node object = lvalue.getFirstChild(); JSType objectJsType = getJSType(object); Node property = lvalue.getLastChild(); String pname = property.getString(); if (object.isGetProp()) { JSType jsType = getJSType(object.getFirstChild()); if (jsType.isInterface() && object.getLastChild().getString().equals(\\\"prototype\\\")) { visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue); } } checkEnumAlias(t, info, rvalue); checkPropCreation(t, lvalue); if (pname.equals(\\\"prototype\\\")) { if (objectJsType != null && objectJsType.isFunctionType()) { FunctionType functionType = objectJsType.toMaybeFunctionType(); if (functionType.isConstructor()) { JSType rvalueType = rvalue.getJSType(); validator.expectObject(t, rvalue, rvalueType, OVERRIDING_PROTOTYPE_WITH_NON_OBJECT); if (functionType.makesStructs() && !rvalueType.isStruct()) { String funName = functionType.getTypeOfThis().toString(); compiler.report(t.makeError(assign, CONFLICTING_SHAPE_TYPE, \\\"struct\\\", funName)); } return; } } } ObjectType type = ObjectType.cast(objectJsType.restrictByNotNullOrUndefined()); if (type != null) { if (type.hasProperty(pname) && !type.isPropertyTypeInferred(pname) && !propertyIsImplicitCast(type, pname)) { JSType expectedType = type.getPropertyType(pname); if (!expectedType.isUnknownType()) { validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), expectedType, object, pname); checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, expectedType); return; } } } checkPropertyInheritanceOnGetpropAssign(t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE)); } JSType leftType = getJSType(lvalue); if (lvalue.isQualifiedName()) { Var var = t.getScope().getVar(lvalue.getQualifiedName()); if (var != null) { if (var.isTypeInferred()) { return; } if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() && t.getScope() != var.getScope()) { return; } if (var.getType() != null) { leftType = var.getType(); } } } Node rightChild = assign.getLastChild(); JSType rightType = getJSType(rightChild); if (validator.expectCanAssignTo(t, assign, rightType, leftType, \\\"assignment\\\")) { ensureTyped(t, assign, rightType); } else { ensureTyped(t, assign); } }"
                    ],
                    [
                        0.989977240562439,
                        "private String getFunctionAnnotation(Node fnNode) { Preconditions.checkState(fnNode.isFunction()); JSType type = fnNode.getJSType(); if (type == null || type.isUnknownType()) { return \\\"\\\"; } FunctionType funType = type.toMaybeFunctionType(); if (JSType.isEquivalent(type, registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE))) { return \\\"/** @type {!Function} */\\n\\\"; } StringBuilder sb = new StringBuilder(\\\"/**\\n\\\"); if (fnNode != null) { Node paramNode = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); for (Node n : funType.getParameters()) { if (paramNode == null) { break; } sb.append(\\\" * \\\"); appendAnnotation(sb, \\\"param\\\", getParameterNodeJSDocType(n)); sb.append(\\\" \\\").append(paramNode.getString()).append(\\\"\\n\\\"); paramNode = paramNode.getNext(); } } JSType retType = funType.getReturnType(); if (retType != null && !retType.isEmptyType() && !funType.isInterface() && !(funType.isConstructor() && retType.isVoidType())) { sb.append(\\\" * \\\"); appendAnnotation(sb, \\\"return\\\", retType.toAnnotationString()); sb.append(\\\"\\n\\\"); } if (funType.isConstructor() || funType.isInterface()) { FunctionType superConstructor = funType.getSuperClassConstructor(); if (superConstructor != null) { ObjectType superInstance = funType.getSuperClassConstructor().getInstanceType(); if (!superInstance.toString().equals(\\\"Object\\\")) { sb.append(\\\" * \\\"); appendAnnotation(sb, \\\"extends\\\", superInstance.toAnnotationString()); sb.append(\\\"\\n\\\"); } } if (funType.isInterface()) { for (ObjectType interfaceType : funType.getExtendedInterfaces()) { sb.append(\\\" * \\\"); appendAnnotation(sb, \\\"extends\\\", interfaceType.toAnnotationString()); sb.append(\\\"\\n\\\"); } } Set<String> interfaces = Sets.newTreeSet(); for (ObjectType interfaze : funType.getImplementedInterfaces()) { interfaces.add(interfaze.toAnnotationString()); } for (String interfaze : interfaces) { sb.append(\\\" * \\\"); appendAnnotation(sb, \\\"implements\\\", interfaze); sb.append(\\\"\\n\\\"); } if (funType.isConstructor()) { sb.append(\\\" * @constructor\\n\\\"); } else if (funType.isInterface()) { sb.append(\\\" * @interface\\n\\\"); } } if (!funType.getTemplateTypeMap().getTemplateKeys().isEmpty()) { sb.append(\\\" * @template \\\"); sb.append(Joiner.on(\\\",\\\").join(funType.getTemplateTypeMap().getTemplateKeys())); sb.append(\\\"\\n\\\"); } if (fnNode != null && fnNode.getBooleanProp(Node.IS_DISPATCHER)) { sb.append(\\\" * @javadispatch\\n\\\"); } sb.append(\\\" */\\n\\\"); return sb.toString(); }"
                    ],
                    [
                        0.9899725317955017,
                        "protected Node visitLet(boolean createWith, Node parent, Node previous, Node scopeNode) { Node vars = scopeNode.getFirstChild(); Node body = vars.getNext(); scopeNode.removeChild(vars); scopeNode.removeChild(body); boolean isExpression = scopeNode.getType() == Token.LETEXPR; Node result; Node newVars; if (createWith) { result = new Node(isExpression ? Token.WITHEXPR : Token.BLOCK); result = replaceCurrent(parent, previous, scopeNode, result); ArrayList<Object> list = new ArrayList<Object>(); Node objectLiteral = new Node(Token.OBJECTLIT); for (Node v = vars.getFirstChild(); v != null; v = v.getNext()) { Node current = v; if (current.getType() == Token.LETEXPR) { List<?> destructuringNames = (List<?>) current.getProp(Node.DESTRUCTURING_NAMES); Node c = current.getFirstChild(); if (c.getType() != Token.LET) throw Kit.codeBug(); if (isExpression) { body = new Node(Token.COMMA, c.getNext(), body); } else { body = new Node(Token.BLOCK, new Node(Token.EXPR_VOID, c.getNext()), body); } if (destructuringNames != null) { list.addAll(destructuringNames); for (int i = 0; i < destructuringNames.size(); i++) { objectLiteral.addChildToBack(new Node(Token.VOID, Node.newNumber(0.0))); } } current = c.getFirstChild(); } if (current.getType() != Token.NAME) throw Kit.codeBug(); list.add(ScriptRuntime.getIndexObject(current.getString())); Node init = current.getFirstChild(); if (init == null) { init = new Node(Token.VOID, Node.newNumber(0.0)); } objectLiteral.addChildToBack(init); } objectLiteral.putProp(Node.OBJECT_IDS_PROP, list.toArray()); newVars = new Node(Token.ENTERWITH, objectLiteral); result.addChildToBack(newVars); result.addChildToBack(new Node(Token.WITH, body)); result.addChildToBack(new Node(Token.LEAVEWITH)); } else { result = new Node(isExpression ? Token.COMMA : Token.BLOCK); result = replaceCurrent(parent, previous, scopeNode, result); newVars = new Node(Token.COMMA); for (Node v = vars.getFirstChild(); v != null; v = v.getNext()) { Node current = v; if (current.getType() == Token.LETEXPR) { Node c = current.getFirstChild(); if (c.getType() != Token.LET) throw Kit.codeBug(); if (isExpression) { body = new Node(Token.COMMA, c.getNext(), body); } else { body = new Node(Token.BLOCK, new Node(Token.EXPR_VOID, c.getNext()), body); } Scope.joinScopes((Scope) current, (Scope) scopeNode); current = c.getFirstChild(); } if (current.getType() != Token.NAME) throw Kit.codeBug(); Node stringNode = Node.newString(current.getString()); stringNode.setScope((Scope) scopeNode); Node init = current.getFirstChild(); if (init == null) { init = new Node(Token.VOID, Node.newNumber(0.0)); } newVars.addChildToBack(new Node(Token.SETVAR, stringNode, init)); } if (isExpression) { result.addChildToBack(newVars); scopeNode.setType(Token.COMMA); result.addChildToBack(scopeNode); scopeNode.addChildToBack(body); if (body instanceof Scope) { Scope scopeParent = ((Scope) body).getParentScope(); ((Scope) body).setParentScope((Scope) scopeNode); ((Scope) scopeNode).setParentScope(scopeParent); } } else { result.addChildToBack(new Node(Token.EXPR_VOID, newVars)); scopeNode.setType(Token.BLOCK); result.addChildToBack(scopeNode); scopeNode.addChildrenToBack(body); if (body instanceof Scope) { Scope scopeParent = ((Scope) body).getParentScope(); ((Scope) body).setParentScope((Scope) scopeNode); ((Scope) scopeNode).setParentScope(scopeParent); } } } return result; }"
                    ],
                    [
                        0.989452064037323,
                        "protected void check(Map<String, String> originalInputs, String generatedSource, String sourceMapFileContent, SourceMapSupplier supplier) { Map<String, Token> originalTokens = findTokens(originalInputs); Map<String, Token> resultTokens = findTokens(generatedSource); assertEquals(originalTokens.size(), resultTokens.size()); SourceMapping reader; try { reader = SourceMapConsumerFactory.parse(sourceMapFileContent, supplier); } catch (SourceMapParseException e) { throw new RuntimeException(\\\"unexpected exception\\\", e); } for (Token token : resultTokens.values()) { OriginalMapping mapping = reader.getMappingForLine(token.position.getLine() + 1, token.position.getColumn() + 1); assertNotNull(mapping); Token inputToken = originalTokens.get(token.tokenName); assertNotNull(inputToken); assertEquals(mapping.getOriginalFile(), inputToken.inputName); assertEquals(mapping.getLineNumber(), inputToken.position.getLine() + 1); int start = inputToken.position.getColumn() + 1; if (inputToken.tokenName.startsWith(\\\"STR\\\")) { start--; } if (validateColumns) { assertEquals(start, mapping.getColumnPosition()); } if (!inputToken.tokenName.startsWith(\\\"STR\\\")) { assertTrue(\\\"missing name for \\\" + inputToken.tokenName, !mapping.getIdentifier().isEmpty()); } if (!mapping.getIdentifier().isEmpty()) { assertEquals(mapping.getIdentifier(), \\\"__\\\" + inputToken.tokenName + \\\"__\\\"); } } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103a",
                    "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103b"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVarAssign) {\n          Node value = v.getInitialValue().detachFromParent();\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not allow hoisted functions or other kinds of local symbols.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103a(ScopedAliasesTest.java:526)  test(\"goog.scope(function () {\" +         \"  var a;\" +         \"  foo.bar = function () { a = 1; };\" +         \"});\",         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n \n#Test method 2:\n```java\n  public void testIssue1103b() {\n    test(\"goog.scope(function () {\" +\n         \"  var a = foo, b, c = 1;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\n  }\n```\n#Error message: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n  Node(FUNCTION ): testcode:1:11\ngoog.scope(function () {  var a = foo, b, c = 1;});\n  Parent(CALL): testcode:1:0\ngoog.scope(function () {  var a = foo, b, c = 1;});\n\n\tat com.google.javascript.jscomp.Compiler.ensureLibraryInjected(Compiler.java:2554)  Node lastChild = firstChild.getLastSibling();\n\tat com.google.javascript.jscomp.NodeTraversal.pushScope(NodeTraversal.java:600)  scopeCallback.enterScope(this);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:558)  pushScope(n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)  traverseFunction(n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:287)  traverseBranch(root, null);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:494)  t.traverse(root);\n\tat com.google.javascript.jscomp.ScopedAliases.hotSwapScript(ScopedAliases.java:133)  NodeTraversal.traverse(compiler, root, traversal);\n\tat com.google.javascript.jscomp.ScopedAliases.process(ScopedAliases.java:127)  hotSwapScript(root, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:845)  getProcessor(compiler).process(externsRoot, mainRoot);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103b(ScopedAliasesTest.java:534)  test(\"goog.scope(function () {\" +         \"  var a = foo, b, c = 1;\" +         \"});\",         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\nCaused by: java.lang.NullPointerException\n\t... 54 more\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVarAssign = parent.isVar() && n.hasChildren();\n    if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVarAssign && v.getInitialValue() != null) {\n      Node value = v.getInitialValue().detachFromParent();\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      compiler.ensureLibraryInjected(\"base\");\n\n      // Add $jscomp.scope.name = EXPR;\n      // Make sure we copy over all the jsdoc and debug info.\n      Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n          compiler.getCodingConvention(),\n          globalName,\n          value,\n          v.getJSDocInfo())\n          .useSourceInfoIfMissingFromForTree(n);\n      NodeUtil.setDebugInformation(\n          newDecl.getFirstChild().getFirstChild(), n, name);\n      parent.getParent().addChildBefore(newDecl, parent);\n\n      // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n      v.getNameNode().addChildToFront(\n          NodeUtil.newQualifiedNameNode(\n              compiler.getCodingConvention(), globalName, n, name));\n\n      recordAlias(v);\n    } else if (!parent.isVar()) {\n      // Do not allow hoisted functions or other kinds of local symbols.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        \n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Do nothing for bleeding functions\n        } else if (parent.getType() == Token.LP) {\n            // Do nothing for parameters of the scope function\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue();\n            if (value != null) {\n                value = value.detachFromParent();\n            }\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (value != null) {\n                // Add $jscomp.scope.name = EXPR;\n                // Make sure we copy over all the jsdoc and debug info.\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value,\n                    v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                    newDecl.getFirstChild().getFirstChild(), n, name);\n                parent.getParent().addChildBefore(newDecl, parent);\n            }\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue();\n            if (value != null) {\n                value = value.detachFromParent();\n                String name = n.getString();\n                int nameCount = scopedAliasNames.count(name);\n                scopedAliasNames.add(name);\n                String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n                compiler.ensureLibraryInjected(\"base\");\n\n                // Add $jscomp.scope.name = EXPR;\n                // Make sure we copy over all the jsdoc and debug info.\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                        compiler.getCodingConvention(),\n                        globalName,\n                        value,\n                        v.getJSDocInfo())\n                        .useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(\n                        newDecl.getFirstChild().getFirstChild(), n, name);\n                parent.getParent().addChildBefore(newDecl, parent);\n\n                // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n                v.getNameNode().addChildToFront(\n                        NodeUtil.newQualifiedNameNode(\n                                compiler.getCodingConvention(), globalName, n, name));\n            }\n\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        \n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue();\n            if (value != null) {\n                value = value.detachFromParent();\n            }\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            \n            compiler.ensureLibraryInjected(\"base\");\n            \n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            \n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n            \n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign && v.getInitialValue() != null) { // Fixing NPE by checking initial value\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else if (parent.isVar() && !n.hasChildren()) { // Handle uninitialized vars inside goog.scope\n            // Do not flag an error; no alias transformation needed as there is no initial value.\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        boolean isInGoogScope = t.getEnclosingScript().getQualifiedName().equals(\"goog.scope\");\n        \n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVarAssign) {\n          Node value = v.getInitialValue();\n          if (value == null) continue;\n\n          value = value.detachFromParent();\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else if (isInGoogScope) {\n          // Handle cases inside goog.scope but without alias assignment\n        } else {\n          // Do not allow hoisted functions or other kinds of local symbols.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    boolean isVarAssign = parent.isVar() && n.hasChildren();\n    if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n      recordAlias(v);\n    } else if (v.isBleedingFunction()) {\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n    } else if (parent.getType() == Token.LP) {\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else if (isVarAssign) {\n      Node value = v.getInitialValue();\n      if (value != null) {\n        value = value.detachFromParent();\n      }\n      String name = n.getString();\n      int nameCount = scopedAliasNames.count(name);\n      scopedAliasNames.add(name);\n      String globalName =\n          \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n      if (value != null) {\n        compiler.ensureLibraryInjected(\"base\");\n\n        // Add $jscomp.scope.name = EXPR;\n        // Make sure we copy over all the jsdoc and debug info.\n        Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n            compiler.getCodingConvention(),\n            globalName,\n            value,\n            v.getJSDocInfo())\n            .useSourceInfoIfMissingFromForTree(n);\n\n        NodeUtil.setDebugInformation(\n            newDecl.getFirstChild().getFirstChild(), n, name);\n        parent.getParent().addChildBefore(newDecl, parent);\n\n        // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n        v.getNameNode().addChildToFront(\n            NodeUtil.newQualifiedNameNode(\n                compiler.getCodingConvention(), globalName, n, name));\n\n        recordAlias(v);\n      }\n    } else {\n      // Do not allow hoisted functions or other kinds of local symbols.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue();\n            if (value != null) {\n                value = value.detachFromParent();\n            } else {\n                continue; // Skip undefined variables.\n            }\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent != null && parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent != null && parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value,\n                    v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                    newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                    NodeUtil.newQualifiedNameNode(\n                            compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n",
                            "\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n            // Bleeding functions and function parameters already get a BAD_PARAMETERS error.\n            continue;\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue();\n            if (value != null) {\n                value = value.detachFromParent();\n            } else {\n                continue;\n            }\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName =\n                \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n            compiler.ensureLibraryInjected(\"base\");\n\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name));\n\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103a": {
                "path": "test/com/google/javascript/jscomp/ScopedAliasesTest.java",
                "function_name": "testIssue1103a",
                "src": "  public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:401)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103a(ScopedAliasesTest.java:526)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103a(ScopedAliasesTest.java:526)  test(\"goog.scope(function () {\" +         \"  var a;\" +         \"  foo.bar = function () { a = 1; };\" +         \"});\",         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\");"
            },
            "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103b": {
                "path": "test/com/google/javascript/jscomp/ScopedAliasesTest.java",
                "function_name": "testIssue1103b",
                "src": "  public void testIssue1103b() {\n    test(\"goog.scope(function () {\" +\n         \"  var a = foo, b, c = 1;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\n  }",
                "error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n  Node(FUNCTION ): testcode:1:11\ngoog.scope(function () {  var a = foo, b, c = 1;});\n  Parent(CALL): testcode:1:0\ngoog.scope(function () {  var a = foo, b, c = 1;});\n\n\tat com.google.javascript.jscomp.Compiler.ensureLibraryInjected(Compiler.java:2554)\n\tat com.google.javascript.jscomp.ScopedAliases$Traversal.findAliases(ScopedAliases.java:373)\n\tat com.google.javascript.jscomp.ScopedAliases$Traversal.enterScope(ScopedAliases.java:298)\n\tat com.google.javascript.jscomp.NodeTraversal.pushScope(NodeTraversal.java:600)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:558)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:287)\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:494)\n\tat com.google.javascript.jscomp.ScopedAliases.hotSwapScript(ScopedAliases.java:133)\n\tat com.google.javascript.jscomp.ScopedAliases.process(ScopedAliases.java:127)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:845)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103b(ScopedAliasesTest.java:534)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: java.lang.NullPointerException\n\t... 54 more",
                "clean_error_msg": "java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n  Node(FUNCTION ): testcode:1:11\ngoog.scope(function () {  var a = foo, b, c = 1;});\n  Parent(CALL): testcode:1:0\ngoog.scope(function () {  var a = foo, b, c = 1;});\n\n\tat com.google.javascript.jscomp.Compiler.ensureLibraryInjected(Compiler.java:2554)  Node lastChild = firstChild.getLastSibling();\n\tat com.google.javascript.jscomp.NodeTraversal.pushScope(NodeTraversal.java:600)  scopeCallback.enterScope(this);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:558)  pushScope(n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)  traverseFunction(n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:287)  traverseBranch(root, null);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:494)  t.traverse(root);\n\tat com.google.javascript.jscomp.ScopedAliases.hotSwapScript(ScopedAliases.java:133)  NodeTraversal.traverse(compiler, root, traversal);\n\tat com.google.javascript.jscomp.ScopedAliases.process(ScopedAliases.java:127)  hotSwapScript(root, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:845)  getProcessor(compiler).process(externsRoot, mainRoot);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103b(ScopedAliasesTest.java:534)  test(\"goog.scope(function () {\" +         \"  var a = foo, b, c = 1;\" +         \"});\",         SCOPE_NAMESPACE + \"$jscomp.scope.c=1\");\nCaused by: java.lang.NullPointerException\n\t... 54 more"
            },
            "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103c": {
                "path": "test/com/google/javascript/jscomp/ScopedAliasesTest.java",
                "function_name": "testIssue1103c",
                "src": "  public void testIssue1103c() {\n    test(\"goog.scope(function () {\" +\n         \"  /** @type {number} */ var a;\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"/** @type {number} */ $jscomp.scope.a;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 52 expected:<0> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:401)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103c(ScopedAliasesTest.java:541)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 52 expected:<0> but was:<1>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)  test(compiler, maybeCreateArray(expected), error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testIssue1103c(ScopedAliasesTest.java:541)  test(\"goog.scope(function () {\" +         \"  /** @type {number} */ var a;\" +         \"});\",         SCOPE_NAMESPACE + \"/** @type {number} */ $jscomp.scope.a;\");"
            }
        },
        "evaluation_done": true
    }
}