{
    "Closure-41": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
                "start_loc": 242,
                "end_loc": 296,
                "buggy_function": "  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                "fixed_function": "  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        paramBuilder.newParameterFromNode(oldParams.next());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                "comment": "  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n",
                "normalized_body": [
                    "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) { if (oldType == null) { return this; } returnType = oldType.getReturnType(); returnTypeInferred = oldType.isReturnTypeInferred(); if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false; boolean oldParamsListHitOptArgs = false; for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { Node oldParam = oldParams.next(); Node newParam = paramBuilder.newParameterFromNode(oldParam); oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg(); if (currentParam.getNext() != null && newParam.isVarArgs()) { newParam.setVarArgs(false); newParam.setOptionalArg(true); } } else { warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); } return this; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) { if (oldType == null) { return this; } returnType = oldType.getReturnType(); returnTypeInferred = oldType.isReturnTypeInferred(); if (paramsParent == null) { parametersNode = oldType.getParametersNode(); if (parametersNode == null) { parametersNode = new FunctionParamBuilder(typeRegistry).build(); } } else { FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry); Iterator<Node> oldParams = oldType.getParameters().iterator(); boolean warnedAboutArgList = false; boolean oldParamsListHitOptArgs = false; for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) { if (oldParams.hasNext()) { Node oldParam = oldParams.next(); Node newParam = paramBuilder.newParameterFromNode(oldParam); oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg(); if (currentParam.getNext() != null && newParam.isVarArgs()) { newParam.setVarArgs(false); newParam.setOptionalArg(true); } } else { warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam)); } } parametersNode = paramBuilder.build(); } return this; }"
                    ],
                    [
                        0.9928151369094849,
                        "private FunctionType createFunctionTypeFromNodes(@Nullable Node rValue, @Nullable String name, @Nullable JSDocInfo info, @Nullable Node lvalueNode) { FunctionType functionType = null; if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() != null && var.getType().isFunctionType()) { FunctionType aliasedType = var.getType().toMaybeFunctionType(); if ((aliasedType.isConstructor() || aliasedType.isInterface()) && !aliasedType.isNativeObjectType()) { functionType = aliasedType; if (name != null && scope.isGlobal()) { typeRegistry.declareType(name, functionType.getInstanceType()); } } } } if (functionType == null) { Node errorRoot = rValue == null ? lvalueNode : rValue; boolean isFnLiteral = rValue != null && rValue.isFunction(); Node fnRoot = isFnLiteral ? rValue : null; Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null; Node fnBlock = isFnLiteral ? parametersNode.getNext() : null; if (info != null && info.hasType()) { JSType type = info.getType().evaluate(scope, typeRegistry); type = type.restrictByNotNullOrUndefined(); if (type.isFunctionType()) { functionType = type.toMaybeFunctionType(); functionType.setJSDocInfo(info); } } if (functionType == null) { Node ownerNode = NodeUtil.getBestLValueOwner(lvalueNode); String ownerName = NodeUtil.getBestLValueName(ownerNode); Var ownerVar = null; String propName = null; ObjectType ownerType = null; if (ownerName != null) { ownerVar = scope.getVar(ownerName); if (ownerVar != null) { ownerType = ObjectType.cast(ownerVar.getType()); } if (name != null) { propName = name.substring(ownerName.length() + 1); } } FunctionType overriddenPropType = null; if (ownerType != null && propName != null) { overriddenPropType = findOverriddenFunction(ownerType, propName); } FunctionTypeBuilder builder = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setContents(getFunctionAnalysisResults(fnRoot)).inferFromOverriddenFunction(overriddenPropType, parametersNode).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info); boolean searchedForThisType = false; if (ownerType != null && ownerType.isFunctionPrototypeType()) { builder.inferThisType(info, ownerType.getOwnerFunction().getInstanceType()); searchedForThisType = true; } else if (ownerNode != null && ownerNode.isThis()) { builder.inferThisType(info, ownerNode.getJSType()); searchedForThisType = true; } if (!searchedForThisType) { builder.inferThisType(info); } functionType = builder.inferParameterTypes(parametersNode, info).buildAndRegister(); } } return functionType; }"
                    ],
                    [
                        0.9920321702957153,
                        "private EnumType createEnumTypeFromNodes(Node rValue, String name, JSDocInfo info, Node lValueNode) { Preconditions.checkNotNull(info); Preconditions.checkState(info.hasEnumParameterType()); EnumType enumType = null; if (rValue != null && rValue.isQualifiedName()) { Var var = scope.getVar(rValue.getQualifiedName()); if (var != null && var.getType() instanceof EnumType) { enumType = (EnumType) var.getType(); } } if (enumType == null) { JSType elementsType = info.getEnumParameterType().evaluate(scope, typeRegistry); enumType = typeRegistry.createEnumType(name, rValue, elementsType); if (rValue != null && rValue.isObjectLit()) { Node key = rValue.getFirstChild(); while (key != null) { String keyName = NodeUtil.getStringValue(key); if (keyName == null) { compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else if (!codingConvention.isValidEnumKey(keyName)) { compiler.report(JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName)); } else { enumType.defineElement(keyName, key); } key = key.getNext(); } } } if (name != null && scope.isGlobal()) { typeRegistry.declareType(name, enumType.getElementsType()); } return enumType; }"
                    ],
                    [
                        0.9907155632972717,
                        "private FlowScope tightenTypesAfterAssertions(FlowScope scope, Node callNode) { Node left = callNode.getFirstChild(); Node firstParam = left.getNext(); AssertionFunctionSpec assertionFunctionSpec = assertionFunctionsMap.get(left.getQualifiedName()); if (assertionFunctionSpec == null || firstParam == null) { return scope; } Node assertedNode = assertionFunctionSpec.getAssertedParam(firstParam); if (assertedNode == null) { return scope; } JSTypeNative assertedType = assertionFunctionSpec.getAssertedType(); String assertedNodeName = assertedNode.getQualifiedName(); if (assertedType == null) { if (assertedNodeName != null) { JSType type = getJSType(assertedNode); JSType narrowed = type.restrictByNotNullOrUndefined(); if (type != narrowed) { scope = narrowScope(scope, assertedNode, narrowed); callNode.setJSType(narrowed); } } else if (assertedNode.isAnd() || assertedNode.isOr()) { BooleanOutcomePair conditionOutcomes = traverseWithinShortCircuitingBinOp(assertedNode, scope); scope = reverseInterpreter.getPreciserScopeKnowingConditionOutcome(assertedNode, conditionOutcomes.getOutcomeFlowScope(assertedNode.getType(), true), true); } } else if (assertedNodeName != null) { JSType type = getJSType(assertedNode); JSType narrowed = type.getGreatestSubtype(getNativeType(assertedType)); if (type != narrowed) { scope = narrowScope(scope, assertedNode, narrowed); callNode.setJSType(narrowed); } } return scope; }"
                    ],
                    [
                        0.9903604984283447,
                        "private boolean maybeProcessDeclaration(NodeTraversal t, Node name, Node parent, NamedInfo info) { Node gramps = parent.getParent(); switch(parent.getType()) { case Token.VAR: if (canMoveValue(name.getFirstChild())) { return info.addDeclaration(new Declaration(t.getModule(), name, parent, gramps)); } return false; case Token.FUNCTION: if (NodeUtil.isFunctionDeclaration(parent)) { return info.addDeclaration(new Declaration(t.getModule(), name, parent, gramps)); } return false; case Token.ASSIGN: case Token.GETPROP: Node child = name; for (Node current : name.getAncestors()) { if (current.isGetProp()) { } else if (current.isAssign() && current.getFirstChild() == child) { Node currentParent = current.getParent(); if (currentParent.isExprResult() && canMoveValue(current.getLastChild())) { return info.addDeclaration(new Declaration(t.getModule(), current, currentParent, currentParent.getParent())); } } else { return false; } child = current; } return false; case Token.CALL: if (NodeUtil.isExprCall(gramps)) { SubclassRelationship relationship = compiler.getCodingConvention().getClassesDefinedByCall(parent); if (relationship != null && name.getString().equals(relationship.subclassName)) { return info.addDeclaration(new Declaration(t.getModule(), parent, gramps, gramps.getParent())); } } return false; default: return false; } }"
                    ],
                    [
                        0.9903180003166199,
                        "private Collection<Action> getImplicitActionsFromCall(Node n, JSType recvType) { Node receiver = n.getFirstChild(); if (recvType.isUnionType()) { List<Action> actions = Lists.newArrayList(); for (JSType alt : recvType.toMaybeUnionType().getAlternates()) { actions.addAll(getImplicitActionsFromCall(n, alt)); } return actions; } else if (!(recvType.isFunctionType())) { return Lists.<Action>newArrayList(); } ObjectType objType = ObjectType.cast(getJSType(receiver.getFirstChild()).restrictByNotNullOrUndefined()); String prop = receiver.getLastChild().getString(); if (objType != null && (objType.isPropertyInExterns(prop)) && (recvType.toMaybeFunctionType()).getParameters() != null) { List<Action> actions = Lists.newArrayList(); Iterator<Node> paramIter = (recvType.toMaybeFunctionType()).getParameters().iterator(); Iterator<Node> argumentIter = n.children().iterator(); argumentIter.next(); while (paramIter.hasNext() && argumentIter.hasNext()) { Node arg = argumentIter.next(); Node param = paramIter.next(); if (arg.getJSType() != null && arg.getJSType().isFunctionType()) { actions.addAll(getImplicitActionsFromArgument(arg, arg.getJSType().toMaybeFunctionType().getTypeOfThis(), param.getJSType())); } } return actions; } return Lists.<Action>newArrayList(); }"
                    ],
                    [
                        0.9895131587982178,
                        "private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); Node cond = n.getFirstChild(); if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (!late && isPropertyAssignmentInExpression(expr)) { return n; } if (cond.isNot()) { if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) { return n; } Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) { return n; } n.removeChild(cond); Node and = IR.and(cond, expr.removeFirstChild()).srcref(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } else { if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) { Node innerIf = thenBranch.getFirstChild(); if (innerIf.isIf()) { Node innerCond = innerIf.getFirstChild(); Node innerThenBranch = innerCond.getNext(); Node innerElseBranch = innerThenBranch.getNext(); if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) { n.detachChildren(); n.addChildToBack(IR.and(cond, innerCond.detachFromParent()).srcref(cond)); n.addChildrenToBack(innerThenBranch.detachFromParent()); reportCodeChange(); return n; } } } } return n; } tryRemoveRepeatedStatements(n); if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node returnNode = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) { if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) { n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } } } n.removeChild(cond); thenOp.detachFromParent(); elseOp.detachFromParent(); Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n)); parent.replaceChild(n, expr); reportCodeChange(); return expr; } boolean thenBranchIsVar = isVarBlock(thenBranch); boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) { Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) { Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent(); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); var.detachFromParent(); name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); reportCodeChange(); return var; } } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild(); if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren(); cond.detachFromParent(); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); var.detachFromParent(); name2.addChildrenToBack(hookNode); parent.replaceChild(n, var); reportCodeChange(); return var; } } return n; }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.LooseTypeCheckTest::testMethodInference6",
                    "com.google.javascript.jscomp.TypeCheckTest::testIssue368",
                    "com.google.javascript.jscomp.TypeCheckTest::testMethodInference6"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n\n```\n\n```java\n  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: unexpected warnings(s):\n \n#Test method 2:\n```java\n  public void testIssue368() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo(){}\" +\n        \"/**\\n\" +\n        \" * @param {number} one\\n\" +\n        \" * @param {string} two\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.add = function(one, two) {};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar(){}\" +\n        \"/** @override */\\n\" +\n        \"Bar.prototype.add = function(ignored) {};\" +\n        \"(new Bar()).add(1, 2);\",\n        \"actual parameter 2 of Bar.prototype.add does not match formal parameter\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n```\n#Error message from the test method 2: junit.framework.ComparisonFailure: expected:<[actual parameter 2 of Bar.prototype.add does not match formal parameter\n \n#Test method 3:\n```java\n  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError: unexpected warnings(s):\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n          // Add the new parameter to the builder.\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              newParam.getJSType(),\n              warnedAboutArgList,\n              newParam.isOptionalArg(),\n              newParam.isVarArgs());\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        Node newParam = paramBuilder.newParameterFromNode(oldParam);\n        addParameter(paramBuilder, newParam.getJSType(),\n            warnedAboutArgList, newParam.isOptionalArg(),\n            newParam.isVarArgs());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        Node newParam;\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              false,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n          continue;\n        }\n\n        // Use the JSDoc information of the current parameter if available\n        JSDocInfo jsDoc = currentParam.getJSDocInfo();\n        boolean isOptional = jsDoc != null && jsDoc.isOptionalParameter();\n        boolean isVarArgs = jsDoc != null && jsDoc.isVarArgsParameter();\n        addParameter(\n            paramBuilder,\n            newParam.getJSType(),\n            warnedAboutArgList,\n            isOptional || oldParamsListHitOptArgs,\n            isVarArgs\n        );\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        Node param = paramBuilder.newParameterFromNode(oldParam);\n        paramBuilder.addParameter(param.getJSType(), oldParam.isOptionalArg(), oldParam.isVarArgs());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n\n          paramBuilder.addParameter(\n              oldParam.getJSType(),\n              oldParam.isOptionalArg() || oldParamsListHitOptArgs,\n              oldParam.isVarArgs()\n          );\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        paramBuilder.addParameter(\n            oldParam.getJSType(),\n            oldParam.isOptionalArg() || oldParamsListHitOptArgs,\n            oldParam.isVarArgs()\n        );\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n/**\n * Infer the parameter and return types of a function from\n * the parameter and return types of the function it is overriding.\n *\n * @param oldType The function being overridden. Does nothing if this is null.\n * @param paramsParent The LP node of the function that we're assigning to.\n *     If null, that just means we're not initializing this to a function\n *     literal.\n */\n\nFunctionTypeBuilder inferFromOverriddenFunction(\n    @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n  if (oldType == null) {\n    return this;\n  }\n\n  returnType = oldType.getReturnType();\n  returnTypeInferred = oldType.isReturnTypeInferred();\n  if (paramsParent == null) {\n    // Not a function literal.\n    parametersNode = oldType.getParametersNode();\n    if (parametersNode == null) {\n      parametersNode = new FunctionParamBuilder(typeRegistry).build();\n    }\n  } else {\n    // We're overriding with a function literal. Apply type information\n    // to each parameter of the literal.\n    FunctionParamBuilder paramBuilder =\n        new FunctionParamBuilder(typeRegistry);\n    Iterator<Node> oldParams = oldType.getParameters().iterator();\n    boolean warnedAboutArgList = false;\n    boolean oldParamsListHitOptArgs = false;\n    for (Node currentParam = paramsParent.getFirstChild();\n         currentParam != null; currentParam = currentParam.getNext()) {\n      JSType parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      boolean isOptional = codingConvention.isOptionalParameter(currentParam) ||\n          oldParamsListHitOptArgs;\n      boolean isVarArgs = codingConvention.isVarArgsParameter(currentParam);\n\n      if (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        parameterType = oldParam.getJSType();\n\n        oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n            oldParam.isVarArgs() ||\n            oldParam.isOptionalArg();\n\n        // The subclass method might write its var_args as individual\n        // arguments.\n        if (currentParam.getNext() != null && oldParam.isVarArgs()) {\n          isVarArgs = false;\n          isOptional = true;\n        }\n      }\n\n      warnedAboutArgList |= addParameter(\n          paramBuilder,\n          parameterType,\n          warnedAboutArgList,\n          isOptional,\n          isVarArgs);\n    }\n\n    // Clone any remaining params that aren't in the function literal.\n    while (oldParams.hasNext()) {\n      Node oldParam = oldParams.next();\n      paramBuilder.newParameterFromNode(oldParam);\n    }\n\n    parametersNode = paramBuilder.build();\n  }\n  return this;\n}\n\n/**\n * Infer the parameter types from the list of argument names and\n * the doc info.\n */\n\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n    @Nullable JSDocInfo info) {\n  if (argsParent == null) {\n    if (info == null) {\n      return this;\n    } else {\n      return inferParameterTypes(info);\n    }\n  }\n\n  // arguments\n  Node oldParameterType = null;\n  if (parametersNode != null) {\n    oldParameterType = parametersNode.getFirstChild();\n  }\n\n  FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n  boolean warnedAboutArgList = false;\n  Set<String> allJsDocParams = (info == null) ?\n      Sets.<String>newHashSet() :\n      Sets.newHashSet(info.getParameterNames());\n  boolean foundTemplateType = false;\n  for (Node arg : argsParent.children()) {\n    String argumentName = arg.getString();\n    allJsDocParams.remove(argumentName);\n\n    // type from JSDocInfo\n    JSType parameterType = null;\n    boolean isOptionalParam = isOptionalParameter(arg, info);\n    boolean isVarArgs = isVarArgsParameter(arg, info);\n\n    if (info != null && info.hasParameterType(argumentName)) {\n      parameterType =\n          info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n    } else if (oldParameterType != null &&\n        oldParameterType.getJSType() != null) {\n      parameterType = oldParameterType.getJSType();\n      isOptionalParam = oldParameterType.isOptionalArg();\n      isVarArgs = oldParameterType.isVarArgs();\n    } else {\n      parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (templateTypeName != null &&\n        parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n      if (foundTemplateType) {\n        reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n      }\n      foundTemplateType = true;\n    }\n    warnedAboutArgList |= addParameter(\n        builder, parameterType, warnedAboutArgList,\n        isOptionalParam,\n        isVarArgs);\n\n    if (oldParameterType != null) {\n      oldParameterType = oldParameterType.getNext();\n    }\n  }\n\n  // Copy over any old parameters that aren't in the param list.\n  while (oldParameterType != null) {\n    builder.newParameterFromNode(oldParameterType);\n    oldParameterType = oldParameterType.getNext();\n  }\n\n  if (templateTypeName != null && !foundTemplateType) {\n    reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n  }\n\n  for (String inexistentName : allJsDocParams) {\n    reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n  }\n\n  parametersNode = builder.build();\n  return this;\n}\n",
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n          \n          if (!currentParam.getString().equals(oldParam.getString())) {\n            warnedAboutArgList |= addParameter(\n                paramBuilder,\n                typeRegistry.getNativeType(UNKNOWN_TYPE),\n                warnedAboutArgList,\n                codingConvention.isOptionalParameter(currentParam) ||\n                    oldParamsListHitOptArgs,\n                codingConvention.isVarArgsParameter(currentParam));\n            continue;\n          }\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n          \n          paramBuilder.add(newParam);\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n\n",
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(currentParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && oldParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n\n          newParam.setJSType(oldParam.getJSType());\n          newParam.setOptionalArg(oldParamsListHitOptArgs);\n          newParam.setVarArgs(oldParam.isVarArgs());\n          paramBuilder.addParameter(newParam);\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        Node newParam = paramBuilder.newParameterFromNode(oldParam);\n        paramBuilder.addParameter(newParam);\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(currentParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n          if (!newParam.getJSType().isSubtype(oldParam.getJSType())) {\n            warnedAboutArgList |= addParameter(\n                paramBuilder,\n                oldParam.getJSType(),\n                warnedAboutArgList,\n                oldParam.isOptionalArg() || oldParamsListHitOptArgs,\n                oldParam.isVarArgs());\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        warnedAboutArgList |= addParameter(\n            paramBuilder,\n            oldParam.getJSType(),\n            warnedAboutArgList,\n            oldParam.isOptionalArg(),\n            oldParam.isVarArgs());\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n\n    if (paramsParent == null) {\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n\n        JSType paramType;\n        boolean isOptional = false;\n        boolean isVarArgs = false;\n\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          paramType = oldParam.getJSType();\n          isOptional = oldParam.isOptionalArg();\n          isVarArgs = oldParam.isVarArgs();\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              isVarArgs ||\n              isOptional;\n\n          if (currentParam.getNext() != null && isVarArgs) {\n            isVarArgs = false;\n            isOptional = true;\n          }\n        } else {\n          paramType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n          isOptional = codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs;\n          isVarArgs = codingConvention.isVarArgsParameter(currentParam);\n        }\n\n        warnedAboutArgList |= addParameter(paramBuilder, paramType, warnedAboutArgList, isOptional, isVarArgs);\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n\n          newParam.setJSType(oldParam.getJSType());\n          paramBuilder.addParameter(newParam);\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n      while (oldParams.hasNext()) {\n        Node oldParam = oldParams.next();\n        Node newParam = paramBuilder.newParameterFromNode(oldParam);\n        newParam.setJSType(oldParam.getJSType());\n        paramBuilder.addParameter(newParam);\n      }\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n",
                            "\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n\n          // Apply type information to the current parameter of the function literal.\n          JSType paramType = oldParam.getJSType();\n          newParam.setJSType(paramType);\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/FunctionTypeBuilder.java",
                "start_loc": 421,
                "end_loc": 494,
                "buggy_function": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                "fixed_function": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    if (!isVarArgs) {\n      while (oldParameterType != null && !isVarArgs) {\n        builder.newParameterFromNode(oldParameterType);\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                "comment": "  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n",
                "normalized_body": [
                    "FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this; } else { return inferParameterTypes(info); } } Node oldParameterType = null; if (parametersNode != null) { oldParameterType = parametersNode.getFirstChild(); } FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; boolean isVarArgs = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType = null; boolean isOptionalParam = isOptionalParameter(arg, info); isVarArgs = isVarArgsParameter(arg, info); if (info != null && info.hasParameterType(argumentName)) { parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry); } else if (oldParameterType != null && oldParameterType.getJSType() != null) { parameterType = oldParameterType.getJSType(); isOptionalParam = oldParameterType.isOptionalArg(); isVarArgs = oldParameterType.isVarArgs(); } else { parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; } warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs); if (oldParameterType != null) { oldParameterType = oldParameterType.getNext(); } } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName); } parametersNode = builder.build(); return this; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) { if (argsParent == null) { if (info == null) { return this; } else { return inferParameterTypes(info); } } Node oldParameterType = null; if (parametersNode != null) { oldParameterType = parametersNode.getFirstChild(); } FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry); boolean warnedAboutArgList = false; Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames()); boolean foundTemplateType = false; boolean isVarArgs = false; for (Node arg : argsParent.children()) { String argumentName = arg.getString(); allJsDocParams.remove(argumentName); JSType parameterType = null; boolean isOptionalParam = isOptionalParameter(arg, info); isVarArgs = isVarArgsParameter(arg, info); if (info != null && info.hasParameterType(argumentName)) { parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry); } else if (oldParameterType != null && oldParameterType.getJSType() != null) { parameterType = oldParameterType.getJSType(); isOptionalParam = oldParameterType.isOptionalArg(); isVarArgs = oldParameterType.isVarArgs(); } else { parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE); } if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) { if (foundTemplateType) { reportError(TEMPLATE_TYPE_DUPLICATED, fnName); } foundTemplateType = true; } warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs); if (oldParameterType != null) { oldParameterType = oldParameterType.getNext(); } } if (templateTypeName != null && !foundTemplateType) { reportError(TEMPLATE_TYPE_EXPECTED, fnName); } for (String inexistentName : allJsDocParams) { reportWarning(INEXISTANT_PARAM, inexistentName, fnName); } parametersNode = builder.build(); return this; }"
                    ],
                    [
                        0.9656108617782593,
                        "@Override public void visit(NodeTraversal traversal, Node node, Node parent) { if (inExterns && node.isName() && parent.isParamList()) { return; } Definition def = DefinitionsRemover.getDefinition(node, inExterns); if (def != null) { String name = getSimplifiedName(def.getLValue()); if (name != null) { Node rValue = def.getRValue(); if ((rValue != null) && !NodeUtil.isImmutableValue(rValue) && !rValue.isFunction()) { Definition unknownDef = new UnknownDefinition(def.getLValue(), inExterns); def = unknownDef; } if (inExterns) { List<Definition> stubsToRemove = Lists.newArrayList(); String qualifiedName = node.getQualifiedName(); if (qualifiedName != null) { for (Definition prevDef : nameDefinitionMultimap.get(name)) { if (prevDef instanceof ExternalNameOnlyDefinition && !jsdocContainsDeclarations(node)) { String prevName = prevDef.getLValue().getQualifiedName(); if (qualifiedName.equals(prevName)) { stubsToRemove.add(prevDef); } } } for (Definition prevDef : stubsToRemove) { nameDefinitionMultimap.remove(name, prevDef); } } } nameDefinitionMultimap.put(name, def); definitionSiteMap.put(node, new DefinitionSite(node, def, traversal.getModule(), traversal.inGlobalScope(), inExterns)); } } if (inExterns && (parent != null) && parent.isExprResult()) { String name = getSimplifiedName(node); if (name != null) { boolean dropStub = false; if (!jsdocContainsDeclarations(node)) { String qualifiedName = node.getQualifiedName(); if (qualifiedName != null) { for (Definition prevDef : nameDefinitionMultimap.get(name)) { String prevName = prevDef.getLValue().getQualifiedName(); if (qualifiedName.equals(prevName)) { dropStub = true; break; } } } } if (!dropStub) { Definition definition = new ExternalNameOnlyDefinition(node); nameDefinitionMultimap.put(name, definition); definitionSiteMap.put(node, new DefinitionSite(node, definition, traversal.getModule(), traversal.inGlobalScope(), inExterns)); } } } }"
                    ],
                    [
                        0.9647884666919708,
                        "private void visitFunction(NodeTraversal t, Node n) { FunctionType funType = JSType.toMaybeFunctionType(n.getJSType()); Node block = n.getLastChild(); Node paramName = NodeUtil.getFunctionParameters(n).getFirstChild(); Node insertionPoint = null; for (Node next = block.getFirstChild(); next != null && NodeUtil.isFunctionDeclaration(next); next = next.getNext()) { insertionPoint = next; } for (Node paramType : funType.getParameters()) { if (paramName == null) { return; } Node checkNode = createCheckTypeCallNode(paramType.getJSType(), paramName.cloneTree()); if (checkNode == null) { paramName = paramName.getNext(); continue; } checkNode = IR.exprResult(checkNode); if (insertionPoint == null) { block.addChildToFront(checkNode); } else { block.addChildAfter(checkNode, insertionPoint); } compiler.reportCodeChange(); paramName = paramName.getNext(); insertionPoint = checkNode; } }"
                    ],
                    [
                        0.9643664658069611,
                        "@Override public void put(int index, Scriptable start, Object value) { Object parent = Undefined.instance; XMLObject xmlValue; if (value == null) { value = \\\"null\\\"; } else if (value instanceof Undefined) { value = \\\"undefined\\\"; } if (value instanceof XMLObject) { xmlValue = (XMLObject) value; } else { if (targetProperty == null) { xmlValue = newXMLFromJs(value.toString()); } else { xmlValue = item(index); if (xmlValue == null) { XML x = item(0); xmlValue = x == null ? newTextElementXML(null, targetProperty, null) : x.copy(); } ((XML) xmlValue).setChildren(value); } } if (index < length()) { parent = item(index).parent(); } else if (length() == 0) { parent = targetObject != null ? targetObject.getXML() : parent(); } else { parent = parent(); } if (parent instanceof XML) { XML xmlParent = (XML) parent; if (index < length()) { XML xmlNode = getXmlFromAnnotation(index); if (xmlValue instanceof XML) { replaceNode(xmlNode, (XML) xmlValue); replace(index, xmlNode); } else if (xmlValue instanceof XMLList) { XMLList list = (XMLList) xmlValue; if (list.length() > 0) { int lastIndexAdded = xmlNode.childIndex(); replaceNode(xmlNode, list.item(0)); replace(index, list.item(0)); for (int i = 1; i < list.length(); i++) { xmlParent.insertChildAfter(xmlParent.getXmlChild(lastIndexAdded), list.item(i)); lastIndexAdded++; insert(index + i, list.item(i)); } } } } else { xmlParent.appendChild(xmlValue); addToList(xmlParent.getLastXmlChild()); } } else { if (index < length()) { XML xmlNode = getXML(_annos, index); if (xmlValue instanceof XML) { replaceNode(xmlNode, (XML) xmlValue); replace(index, xmlNode); } else if (xmlValue instanceof XMLList) { XMLList list = (XMLList) xmlValue; if (list.length() > 0) { replaceNode(xmlNode, list.item(0)); replace(index, list.item(0)); for (int i = 1; i < list.length(); i++) { insert(index + i, list.item(i)); } } } } else { addToList(xmlValue); } } }"
                    ],
                    [
                        0.9643140137195587,
                        "public Scriptable construct(Context cx, Scriptable scope, Object[] args) { Class<?> classObject = getClassObject(); int modifiers = classObject.getModifiers(); if (!(Modifier.isInterface(modifiers) || Modifier.isAbstract(modifiers))) { NativeJavaMethod ctors = members.ctors; int index = ctors.findCachedFunction(cx, args); if (index < 0) { String sig = NativeJavaMethod.scriptSignature(args); throw Context.reportRuntimeError2(\\\"msg.no.java.ctor\\\", classObject.getName(), sig); } return constructSpecific(cx, scope, args, ctors.methods[index]); } else { Scriptable topLevel = ScriptableObject.getTopLevelScope(this); String msg = \\\"\\\"; try { Object v = topLevel.get(\\\"JavaAdapter\\\", topLevel); if (v != NOT_FOUND) { Function f = (Function) v; Object[] adapterArgs = { this, args[0] }; return f.construct(cx, topLevel, adapterArgs); } } catch (Exception ex) { String m = ex.getMessage(); if (m != null) msg = m; } throw Context.reportRuntimeError2(\\\"msg.cant.instantiate\\\", msg, classObject.getName()); } }"
                    ],
                    [
                        0.962497740983963,
                        "@Override public void enterScope(NodeTraversal t) { Scope s = t.getScope(); if (!s.isLocal()) { return; } if (s.getParent().isGlobal()) { return; } for (Iterator<Var> vars = s.getVars(); vars.hasNext(); ) { Var var = vars.next(); if (var.isBleedingFunction()) { continue; } if (compiler.getCodingConvention().isExported(var.name, s.isLocal())) { continue; } Assignment bestShadow = findBestShadow(s, var); if (bestShadow == null) { continue; } Assignment localAssignment = assignments.get(var.getName()); if (bestShadow.count < localAssignment.count) { continue; } doShadow(localAssignment, bestShadow, var); if (oldPseudoNameMap != null) { String targetPseudoName = oldPseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode); for (Node use : varToNameUsage.get(var)) { deltaPseudoNameMap.put(use, targetPseudoName); } } } }"
                    ],
                    [
                        0.9622884392738342,
                        "private void visitFunction(NodeTraversal t, Node n) { FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType()); String functionPrivateName = n.getFirstChild().getString(); if (functionType.isConstructor()) { FunctionType baseConstructor = functionType.getSuperClassConstructor(); if (baseConstructor != null && baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) && (baseConstructor.isInterface() && functionType.isConstructor())) { compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName)); } else { for (JSType baseInterface : functionType.getImplementedInterfaces()) { boolean badImplementedType = false; ObjectType baseInterfaceObj = ObjectType.cast(baseInterface); if (baseInterfaceObj != null) { FunctionType interfaceConstructor = baseInterfaceObj.getConstructor(); if (interfaceConstructor != null && !interfaceConstructor.isInterface()) { badImplementedType = true; } } else { badImplementedType = true; } if (badImplementedType) { report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName); } } validator.expectAllInterfaceProperties(t, n, functionType); } } else if (functionType.isInterface()) { for (ObjectType extInterface : functionType.getExtendedInterfaces()) { if (extInterface.getConstructor() != null && !extInterface.getConstructor().isInterface()) { compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName)); } } if (functionType.hasImplementedInterfaces()) { compiler.report(t.makeError(n, CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName)); } if (functionType.getExtendedInterfacesCount() > 1) { HashMap<String, ObjectType> properties = new HashMap<String, ObjectType>(); HashMap<String, ObjectType> currentProperties = new HashMap<String, ObjectType>(); for (ObjectType interfaceType : functionType.getExtendedInterfaces()) { currentProperties.clear(); checkInterfaceConflictProperties(t, n, functionPrivateName, properties, currentProperties, interfaceType); properties.putAll(currentProperties); } } } }"
                    ]
                ],
                "non_directly_related_tests": [
                    "com.google.javascript.jscomp.LooseTypeCheckTest::testMethodInference6",
                    "com.google.javascript.jscomp.TypeCheckTest::testIssue368",
                    "com.google.javascript.jscomp.TypeCheckTest::testMethodInference6"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n  /**\n   * Infer the parameter and return types of a function from\n   * the parameter and return types of the function it is overriding.\n   *\n   * @param oldType The function being overridden. Does nothing if this is null.\n   * @param paramsParent The LP node of the function that we're assigning to.\n   *     If null, that just means we're not initializing this to a function\n   *     literal.\n   */\n\n  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might write its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n\n      // Clone any remaining params that aren't in the function literal.\n\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }\n\n```\n\n```java\n  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: unexpected warnings(s):\n \n#Test method 2:\n```java\n  public void testIssue368() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo(){}\" +\n        \"/**\\n\" +\n        \" * @param {number} one\\n\" +\n        \" * @param {string} two\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.add = function(one, two) {};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar(){}\" +\n        \"/** @override */\\n\" +\n        \"Bar.prototype.add = function(ignored) {};\" +\n        \"(new Bar()).add(1, 2);\",\n        \"actual parameter 2 of Bar.prototype.add does not match formal parameter\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }\n```\n#Error message from the test method 2: junit.framework.ComparisonFailure: expected:<[actual parameter 2 of Bar.prototype.add does not match formal parameter\n \n#Test method 3:\n```java\n  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError: unexpected warnings(s):\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n      addParameter(builder, oldParameterType.getJSType(),\n          warnedAboutArgList, oldParameterType.isOptionalArg(),\n          oldParameterType.isVarArgs());\n      oldParameterType = oldParameterType.getNext();\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    while (oldParameterType != null) {\n      addParameter(\n          builder,\n          oldParameterType.getJSType(),\n          warnedAboutArgList,\n          oldParameterType.isOptionalArg(),\n          oldParameterType.isVarArgs());\n      oldParameterType = oldParameterType.getNext();\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                            "\n  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      boolean isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n      builder.addParameter(\n          oldParameterType.getJSType(),\n          oldParameterType.isOptionalArg(),\n          oldParameterType.isVarArgs()\n      );\n      oldParameterType = oldParameterType.getNext();\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null &&\n          oldParameterType.getString().equals(argumentName)) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n\n",
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n      addParameter(builder, oldParameterType.getJSType(), warnedAboutArgList,\n          oldParameterType.isOptionalArg(), oldParameterType.isVarArgs());\n      oldParameterType = oldParameterType.getNext();\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n\n",
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      boolean isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n      warnedAboutArgList |= addParameter(\n          builder,\n          oldParameterType.getJSType(),\n          warnedAboutArgList,\n          oldParameterType.isOptionalArg(),\n          oldParameterType.isVarArgs());\n      oldParameterType = oldParameterType.getNext();\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    Node oldParameterType = parametersNode != null ? parametersNode.getFirstChild() : null;\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = info == null ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      JSType parameterType;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      boolean isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                            "\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      boolean isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n      Node newParam = builder.newParameterFromNode(oldParameterType);\n      newParam.setJSType(oldParameterType.getJSType());\n      builder.addParameter(newParam);\n      oldParameterType = oldParameterType.getNext();\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n",
                            "\n  /**\n   * Infer the parameter types from the list of argument names and\n   * the doc info.\n   */\n\n  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      isVarArgs = isVarArgsParameter(arg, info);\n\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null) {\n        if (oldParameterType.getJSType() != null) {\n          parameterType = oldParameterType.getJSType();\n        } else {\n          parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    // Copy over any old parameters that aren't in the param list.\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }\n\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.LooseTypeCheckTest::testMethodInference6": {
                "path": "test/com/google/javascript/jscomp/LooseTypeCheckTest.java",
                "function_name": "testMethodInference6",
                "src": "  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):\nJSC_WRONG_ARGUMENT_COUNT. Function G.prototype.foo: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s). at [testcode] line 2 : 89\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7035)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7009)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6953)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6949)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testMethodInference6(LooseTypeCheckTest.java:1772)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):\nJSC_WRONG_ARGUMENT_COUNT. Function G.prototype.foo: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s). at [testcode] line 2 : 89\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7035)  fail(\"unexpected warnings(s):\\n\" + Joiner.on(\"\\n\").join(warnings));\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7009)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6953)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6949)  testTypes(js, (String) null);\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testMethodInference6(LooseTypeCheckTest.java:1772)  testTypes(        \"/** @constructor */ function F() {}\" +        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +        \"/** @constructor \\n * @extends {F} */ \" +        \"function G() {}\" +        \"/** @override */ G.prototype.foo = function() { };\" +        \"(new G()).foo(1);\");"
            },
            "com.google.javascript.jscomp.TypeCheckTest::testIssue368": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testIssue368",
                "src": "  public void testIssue368() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo(){}\" +\n        \"/**\\n\" +\n        \" * @param {number} one\\n\" +\n        \" * @param {string} two\\n\" +\n        \" */\\n\" +\n        \"Foo.prototype.add = function(one, two) {};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar(){}\" +\n        \"/** @override */\\n\" +\n        \"Bar.prototype.add = function(ignored) {};\" +\n        \"(new Bar()).add(1, 2);\",\n        \"actual parameter 2 of Bar.prototype.add does not match formal parameter\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\");\n  }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[actual parameter 2 of Bar.prototype.add does not match formal parameter\nfound   : number\nrequired: string]> but was:<[Function Bar.prototype.add: called with 2 argument(s). Function requires at least 1 argument(s) and no more than 1 argument(s).]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9529)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9508)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9446)\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue368(TypeCheckTest.java:5326)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[actual parameter 2 of Bar.prototype.add does not match formal parameter\nfound   : number\nrequired: string]> but was:<[Function Bar.prototype.add: called with 2 argument(s). Function requires at least 1 argument(s) and no more than 1 argument(s).]>\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9529)  assertEquals(description, warnings[0].description);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9508)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9446)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue368(TypeCheckTest.java:5326)  testTypes(        \"/** @constructor */ function Foo(){}\" +        \"/**\\n\" +        \" * @param {number} one\\n\" +        \" * @param {string} two\\n\" +        \" */\\n\" +        \"Foo.prototype.add = function(one, two) {};\" +        \"/**\\n\" +        \" * @constructor\\n\" +        \" * @extends {Foo}\\n\" +        \" */\\n\" +        \"function Bar(){}\" +        \"/** @override */\\n\" +        \"Bar.prototype.add = function(ignored) {};\" +        \"(new Bar()).add(1, 2);\",        \"actual parameter 2 of Bar.prototype.add does not match formal parameter\\n\" +        \"found   : number\\n\" +        \"required: string\");"
            },
            "com.google.javascript.jscomp.TypeCheckTest::testMethodInference6": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testMethodInference6",
                "src": "  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):\nJSC_WRONG_ARGUMENT_COUNT. Function G.prototype.foo: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s). at [testcode] line 2 : 89\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.TestCase.fail(TestCase.java:227)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9534)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9508)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9446)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9442)\n\tat com.google.javascript.jscomp.TypeCheckTest.testMethodInference6(TypeCheckTest.java:2027)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warnings(s):\nJSC_WRONG_ARGUMENT_COUNT. Function G.prototype.foo: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s). at [testcode] line 2 : 89\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9534)  fail(\"unexpected warnings(s):\\n\" + Joiner.on(\"\\n\").join(warnings));\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9508)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9446)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9442)  testTypes(js, (String) null);\n\tat com.google.javascript.jscomp.TypeCheckTest.testMethodInference6(TypeCheckTest.java:2027)  testTypes(        \"/** @constructor */ function F() {}\" +        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +        \"/** @constructor \\n * @extends {F} */ \" +        \"function G() {}\" +        \"/** @override */ G.prototype.foo = function() { };\" +        \"(new G()).foo(1);\");"
            }
        },
        "evaluation_done": true
    }
}