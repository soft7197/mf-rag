{
    "Closure-6": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/TypeValidator.java",
                "start_loc": 362,
                "end_loc": 389,
                "buggy_function": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                "fixed_function": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
                "comment": "  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   */\n",
                "normalized_body": [
                    "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true; } } mismatch(t, n, \\\"assignment to property \\\" + propName + \\\" of \\\" + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) { if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { JSType ownerType = getJSType(owner); if (ownerType.isFunctionPrototypeType()) { FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction(); if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) { return true; } } mismatch(t, n, \\\"assignment to property \\\" + propName + \\\" of \\\" + getReadableJSTypeName(owner, true), rightType, leftType); } return false; } return true; }"
                    ],
                    [
                        0.9620340466499329,
                        "private void annotateConstantsByConvention(Node n, Node parent) { Preconditions.checkState(n.isName() || n.isString() || n.isStringKey() || n.isGetterDef() || n.isSetterDef()); boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent); boolean isProperty = isObjLitKey || (parent.isGetProp() && parent.getLastChild() == n); if (n.isName() || isProperty) { boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME); if (!isMarkedConstant && NodeUtil.isConstantByConvention(compiler.getCodingConvention(), n, parent)) { if (assertOnChange) { String name = n.getString(); throw new IllegalStateException(\\\"Unexpected const change.\\n\\\" + \\\" name: \\\" + name + \\\"\\n\\\" + \\\" parent:\\\" + n.getParent().toStringTree()); } n.putBooleanProp(Node.IS_CONSTANT_NAME, true); } } }"
                    ],
                    [
                        0.9586790800094604,
                        "private void assertNodeOrder(ControlFlowGraph<Node> cfg, List<Integer> nodeTypes) { List<DiGraphNode<Node, Branch>> cfgNodes = Lists.newArrayList(cfg.getDirectedGraphNodes()); Collections.sort(cfgNodes, cfg.getOptionalNodeComparator(true)); Node implicitReturn = cfgNodes.remove(cfgNodes.size() - 1).getValue(); assertNull(implicitReturn == null ? \\\"null\\\" : implicitReturn.toStringTree(), implicitReturn); assertEquals(\\\"Wrong number of CFG nodes\\\", nodeTypes.size(), cfgNodes.size()); for (int i = 0; i < cfgNodes.size(); i++) { int expectedType = nodeTypes.get(i); int actualType = cfgNodes.get(i).getValue().getType(); assertEquals(\\\"node type mismatch at \\\" + i + \\\".\\n\\\" + \\\"found : \\\" + Token.name(actualType) + \\\"\\n\\\" + \\\"required: \\\" + Token.name(expectedType) + \\\"\\n\\\", expectedType, actualType); } }"
                    ],
                    [
                        0.9539586901664734,
                        "public void testAnnotationInExternStubs5() throws Exception { String externs = \\\"/**@constructor*/function externObj5(){}\\n\\\" + \\\"/**\\n\\\" + \\\" * @param {string} s id.\\n\\\" + \\\" * @return {string}\\n\\\" + \\\" * @nosideeffects\\n\\\" + \\\" */\\n\\\" + \\\"externObj5.prototype.propWithAnnotatedStubAfter = function(s) {};\\n\\\" + \\\"/**\\n\\\" + \\\" * @param {string} s id.\\n\\\" + \\\" * @return {string}\\n\\\" + \\\" */\\n\\\" + \\\"externObj5.prototype.propWithAnnotatedStubAfter;\\n\\\"; List<String> expected = ImmutableList.<String>of(); testSame(externs, \\\"o.prototype.propWithAnnotatedStubAfter\\\", TypeValidator.DUP_VAR_DECLARATION, false); assertEquals(expected, noSideEffectCalls); noSideEffectCalls.clear(); }"
                    ],
                    [
                        0.952749490737915,
                        "private Node constructStringExprNode(Iterator<CharSequence> parts, Node objLitNode) throws MalformedException { CharSequence part = parts.next(); Node partNode = null; if (part instanceof JsMessage.PlaceholderReference) { JsMessage.PlaceholderReference phRef = (JsMessage.PlaceholderReference) part; if (objLitNode == null) { throw new MalformedException(\\\"Empty placeholder value map \\\" + \\\"for a translated message with placeholders.\\\", objLitNode); } for (Node key = objLitNode.getFirstChild(); key != null; key = key.getNext()) { if (key.getString().equals(phRef.getName())) { Node valueNode = key.getFirstChild(); partNode = valueNode.cloneTree(); } } if (partNode == null) { throw new MalformedException(\\\"Unrecognized message placeholder referenced: \\\" + phRef.getName(), objLitNode); } } else { partNode = IR.string(part.toString()); } if (parts.hasNext()) { return IR.add(partNode, constructStringExprNode(parts, objLitNode)); } else { return partNode; } }"
                    ],
                    [
                        0.9525032043457031,
                        "private Node getNewValueNode(Node origNode, JsMessage message) throws MalformedException { Node newValueNode = getChromeI18nGetMessageNode(message.getId()); if (!message.placeholders().isEmpty()) { Node placeholderValues = origNode.getLastChild(); checkNode(placeholderValues, Token.OBJECTLIT); List<String> placeholderNames = Lists.newArrayList(); for (CharSequence cs : message.parts()) { if (cs instanceof PlaceholderReference) { String placeholderName = ((PlaceholderReference) cs).getName(); placeholderNames.add(placeholderName); } } Collections.sort(placeholderNames); Node placeholderValueArray = IR.arraylit(); for (String name : placeholderNames) { Node value = getPlaceholderValue(placeholderValues, name); if (value == null) { throw new MalformedException(\\\"No value was provided for placeholder \\\" + name, origNode); } placeholderValueArray.addChildToBack(value); } newValueNode.addChildToBack(placeholderValueArray); } newValueNode.copyInformationFromForTree(origNode); return newValueNode; }"
                    ],
                    [
                        0.9494174122810364,
                        "void expectIndexMatch(NodeTraversal t, Node n, JSType objType, JSType indexType) { Preconditions.checkState(n.isGetElem()); Node indexNode = n.getLastChild(); if (objType.isStruct()) { report(JSError.make(t.getSourceName(), indexNode, ILLEGAL_PROPERTY_ACCESS, \\\"'[]'\\\", \\\"struct\\\")); } if (objType.isUnknownType()) { expectStringOrNumber(t, indexNode, indexType, \\\"property access\\\"); } else { ObjectType dereferenced = objType.dereference(); if (dereferenced != null && dereferenced.getIndexType() != null) { expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(), \\\"restricted index type\\\"); } else if (dereferenced != null && dereferenced.isArrayType()) { expectNumber(t, indexNode, indexType, \\\"array access\\\"); } else if (objType.matchesObjectContext()) { expectString(t, indexNode, indexType, \\\"property access\\\"); } else { mismatch(t, n, \\\"only arrays or objects can be accessed\\\", objType, typeRegistry.createUnionType(ARRAY_TYPE, OBJECT_TYPE)); } } }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.LooseTypeCheckTest::testTypeRedefinition",
                    "com.google.javascript.jscomp.TypeCheckTest::testTypeRedefinition"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param owner The owner of the property being assigned to.\n   * @param propName The name of the property being assigned to.\n   * @return True if the types matched, false otherwise.\n   */\n\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2> but was:<1>\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testClosureTypesMultipleWarnings(LooseTypeCheckTest.java:6939)  assertEquals(descriptions.size(), compiler.getWarningCount());\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypeRedefinition(LooseTypeCheckTest.java:2121)  testClosureTypesMultipleWarnings(        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"        + \"/** @constructor */ a.A = function() {}\",        Lists.newArrayList(            \"variable a.A redefined with type function (new:a.A): undefined, \" +            \"original definition at [testcode]:1 with type enum{a.A}\",            \"assignment to property A of a\\n\" +            \"found   : function (new:a.A): undefined\\n\" +            \"required: enum{a.A}\"));\n \n#Test method 2:\n```java\n  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }\n```\n#Error message: junit.framework.AssertionFailedError: unexpected warning(s) : JSC_DUP_VAR_DECLARATION. variable a.A redefined with type function (new:a.A): undefined, original definition at [testcode]:1 with type enum{a.A} at [testcode] line 1 : 61 expected:<2> but was:<1>\n\tat com.google.javascript.jscomp.TypeCheckTest.testClosureTypesMultipleWarnings(TypeCheckTest.java:10876)  assertEquals(          \"unexpected warning(s) : \" +          Joiner.on(\", \").join(compiler.getWarnings()),          descriptions.size(), compiler.getWarningCount());\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypeRedefinition(TypeCheckTest.java:2516)  testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"        + \"/** @constructor */ a.A = function() {}\",        Lists.newArrayList(            \"variable a.A redefined with type function (new:a.A): undefined, \" +            \"original definition at [testcode]:1 with type enum{a.A}\",            \"assignment to property A of a\\n\" +            \"found   : function (new:a.A): undefined\\n\" +            \"required: enum{a.A}\"));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n        return false;  // Ensure that we register the mismatch and return false.\n      }\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() &&\n              rightType.isFunctionType() && leftType.isFunctionType()) {\n            return true;\n          }\n        }\n\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n\n        // Adding call to registerMismatch to register the mismatch\n        registerMismatch(rightType, leftType, null);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      boolean areBothSpecialTypes = (leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType());\n      boolean areBothFunctionTypes = rightType.isFunctionType() && leftType.isFunctionType();\n\n      if (areBothSpecialTypes) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() && areBothFunctionTypes) {\n            return true;\n          }\n        }\n\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      registerMismatch(rightType, leftType, null);\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && \n          (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n        registerMismatch(rightType, leftType, null);\n        return false;\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() &&\n              rightType.isFunctionType() && leftType.isFunctionType()) {\n            return true;\n          }\n        }\n\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      }\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      // Register mismatch for redefined variables to catch all warnings\n      registerMismatch(rightType, leftType, null);\n      \n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() &&\n              rightType.isFunctionType() && leftType.isFunctionType()) {\n            return true;\n          }\n        }\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n        mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n"
                        ],
                        "plausible_patches": [
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      } else {\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && \n          (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n        registerMismatch(rightType, leftType, null);\n        return false;\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() &&\n              rightType.isFunctionType() && leftType.isFunctionType()) {\n            return true;\n          }\n        }\n\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      }\n      // Do not type-check interface methods, because we expect that\n      // they will have dummy implementations that do not match the type\n      // annotations.\n      JSType ownerType = getJSType(owner);\n      if (ownerType.isFunctionPrototypeType()) {\n        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n        if (ownerFn.isInterface() &&\n            rightType.isFunctionType() && leftType.isFunctionType()) {\n          return true;\n        }\n      }\n\n      // Register mismatch for redefined variables to catch all warnings\n      registerMismatch(rightType, leftType, null);\n      \n      mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n,\n          \"assignment to property \" + propName + \" of \" +\n          getReadableJSTypeName(owner, true),\n          rightType, leftType);\n      } else {\n        // Do not type-check interface methods, because we expect that\n        // they will have dummy implementations that do not match the type\n        // annotations.\n        JSType ownerType = getJSType(owner);\n        if (ownerType.isFunctionPrototypeType()) {\n          FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n          if (ownerFn.isInterface() &&\n              rightType.isFunctionType() && leftType.isFunctionType()) {\n            return true;\n          }\n        }\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/TypeValidator.java",
                "start_loc": 402,
                "end_loc": 413,
                "buggy_function": "  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                "fixed_function": "  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    return true;\n  }\n",
                "comment": "  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   */\n",
                "normalized_body": [
                    "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } return false; } return true; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) { if (!rightType.canAssignTo(leftType)) { if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) { registerMismatch(rightType, leftType, null); } else { mismatch(t, n, msg, rightType, leftType); } return false; } return true; }"
                    ],
                    [
                        0.9661386013031006,
                        "private Collection<Definition> lookupDefinitionsForTargetsOfCall(Node callsite, DefinitionProvider definitionProvider) { Preconditions.checkArgument(callsite.isCall() || callsite.isNew()); Node targetExpression = callsite.getFirstChild(); if (!useNameReferenceGraph || (targetExpression.isGetProp() || targetExpression.isName())) { Collection<Definition> definitions = definitionProvider.getDefinitionsReferencedAt(targetExpression); if (definitions != null && !definitions.isEmpty()) { return definitions; } } return null; }"
                    ],
                    [
                        0.9451588988304138,
                        "private boolean needsPropertyScope(Symbol sym) { ObjectType type = ObjectType.cast(sym.getType()); if (type == null) { return false; } if (type.getReferenceName() == null) { return true; } if (sym.getName().equals(type.getReferenceName())) { return true; } if (type.isEnumType() && sym.getName().equals(type.toMaybeEnumType().getElementsType().getReferenceName())) { return true; } return false; }"
                    ],
                    [
                        0.9443999528884888,
                        "public void testGreatestSubtypeWithProperty() { ObjectType foo = registry.createObjectType(\\\"foo\\\", null, OBJECT_TYPE); ObjectType bar = registry.createObjectType(\\\"bar\\\", null, namedGoogBar); foo.defineDeclaredProperty(\\\"propz\\\", UNKNOWN_TYPE, null); bar.defineDeclaredProperty(\\\"propz\\\", UNKNOWN_TYPE, null); assertTypeEquals(bar, registry.getGreatestSubtypeWithProperty(namedGoogBar, \\\"propz\\\")); }"
                    ],
                    [
                        0.9418619871139526,
                        "private void reusePreviouslyUsedVariableMap() { for (Assignment a : assignments.values()) { String prevNewName = prevUsedRenameMap.lookupNewName(a.oldName); if (prevNewName == null || reservedNames.contains(prevNewName)) { continue; } if (a.oldName.startsWith(LOCAL_VAR_PREFIX) || (!externNames.contains(a.oldName) && prevNewName.startsWith(prefix))) { reservedNames.add(prevNewName); finalizeNameAssignment(a, prevNewName); } } }"
                    ],
                    [
                        0.9378969669342041,
                        "public void testShortcutMode3() { String contents = \\\"/**\\n\\\" + \\\" * goog.provide('no1');\\n */\\n\\\" + \\\"goog.provide('yes1');\\n\\\"; DependencyInfo expected = new SimpleDependencyInfo(CLOSURE_PATH, SRC_PATH, ImmutableList.of(\\\"yes1\\\"), Collections.<String>emptyList()); DependencyInfo result = parser.parseFile(SRC_PATH, CLOSURE_PATH, contents); assertDeps(expected, result); }"
                    ],
                    [
                        0.9377347826957703,
                        "private boolean isPropertyAssignmentToName(Node propertyCandidate) { if (propertyCandidate == null) { return false; } if (!NodeUtil.isExprAssign(propertyCandidate)) { return false; } Node expr = propertyCandidate.getFirstChild(); Node lhs = expr.getFirstChild(); if (!NodeUtil.isGet(lhs)) { return false; } Node obj = lhs.getFirstChild(); if (!obj.isName()) { return false; } return true; }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.TypeCheckTest::testIssue635b"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   */\n\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n      mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue635b() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"function F() {}\" +\n        \"/** @constructor */\" +\n        \"function G() {}\" +\n        \"/** @type {function(new:G)} */ var x = F;\",\n        \"initializing variable\\n\" +\n        \"found   : function (new:F): undefined\\n\" +\n        \"required: function (new:G): ?\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: expected a warning\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10911)  assertTrue(\"expected a warning\", warnings.length > 0);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10891)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10827)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue635b(TypeCheckTest.java:6342)  testTypes(        \"/** @constructor */\" +        \"function F() {}\" +        \"/** @constructor */\" +        \"function G() {}\" +        \"/** @type {function(new:G)} */ var x = F;\",        \"initializing variable\\n\" +        \"found   : function (new:F): undefined\\n\" +        \"required: function (new:G): ?\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() && rightType.isConstructor()) || (leftType.isEnumType() && rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() && rightType.isConstructor()) || (leftType.isEnumType() && rightType.isEnumType())) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        registerMismatch(rightType, leftType, null);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      // Adjusting condition to correctly identify mismatches between\n      // constructors and enum types.\n      if (leftType.isConstructor() && rightType.isConstructor()) {\n        registerMismatch(rightType, leftType, null);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n      registerMismatch(rightType, leftType, null);\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  /**\n   * Expect that the first type can be assigned to a symbol of the second\n   * type.\n   *\n   * @param t The node traversal.\n   * @param n The node to issue warnings on.\n   * @param rightType The type on the RHS of the assign.\n   * @param leftType The type of the symbol on the LHS of the assign.\n   * @param msg An extra message for the mismatch warning, if necessary.\n   * @return True if the types matched, false otherwise.\n   */\n\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n      registerMismatch(rightType, leftType, null);\n      return false;\n    }\n    return true;\n  }\n"
                        ],
                        "plausible_patches": [
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        mismatch(t, n, msg, rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n        mismatch(t, n, msg, rightType, leftType);\n      } else {\n        registerMismatch(rightType, leftType, null);\n      }\n      return false;\n    }\n    return true;\n  }\n",
                            "\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, String msg) {\n    if (!rightType.canAssignTo(leftType)) {\n      mismatch(t, n, msg, rightType, leftType);\n      return false;\n    }\n    if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n      registerMismatch(rightType, leftType, null);\n      return false;\n    }\n    return true;\n  }\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.LooseTypeCheckTest::testTypeRedefinition": {
                "path": "test/com/google/javascript/jscomp/LooseTypeCheckTest.java",
                "function_name": "testTypeRedefinition",
                "src": "  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.Assert.assertEquals(Assert.java:241)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:409)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testClosureTypesMultipleWarnings(LooseTypeCheckTest.java:6939)\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypeRedefinition(LooseTypeCheckTest.java:2121)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<2> but was:<1>\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testClosureTypesMultipleWarnings(LooseTypeCheckTest.java:6939)  assertEquals(descriptions.size(), compiler.getWarningCount());\n\tat com.google.javascript.jscomp.LooseTypeCheckTest.testTypeRedefinition(LooseTypeCheckTest.java:2121)  testClosureTypesMultipleWarnings(        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"        + \"/** @constructor */ a.A = function() {}\",        Lists.newArrayList(            \"variable a.A redefined with type function (new:a.A): undefined, \" +            \"original definition at [testcode]:1 with type enum{a.A}\",            \"assignment to property A of a\\n\" +            \"found   : function (new:a.A): undefined\\n\" +            \"required: enum{a.A}\"));"
            },
            "com.google.javascript.jscomp.TypeCheckTest::testIssue635b": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testIssue635b",
                "src": "  public void testIssue635b() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"function F() {}\" +\n        \"/** @constructor */\" +\n        \"function G() {}\" +\n        \"/** @type {function(new:G)} */ var x = F;\",\n        \"initializing variable\\n\" +\n        \"found   : function (new:F): undefined\\n\" +\n        \"required: function (new:G): ?\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: expected a warning\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.TestCase.assertTrue(TestCase.java:192)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10911)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10891)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10827)\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue635b(TypeCheckTest.java:6342)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected a warning\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10911)  assertTrue(\"expected a warning\", warnings.length > 0);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10891)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10827)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue635b(TypeCheckTest.java:6342)  testTypes(        \"/** @constructor */\" +        \"function F() {}\" +        \"/** @constructor */\" +        \"function G() {}\" +        \"/** @type {function(new:G)} */ var x = F;\",        \"initializing variable\\n\" +        \"found   : function (new:F): undefined\\n\" +        \"required: function (new:G): ?\");"
            },
            "com.google.javascript.jscomp.TypeCheckTest::testTypeRedefinition": {
                "path": "test/com/google/javascript/jscomp/TypeCheckTest.java",
                "function_name": "testTypeRedefinition",
                "src": "  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\"));\n  }",
                "error_msg": "junit.framework.AssertionFailedError: unexpected warning(s) : JSC_DUP_VAR_DECLARATION. variable a.A redefined with type function (new:a.A): undefined, original definition at [testcode]:1 with type enum{a.A} at [testcode] line 1 : 61 expected:<2> but was:<1>\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.failNotEquals(Assert.java:329)\n\tat junit.framework.Assert.assertEquals(Assert.java:78)\n\tat junit.framework.Assert.assertEquals(Assert.java:234)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:401)\n\tat com.google.javascript.jscomp.TypeCheckTest.testClosureTypesMultipleWarnings(TypeCheckTest.java:10876)\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypeRedefinition(TypeCheckTest.java:2516)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: unexpected warning(s) : JSC_DUP_VAR_DECLARATION. variable a.A redefined with type function (new:a.A): undefined, original definition at [testcode]:1 with type enum{a.A} at [testcode] line 1 : 61 expected:<2> but was:<1>\n\tat com.google.javascript.jscomp.TypeCheckTest.testClosureTypesMultipleWarnings(TypeCheckTest.java:10876)  assertEquals(          \"unexpected warning(s) : \" +          Joiner.on(\", \").join(compiler.getWarnings()),          descriptions.size(), compiler.getWarningCount());\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypeRedefinition(TypeCheckTest.java:2516)  testClosureTypesMultipleWarnings(\"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"        + \"/** @constructor */ a.A = function() {}\",        Lists.newArrayList(            \"variable a.A redefined with type function (new:a.A): undefined, \" +            \"original definition at [testcode]:1 with type enum{a.A}\",            \"assignment to property A of a\\n\" +            \"found   : function (new:a.A): undefined\\n\" +            \"required: enum{a.A}\"));"
            }
        },
        "evaluation_done": true
    }
}