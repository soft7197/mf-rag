{
    "Closure-76": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
                "start_loc": 290,
                "end_loc": 324,
                "buggy_function": "  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the currently node is the first child of\n          // AND/OR, be conservative only consider the READs\n          // of the second operand.\n\n        case Token.HOOK:\n          // If current node is the condition, check each following\n          // branch, otherwise it is a conditional branch and the\n          // other branch can be ignored.\n\n        default:\n          for(Node sibling = n.getNext(); sibling != null;\n              sibling = sibling.getNext()) {\n            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n            state = isVariableReadBeforeKill(sibling, variable);\n\n      // If we see a READ or KILL there is no need to continue.\n      if (state == VariableLiveness.READ) {\n        return true;\n      } else if (state == VariableLiveness.KILL) {\n        return false;\n            }\n          }\n      }\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n",
                "fixed_function": "  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the currently node is the first child of\n          // AND/OR, be conservative only consider the READs\n          // of the second operand.\n          if (n.getNext() != null) {\n            state = isVariableReadBeforeKill(\n                n.getNext(), variable);\n            if (state == VariableLiveness.KILL) {\n              state = VariableLiveness.MAYBE_LIVE;\n            }\n          }\n          break;\n\n        case Token.HOOK:\n          // If current node is the condition, check each following\n          // branch, otherwise it is a conditional branch and the\n          // other branch can be ignored.\n          if (n.getNext() != null && n.getNext().getNext() != null) {\n            state = checkHookBranchReadBeforeKill(\n                n.getNext(), n.getNext().getNext(), variable);\n          }\n          break;\n\n        default:\n          for(Node sibling = n.getNext(); sibling != null;\n              sibling = sibling.getNext()) {\n            state = isVariableReadBeforeKill(sibling, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n              break;\n            }\n          }\n      }\n\n      // If we see a READ or KILL there is no need to continue.\n      if (state == VariableLiveness.READ) {\n        return true;\n      } else if (state == VariableLiveness.KILL) {\n        return false;\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n",
                "comment": "  /**\n   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n   * the root, this function returns true if there exists a read of that\n   * variable before a write to that variable that is on the right side of n.\n   *\n   * For example, suppose the node is x = 1:\n   *\n   * y = 1, x = 1; // false, there is no reads at all.\n   * y = 1, x = 1, print(x) // true, there is a read right of n.\n   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but\n   *                               // it is after a write.\n   *\n   * @param n The current node we should look at.\n   * @param exprRoot The node\n   */\n",
                "normalized_body": [
                    "private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch(n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent(); } return false; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private boolean isVariableStillLiveWithinExpression(Node n, Node exprRoot, String variable) { while (n != exprRoot) { VariableLiveness state = VariableLiveness.MAYBE_LIVE; switch(n.getParent().getType()) { case Token.OR: case Token.AND: case Token.HOOK: default: for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) { state = isVariableReadBeforeKill(sibling, variable); if (state == VariableLiveness.READ) { return true; } else if (state == VariableLiveness.KILL) { return false; } } } } n = n.getParent(); } return false; }"
                    ],
                    [
                        0.986775815486908,
                        "private void collectAliasCandidates(NodeTraversal t, Map<Var, ReferenceCollection> referenceMap) { if (mode != Mode.CONSTANTS_ONLY) { for (Iterator<Var> it = t.getScope().getVars(); it.hasNext(); ) { Var v = it.next(); ReferenceCollection referenceInfo = referenceMap.get(v); if (referenceInfo != null && referenceInfo.references.size() >= 2 && referenceInfo.isWellDefined() && referenceInfo.isAssignedOnceInLifetime()) { Reference init = referenceInfo.getInitializingReference(); Node value = init.getAssignedValue(); if (value != null && value.getType() == Token.NAME) { aliasCandidates.put(value, new AliasCandidate(v, referenceInfo)); } } } } }"
                    ],
                    [
                        0.9848147630691528,
                        "static boolean isSubtype(ObjectType typeA, RecordType typeB) { for (String property : typeB.properties.keySet()) { if (!typeA.hasProperty(property)) { return false; } JSType propA = typeA.getPropertyType(property); JSType propB = typeB.getPropertyType(property); if (!propA.isUnknownType() && !propB.isUnknownType()) { if (typeA.isPropertyTypeDeclared(property)) { if (!propA.isEquivalentTo(propB)) { return false; } } else { if (!propA.isSubtype(propB)) { return false; } } } } return true; }"
                    ],
                    [
                        0.9824758172035217,
                        "static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) { if (valueType != null) { switch(key.getType()) { case Token.GET: if (valueType.isFunctionType()) { FunctionType fntype = ((FunctionType) valueType); valueType = fntype.getReturnType(); } else { return null; } break; case Token.SET: if (valueType.isFunctionType()) { FunctionType fntype = ((FunctionType) valueType); Node param = fntype.getParametersNode().getFirstChild(); valueType = param.getJSType(); } else { return null; } break; } } return valueType; }"
                    ],
                    [
                        0.9814054369926453,
                        "private void getDefinition(Node n, Node parent) { AbstractCfgNodeTraversalCallback gatherCb = new AbstractCfgNodeTraversalCallback() { @Override public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.NAME: if (n.getString().equals(varName) && n.hasChildren()) { def = n; } return; case Token.ASSIGN: Node lhs = n.getFirstChild(); if (NodeUtil.isName(lhs) && lhs.getString().equals(varName)) { def = n; } return; } } }; NodeTraversal.traverse(compiler, n, gatherCb); }"
                    ],
                    [
                        0.9809951782226562,
                        "public void visit(NodeTraversal t, Node n, Node parent) { Node child; switch(n.getType()) { case Token.IF: child = n.getFirstChild().getNext(); break; case Token.WHILE: case Token.FOR: child = NodeUtil.getLoopCodeBlock(n); break; default: return; } for (; child != null; child = child.getNext()) { if ((child.getType() == Token.BLOCK) && (!child.hasChildren())) { if (child.wasEmptyNode()) { t.getCompiler().report(t.makeError(n, level, SUSPICIOUS_SEMICOLON)); } } } }"
                    ],
                    [
                        0.979676365852356,
                        "private SubclassType typeofClassDefiningName(Node callName) { String methodName = null; if (callName.getType() == Token.GETPROP) { methodName = callName.getLastChild().getString(); } else if (callName.getType() == Token.NAME) { String name = callName.getString(); int dollarIndex = name.lastIndexOf('$'); if (dollarIndex != -1) { methodName = name.substring(dollarIndex + 1); } } if (methodName != null) { if (methodName.equals(\\\"inherits\\\")) { return SubclassType.INHERITS; } else if (methodName.equals(\\\"mixin\\\")) { return SubclassType.MIXIN; } } return null; }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue384b",
                    "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue384c",
                    "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue384d"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n  /**\n   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n   * the root, this function returns true if there exists a read of that\n   * variable before a write to that variable that is on the right side of n.\n   *\n   * For example, suppose the node is x = 1:\n   *\n   * y = 1, x = 1; // false, there is no reads at all.\n   * y = 1, x = 1, print(x) // true, there is a read right of n.\n   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but\n   *                               // it is after a write.\n   *\n   * @param n The current node we should look at.\n   * @param exprRoot The node\n   */\n\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the currently node is the first child of\n          // AND/OR, be conservative only consider the READs\n          // of the second operand.\n\n        case Token.HOOK:\n          // If current node is the condition, check each following\n          // branch, otherwise it is a conditional branch and the\n          // other branch can be ignored.\n\n        default:\n          for(Node sibling = n.getNext(); sibling != null;\n              sibling = sibling.getNext()) {\n            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n            state = isVariableReadBeforeKill(sibling, variable);\n\n      // If we see a READ or KILL there is no need to continue.\n      if (state == VariableLiveness.READ) {\n        return true;\n      } else if (state == VariableLiveness.KILL) {\n        return false;\n            }\n          }\n      }\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue384b() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +\n            \" return a;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;f(b=true)||f(b=false)?a=b:a=null;return a}\nResult: function FUNC(param1,param2){var a,b;f(true)||f(b=false)?a=b:a=null;return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    HOOK 2 [sourcename: expected0]\n                        OR 2 [sourcename: expected0] [parenthesized: true]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NULL 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    HOOK 2 [sourcename: testcode]\n                        OR 2 [sourcename: testcode] [parenthesized: true]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NULL 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)  inFunction(src, src);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384b(DeadAssignmentsEliminationTest.java:501)  inFunction(            \" var a, b;\\n\" +            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +            \" return a;\");\n \n#Test method 2:\n```java\n  public void testIssue384c() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;(a?f(b=true):f(b=false))&&(a=b);return a}\nResult: function FUNC(param1,param2){var a,b;(a?f(true):f(b=false))&&(a=b);return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    AND 2 [sourcename: expected0]\n                        HOOK 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    AND 2 [sourcename: testcode]\n                        HOOK 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)  inFunction(src, src);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384c(DeadAssignmentsEliminationTest.java:508)  inFunction(            \" var a, b;\\n\" +            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +            \" return a;\");\n \n#Test method 3:\n```java\n  public void testIssue384d() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }\n```\n#Error message: junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;(f(b=true)||f(b=false))&&(a=b);return a}\nResult: function FUNC(param1,param2){var a,b;(f(true)||f(b=false))&&(a=b);return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    AND 2 [sourcename: expected0]\n                        OR 2 [sourcename: expected0] [parenthesized: true]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    AND 2 [sourcename: testcode]\n                        OR 2 [sourcename: testcode] [parenthesized: true]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)  inFunction(src, src);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384d(DeadAssignmentsEliminationTest.java:515)  inFunction(            \" var a, b;\\n\" +            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +            \" return a;\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          if (n.getParent().getFirstChild() == n) {\n            // If the current node is the first child of AND/OR,\n            // only consider the reads of the second operand.\n            n = n.getNext();\n            continue;\n          }\n          break;\n\n        case Token.HOOK:\n          if (n.getParent().getFirstChild() == n) {\n            // If current node is the condition, check each following branch\n            n = n.getNext();\n            continue;\n          }\n          break;\n\n        default:\n          break;\n      }\n\n      for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n          state = isVariableReadBeforeKill(sibling, variable);\n\n          // If we see a READ or KILL there is no need to continue.\n          if (state == VariableLiveness.READ) {\n            return true;\n          } else if (state == VariableLiveness.KILL) {\n            return false;\n          }\n        }\n      }\n      \n      n = n.getParent();\n    }\n    return false;\n  }\n",
                            "\nprivate boolean isVariableStillLiveWithinExpression(\n    Node n, Node exprRoot, String variable) {\n  while (n != exprRoot) {\n    VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.OR:\n      case Token.AND:\n        if (parent.getFirstChild() == n) {\n          n = parent.getSecondChild(); // Move to the second operand\n        }\n        break;\n\n      case Token.HOOK:\n        if (parent.getFirstChild() == n) {\n          n = parent.getSecondChild(); // Move to the \"true\" branch\n        } else if (parent.getSecondChild() == n) {\n          n = parent.getLastChild(); // Move to the \"false\" branch\n        }\n        break;\n\n      default:\n        for (Node sibling = n.getNext(); sibling != null;\n             sibling = sibling.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n            state = isVariableReadBeforeKill(sibling, variable);\n\n            if (state == VariableLiveness.READ) {\n              return true;\n            } else if (state == VariableLiveness.KILL) {\n              return false;\n            }\n          }\n        }\n        break;\n    }\n    n = n.getParent();\n  }\n  return false;\n}\n",
                            "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.OR:\n        case Token.AND:\n          if (n == parent.getFirstChild()) {\n            n = parent;\n            continue;\n          }\n          break;\n\n        case Token.HOOK:\n          if (n == parent.getFirstChild()) {\n            n = parent;\n            continue;\n          }\n          break;\n\n        default:\n          for (Node sibling = n.getNext(); sibling != null;\n              sibling = sibling.getNext()) {\n            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n              state = isVariableReadBeforeKill(sibling, variable);\n\n              if (state == VariableLiveness.READ) {\n                return true;\n              } else if (state == VariableLiveness.KILL) {\n                return false;\n              }\n            }\n          }\n          break;\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n",
                            "\nprivate boolean isVariableStillLiveWithinExpression(\n    Node n, Node exprRoot, String variable) {\n  while (n != exprRoot) {\n    VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n    switch (n.getParent().getType()) {\n      case Token.OR:\n      case Token.AND:\n        // If the currently node is the first child of\n        // AND/OR, be conservative only consider the READs\n        // of the second operand.\n        if (n != n.getParent().getFirstChild()) {\n          n = n.getNext();\n          continue;\n        }\n        break;\n\n      case Token.HOOK:\n        // If current node is the condition, check each following\n        // branch, otherwise it is a conditional branch and the\n        // other branch can be ignored.\n        if (n == n.getParent().getFirstChild()) {\n          for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\n            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n              state = isVariableReadBeforeKill(sibling, variable);\n\n              // If we see a READ or KILL there is no need to continue.\n              if (state == VariableLiveness.READ) {\n                return true;\n              } else if (state == VariableLiveness.KILL) {\n                return false;\n              }\n            }\n          }\n        }\n        break;\n\n      default:\n        for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n            state = isVariableReadBeforeKill(sibling, variable);\n\n            // If we see a READ or KILL there is no need to continue.\n            if (state == VariableLiveness.READ) {\n              return true;\n            } else if (state == VariableLiveness.KILL) {\n              return false;\n            }\n          }\n        }\n    }\n    n = n.getParent();\n  }\n  return false;\n}\n",
                            "\nprivate boolean isVariableStillLiveWithinExpression(\n    Node n, Node exprRoot, String variable) {\n  while (n != exprRoot) {\n    VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n    switch (n.getType()) {\n      case Token.OR:\n      case Token.AND:\n        if (n.getFirstChild() != null && n.getFirstChild() == n) {\n          n = n.getNext();\n          continue;\n        }\n        break;\n\n      case Token.HOOK:\n        if (n.getFirstChild() != null && n.getFirstChild() == n) {\n          n = n.getNext();\n          continue;\n        }\n        break;\n    }\n    for (Node sibling = n.getNext(); sibling != null;\n        sibling = sibling.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n        state = isVariableReadBeforeKill(sibling, variable);\n\n        if (state == VariableLiveness.READ) {\n          return true;\n        } else if (state == VariableLiveness.KILL) {\n          return false;\n        }\n      }\n    }\n    n = n.getParent();\n  }\n  return false;\n}\n",
                            "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the current node is the first child of\n          // AND/OR, be conservative only consider the READs\n          // of the second operand.\n          if (n == n.getParent().getFirstChild()) {\n            n = n.getParent();\n            continue;\n          }\n          break;\n        case Token.HOOK:\n          // If current node is the condition, check each following\n          // branch, otherwise it is a conditional branch and the\n          // other branch can be ignored.\n          if (n == n.getParent().getFirstChild()) {\n            n = n.getParent();\n            continue;\n          }\n          break;\n        default:\n          break;\n      }\n\n      for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n          state = isVariableReadBeforeKill(sibling, variable);\n\n          // If we see a READ or KILL there is no need to continue.\n          if (state == VariableLiveness.READ) {\n            return true;\n          } else if (state == VariableLiveness.KILL) {\n            return false;\n          }\n        }\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n",
                            "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the current node is the first child of AND/OR, be conservative only consider \n          // the READs of the second operand.\n          if (n == n.getParent().getFirstChild()) {\n            n = n.getNext();\n            continue;\n          }\n          break;\n\n        case Token.HOOK:\n          // If current node is the condition, check each following branch, otherwise it is \n          // a conditional branch and the other branch can be ignored.\n          if (n == n.getParent().getFirstChild()) {\n            n = n.getNext();\n            continue;\n          }\n          if (n == n.getParent().getSecondChild()) {\n            // Ignore the else branch if we're currently in the then branch.\n            break;\n          }\n          break;\n      }\n      \n      for(Node sibling = n.getNext(); sibling != null;\n          sibling = sibling.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n          state = isVariableReadBeforeKill(sibling, variable);\n\n          // If we see a READ or KILL there is no need to continue.\n          if (state == VariableLiveness.READ) {\n            return true;\n          } else if (state == VariableLiveness.KILL) {\n            return false;\n          }\n        }\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n",
                            "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the current node is the first child of\n          // AND/OR, be conservative only consider the READs\n          // of the second operand.\n          if (parent.getFirstChild() == n) {\n            n = n.getNext();\n            continue;\n          }\n          break;\n\n        case Token.HOOK:\n          // If current node is the condition, check each following\n          // branch, otherwise it is a conditional branch and the\n          // other branch can be ignored.\n          if (parent.getFirstChild() == n) {\n            n = n.getNext();\n            continue;\n          }\n          break;\n\n        default:\n          break;\n      }\n      \n      for (Node sibling = n.getNext(); sibling != null;\n           sibling = sibling.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n          state = isVariableReadBeforeKill(sibling, variable);\n\n          // If we see a READ or KILL there is no need to continue.\n          if (state == VariableLiveness.READ) {\n            return true;\n          } else if (state == VariableLiveness.KILL) {\n            return false;\n          }\n        }\n      }\n      \n      n = parent;\n    }\n    return false;\n  }\n",
                            "\n  private boolean isVariableStillLiveWithinExpression(\n      Node n, Node exprRoot, String variable) {\n    while (n != exprRoot) {\n      VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n      switch (n.getParent().getType()) {\n        case Token.OR:\n        case Token.AND:\n          // If the current node is the first child of\n          // AND/OR, be conservative and only consider the READs\n          // of the second operand.\n          if (n == n.getParent().getFirstChild()) {\n            n = n.getParent();  // Move to the parent node\n            continue;\n          }\n          break;\n\n        case Token.HOOK:\n          // If current node is the condition, check each following\n          // branch, otherwise it is a conditional branch and the\n          // other branch can be ignored.\n          if (n == n.getParent().getFirstChild()) {\n            Node trueBranch = n.getNext();\n            Node falseBranch = trueBranch.getNext();\n            // Check both branches independently\n            if (isVariableReadBeforeKill(trueBranch, variable) == VariableLiveness.READ ||\n                isVariableReadBeforeKill(falseBranch, variable) == VariableLiveness.READ) {\n              return true;\n            }\n            return false;\n          }\n          break;\n\n        default:\n          for(Node sibling = n.getNext(); sibling != null;\n              sibling = sibling.getNext()) {\n            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n              state = isVariableReadBeforeKill(sibling, variable);\n              // If we see a READ or KILL there is no need to continue.\n              if (state == VariableLiveness.READ) {\n                return true;\n              } else if (state == VariableLiveness.KILL) {\n                return false;\n              }\n            }\n          }\n      }\n      n = n.getParent();\n    }\n    return false;\n  }\n",
                            "\nprivate boolean isVariableStillLiveWithinExpression(\n    Node n, Node exprRoot, String variable) {\n  while (n != exprRoot) {\n    VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n    Node parent = n.getParent();\n    boolean checkSiblings = false;\n\n    switch (parent.getType()) {\n      case Token.OR:\n      case Token.AND:\n        checkSiblings = (n != parent.getFirstChild());\n        break;\n      case Token.HOOK:\n        checkSiblings = (n == parent.getFirstChild());\n        break;\n      default:\n        checkSiblings = true;\n    }\n\n    if (checkSiblings) {\n      for (Node sibling = n.getNext(); sibling != null; sibling = sibling.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n          state = isVariableReadBeforeKill(sibling, variable);\n\n          if (state == VariableLiveness.READ) {\n            return true;\n          } else if (state == VariableLiveness.KILL) {\n            return false;\n          }\n        }\n      }\n    }\n    n = parent;\n  }\n  return false;\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/com/google/javascript/jscomp/DeadAssignmentsElimination.java",
                "start_loc": 338,
                "end_loc": 382,
                "buggy_function": "  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    switch (n.getType()) {\n      // Conditionals\n      case Token.OR:\n      case Token.AND:\n        // With a AND/OR the first branch always runs, but the second is\n        // may not.\n      case Token.HOOK:\n        return checkHookBranchReadBeforeKill(\n            n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n      default:\n        // Expressions are evaluated left-right, depth first.\n        for (Node child = n.getFirstChild();\n            child != null; child = child.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }\n",
                "fixed_function": "  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION\n      return VariableLiveness.MAYBE_LIVE;\n    }\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    switch (n.getType()) {\n      // Conditionals\n      case Token.OR:\n      case Token.AND:\n        VariableLiveness v1 = isVariableReadBeforeKill(\n          n.getFirstChild(), variable);\n        VariableLiveness v2 = isVariableReadBeforeKill(\n          n.getLastChild(), variable);\n        // With a AND/OR the first branch always runs, but the second is\n        // may not.\n        if (v1 != VariableLiveness.MAYBE_LIVE) {\n          return v1;\n        } else if (v2 == VariableLiveness.READ) {\n          return VariableLiveness.READ;\n        } else {\n          return VariableLiveness.MAYBE_LIVE;\n        }\n      case Token.HOOK:\n        VariableLiveness first = isVariableReadBeforeKill(\n            n.getFirstChild(), variable);\n        if (first != VariableLiveness.MAYBE_LIVE) {\n          return first;\n        }\n        return checkHookBranchReadBeforeKill(\n            n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n      default:\n        // Expressions are evaluated left-right, depth first.\n        for (Node child = n.getFirstChild();\n            child != null; child = child.getNext()) {\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }\n",
                "comment": "  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n",
                "normalized_body": [
                    "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; } } switch(n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999999403953552,
                        "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) { if (NodeUtil.isName(n) && variable.equals(n.getString())) { if (NodeUtil.isLhs(n, n.getParent())) { Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; } return VariableLiveness.KILL; } else { return VariableLiveness.READ; } } switch(n.getType()) { case Token.OR: case Token.AND: case Token.HOOK: return checkHookBranchReadBeforeKill(n.getFirstChild().getNext(), n.getLastChild(), variable); default: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { VariableLiveness state = isVariableReadBeforeKill(child, variable); if (state != VariableLiveness.MAYBE_LIVE) { return state; } } } } return VariableLiveness.MAYBE_LIVE; }"
                    ],
                    [
                        0.9688693284988403,
                        "public Collection<Assignment> getAssignments(ConcreteScope scope) { ConcreteType thisType = ConcreteType.NONE; ConcreteType recvType = inferConcreteType(scope, receiver); if (propName != null) { thisType = recvType; recvType = thisType.getPropertyType(propName); } if (recvType.isAll()) { throw new AssertionError(\\\"Found call on all type, which makes tighten types useless.\\\"); } if (isNewCall) { thisType = ConcreteType.NONE; for (ConcreteInstanceType instType : recvType.getFunctionInstanceTypes()) { thisType = thisType.unionWith(instType); } boolean added = allInstantiatedTypes.add(thisType); if (added) { typeIntersectionMemos.clear(); } } List<ConcreteType> argTypes = Lists.newArrayList(); for (Node arg = firstArgument; arg != null; arg = arg.getNext()) { argTypes.add(inferConcreteType(scope, arg)); } return getFunctionCallAssignments(recvType, thisType, argTypes); }"
                    ],
                    [
                        0.9682862758636475,
                        "public void visit(NodeTraversal t, Node n, Node parent) { if (n.getType() == Token.GETPROP) { String propName = n.getFirstChild().getNext().getString(); if (propName.equals(\\\"prototype\\\")) { processPrototypeParent(t, parent); } else if (compiler.getCodingConvention().isExported(propName)) { addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY); } else { addSymbolUse(propName, t.getModule(), PROPERTY); } } else if (n.getType() == Token.OBJECTLIT && !(parent.getType() == Token.ASSIGN && parent.getFirstChild().getType() == Token.GETPROP && parent.getFirstChild().getLastChild().getString().equals(\\\"prototype\\\"))) { for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) { if (propNameNode.getType() != Token.NUMBER && !propNameNode.isQuotedString()) { addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY); } } } else if (n.getType() == Token.NAME) { String name = n.getString(); Var var = t.getScope().getVar(name); if (var != null) { if (var.isGlobal()) { if (var.getInitialValue() != null && var.getInitialValue().getType() == Token.FUNCTION) { if (t.inGlobalScope()) { if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) { addGlobalUseOfSymbol(name, t.getModule(), VAR); } } else { addSymbolUse(name, t.getModule(), VAR); } } } else if (var.getScope() != t.getScope()) { for (int i = symbolStack.size() - 1; i >= 0; i--) { NameContext context = symbolStack.get(i); context.name.readClosureVariables = true; if (context.scope == var.getScope()) { break; } } } } } if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || NodeUtil.isFunction(n)) { symbolStack.pop(); } }"
                    ],
                    [
                        0.9681941270828247,
                        "private static Node replaceReturnWithBreak(Node current, Node parent, String resultName, String labelName) { if (current.getType() == Token.FUNCTION || current.getType() == Token.EXPR_RESULT) { return current; } if (current.getType() == Token.RETURN) { Preconditions.checkState(NodeUtil.isStatementBlock(parent)); Node resultNode = getReplacementReturnStatement(current, resultName); Node name = Node.newString(Token.LABEL_NAME, labelName); Node breakNode = new Node(Token.BREAK, name); breakNode.copyInformationFromForTree(current); parent.replaceChild(current, breakNode); if (resultNode != null) { resultNode.copyInformationFromForTree(current); parent.addChildBefore(resultNode, breakNode); } current = breakNode; } else { for (Node c = current.getFirstChild(); c != null; c = c.getNext()) { c = replaceReturnWithBreak(c, current, resultName, labelName); } } return current; }"
                    ],
                    [
                        0.9677867889404297,
                        "public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.GETPROP: Node dest = n.getFirstChild().getNext(); if (dest.getType() == Token.STRING) { if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n || NodeUtil.isExpressionNode(parent)) { addWrite(dest, t, false); } else { addRead(dest, t); } } break; case Token.OBJECTLIT: for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { if (child.getType() != Token.NUMBER) { addWrite(child, t, true); } } break; case Token.CALL: Node callee = n.getFirstChild(); if (callee.getType() == Token.NAME && callee.getString().equals(RenameProperties.RENAME_PROPERTY_FUNCTION_NAME)) { Node argument = callee.getNext(); if (argument.getType() == Token.STRING) { for (String name : DOT_PATTERN.split(argument.getString())) { Property prop = getProperty(name); prop.readCount++; prop.writeCount++; prop.reads = null; prop.writes = null; } } } break; } }"
                    ],
                    [
                        0.9669183492660522,
                        "UnionTypeBuilder addAlternate(JSType alternate) { if (alternate.isNoType()) { return this; } isAllType = isAllType || alternate.isAllType(); boolean isAlternateUnknown = alternate instanceof UnknownType; isNativeUnknownType = isNativeUnknownType || isAlternateUnknown; if (isAlternateUnknown) { areAllUnknownsChecked = areAllUnknownsChecked && alternate.isCheckedUnknownType(); } if (!isAllType && !isNativeUnknownType) { if (alternate instanceof UnionType) { UnionType union = (UnionType) alternate; for (JSType unionAlt : union.getAlternates()) { addAlternate(unionAlt); } } else { if (alternates.size() > MAX_UNION_SIZE) { return this; } Iterator<JSType> it = alternates.iterator(); while (it.hasNext()) { JSType current = it.next(); if (alternate.isUnknownType() || current.isUnknownType() || alternate.isNoResolvedType() || current.isNoResolvedType()) { if (alternate.isEquivalentTo(current)) { return this; } } else { if (alternate.isSubtype(current)) { return this; } else if (current.isSubtype(alternate)) { it.remove(); } } } alternates.add(alternate); result = null; } } else { result = null; } return this; }"
                    ],
                    [
                        0.9663282632827759,
                        "private void handleStmtList(Node node) { Node parent = node.getParent(); if (node.getType() == Token.BLOCK && parent != null && parent.getType() == Token.TRY && NodeUtil.getCatchBlock(parent) == node && !NodeUtil.hasCatchHandler(node)) { return; } Node child = node.getFirstChild(); while (child != null && child.getType() == Token.FUNCTION) { child = child.getNext(); } if (child != null) { createEdge(node, Branch.UNCOND, computeFallThrough(child)); } else { createEdge(node, Branch.UNCOND, computeFollowNode(node, this)); } if (parent != null) { switch(parent.getType()) { case Token.DEFAULT: case Token.CASE: case Token.TRY: break; default: if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) { createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this)); } break; } } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n  /**\n   * Give an expression and a variable. It returns READ, if the first\n   * reference of that variable is a read. It returns KILL, if the first\n   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n   */\n\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    switch (n.getType()) {\n      // Conditionals\n      case Token.OR:\n      case Token.AND:\n        // With a AND/OR the first branch always runs, but the second is\n        // may not.\n      case Token.HOOK:\n        return checkHookBranchReadBeforeKill(\n            n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n      default:\n        // Expressions are evaluated left-right, depth first.\n        for (Node child = n.getFirstChild();\n            child != null; child = child.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testInExpression2() {\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\n        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",\n        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\");\n\n    inFunction(\n        \"var a; (a = 1) || (a = 2)\",\n        \"var a; 1 || 2\");\n\n    inFunction(\"var a; (a = 1) || (a = 2); return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a = 2 : a;\",\n        \"var a; a = 1; a ?     2 : a;\");\n\n    inFunction(\"var a; a = 1; a ? a = 2 : a; return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a : a = 2;\",\n        \"var a; a = 1; a ? a : 2;\");\n\n    inFunction(\"var a; a = 1; a ? a : a =2; return a\");\n\n    inFunction(\n        \"var a; (a = 1) ? a = 2 : a = 3;\",\n        \"var a;      1  ?     2 :     3;\");\n\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\"var a; (a = 1) ? a = 2 : a = 3; return a\");\n  }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError:\n \n#Test method 2:\n```java\n  public void testIssue384b() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +\n            \" return a;\");\n  }\n```\n#Error message from the test method 2: junit.framework.AssertionFailedError:\n \n#Test method 3:\n```java\n  public void testIssue384c() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }\n```\n#Error message from the test method 3: junit.framework.AssertionFailedError:\n \n#Test method 4:\n```java\n  public void testIssue384d() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }\n```\n#Error message from the test method 4: junit.framework.AssertionFailedError:\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.OR:\n    case Token.AND:\n    case Token.HOOK:\n      Node firstChild = n.getFirstChild();\n      Node secondChild = firstChild.getNext();\n      Node thirdChild = n.getLastChild();\n\n      VariableLiveness firstState = isVariableReadBeforeKill(firstChild, variable);\n      if (firstState != VariableLiveness.MAYBE_LIVE) {\n        return firstState;\n      }\n\n      VariableLiveness secondState = isVariableReadBeforeKill(secondChild, variable);\n      if (secondState != VariableLiveness.MAYBE_LIVE) {\n        return secondState;\n      }\n\n      return isVariableReadBeforeKill(thirdChild, variable);\n\n    default:\n      for (Node child = n.getFirstChild();\n           child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n  }\n\n  return VariableLiveness.MAYBE_LIVE;\n}\n",
                            "\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.OR:\n    case Token.AND:\n      if (isVariableReadBeforeKill(n.getFirstChild(), variable) == VariableLiveness.READ) {\n        return VariableLiveness.READ;\n      }\n      return isVariableReadBeforeKill(n.getLastChild(), variable);\n\n    case Token.HOOK:\n      return checkHookBranchReadBeforeKill(\n          n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n    default:\n      for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n  }\n\n  return VariableLiveness.MAYBE_LIVE;\n}\n",
                            "\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(\n            n.getParent().getType() == Token.ASSIGN || \n            NodeUtil.isVarDeclaration(n.getParent()));\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    switch (n.getType()) {\n      // Conditionals\n      case Token.OR:\n      case Token.AND:\n        VariableLiveness leftState = isVariableReadBeforeKill(\n            n.getFirstChild(), variable);\n        if (leftState != VariableLiveness.MAYBE_LIVE) {\n          return leftState;\n        }\n        return isVariableReadBeforeKill(\n            n.getFirstChild().getNext(), variable);\n\n      case Token.HOOK:\n        return checkHookBranchReadBeforeKill(\n            n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n      default:\n        for (Node child = n.getFirstChild();\n            child != null; child = child.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n              return state;\n            }\n          }\n        }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }\n",
                            "\nprivate VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n        if (NodeUtil.isLhs(n, n.getParent())) {\n            Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n            // The expression to which the assignment is made is evaluated before\n            // the RHS is evaluated (normal left to right evaluation) but the KILL\n            // occurs after the RHS is evaluated.\n            Node rhs = n.getNext();\n            VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n            if (state == VariableLiveness.READ) {\n                return state;\n            }\n            return VariableLiveness.KILL;\n        } else {\n            return VariableLiveness.READ;\n        }\n    }\n\n    switch (n.getType()) {\n        // Conditionals\n        case Token.OR:\n        case Token.AND:\n            // With a AND/OR the first branch always runs, but the second is\n            // may not.\n        case Token.HOOK:\n            VariableLiveness firstState = isVariableReadBeforeKill(n.getFirstChild(), variable);\n            if (firstState == VariableLiveness.READ) {\n                return VariableLiveness.READ;\n            }\n            return checkHookBranchReadBeforeKill(\n                n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n        default:\n            // Expressions are evaluated left-right, depth first.\n            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n                    VariableLiveness state = isVariableReadBeforeKill(child, variable);\n                    if (state != VariableLiveness.MAYBE_LIVE) {\n                        return state;\n                    }\n                }\n            }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n}\n",
                            "\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  switch (n.getType()) {\n    // Conditionals\n    case Token.OR:\n    case Token.AND:\n      VariableLiveness firstBranchState = isVariableReadBeforeKill(n.getFirstChild(), variable);\n      if (firstBranchState != VariableLiveness.MAYBE_LIVE) {\n        return firstBranchState;\n      }\n      return isVariableReadBeforeKill(n.getLastChild(), variable);\n        \n    case Token.HOOK:\n      return checkHookBranchReadBeforeKill(\n          n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n    default:\n      // Expressions are evaluated left-right, depth first.\n      for (Node child = n.getFirstChild();\n          child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n  }\n\n  return VariableLiveness.MAYBE_LIVE;\n}\n",
                            "\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        if (n.getParent().getType() == Token.ASSIGN) {\n          Node rhs = n.getNext();\n          VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n          if (state == VariableLiveness.READ) {\n            return state;\n          }\n          return VariableLiveness.KILL;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    switch (n.getType()) {\n      case Token.OR:\n      case Token.AND: \n      case Token.HOOK:\n        VariableLiveness left = isVariableReadBeforeKill(n.getFirstChild(), variable);\n        if (left == VariableLiveness.READ) {\n          return left;\n        }\n        VariableLiveness right = isVariableReadBeforeKill(n.getLastChild(), variable);\n        if (right != VariableLiveness.MAYBE_LIVE) {\n          return right;\n        }\n        return left;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n              return state;\n            }\n          }\n        }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }\n",
                            "\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      // The expression to which the assignment is made is evaluated before\n      // the RHS is evaluated (normal left to right evaluation) but the KILL\n      // occurs after the RHS is evaluated.\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ || state == VariableLiveness.KILL) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  switch (n.getType()) {\n    // Conditionals\n    case Token.OR:\n    case Token.AND:\n      // With an AND/OR the first branch always runs, but the second is\n      // may not.\n    case Token.HOOK:\n      VariableLiveness firstBranchState = isVariableReadBeforeKill(n.getFirstChild(), variable);\n      if (firstBranchState != VariableLiveness.MAYBE_LIVE) {\n        return firstBranchState;\n      }\n      return checkHookBranchReadBeforeKill(\n          n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n    default:\n      // Expressions are evaluated left-right, depth first.\n      for (Node child = n.getFirstChild();\n          child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n        if (state != VariableLiveness.MAYBE_LIVE) {\n          return state;\n        }\n      }\n    }\n  }\n\n  return VariableLiveness.MAYBE_LIVE;\n}\n",
                            "\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  switch (n.getType()) {\n    case Token.OR:\n    case Token.AND:\n      VariableLiveness leftState = isVariableReadBeforeKill(n.getFirstChild(), variable);\n      if (leftState == VariableLiveness.READ) {\n        return VariableLiveness.READ;\n      }\n      return isVariableReadBeforeKill(n.getLastChild(), variable);\n\n    case Token.HOOK:\n      return checkHookBranchReadBeforeKill(\n          n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n    default:\n      for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n  }\n\n  return VariableLiveness.MAYBE_LIVE;\n}\n",
                            "\n  private VariableLiveness isVariableReadBeforeKill(\n      Node n, String variable) {\n\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n      if (NodeUtil.isLhs(n, n.getParent())) {\n        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n        // The expression to which the assignment is made is evaluated before\n        // the RHS is evaluated (normal left to right evaluation) but the KILL\n        // occurs after the RHS is evaluated.\n        Node rhs = n.getNext();\n        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n        if (state == VariableLiveness.READ) {\n          return state;\n        }\n        return VariableLiveness.KILL;\n      } else {\n        return VariableLiveness.READ;\n      }\n    }\n\n    switch (n.getType()) {\n      // Conditionals\n      case Token.OR:\n      case Token.AND:\n        // With an AND/OR, the first branch always runs, but the second might not.\n        {\n          VariableLiveness state = isVariableReadBeforeKill(n.getFirstChild(), variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n          return isVariableReadBeforeKill(n.getLastChild(), variable);\n        }\n\n      case Token.HOOK:\n        return checkHookBranchReadBeforeKill(\n            n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n      default:\n        // Expressions are evaluated left-right, depth first.\n        for (Node child = n.getFirstChild();\n            child != null; child = child.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n              return state;\n            }\n          }\n        }\n    }\n\n    return VariableLiveness.MAYBE_LIVE;\n  }\n",
                            "\nprivate VariableLiveness isVariableReadBeforeKill(\n    Node n, String variable) {\n\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n      // The expression to which the assignment is made is evaluated before\n      // the RHS is evaluated (normal left to right evaluation) but the KILL\n      // occurs after the RHS is evaluated.\n      Node rhs = n.getNext();\n      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n      if (state == VariableLiveness.READ) {\n        return state;\n      }\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  switch (n.getType()) {\n    // Conditionals\n    case Token.OR:\n    case Token.AND:\n      // With a AND/OR the first branch always runs, but the second is\n      // may not.\n    case Token.HOOK:\n      VariableLiveness firstBranchState = isVariableReadBeforeKill(\n          n.getFirstChild(), variable);\n      if (firstBranchState != VariableLiveness.MAYBE_LIVE) {\n        return firstBranchState;\n      }\n      return checkHookBranchReadBeforeKill(\n          n.getFirstChild().getNext(), n.getLastChild(), variable);\n\n    default:\n      // Expressions are evaluated left-right, depth first.\n      for (Node child = n.getFirstChild();\n          child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n          VariableLiveness state = isVariableReadBeforeKill(child, variable);\n          if (state != VariableLiveness.MAYBE_LIVE) {\n            return state;\n          }\n        }\n      }\n  }\n\n  return VariableLiveness.MAYBE_LIVE;\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testInExpression2": {
                "path": "test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java",
                "function_name": "testInExpression2",
                "src": "  public void testInExpression2() {\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\n        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",\n        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\");\n\n    inFunction(\n        \"var a; (a = 1) || (a = 2)\",\n        \"var a; 1 || 2\");\n\n    inFunction(\"var a; (a = 1) || (a = 2); return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a = 2 : a;\",\n        \"var a; a = 1; a ?     2 : a;\");\n\n    inFunction(\"var a; a = 1; a ? a = 2 : a; return a\");\n\n    inFunction(\n        \"var a; a = 1; a ? a : a = 2;\",\n        \"var a; a = 1; a ? a : 2;\");\n\n    inFunction(\"var a; a = 1; a ? a : a =2; return a\");\n\n    inFunction(\n        \"var a; (a = 1) ? a = 2 : a = 3;\",\n        \"var a;      1  ?     2 :     3;\");\n\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\"var a; (a = 1) ? a = 2 : a = 3; return a\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a;a=1;if(2||(a=3)||a);}\nResult: function FUNC(param1,param2){var a;a=1;if((a=2)||(a=3)||a);}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                EXPR_RESULT 1 [sourcename: expected0]\n                    ASSIGN 1 [sourcename: expected0]\n                        NAME a 1 [sourcename: expected0]\n                        NUMBER 1.0 1 [sourcename: expected0]\n                IF 1 [sourcename: expected0]\n                    OR 1 [sourcename: expected0]\n                        NUMBER 2.0 1 [sourcename: expected0] [parenthesized: true]\n                        OR 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0] [parenthesized: true]\n                                NAME a 1 [sourcename: expected0]\n                                NUMBER 3.0 1 [sourcename: expected0]\n                            NAME a 1 [sourcename: expected0] [parenthesized: true]\n                    BLOCK 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                EXPR_RESULT 1 [sourcename: testcode]\n                    ASSIGN 1 [sourcename: testcode]\n                        NAME a 1 [sourcename: testcode]\n                        NUMBER 1.0 1 [sourcename: testcode]\n                IF 1 [sourcename: testcode]\n                    OR 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode] [parenthesized: true]\n                            NAME a 1 [sourcename: testcode]\n                            NUMBER 2.0 1 [sourcename: testcode]\n                        OR 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode] [parenthesized: true]\n                                NAME a 1 [sourcename: testcode]\n                                NUMBER 3.0 1 [sourcename: testcode]\n                            NAME a 1 [sourcename: testcode] [parenthesized: true]\n                    BLOCK 1 [sourcename: testcode]\n\n\nSubtree1: NUMBER 2.0 1 [sourcename: expected0] [parenthesized: true]\n\n\nSubtree2: ASSIGN 1 [sourcename: testcode] [parenthesized: true]\n    NAME a 1 [sourcename: testcode]\n    NUMBER 2.0 1 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testInExpression2(DeadAssignmentsEliminationTest.java:459)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a;a=1;if(2||(a=3)||a);}\nResult: function FUNC(param1,param2){var a;a=1;if((a=2)||(a=3)||a);}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                EXPR_RESULT 1 [sourcename: expected0]\n                    ASSIGN 1 [sourcename: expected0]\n                        NAME a 1 [sourcename: expected0]\n                        NUMBER 1.0 1 [sourcename: expected0]\n                IF 1 [sourcename: expected0]\n                    OR 1 [sourcename: expected0]\n                        NUMBER 2.0 1 [sourcename: expected0] [parenthesized: true]\n                        OR 1 [sourcename: expected0]\n                            ASSIGN 1 [sourcename: expected0] [parenthesized: true]\n                                NAME a 1 [sourcename: expected0]\n                                NUMBER 3.0 1 [sourcename: expected0]\n                            NAME a 1 [sourcename: expected0] [parenthesized: true]\n                    BLOCK 1 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                EXPR_RESULT 1 [sourcename: testcode]\n                    ASSIGN 1 [sourcename: testcode]\n                        NAME a 1 [sourcename: testcode]\n                        NUMBER 1.0 1 [sourcename: testcode]\n                IF 1 [sourcename: testcode]\n                    OR 1 [sourcename: testcode]\n                        ASSIGN 1 [sourcename: testcode] [parenthesized: true]\n                            NAME a 1 [sourcename: testcode]\n                            NUMBER 2.0 1 [sourcename: testcode]\n                        OR 1 [sourcename: testcode]\n                            ASSIGN 1 [sourcename: testcode] [parenthesized: true]\n                                NAME a 1 [sourcename: testcode]\n                                NUMBER 3.0 1 [sourcename: testcode]\n                            NAME a 1 [sourcename: testcode] [parenthesized: true]\n                    BLOCK 1 [sourcename: testcode]\n\n\nSubtree1: NUMBER 2.0 1 [sourcename: expected0] [parenthesized: true]\n\n\nSubtree2: ASSIGN 1 [sourcename: testcode] [parenthesized: true]\n    NAME a 1 [sourcename: testcode]\n    NUMBER 2.0 1 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testInExpression2(DeadAssignmentsEliminationTest.java:459)  inFunction(        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\");"
            },
            "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue384b": {
                "path": "test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java",
                "function_name": "testIssue384b",
                "src": "  public void testIssue384b() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +\n            \" return a;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;f(b=true)||f(b=false)?a=b:a=null;return a}\nResult: function FUNC(param1,param2){var a,b;f(true)||f(b=false)?a=b:a=null;return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    HOOK 2 [sourcename: expected0]\n                        OR 2 [sourcename: expected0] [parenthesized: true]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NULL 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    HOOK 2 [sourcename: testcode]\n                        OR 2 [sourcename: testcode] [parenthesized: true]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NULL 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384b(DeadAssignmentsEliminationTest.java:501)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;f(b=true)||f(b=false)?a=b:a=null;return a}\nResult: function FUNC(param1,param2){var a,b;f(true)||f(b=false)?a=b:a=null;return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    HOOK 2 [sourcename: expected0]\n                        OR 2 [sourcename: expected0] [parenthesized: true]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NULL 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    HOOK 2 [sourcename: testcode]\n                        OR 2 [sourcename: testcode] [parenthesized: true]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NULL 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)  inFunction(src, src);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384b(DeadAssignmentsEliminationTest.java:501)  inFunction(            \" var a, b;\\n\" +            \" (f(b = true) || f(b = false)) ? (a = b) : (a = null);\\n\" +            \" return a;\");"
            },
            "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue384c": {
                "path": "test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java",
                "function_name": "testIssue384c",
                "src": "  public void testIssue384c() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;(a?f(b=true):f(b=false))&&(a=b);return a}\nResult: function FUNC(param1,param2){var a,b;(a?f(true):f(b=false))&&(a=b);return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    AND 2 [sourcename: expected0]\n                        HOOK 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    AND 2 [sourcename: testcode]\n                        HOOK 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384c(DeadAssignmentsEliminationTest.java:508)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;(a?f(b=true):f(b=false))&&(a=b);return a}\nResult: function FUNC(param1,param2){var a,b;(a?f(true):f(b=false))&&(a=b);return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    AND 2 [sourcename: expected0]\n                        HOOK 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    AND 2 [sourcename: testcode]\n                        HOOK 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)  inFunction(src, src);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384c(DeadAssignmentsEliminationTest.java:508)  inFunction(            \" var a, b;\\n\" +            \" (a ? f(b = true) : f(b = false)) && (a = b);\\n\" +            \" return a;\");"
            },
            "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testIssue384d": {
                "path": "test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java",
                "function_name": "testIssue384d",
                "src": "  public void testIssue384d() {\n    inFunction(\n            \" var a, b;\\n\" +\n            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +\n            \" return a;\");\n  }",
                "error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;(f(b=true)||f(b=false))&&(a=b);return a}\nResult: function FUNC(param1,param2){var a,b;(f(true)||f(b=false))&&(a=b);return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    AND 2 [sourcename: expected0]\n                        OR 2 [sourcename: expected0] [parenthesized: true]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    AND 2 [sourcename: testcode]\n                        OR 2 [sourcename: testcode] [parenthesized: true]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertNull(Assert.java:277)\n\tat junit.framework.TestCase.assertNull(TestCase.java:447)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384d(DeadAssignmentsEliminationTest.java:515)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: \nExpected: function FUNC(param1,param2){var a,b;(f(b=true)||f(b=false))&&(a=b);return a}\nResult: function FUNC(param1,param2){var a,b;(f(true)||f(b=false))&&(a=b);return a}\nNode tree inequality:\nTree1:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: expected0] [synthetic: 1]\n        FUNCTION  1 [sourcename: expected0]\n            NAME FUNC 1 [sourcename: expected0]\n            LP 1 [sourcename: expected0]\n                NAME param1 1 [sourcename: expected0]\n                NAME param2 1 [sourcename: expected0]\n            BLOCK 1 [sourcename: expected0]\n                VAR 1 [sourcename: expected0]\n                    NAME a 1 [sourcename: expected0]\n                    NAME b 1 [sourcename: expected0]\n                EXPR_RESULT 2 [sourcename: expected0]\n                    AND 2 [sourcename: expected0]\n                        OR 2 [sourcename: expected0] [parenthesized: true]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    TRUE 2 [sourcename: expected0]\n                            CALL 2 [sourcename: expected0] [free_call: 1]\n                                NAME f 2 [sourcename: expected0]\n                                ASSIGN 2 [sourcename: expected0]\n                                    NAME b 2 [sourcename: expected0]\n                                    FALSE 2 [sourcename: expected0]\n                        ASSIGN 2 [sourcename: expected0] [parenthesized: true]\n                            NAME a 2 [sourcename: expected0]\n                            NAME b 2 [sourcename: expected0]\n                RETURN 3 [sourcename: expected0]\n                    NAME a 3 [sourcename: expected0]\n\n\nTree2:\nBLOCK [synthetic: 1]\n    SCRIPT 1 [sourcename: testcode] [synthetic: 1]\n        FUNCTION  1 [sourcename: testcode]\n            NAME FUNC 1 [sourcename: testcode]\n            LP 1 [sourcename: testcode]\n                NAME param1 1 [sourcename: testcode]\n                NAME param2 1 [sourcename: testcode]\n            BLOCK 1 [sourcename: testcode]\n                VAR 1 [sourcename: testcode]\n                    NAME a 1 [sourcename: testcode]\n                    NAME b 1 [sourcename: testcode]\n                EXPR_RESULT 2 [sourcename: testcode]\n                    AND 2 [sourcename: testcode]\n                        OR 2 [sourcename: testcode] [parenthesized: true]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                TRUE 2 [sourcename: testcode]\n                            CALL 2 [sourcename: testcode] [free_call: 1]\n                                NAME f 2 [sourcename: testcode]\n                                ASSIGN 2 [sourcename: testcode]\n                                    NAME b 2 [sourcename: testcode]\n                                    FALSE 2 [sourcename: testcode]\n                        ASSIGN 2 [sourcename: testcode] [parenthesized: true]\n                            NAME a 2 [sourcename: testcode]\n                            NAME b 2 [sourcename: testcode]\n                RETURN 3 [sourcename: testcode]\n                    NAME a 3 [sourcename: testcode]\n\n\nSubtree1: ASSIGN 2 [sourcename: expected0]\n    NAME b 2 [sourcename: expected0]\n    TRUE 2 [sourcename: expected0]\n\n\nSubtree2: TRUE 2 [sourcename: testcode]\n\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)  assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +            \"\\nResult: \" + compiler.toSource(mainRoot) +            \"\\n\" + explanation, explanation);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)  test(\"function FUNC(param1, param2){\" + src + \"}\",         \"function FUNC(param1, param2){\" + expected + \"}\");\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:341)  inFunction(src, src);\n\tat com.google.javascript.jscomp.DeadAssignmentsEliminationTest.testIssue384d(DeadAssignmentsEliminationTest.java:515)  inFunction(            \" var a, b;\\n\" +            \" (f(b = true) || f(b = false)) && (a = b);\\n\" +            \" return a;\");"
            }
        },
        "evaluation_done": true
    }
}