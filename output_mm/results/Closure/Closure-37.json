{
    "Closure-37": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/com/google/javascript/jscomp/NodeTraversal.java",
                "start_loc": 510,
                "end_loc": 545,
                "buggy_function": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock());\n    traverseBranch(body, n);\n\n    popScope();\n  }\n",
                "fixed_function": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }\n",
                "comment": "  /**\n   * Traverses a function.\n   */\n",
                "normalized_body": [
                    "private void traverseFunction(Node n, Node parent) { Preconditions.checkState(n.getChildCount() == 3); Preconditions.checkState(n.isFunction()); final Node fnName = n.getFirstChild(); boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n); if (!isFunctionExpression) { traverseBranch(fnName, n); } curNode = n; pushScope(n); if (isFunctionExpression) { traverseBranch(fnName, n); } final Node args = fnName.getNext(); final Node body = args.getNext(); traverseBranch(args, n); Preconditions.checkState(body.getNext() == null && body.isBlock()); traverseBranch(body, n); popScope(); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private void traverseFunction(Node n, Node parent) { Preconditions.checkState(n.getChildCount() == 3); Preconditions.checkState(n.isFunction()); final Node fnName = n.getFirstChild(); boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n); if (!isFunctionExpression) { traverseBranch(fnName, n); } curNode = n; pushScope(n); if (isFunctionExpression) { traverseBranch(fnName, n); } final Node args = fnName.getNext(); final Node body = args.getNext(); traverseBranch(args, n); Preconditions.checkState(body.getNext() == null && body.isBlock()); traverseBranch(body, n); popScope(); }"
                    ],
                    [
                        0.9901807308197021,
                        "private void transformPotentiallyUnwrappedBlock(JsonML element, Node parent) throws JsonMLException { if (element.getType() == TagType.EmptyStmt || element.getType() == TagType.Empty) { nodeIndex++; Node block = IR.block(); parent.addChildToBack(block); block.putBooleanProp(Node.EMPTY_BLOCK, true); } else if (element.getType() != TagType.BlockStmt) { Node block = IR.block(); parent.addChildToBack(block); boolean state = insertExprResultState; insertExprResultState = true; transformElement(element, block); insertExprResultState = state; } else { nodeIndex++; transformBlock(element, parent); } }"
                    ],
                    [
                        0.9870973229408264,
                        "public void testRemoveDeclaration1() { Name n = new Name(\\\"a\\\", null, false); Ref set1 = createNodelessRef(Ref.Type.SET_FROM_GLOBAL); Ref set2 = createNodelessRef(Ref.Type.SET_FROM_GLOBAL); n.addRef(set1); n.addRef(set2); assertEquals(set1, n.getDeclaration()); assertEquals(2, n.globalSets); assertEquals(2, n.getRefs().size()); n.removeRef(set1); assertEquals(set2, n.getDeclaration()); assertEquals(1, n.globalSets); assertEquals(1, n.getRefs().size()); }"
                    ],
                    [
                        0.9864732027053833,
                        "private void transformIfStmt(JsonML element, Node parent) throws JsonMLException { Preconditions.checkState(insertExprResultState == true); insertExprResultState = false; Node node = createNode(Token.IF, element); parent.addChildToBack(node); JsonML child = element.getChild(0); transformElement(child, node); child = element.getChild(1); transformPotentiallyUnwrappedBlock(child, node); child = element.getChild(2); if (child.getType() != TagType.EmptyStmt && child.getType() != TagType.Empty) { transformPotentiallyUnwrappedBlock(child, node); } else { nodeIndex++; } insertExprResultState = true; }"
                    ],
                    [
                        0.9857865571975708,
                        "private void moveNamedFunctions(Node functionBody) { Preconditions.checkState(functionBody.getParent().isFunction()); Node previous = null; Node current = functionBody.getFirstChild(); while (current != null && NodeUtil.isFunctionDeclaration(current)) { previous = current; current = current.getNext(); } Node insertAfter = previous; while (current != null) { Node next = current.getNext(); if (NodeUtil.isFunctionDeclaration(current)) { Preconditions.checkNotNull(previous); functionBody.removeChildAfter(previous); insertAfter = addToFront(functionBody, current, insertAfter); reportCodeChange(\\\"Move function declaration not at top of function\\\"); } else { previous = current; } current = next; } }"
                    ],
                    [
                        0.9851365089416504,
                        "private void dcpLoadAsNumber(int dcp_register) { cfw.addALoad(dcp_register); cfw.add(ByteCode.GETSTATIC, \\\"java/lang/Void\\\", \\\"TYPE\\\", \\\"Ljava/lang/Class;\\\"); int isNumberLabel = cfw.acquireLabel(); cfw.add(ByteCode.IF_ACMPEQ, isNumberLabel); short stack = cfw.getStackTop(); cfw.addALoad(dcp_register); addObjectToDouble(); int beyond = cfw.acquireLabel(); cfw.add(ByteCode.GOTO, beyond); cfw.markLabel(isNumberLabel, stack); cfw.addDLoad(dcp_register + 1); cfw.markLabel(beyond); }"
                    ],
                    [
                        0.9849338531494141,
                        "private void replacePrototypeMemberDeclaration(PrototypeMemberDeclaration declar) { Node assignment = declar.node.getFirstChild(); Node lhs = assignment.getFirstChild(); Node name = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), prototypeAlias + \\\".\\\" + declar.memberName, declar.node, declar.memberName); Node accessNode = declar.lhs.getFirstChild().getFirstChild(); Object originalName = accessNode.getProp(Node.ORIGINALNAME_PROP); String className = \\\"?\\\"; if (originalName != null) { className = originalName.toString(); } NodeUtil.setDebugInformation(name.getFirstChild(), lhs, className + \\\".prototype\\\"); assignment.replaceChild(lhs, name); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/com/google/javascript/jscomp/parsing/IRFactory.java",
                "start_loc": 609,
                "end_loc": 673,
                "buggy_function": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n",
                "fixed_function": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      if (!bodyNode.isBlock()) {\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n        Preconditions.checkState(config.isIdeMode);\n        bodyNode = IR.block();\n      }\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error(\\\"unnamed function statement\\\", sourceName, functionNode.getLineno(), \\\"\\\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } name = new Name(); name.setIdentifier(\\\"\\\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); maybeSetLengthFrom(newName, name); } node.addChildToBack(newName); Node lp = newNode(Token.PARAM_LIST); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "@Override Node processFunctionNode(FunctionNode functionNode) { Name name = functionNode.getFunctionName(); Boolean isUnnamedFunction = false; if (name == null) { int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error(\\\"unnamed function statement\\\", sourceName, functionNode.getLineno(), \\\"\\\", 0); return newNode(Token.EXPR_RESULT, Node.newNumber(0)); } name = new Name(); name.setIdentifier(\\\"\\\"); isUnnamedFunction = true; } Node node = newNode(Token.FUNCTION); Node newName = transform(name); if (isUnnamedFunction) { newName.setLineno(functionNode.getLineno()); int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp(); newName.setCharno(position2charno(lpColumn)); maybeSetLengthFrom(newName, name); } node.addChildToBack(newName); Node lp = newNode(Token.PARAM_LIST); Name fnName = functionNode.getFunctionName(); if (fnName != null) { lp.setLineno(fnName.getLineno()); } else { lp.setLineno(functionNode.getLineno()); } int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition(); lp.setCharno(position2charno(lparenCharno)); for (AstNode param : functionNode.getParams()) { lp.addChildToBack(transform(param)); } node.addChildToBack(lp); Node bodyNode = transform(functionNode.getBody()); parseDirectives(bodyNode); node.addChildToBack(bodyNode); return node; }"
                    ],
                    [
                        0.993320107460022,
                        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition != null && explicitNode != null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (candidateDefinition.isExprResult() && !candidateDefinition.getFirstChild().isQualifiedName()) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.isName()) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = IR.var(nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild(candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode); } } if (explicitNode != null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }"
                    ],
                    [
                        0.9932376146316528,
                        "boolean destructuringObject(ObjectLiteral node, int variableType, String tempName, Node parent, List<String> destructuringNames) { boolean empty = true; int setOp = variableType == Token.CONST ? Token.SETCONST : Token.SETNAME; for (ObjectProperty prop : node.getElements()) { int lineno = 0; if (ts != null) { lineno = ts.lineno; } AstNode id = prop.getLeft(); Node rightElem = null; if (id instanceof Name) { Node s = Node.newString(((Name) id).getIdentifier()); rightElem = new Node(Token.GETPROP, createName(tempName), s); } else if (id instanceof StringLiteral) { Node s = Node.newString(((StringLiteral) id).getValue()); rightElem = new Node(Token.GETPROP, createName(tempName), s); } else if (id instanceof NumberLiteral) { Node s = createNumber((int) ((NumberLiteral) id).getNumber()); rightElem = new Node(Token.GETELEM, createName(tempName), s); } else { throw codeBug(); } rightElem.setLineno(lineno); AstNode value = prop.getRight(); if (value.getType() == Token.NAME) { String name = ((Name) value).getIdentifier(); parent.addChildToBack(new Node(setOp, createName(Token.BINDNAME, name, null), rightElem)); if (variableType != -1) { defineSymbol(variableType, name, true); destructuringNames.add(name); } } else { parent.addChildToBack(destructuringAssignmentHelper(variableType, value, rightElem, currentScriptOrFn.getNextTempName())); } empty = false; } return empty; }"
                    ],
                    [
                        0.9930298328399658,
                        "private Node createTryCatchFinally(Node tryBlock, Node catchBlocks, Node finallyBlock, int lineno) { boolean hasFinally = (finallyBlock != null) && (finallyBlock.getType() != Token.BLOCK || finallyBlock.hasChildren()); if (tryBlock.getType() == Token.BLOCK && !tryBlock.hasChildren() && !hasFinally) { return tryBlock; } boolean hasCatch = catchBlocks.hasChildren(); if (!hasFinally && !hasCatch) { return tryBlock; } Node handlerBlock = new Node(Token.LOCAL_BLOCK); Jump pn = new Jump(Token.TRY, tryBlock, lineno); pn.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock); if (hasCatch) { Node endCatch = Node.newTarget(); pn.addChildToBack(makeJump(Token.GOTO, endCatch)); Node catchTarget = Node.newTarget(); pn.target = catchTarget; pn.addChildToBack(catchTarget); Node catchScopeBlock = new Node(Token.LOCAL_BLOCK); Node cb = catchBlocks.getFirstChild(); boolean hasDefault = false; int scopeIndex = 0; while (cb != null) { int catchLineNo = cb.getLineno(); Node name = cb.getFirstChild(); Node cond = name.getNext(); Node catchStatement = cond.getNext(); cb.removeChild(name); cb.removeChild(cond); cb.removeChild(catchStatement); catchStatement.addChildToBack(new Node(Token.LEAVEWITH)); catchStatement.addChildToBack(makeJump(Token.GOTO, endCatch)); Node condStmt; if (cond.getType() == Token.EMPTY) { condStmt = catchStatement; hasDefault = true; } else { condStmt = createIf(cond, catchStatement, null, catchLineNo); } Node catchScope = new Node(Token.CATCH_SCOPE, name, createUseLocal(handlerBlock)); catchScope.putProp(Node.LOCAL_BLOCK_PROP, catchScopeBlock); catchScope.putIntProp(Node.CATCH_SCOPE_PROP, scopeIndex); catchScopeBlock.addChildToBack(catchScope); catchScopeBlock.addChildToBack(createWith(createUseLocal(catchScopeBlock), condStmt, catchLineNo)); cb = cb.getNext(); ++scopeIndex; } pn.addChildToBack(catchScopeBlock); if (!hasDefault) { Node rethrow = new Node(Token.RETHROW); rethrow.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock); pn.addChildToBack(rethrow); } pn.addChildToBack(endCatch); } if (hasFinally) { Node finallyTarget = Node.newTarget(); pn.setFinally(finallyTarget); pn.addChildToBack(makeJump(Token.JSR, finallyTarget)); Node finallyEnd = Node.newTarget(); pn.addChildToBack(makeJump(Token.GOTO, finallyEnd)); pn.addChildToBack(finallyTarget); Node fBlock = new Node(Token.FINALLY, finallyBlock); fBlock.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock); pn.addChildToBack(fBlock); pn.addChildToBack(finallyEnd); } handlerBlock.addChildToBack(pn); return handlerBlock; }"
                    ],
                    [
                        0.992518961429596,
                        "String getName(Node node) { switch(node.getType()) { case Token.FUNCTION: Node functionNameNode = node.getFirstChild(); return functionNameNode.getString(); case Token.GETPROP: Node lhsOfDot = node.getFirstChild(); Node rhsOfDot = lhsOfDot.getNext(); String lhsOfDotName = getName(lhsOfDot); String rhsOfDotName = getName(rhsOfDot); if (\\\"prototype\\\".equals(rhsOfDotName)) { return lhsOfDotName + delimiter; } else { return lhsOfDotName + delimiter + rhsOfDotName; } case Token.GETELEM: Node outsideBrackets = node.getFirstChild(); Node insideBrackets = outsideBrackets.getNext(); String nameOutsideBrackets = getName(outsideBrackets); String nameInsideBrackets = getName(insideBrackets); if (\\\"prototype\\\".equals(nameInsideBrackets)) { return nameOutsideBrackets + delimiter; } else { return nameOutsideBrackets + delimiter + nameInsideBrackets; } case Token.NAME: return node.getString(); case Token.STRING: return TokenStream.isJSIdentifier(node.getString()) ? node.getString() : (\\\"__\\\" + nextUniqueInt++); case Token.NUMBER: return NodeUtil.getStringValue(node); case Token.THIS: return \\\"this\\\"; case Token.CALL: return getName(node.getFirstChild()); default: StringBuilder sb = new StringBuilder(); for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { if (sb.length() > 0) { sb.append(delimiter); } sb.append(getName(child)); } return sb.toString(); } }"
                    ],
                    [
                        0.9922811388969421,
                        "private Node transformXmlLiteral(XmlLiteral node) { Node pnXML = new Node(Token.NEW, node.getLineno()); List<XmlFragment> frags = node.getFragments(); XmlString first = (XmlString) frags.get(0); boolean anon = first.getXml().trim().startsWith(\\\"<>\\\"); pnXML.addChildToBack(createName(anon ? \\\"XMLList\\\" : \\\"XML\\\")); Node pn = null; for (XmlFragment frag : frags) { if (frag instanceof XmlString) { String xml = ((XmlString) frag).getXml(); decompiler.addName(xml); if (pn == null) { pn = createString(xml); } else { pn = createBinary(Token.ADD, pn, createString(xml)); } } else { XmlExpression xexpr = (XmlExpression) frag; boolean isXmlAttr = xexpr.isXmlAttribute(); Node expr; decompiler.addToken(Token.LC); if (xexpr.getExpression() instanceof EmptyExpression) { expr = createString(\\\"\\\"); } else { expr = transform(xexpr.getExpression()); } decompiler.addToken(Token.RC); if (isXmlAttr) { expr = createUnary(Token.ESCXMLATTR, expr); Node prepend = createBinary(Token.ADD, createString(\\\"\\\\\"\\\"), expr); expr = createBinary(Token.ADD, prepend, createString(\\\"\\\\\"\\\")); } else { expr = createUnary(Token.ESCXMLTEXT, expr); } pn = createBinary(Token.ADD, pn, expr); } } pnXML.addChildToBack(pn); return pnXML; }"
                    ],
                    [
                        0.9920568466186523,
                        "private void replaceJqueryExtendCall(Node n) { Node callTarget = n.getFirstChild(); Node objectToExtend = callTarget.getNext(); Node extendArg = objectToExtend.getNext(); if (extendArg == null) { extendArg = objectToExtend; objectToExtend = callTarget.getFirstChild(); } if (!extendArg.hasChildren()) return; Node fncBlock = IR.block().srcref(n); while (extendArg.hasChildren()) { Node currentProp = extendArg.removeFirstChild(); Node propValue = currentProp.removeFirstChild(); Node newProp; if (currentProp.isQuotedString()) { newProp = IR.getelem(objectToExtend.cloneTree(), currentProp).srcref(currentProp); } else { newProp = IR.getprop(objectToExtend.cloneTree(), currentProp).srcref(currentProp); } Node assignNode = IR.assign(newProp, propValue).srcref(currentProp); fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp)); } Node targetVal; if (\\\"jQuery.prototype\\\".equals(objectToExtend.getQualifiedName())) { targetVal = objectToExtend.getFirstChild().cloneTree(); } else { targetVal = objectToExtend.cloneTree(); } fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal)); Node fnc = IR.function(IR.name(\\\"\\\").srcref(n), IR.paramList().srcref(n), fncBlock); n.replaceChild(callTarget, fnc); n.putBooleanProp(Node.FREE_CALL, true); while (fnc.getNext() != null) { n.removeChildAfter(fnc); } compiler.reportCodeChange(); }"
                    ]
                ],
                "directly_related_tests": [
                    "com.google.javascript.jscomp.IntegrationTest::testIncompleteFunction"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    );\n  }\n```\n#Error message: java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:642)  throw new RuntimeException(exception[0]);\n\tat com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:587)  return runCallable(callable, useThreads, options.tracer.isOn());\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:569)  return runInCompilerThread(new Callable<Result>() {      @Override      public Result call() throws Exception {        compileInternal();        return getResult();      }    });\n\tat com.google.javascript.jscomp.Compiler.compileModules(Compiler.java:560)  return compile();\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:542)  return compileModules(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSModule>newArrayList(modules),        options);\n\tat com.google.javascript.jscomp.IntegrationTest.compile(IntegrationTest.java:2080)  compiler.compile(        externs, CompilerTestCase.createModuleChain(original), options);\n\tat com.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:2041)  Compiler compiler = compile(options, original);\n\tat com.google.javascript.jscomp.IntegrationTest.testIncompleteFunction(IntegrationTest.java:1945)  test(options,        new String[] { \"var foo = {bar: function(e) }\" },        new String[] { \"var foo = {bar: function(e){}};\" },        warnings    );\nCaused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:540)  Preconditions.checkState(body.getNext() == null &&            body.isBlock());\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:489)  traverseFunction(n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:277)  traverseBranch(root, null);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:455)  t.traverse(root);\n\tat com.google.javascript.jscomp.PrepareAst.process(PrepareAst.java:70)  NodeTraversal.traverse(            compiler, root, new PrepareAnnotations(compiler));\n\tat com.google.javascript.jscomp.Compiler.prepareAst(Compiler.java:1835)  pass.process(null, root);\n\tat com.google.javascript.jscomp.JsAst.parse(JsAst.java:99)  compiler.prepareAst(root);\n\tat com.google.javascript.jscomp.JsAst.getAstRoot(JsAst.java:52)  parse(compiler);\n\tat com.google.javascript.jscomp.CompilerInput.getAstRoot(CompilerInput.java:119)  Node root = ast.getAstRoot(compiler);\n\tat com.google.javascript.jscomp.Compiler.parseInputs(Compiler.java:1302)  Node n = input.getAstRoot(this);\n\tat com.google.javascript.jscomp.Compiler.parse(Compiler.java:696)  parseInputs();\n\tat com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:650)  parse();\n\tat com.google.javascript.jscomp.Compiler.access$000(Compiler.java:71)  public class Compiler extends AbstractCompiler {  static final String SINGLETON_MODULE_NAME = \"[singleton]\";  static final DiagnosticType MODULE_DEPENDENCY_ERROR =      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",          \"Bad dependency: {0} -> {1}. \"              + \"Modules must be listed in dependency order.\");  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(      \"JSC_MISSING_ENTRY_ERROR\",      \"required entry point \\\"{0}\\\" never provided\");  CompilerOptions options = null;  private PassConfig passes = null;  // The externs inputs  private List<CompilerInput> externs;  // The JS source modules  private List<JSModule> modules;  // The graph of the JS source modules. Must be null if there are less than  // 2 modules, because we use this as a signal for which passes to run.  private JSModuleGraph moduleGraph;  // The JS source inputs  private List<CompilerInput> inputs;  // error manager to which error management is delegated  private ErrorManager errorManager;  // Warnings guard for filtering warnings.  private WarningsGuard warningsGuard;  // Parse tree root nodes  Node externsRoot;  Node jsRoot;  Node externAndJsRoot;  private Map<InputId, CompilerInput> inputsById;  /** The source code map */  private SourceMap sourceMap;  /** The externs created from the exports.  */  private String externExports = null;  /**   * Ids for function inlining so that each declared name remains   * unique.   */  private int uniqueNameId = 0;  /** Whether to use threads. */  private boolean useThreads = true;  /**   * Whether to assume there are references to the RegExp Global object   * properties.   */  private boolean hasRegExpGlobalReferences = true;  /** The function information map */  private FunctionInformationMap functionInformationMap;  /** Debugging information */  private final StringBuilder debugLog = new StringBuilder();  /** Detects Google-specific coding conventions. */  CodingConvention defaultCodingConvention = new ClosureCodingConvention();  private JSTypeRegistry typeRegistry;  private Config parserConfig = null;  private ReverseAbstractInterpreter abstractInterpreter;  private TypeValidator typeValidator;  public PerformanceTracker tracker;  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =      RhinoErrorReporter.forOldRhino(this);  // This error reporter gets the messages from the current Rhino parser.  private final ErrorReporter defaultErrorReporter =      RhinoErrorReporter.forNewRhino(this);  /** Error strings used for reporting JSErrors */  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(      \"JSC_OPTIMIZE_LOOP_ERROR\",      \"Exceeded max number of optimization iterations: {0}\");  public static final DiagnosticType MOTION_ITERATIONS_ERROR =      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",          \"Exceeded max number of code motion iterations: {0}\");  private static final long COMPILER_STACK_SIZE = 1048576L;  /**   * Logger for the whole com.google.javascript.jscomp domain -   * setting configuration for this logger affects all loggers   *  in other classes within the compiler.   */  private static final Logger logger =      Logger.getLogger(\"com.google.javascript.jscomp\");  private final PrintStream outStream;  private GlobalVarReferenceMap globalRefMap = null;  private volatile double progress = 0.0;  /**   * Creates a Compiler that reports errors and warnings to its logger.   */  public Compiler() {    this((PrintStream) null);  }  /**   * Creates n Compiler that reports errors and warnings to an output   * stream.   */  public Compiler(PrintStream stream) {    addChangeHandler(recentChange);    outStream = stream;  }  /**   * Creates a Compiler that uses a custom error manager.   */  public Compiler(ErrorManager errorManager) {    this();    setErrorManager(errorManager);  }  /**   * Sets the error manager.   *   * @param errorManager the error manager, it cannot be {@code null}   */  public void setErrorManager(ErrorManager errorManager) {    Preconditions.checkNotNull(        errorManager, \"the error manager cannot be null\");    this.errorManager = errorManager;  }  /**   * Creates a message formatter instance corresponding to the value of   * {@link CompilerOptions}.   */  private MessageFormatter createMessageFormatter() {    boolean colorize = options.shouldColorizeErrorOutput();    return options.errorFormat.toFormatter(this, colorize);  }  /**   * Initialize the compiler options. Only necessary if you're not doing   * a normal compile() job.   */  public void initOptions(CompilerOptions options) {    this.options = options;    if (errorManager == null) {      if (outStream == null) {        setErrorManager(            new LoggerErrorManager(createMessageFormatter(), logger));      } else {        PrintStreamErrorManager printer =            new PrintStreamErrorManager(createMessageFormatter(), outStream);        printer.setSummaryDetailLevel(options.summaryDetailLevel);        setErrorManager(printer);      }    }    // DiagnosticGroups override the plain checkTypes option.    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {      options.checkTypes = true;    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {      options.checkTypes = false;    } else if (!options.checkTypes) {      // If DiagnosticGroups did not override the plain checkTypes      // option, and checkTypes is enabled, then turn off the      // parser type warnings.      options.setWarningLevel(          DiagnosticGroup.forType(              RhinoErrorReporter.TYPE_PARSE_ERROR),          CheckLevel.OFF);    }    if (options.checkGlobalThisLevel.isOn() &&        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {      options.setWarningLevel(          DiagnosticGroups.GLOBAL_THIS,          options.checkGlobalThisLevel);    }    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {      options.setWarningLevel(          DiagnosticGroups.ES5_STRICT,          CheckLevel.ERROR);    }    // Initialize the warnings guard.    List<WarningsGuard> guards = Lists.newArrayList();    guards.add(        new SuppressDocWarningsGuard(            getDiagnosticGroups().getRegisteredGroups()));    guards.add(options.getWarningsGuard());    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);    // All passes must run the variable check. This synthesizes    // variables later so that the compiler doesn't crash. It also    // checks the externs file for validity. If you don't want to warn    // about missing variable declarations, we shut that specific    // error off.    if (!options.checkSymbols &&        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));    }    this.warningsGuard = composedGuards;  }  /**   * Initializes the instance state needed for a compile job.   */  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,      CompilerOptions options) {    init(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSSourceFile>newArrayList(inputs), options);  }  /**   * Initializes the instance state needed for a compile job.   */  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,      CompilerOptions options) {    JSModule module = new JSModule(SINGLETON_MODULE_NAME);    for (JSSourceFile input : inputs) {      module.add(input);    }    initModules(externs, Lists.newArrayList(module), options);  }  /**   * Initializes the instance state needed for a compile job if the sources   * are in modules.   */  public void init(JSSourceFile[] externs, JSModule[] modules,      CompilerOptions options) {    initModules(Lists.<JSSourceFile>newArrayList(externs),         Lists.<JSModule>newArrayList(modules), options);  }  /**   * Initializes the instance state needed for a compile job if the sources   * are in modules.   */  public void initModules(      List<JSSourceFile> externs, List<JSModule> modules,      CompilerOptions options) {    initOptions(options);    checkFirstModule(modules);    fillEmptyModules(modules);    this.externs = makeCompilerInput(externs, true);    // Generate the module graph, and report any errors in the module    // specification as errors.    this.modules = modules;    if (modules.size() > 1) {      try {        this.moduleGraph = new JSModuleGraph(modules);      } catch (JSModuleGraph.ModuleDependenceException e) {        // problems with the module format.  Report as an error.  The        // message gives all details.        report(JSError.make(MODULE_DEPENDENCY_ERROR,                e.getModule().getName(), e.getDependentModule().getName()));        return;      }    } else {      this.moduleGraph = null;    }    this.inputs = getAllInputsFromModules(modules);    initBasedOnOptions();    initInputsByIdMap();  }  /**   * Do any initialization that is dependent on the compiler options.   */  private void initBasedOnOptions() {    // Create the source map if necessary.    if (options.sourceMapOutputPath != null) {      sourceMap = options.sourceMapFormat.getInstance();      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);    }  }  private List<CompilerInput> makeCompilerInput(      List<JSSourceFile> files, boolean isExtern) {    List<CompilerInput> inputs = Lists.newArrayList();    for (JSSourceFile file : files) {      inputs.add(new CompilerInput(file, isExtern));    }    return inputs;  }  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",          \"At least one module must be provided\");  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",          \"Root module '{0}' must contain at least one source code input\");  /**   * Verifies that at least one module has been provided and that the first one   * has at least one source code input.   */  private void checkFirstModule(List<JSModule> modules) {    if (modules.isEmpty()) {      report(JSError.make(EMPTY_MODULE_LIST_ERROR));    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {      // The root module may only be empty if there is exactly 1 module.      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,          modules.get(0).getName()));    }  }  /**   * Empty modules get an empty \"fill\" file, so that we can move code into   * an empty module.   */  static String createFillFileName(String moduleName) {    return \"[\" + moduleName + \"]\";  }  /**   * Fill any empty modules with a place holder file. It makes any cross module   * motion easier.   */  private static void fillEmptyModules(List<JSModule> modules) {    for (JSModule module : modules) {      if (module.getInputs().isEmpty()) {        module.add(JSSourceFile.fromCode(            createFillFileName(module.getName()), \"\"));      }    }  }  /**   * Rebuilds the internal list of inputs by iterating over all modules.   * This is necessary if inputs have been added to or removed from a module   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.   */  public void rebuildInputsFromModules() {    inputs = getAllInputsFromModules(modules);    initInputsByIdMap();  }  /**   * Builds a single list of all module inputs. Verifies that it contains no   * duplicates.   */  private static List<CompilerInput> getAllInputsFromModules(      List<JSModule> modules) {    List<CompilerInput> inputs = Lists.newArrayList();    Map<String, JSModule> inputMap = Maps.newHashMap();    for (JSModule module : modules) {      for (CompilerInput input : module.getInputs()) {        String inputName = input.getName();        // NOTE(nicksantos): If an input is in more than one module,        // it will show up twice in the inputs list, and then we        // will get an error down the line.        inputs.add(input);        inputMap.put(inputName, module);      }    }    return inputs;  }  static final DiagnosticType DUPLICATE_INPUT =      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");  static final DiagnosticType DUPLICATE_EXTERN_INPUT =      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",          \"Duplicate extern input: {0}\");  /**   * Creates a map to make looking up an input by name fast. Also checks for   * duplicate inputs.   */  void initInputsByIdMap() {    inputsById = new HashMap<InputId, CompilerInput>();    for (CompilerInput input : externs) {      InputId id = input.getInputId();      CompilerInput previous = inputsById.put(id, input);      if (previous != null) {        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));      }    }    for (CompilerInput input : inputs) {      InputId id = input.getInputId();      CompilerInput previous = inputsById.put(id, input);      if (previous != null) {        report(JSError.make(DUPLICATE_INPUT, input.getName()));      }    }  }  public Result compile(      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {     return compile(extern, new JSSourceFile[] { input }, options);  }  public Result compile(      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options) {     return compile(new JSSourceFile[] { extern }, input, options);  }  public Result compile(      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {     return compile(new JSSourceFile[] { extern }, modules, options);  }  /**   * Compiles a list of inputs.   */  public Result compile(JSSourceFile[] externs,                        JSSourceFile[] inputs,                        CompilerOptions options) {    return compile(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSSourceFile>newArrayList(inputs),        options);  }  /**   * Compiles a list of inputs.   */  public Result compile(List<JSSourceFile> externs,      List<JSSourceFile> inputs, CompilerOptions options) {    // The compile method should only be called once.    Preconditions.checkState(jsRoot == null);    try {      init(externs, inputs, options);      if (hasErrors()) {        return getResult();      }      return compile();    } finally {      Tracer t = newTracer(\"generateReport\");      errorManager.generateReport();      stopTracer(t, \"generateReport\");    }  }  /**   * Compiles a list of modules.   */  public Result compile(JSSourceFile[] externs,                        JSModule[] modules,                        CompilerOptions options) {    return compileModules(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSModule>newArrayList(modules),        options);  }  /**   * Compiles a list of modules.   */  public Result compileModules(List<JSSourceFile> externs,      List<JSModule> modules, CompilerOptions options) {    // The compile method should only be called once.    Preconditions.checkState(jsRoot == null);    try {      initModules(externs, modules, options);      if (hasErrors()) {        return getResult();      }      return compile();    } finally {      Tracer t = newTracer(\"generateReport\");      errorManager.generateReport();      stopTracer(t, \"generateReport\");    }  }  private Result compile() {    return runInCompilerThread(new Callable<Result>() {      @Override      public Result call() throws Exception {        compileInternal();        return getResult();      }    });  }  /**   * Disable threads. This is for clients that run on AppEngine and   * don't have threads.   */  public void disableThreads() {    useThreads = false;  }  private <T> T runInCompilerThread(final Callable<T> callable) {    return runCallable(callable, useThreads, options.tracer.isOn());  }  static <T> T runCallableWithLargeStack(final Callable<T> callable) {    return runCallable(callable, true, false);  }  @SuppressWarnings(\"unchecked\")  static <T> T runCallable(      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {    // Under JRE 1.6, the jscompiler overflows the stack when running on some    // large or complex js code. Here we start a new thread with a larger    // stack in order to let the compiler do its thing, without having to    // increase the stack size for *every* thread (which is what -Xss does).    // Might want to add thread pool support for clients that compile a lot.    final boolean dumpTraceReport = trace;    final Object[] result = new Object[1];    final Throwable[] exception = new Throwable[1];    Runnable runnable = new Runnable() {      @Override      public void run() {        try {          if (dumpTraceReport) {            Tracer.initCurrentThreadTrace();          }          result[0] = callable.call();        } catch (Throwable e) {          exception[0] = e;        } finally {          if (dumpTraceReport) {            Tracer.logAndClearCurrentThreadTrace();          }        }      }    };    if (useLargeStackThread) {      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);      th.start();      while (true) {        try {          th.join();          break;        } catch (InterruptedException ignore) {          // ignore        }      }    } else {      runnable.run();    }    // Pass on any exception caught by the runnable object.    if (exception[0] != null) {      throw new RuntimeException(exception[0]);    }    return (T) result[0];  }  private void compileInternal() {    setProgress(0.0);    parse();    // 15 percent of the work is assumed to be for parsing (based on some    // minimal analysis on big JS projects, of course this depends on options)    setProgress(0.15);    if (hasErrors()) {      return;    }    if (!precheck()) {      return;    }    if (options.nameAnonymousFunctionsOnly) {      // TODO(nicksantos): Move this into an instrument() phase maybe?      check();      return;    }    if (!options.skipAllPasses) {      check();      if (hasErrors()) {        return;      }      if (options.isExternExportsEnabled()          || options.externExportsPath != null) {        externExports();      }      // IDE-mode is defined to stop here, before the heavy rewriting begins.      if (!options.ideMode) {        optimize();      }    }    if (options.recordFunctionInformation) {      recordFunctionInformation();    }    if (options.devMode == DevMode.START_AND_END) {      runSanityCheck();    }    setProgress(1.0);  }  public void parse() {    parseInputs();  }  PassConfig getPassConfig() {    if (passes == null) {      passes = createPassConfigInternal();    }    return passes;  }  /**   * Create the passes object. Clients should use setPassConfig instead of   * overriding this.   */  PassConfig createPassConfigInternal() {    return new DefaultPassConfig(options);  }  /**   * @param passes The PassConfig to use with this Compiler.   * @throws NullPointerException if passes is null   * @throws IllegalStateException if this.passes has already been assigned   */  public void setPassConfig(PassConfig passes) {    // Important to check for null because if setPassConfig(null) is    // called before this.passes is set, getPassConfig() will create a    // new PassConfig object and use that, which is probably not what    // the client wanted since he or she probably meant to use their    // own PassConfig object.    Preconditions.checkNotNull(passes);    if (this.passes != null) {      throw new IllegalStateException(\"this.passes has already been assigned\");    }    this.passes = passes;  }  /**   * Carry out any special checks or procedures that need to be done before   * proceeding with rest of the compilation process.   *   * @return true, to continue with compilation   */  boolean precheck() {    return true;  }  public void check() {    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);    // We are currently only interested in check-passes for progress reporting    // as it is used for IDEs, that's why the maximum progress is set to 1.0.    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));    if (options.devMode == DevMode.EVERY_PASS) {      phaseOptimizer.setSanityCheck(sanityCheck);    }    phaseOptimizer.consume(getPassConfig().getChecks());    phaseOptimizer.process(externsRoot, jsRoot);    if (hasErrors()) {      return;    }    // TODO(nicksantos): clean this up. The flow here is too hard to follow.    if (options.nameAnonymousFunctionsOnly) {      return;    }    if (options.removeTryCatchFinally) {      removeTryCatchFinally();    }    if (options.getTweakProcessing().shouldStrip() ||        !options.stripTypes.isEmpty() ||        !options.stripNameSuffixes.isEmpty() ||        !options.stripTypePrefixes.isEmpty() ||        !options.stripNamePrefixes.isEmpty()) {      stripCode(options.stripTypes, options.stripNameSuffixes,          options.stripTypePrefixes, options.stripNamePrefixes);    }    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);  }  private void externExports() {    logger.fine(\"Creating extern file for exports\");    startPass(\"externExports\");    ExternExportsPass pass = new ExternExportsPass(this);    process(pass);    externExports = pass.getGeneratedExterns();    endPass();  }  @Override  void process(CompilerPass p) {    p.process(externsRoot, jsRoot);  }  private final PassFactory sanityCheck =      new PassFactory(\"sanityCheck\", false) {    @Override    protected CompilerPass createInternal(AbstractCompiler compiler) {      return new SanityCheck(compiler);    }  };  private void maybeSanityCheck() {    if (options.devMode == DevMode.EVERY_PASS) {      runSanityCheck();    }  }  private void runSanityCheck() {    sanityCheck.create(this).process(externsRoot, jsRoot);  }  /**   * Removes try/catch/finally statements for easier debugging.   */  void removeTryCatchFinally() {    logger.fine(\"Remove try/catch/finally\");    startPass(\"removeTryCatchFinally\");    RemoveTryCatch r = new RemoveTryCatch(this);    process(r);    endPass();  }  /**   * Strips code for smaller compiled code. This is useful for removing debug   * statements to prevent leaking them publicly.   */  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {    logger.fine(\"Strip code\");    startPass(\"stripCode\");    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,        stripTypePrefixes, stripNamePrefixes);    if (options.getTweakProcessing().shouldStrip()) {      r.enableTweakStripping();    }    process(r);    endPass();  }  /**   * Runs custom passes that are designated to run at a particular time.   */  private void runCustomPasses(CustomPassExecutionTime executionTime) {    if (options.customPasses != null) {      Tracer t = newTracer(\"runCustomPasses\");      try {        for (CompilerPass p : options.customPasses.get(executionTime)) {          process(p);        }      } finally {        stopTracer(t, \"runCustomPasses\");      }    }  }  private Tracer currentTracer = null;  private String currentPassName = null;  /**   * Marks the beginning of a pass.   */  void startPass(String passName) {    Preconditions.checkState(currentTracer == null);    currentPassName = passName;    currentTracer = newTracer(passName);  }  /**   * Marks the end of a pass.   */  void endPass() {    Preconditions.checkState(currentTracer != null,        \"Tracer should not be null at the end of a pass.\");    stopTracer(currentTracer, currentPassName);    String passToCheck = currentPassName;    currentPassName = null;    currentTracer = null;    maybeSanityCheck();  }  /**   * Returns a new tracer for the given pass name.   */  Tracer newTracer(String passName) {    String comment = passName        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");    if (options.tracer.isOn()) {      tracker.recordPassStart(passName);    }    return new Tracer(\"Compiler\", comment);  }  void stopTracer(Tracer t, String passName) {    long result = t.stop();    if (options.tracer.isOn()) {      tracker.recordPassStop(passName, result);    }  }  /**   * Returns the result of the compilation.   */  public Result getResult() {    PassConfig.State state = getPassConfig().getIntermediateState();    return new Result(getErrors(), getWarnings(), debugLog.toString(),        state.variableMap, state.propertyMap,        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,        sourceMap, externExports, state.cssNames, state.idGeneratorMap);  }  /**   * Returns an array constructed from errors + temporary warnings.   */  public JSError[] getMessages() {    return getErrors();  }  /**   * Returns the array of errors (never null).   */  public JSError[] getErrors() {    return errorManager.getErrors();  }  /**   * Returns the array of warnings (never null).   */  public JSError[] getWarnings() {    return errorManager.getWarnings();  }  @Override  public Node getRoot() {    return externAndJsRoot;  }  /**   * Creates a new id for making unique names.   */  private int nextUniqueNameId() {    return uniqueNameId++;  }  /**   * Resets the unique name id counter   */  @VisibleForTesting  void resetUniqueNameId() {    uniqueNameId = 0;  }  @Override  Supplier<String> getUniqueNameIdSupplier() {    final Compiler self = this;    return new Supplier<String>() {      @Override      public String get() {        return String.valueOf(self.nextUniqueNameId());      }    };  }  @Override  boolean areNodesEqualForInlining(Node n1, Node n2) {    if (options.ambiguateProperties ||        options.disambiguateProperties) {      // The type based optimizations require that type information is preserved      // during other optimizations.      return n1.isEquivalentToTyped(n2);    } else {      return n1.isEquivalentTo(n2);    }  }  //------------------------------------------------------------------------  // Inputs  //------------------------------------------------------------------------  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler  // interface, and which ones should always be injected.  @Override  public CompilerInput getInput(InputId id) {    return inputsById.get(id);  }  /**   * Removes an input file from AST.   * @param id The id of the input to be removed.   */  protected void removeExternInput(InputId id) {    CompilerInput input = getInput(id);    if (input == null) {      return;    }    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());    inputsById.remove(id);    externs.remove(input);    Node root = input.getAstRoot(this);    if (root != null) {      root.detachFromParent();    }  }  @Override  public CompilerInput newExternInput(String name) {    SourceAst ast = new SyntheticAst(name);    if (inputsById.containsKey(ast.getInputId())) {      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);    }    CompilerInput input = new CompilerInput(ast, true);    inputsById.put(input.getInputId(), input);    externsRoot.addChildToFront(ast.getAstRoot(this));    externs.add(0, input);    return input;  }  /** Add a source input dynamically. Intended for incremental compilation. */  void addIncrementalSourceAst(JsAst ast) {    InputId id = ast.getInputId();    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());    inputsById.put(id, new CompilerInput(ast));  }  /**   * Replace a source input dynamically. Intended for incremental   * re-compilation.   *   * If the new source input doesn't parse, then keep the old input   * in the AST and return false.   *   * @return Whether the new AST was attached successfully.   */  boolean replaceIncrementalSourceAst(JsAst ast) {    CompilerInput oldInput = getInput(ast.getInputId());    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());    Node newRoot = ast.getAstRoot(this);    if (newRoot == null) {      return false;    }    Node oldRoot = oldInput.getAstRoot(this);    if (oldRoot != null) {      oldRoot.getParent().replaceChild(oldRoot, newRoot);    } else {      getRoot().getLastChild().addChildToBack(newRoot);    }    CompilerInput newInput = new CompilerInput(ast);    inputsById.put(ast.getInputId(), newInput);    JSModule module = oldInput.getModule();    if (module != null) {      module.addAfter(newInput, oldInput);      module.remove(oldInput);    }    // Verify the input id is set properly.    Preconditions.checkState(        newInput.getInputId().equals(oldInput.getInputId()));    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));    inputs.remove(oldInput);    return true;  }  /**   * Add a new source input dynamically. Intended for incremental compilation.   * <p>   * If the new source input doesn't parse, it will not be added, and a false   * will be returned.   *   * @param ast the JS Source to add.   * @return true if the source was added successfully, false otherwise.   * @throws IllegalStateException if an input for this ast already exists.   */  boolean addNewSourceAst(JsAst ast) {    CompilerInput oldInput = getInput(ast.getInputId());    if (oldInput != null) {      throw new IllegalStateException(          \"Input already exists: \" + ast.getInputId().getIdName());    }    Node newRoot = ast.getAstRoot(this);    if (newRoot == null) {      return false;    }    getRoot().getLastChild().addChildToBack(newRoot);    CompilerInput newInput = new CompilerInput(ast);    // TODO(tylerg): handle this for multiple modules at some point.    if (moduleGraph == null && !modules.isEmpty()) {      // singleton module      modules.get(0).add(newInput);    }    inputsById.put(ast.getInputId(), newInput);    return true;  }  @Override  JSModuleGraph getModuleGraph() {    return moduleGraph;  }  /**   * Gets a module graph. This will always return a module graph, even   * in the degenerate case when there's only one module.   */  JSModuleGraph getDegenerateModuleGraph() {    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;  }  @Override  public JSTypeRegistry getTypeRegistry() {    if (typeRegistry == null) {      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);    }    return typeRegistry;  }  @Override  public MemoizedScopeCreator getTypedScopeCreator() {    return getPassConfig().getTypedScopeCreator();  }  @SuppressWarnings(\"unchecked\")  DefaultPassConfig ensureDefaultPassConfig() {    PassConfig passes = getPassConfig().getBasePassConfig();    Preconditions.checkState(passes instanceof DefaultPassConfig,        \"PassConfigs must eventually delegate to the DefaultPassConfig\");    return (DefaultPassConfig) passes;  }  public SymbolTable buildKnownSymbolTable() {    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();    if (typedScopeCreator != null) {      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());      symbolTable.addSymbolsFrom(typedScopeCreator);    } else {      symbolTable.findScopes(this, externsRoot, jsRoot);    }    GlobalNamespace globalNamespace =        ensureDefaultPassConfig().getGlobalNamespace();    if (globalNamespace != null) {      symbolTable.addSymbolsFrom(globalNamespace);    }    ReferenceCollectingCallback refCollector =        new ReferenceCollectingCallback(            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);    NodeTraversal.traverse(this, getRoot(), refCollector);    symbolTable.addSymbolsFrom(refCollector);    PreprocessorSymbolTable preprocessorSymbolTable =        ensureDefaultPassConfig().getPreprocessorSymbolTable();    if (preprocessorSymbolTable != null) {      symbolTable.addSymbolsFrom(preprocessorSymbolTable);    }    symbolTable.fillNamespaceReferences();    symbolTable.fillPropertyScopes();    symbolTable.fillThisReferences(this, externsRoot, jsRoot);    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);    return symbolTable;  }  @Override  public Scope getTopScope() {    return getPassConfig().getTopScope();  }  @Override  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {    if (abstractInterpreter == null) {      ChainableReverseAbstractInterpreter interpreter =          new SemanticReverseAbstractInterpreter(              getCodingConvention(), getTypeRegistry());      if (options.closurePass) {        interpreter = new ClosureReverseAbstractInterpreter(            getCodingConvention(), getTypeRegistry())            .append(interpreter).getFirst();      }      abstractInterpreter = interpreter;    }    return abstractInterpreter;  }  @Override  TypeValidator getTypeValidator() {    if (typeValidator == null) {      typeValidator = new TypeValidator(this);    }    return typeValidator;  }  //------------------------------------------------------------------------  // Parsing  //------------------------------------------------------------------------  /**   * Parses the externs and main inputs.   *   * @return A synthetic root node whose two children are the externs root   *     and the main root   */  Node parseInputs() {    boolean devMode = options.devMode != DevMode.OFF;    // If old roots exist (we are parsing a second time), detach each of the    // individual file parse trees.    if (externsRoot != null) {      externsRoot.detachChildren();    }    if (jsRoot != null) {      jsRoot.detachChildren();    }    // Parse main js sources.    jsRoot = IR.block();    jsRoot.setIsSyntheticBlock(true);    externsRoot = IR.block();    externsRoot.setIsSyntheticBlock(true);    externAndJsRoot = IR.block(externsRoot, jsRoot);    externAndJsRoot.setIsSyntheticBlock(true);    if (options.tracer.isOn()) {      tracker = new PerformanceTracker(jsRoot,          options.tracer == TracerMode.ALL);      addChangeHandler(tracker.getCodeChangeHandler());    }    Tracer tracer = newTracer(\"parseInputs\");    try {      // Parse externs sources.      for (CompilerInput input : externs) {        Node n = input.getAstRoot(this);        if (hasErrors()) {          return null;        }        externsRoot.addChildToBack(n);      }      // Modules inferred in ProcessCommonJS pass.      if (options.transformAMDToCJSModules || options.processCommonJSModules) {        processAMDAndCommonJSModules();      }      // Check if the sources need to be re-ordered.      if (options.dependencyOptions.needsManagement()) {        for (CompilerInput input : inputs) {          input.setCompiler(this);          // Forward-declare all the provided types, so that they          // are not flagged even if they are dropped from the process.          for (String provide : input.getProvides()) {            getTypeRegistry().forwardDeclareType(provide);          }        }        try {          inputs =              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)              .manageDependencies(options.dependencyOptions, inputs);        } catch (CircularDependencyException e) {          report(JSError.make(              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));          // If in IDE mode, we ignore the error and keep going.          if (hasErrors()) {            return null;          }        } catch (MissingProvideException e) {          report(JSError.make(              MISSING_ENTRY_ERROR, e.getMessage()));          // If in IDE mode, we ignore the error and keep going.          if (hasErrors()) {            return null;          }        }      }      // Check if inputs need to be rebuilt from modules.      boolean staleInputs = false;      for (CompilerInput input : inputs) {        Node n = input.getAstRoot(this);        // Inputs can have a null AST during initial parse.        if (n == null) {          continue;        }        if (n.getJSDocInfo() != null) {          JSDocInfo info = n.getJSDocInfo();          if (info.isExterns()) {            // If the input file is explicitly marked as an externs file, then            // assume the programmer made a mistake and throw it into            // the externs pile anyways.            externsRoot.addChildToBack(n);            input.setIsExtern(true);            input.getModule().remove(input);            externs.add(input);            staleInputs = true;          } else if (info.isNoCompile()) {            input.getModule().remove(input);            staleInputs = true;          }        }      }      if (staleInputs) {        fillEmptyModules(modules);        rebuildInputsFromModules();      }      // Build the AST.      for (CompilerInput input : inputs) {        Node n = input.getAstRoot(this);        if (n == null) {          continue;        }        if (devMode) {          runSanityCheck();          if (hasErrors()) {            return null;          }        }        if (options.sourceMapOutputPath != null ||            options.nameReferenceReportPath != null) {          // Annotate the nodes in the tree with information from the          // input file. This information is used to construct the SourceMap.          SourceInformationAnnotator sia =              new SourceInformationAnnotator(                  input.getName(), options.devMode != DevMode.OFF);          NodeTraversal.traverse(this, n, sia);        }        jsRoot.addChildToBack(n);      }      if (hasErrors()) {        return null;      }      return externAndJsRoot;    } finally {      stopTracer(tracer, \"parseInputs\");    }  }  /**   * Transforms AMD and CJS modules to something closure compiler can   * process and creates JSModules and the corresponding dependency tree   * on the way.   */  private void processAMDAndCommonJSModules() {    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();    // TODO(nicksantos): Refactor module dependency resolution to work nicely    // with multiple ways to express dependencies. Directly support JSModules    // that are equivalent to a signal file and which express their deps    // directly in the source.    for (CompilerInput input : inputs) {      input.setCompiler(this);      Node root = input.getAstRoot(this);      if (root == null) {        continue;      }      if (options.transformAMDToCJSModules) {        new TransformAMDToCJSModule(this).process(null, root);      }      if (options.processCommonJSModules) {        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,            options.commonJSModulePathPrefix);        cjs.process(null, root);        JSModule m = cjs.getModule();        if (m != null) {          modulesByName.put(m.getName(), m);          modulesByInput.put(input, m);        }      }    }    if (options.processCommonJSModules) {      List<JSModule> modules = Lists.newArrayList(modulesByName.values());      if (!modules.isEmpty()) {        this.modules = modules;        this.moduleGraph = new JSModuleGraph(this.modules);      }      for (JSModule module : modules) {        for (CompilerInput input : module.getInputs()) {          for (String require : input.getRequires()) {            module.addDependency(modulesByName.get(require));          }        }      }      try {        modules = Lists.newArrayList();        for (CompilerInput input : this.moduleGraph.manageDependencies(            options.dependencyOptions, inputs)) {          modules.add(modulesByInput.get(input));        }        this.modules = modules;        this.moduleGraph = new JSModuleGraph(modules);      } catch (Exception e) {        Throwables.propagate(e);      }    }  }  public Node parse(JSSourceFile file) {    initCompilerOptionsIfTesting();    addToDebugLog(\"Parsing: \" + file.getName());    return new JsAst(file).getAstRoot(this);  }  private int syntheticCodeId = 0;  @Override  Node parseSyntheticCode(String js) {    CompilerInput input = new CompilerInput(        JSSourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));    inputsById.put(input.getInputId(), input);    return input.getAstRoot(this);  }  /**   * Allow subclasses to override the default CompileOptions object.   */  protected CompilerOptions newCompilerOptions() {    return new CompilerOptions();  }  void initCompilerOptionsIfTesting() {    if (options == null) {      // initialization for tests that don't initialize the compiler      // by the normal mechanisms.      initOptions(newCompilerOptions());    }  }  @Override  Node parseSyntheticCode(String fileName, String js) {    initCompilerOptionsIfTesting();    return parse(JSSourceFile.fromCode(fileName, js));  }  @Override  Node parseTestCode(String js) {    initCompilerOptionsIfTesting();    CompilerInput input = new CompilerInput(        JSSourceFile.fromCode(\" [testcode] \", js));    if (inputsById == null) {      inputsById = Maps.newHashMap();    }    inputsById.put(input.getInputId(), input);    return input.getAstRoot(this);  }  @Override  ErrorReporter getDefaultErrorReporter() {    return defaultErrorReporter;  }  //------------------------------------------------------------------------  // Convert back to source code  //------------------------------------------------------------------------  /**   * Converts the main parse tree back to js code.   */  public String toSource() {    return runInCompilerThread(new Callable<String>() {      @Override      public String call() throws Exception {        Tracer tracer = newTracer(\"toSource\");        try {          CodeBuilder cb = new CodeBuilder();          if (jsRoot != null) {            int i = 0;            for (Node scriptNode = jsRoot.getFirstChild();                 scriptNode != null;                 scriptNode = scriptNode.getNext()) {              toSource(cb, i++, scriptNode);            }          }          return cb.toString();        } finally {          stopTracer(tracer, \"toSource\");        }      }    });  }  /**   * Converts the parse tree for each input back to js code.   */  public String[] toSourceArray() {    return runInCompilerThread(new Callable<String[]>() {      @Override      public String[] call() throws Exception {        Tracer tracer = newTracer(\"toSourceArray\");        try {          int numInputs = inputs.size();          String[] sources = new String[numInputs];          CodeBuilder cb = new CodeBuilder();          for (int i = 0; i < numInputs; i++) {            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);            cb.reset();            toSource(cb, i, scriptNode);            sources[i] = cb.toString();          }          return sources;        } finally {          stopTracer(tracer, \"toSourceArray\");        }      }    });  }  /**   * Converts the parse tree for a module back to js code.   */  public String toSource(final JSModule module) {    return runInCompilerThread(new Callable<String>() {      @Override      public String call() throws Exception {        List<CompilerInput> inputs = module.getInputs();        int numInputs = inputs.size();        if (numInputs == 0) {          return \"\";        }        CodeBuilder cb = new CodeBuilder();        for (int i = 0; i < numInputs; i++) {          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);          if (scriptNode == null) {            throw new IllegalArgumentException(                \"Bad module: \" + module.getName());          }          toSource(cb, i, scriptNode);        }        return cb.toString();      }    });  }  /**   * Converts the parse tree for each input in a module back to js code.   */  public String[] toSourceArray(final JSModule module) {    return runInCompilerThread(new Callable<String[]>() {      @Override      public String[] call() throws Exception {        List<CompilerInput> inputs = module.getInputs();        int numInputs = inputs.size();        if (numInputs == 0) {          return new String[0];        }        String[] sources = new String[numInputs];        CodeBuilder cb = new CodeBuilder();        for (int i = 0; i < numInputs; i++) {          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);          if (scriptNode == null) {            throw new IllegalArgumentException(                \"Bad module input: \" + inputs.get(i).getName());          }          cb.reset();          toSource(cb, i, scriptNode);          sources[i] = cb.toString();        }        return sources;      }    });  }  /**   * Writes out js code from a root node. If printing input delimiters, this   * method will attach a comment to the start of the text indicating which   * input the output derived from. If there were any preserve annotations   * within the root's source, they will also be printed in a block comment   * at the beginning of the output.   */  public void toSource(final CodeBuilder cb,                       final int inputSeqNum,                       final Node root) {    runInCompilerThread(new Callable<Void>() {      @Override      public Void call() throws Exception {        if (options.printInputDelimiter) {          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {            cb.append(\"\\n\");  // Make sure that the label starts on a new line          }          Preconditions.checkState(root.isScript());          String delimiter = options.inputDelimiter;          String inputName = root.getInputId().getIdName();          String sourceName = root.getSourceFileName();          Preconditions.checkState(sourceName != null);          Preconditions.checkState(!sourceName.isEmpty());          delimiter = delimiter              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));          cb.append(delimiter)            .append(\"\\n\");        }        if (root.getJSDocInfo() != null &&            root.getJSDocInfo().getLicense() != null) {          cb.append(\"/*\\n\")            .append(root.getJSDocInfo().getLicense())            .append(\"*/\\n\");        }        // If there is a valid source map, then indicate to it that the current        // root node's mappings are offset by the given string builder buffer.        if (options.sourceMapOutputPath != null) {          sourceMap.setStartingPosition(              cb.getLineIndex(), cb.getColumnIndex());        }        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'        // for the first input file        String code = toSource(root, sourceMap, inputSeqNum == 0);        if (!code.isEmpty()) {          cb.append(code);          // In order to avoid parse ambiguity when files are concatenated          // together, all files should end in a semi-colon. Do a quick          // heuristic check if there's an obvious semi-colon already there.          int length = code.length();          char lastChar = code.charAt(length - 1);          char secondLastChar = length >= 2 ?              code.charAt(length - 2) : '\\0';          boolean hasSemiColon = lastChar == ';' ||              (lastChar == '\\n' && secondLastChar == ';');          if (!hasSemiColon) {            cb.append(\";\");          }        }        return null;      }    });  }  /**   * Generates JavaScript source code for an AST, doesn't generate source   * map info.   */  @Override  String toSource(Node n) {    initCompilerOptionsIfTesting();    return toSource(n, null, true);  }  /**   * Generates JavaScript source code for an AST.   */  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {    CodePrinter.Builder builder = new CodePrinter.Builder(n);    builder.setPrettyPrint(options.prettyPrint);    builder.setLineBreak(options.lineBreak);    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);    builder.setSourceMap(sourceMap);    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);    builder.setTagAsStrict(firstOutput &&        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);    builder.setLineLengthThreshold(options.lineLengthThreshold);    Charset charset = options.outputCharset != null ?        Charset.forName(options.outputCharset) : null;    builder.setOutputCharset(charset);    return builder.build();  }  /**   * Stores a buffer of text to which more can be appended.  This is just like a   * StringBuilder except that we also track the number of lines.   */  public static class CodeBuilder {    private final StringBuilder sb = new StringBuilder();    private int lineCount = 0;    private int colCount = 0;    /** Removes all text, but leaves the line count unchanged. */    void reset() {      sb.setLength(0);    }    /** Appends the given string to the text buffer. */    CodeBuilder append(String str) {      sb.append(str);      // Adjust the line and column information for the new text.      int index = -1;      int lastIndex = index;      while ((index = str.indexOf('\\n', index + 1)) >= 0) {        ++lineCount;        lastIndex = index;      }      if (lastIndex == -1) {        // No new lines, append the new characters added.        colCount += str.length();      } else {        colCount = str.length() - (lastIndex + 1);      }      return this;    }    /** Returns all text in the text buffer. */    @Override    public String toString() {      return sb.toString();    }    /** Returns the length of the text buffer. */    public int getLength() {      return sb.length();    }    /** Returns the (zero-based) index of the last line in the text buffer. */    int getLineIndex() {      return lineCount;    }    /** Returns the (zero-based) index of the last column in the text buffer. */    int getColumnIndex() {      return colCount;    }    /** Determines whether the text ends with the given suffix. */    boolean endsWith(String suffix) {      return (sb.length() > suffix.length())          && suffix.equals(sb.substring(sb.length() - suffix.length()));    }  }  //------------------------------------------------------------------------  // Optimizations  //------------------------------------------------------------------------  public void optimize() {    // Ideally, this pass should be the first pass run, however:    // 1) VariableReferenceCheck reports unexpected warnings if Normalize    // is done first.    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on    // unmodified local names.    normalize();    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);    if (options.devMode == DevMode.EVERY_PASS) {      phaseOptimizer.setSanityCheck(sanityCheck);    }    phaseOptimizer.consume(getPassConfig().getOptimizations());    phaseOptimizer.process(externsRoot, jsRoot);    if (hasErrors()) {      return;    }  }  @Override  void setCssRenamingMap(CssRenamingMap map) {    options.cssRenamingMap = map;  }  @Override  CssRenamingMap getCssRenamingMap() {    return options.cssRenamingMap;  }  /**   * Reprocesses the current defines over the AST.  This is used by GwtCompiler   * to generate N outputs for different targets from the same (checked) AST.   * For each target, we apply the target-specific defines by calling   * {@code processDefines} and then {@code optimize} to optimize the AST   * specifically for that target.   */  public void processDefines() {    (new DefaultPassConfig(options)).processDefines.create(this)        .process(externsRoot, jsRoot);  }  boolean isInliningForbidden() {    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||        options.propertyRenaming ==            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;  }  /** Control Flow Analysis. */  ControlFlowGraph<Node> computeCFG() {    logger.fine(\"Computing Control Flow Graph\");    Tracer tracer = newTracer(\"computeCFG\");    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);    process(cfa);    stopTracer(tracer, \"computeCFG\");    return cfa.getCfg();  }  public void normalize() {    logger.fine(\"Normalizing\");    startPass(\"normalize\");    process(new Normalize(this, false));    endPass();  }  @Override  void prepareAst(Node root) {    CompilerPass pass = new PrepareAst(this);    pass.process(null, root);  }  void recordFunctionInformation() {    logger.fine(\"Recording function information\");    startPass(\"recordFunctionInformation\");    RecordFunctionInformation recordFunctionInfoPass =        new RecordFunctionInformation(            this, getPassConfig().getIntermediateState().functionNames);    process(recordFunctionInfoPass);    functionInformationMap = recordFunctionInfoPass.getMap();    endPass();  }  protected final CodeChangeHandler.RecentChange recentChange =      new CodeChangeHandler.RecentChange();  private final List<CodeChangeHandler> codeChangeHandlers =      Lists.<CodeChangeHandler>newArrayList();  /** Name of the synthetic input that holds synthesized externs. */  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";  private CompilerInput synthesizedExternsInput = null;  @Override  void addChangeHandler(CodeChangeHandler handler) {    codeChangeHandlers.add(handler);  }  @Override  void removeChangeHandler(CodeChangeHandler handler) {    codeChangeHandlers.remove(handler);  }  /**   * All passes should call reportCodeChange() when they alter   * the JS tree structure. This is verified by CompilerTestCase.   * This allows us to optimize to a fixed point.   */  @Override  public void reportCodeChange() {    for (CodeChangeHandler handler : codeChangeHandlers) {      handler.reportChange();    }  }  @Override  public CodingConvention getCodingConvention() {    CodingConvention convention = options.getCodingConvention();    convention = convention != null ? convention : defaultCodingConvention;    return convention;  }  @Override  public boolean isIdeMode() {    return options.ideMode;  }  @Override  public boolean acceptEcmaScript5() {    switch (options.getLanguageIn()) {      case ECMASCRIPT5:      case ECMASCRIPT5_STRICT:        return true;    }    return false;  }  public LanguageMode languageMode() {    return options.getLanguageIn();  }  @Override  public boolean acceptConstKeyword() {    return options.acceptConstKeyword;  }  @Override  Config getParserConfig() {    if (parserConfig == null) {      Config.LanguageMode mode;      switch (options.getLanguageIn()) {        case ECMASCRIPT3:          mode = Config.LanguageMode.ECMASCRIPT3;          break;        case ECMASCRIPT5:          mode = Config.LanguageMode.ECMASCRIPT5;          break;        case ECMASCRIPT5_STRICT:          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;          break;        default:          throw new IllegalStateException(\"unexpected language mode\");      }      parserConfig = ParserRunner.createConfig(        isIdeMode(),        mode,        acceptConstKeyword(),        options.extraAnnotationNames);    }    return parserConfig;  }  @Override  public boolean isTypeCheckingEnabled() {    return options.checkTypes;  }  //------------------------------------------------------------------------  // Error reporting  //------------------------------------------------------------------------  /**   * The warning classes that are available from the command-line, and   * are suppressable by the {@code @suppress} annotation.   */  protected DiagnosticGroups getDiagnosticGroups() {    return new DiagnosticGroups();  }  @Override  public void report(JSError error) {    CheckLevel level = error.level;    if (warningsGuard != null) {      CheckLevel newLevel = warningsGuard.level(error);      if (newLevel != null) {        level = newLevel;      }    }    if (level.isOn()) {      errorManager.report(level, error);    }  }  @Override  public CheckLevel getErrorLevel(JSError error) {    Preconditions.checkNotNull(options);    return warningsGuard.level(error);  }  /**   * Report an internal error.   */  @Override  void throwInternalError(String message, Exception cause) {    String finalMessage =      \"INTERNAL COMPILER ERROR.\\n\" +      \"Please report this problem.\\n\" + message;    RuntimeException e = new RuntimeException(finalMessage, cause);    if (cause != null) {      e.setStackTrace(cause.getStackTrace());    }    throw e;  }  /**   * Gets the number of errors.   */  public int getErrorCount() {    return errorManager.getErrorCount();  }  /**   * Gets the number of warnings.   */  public int getWarningCount() {    return errorManager.getWarningCount();  }  @Override  boolean hasHaltingErrors() {    return !isIdeMode() && getErrorCount() > 0;  }  /**   * Consults the {@link ErrorManager} to see if we've encountered errors   * that should halt compilation. <p>   *   * If {@link CompilerOptions#ideMode} is {@code true}, this function   * always returns {@code false} without consulting the error manager. The   * error manager will continue to be told about new errors and warnings, but   * the compiler will complete compilation of all inputs.<p>   */  public boolean hasErrors() {    return hasHaltingErrors();  }  /** Called from the compiler passes, adds debug info */  @Override  void addToDebugLog(String str) {    debugLog.append(str);    debugLog.append('\\n');    logger.fine(str);  }  private SourceFile getSourceFileByName(String sourceName) {    // Here we assume that the source name is the input name, this    // is try of javascript parsed from source.    if (sourceName != null) {      CompilerInput input = inputsById.get(new InputId(sourceName));      if (input != null) {        return input.getSourceFile();      }    }    return null;  }  @Override  public String getSourceLine(String sourceName, int lineNumber) {    if (lineNumber < 1) {      return null;    }    SourceFile input = getSourceFileByName(sourceName);    if (input != null) {      return input.getLine(lineNumber);    }    return null;  }  @Override  public Region getSourceRegion(String sourceName, int lineNumber) {    if (lineNumber < 1) {      return null;    }    SourceFile input = getSourceFileByName(sourceName);    if (input != null) {      return input.getRegion(lineNumber);    }    return null;  }  //------------------------------------------------------------------------  // Package-private helpers  //------------------------------------------------------------------------  @Override  Node getNodeForCodeInsertion(JSModule module) {    if (module == null) {      if (inputs.isEmpty()) {        throw new IllegalStateException(\"No inputs\");      }      return inputs.get(0).getAstRoot(this);    }    List<CompilerInput> moduleInputs = module.getInputs();    if (moduleInputs.size() > 0) {      return moduleInputs.get(0).getAstRoot(this);    }    throw new IllegalStateException(\"Root module has no inputs\");  }  public SourceMap getSourceMap() {    return sourceMap;  }  VariableMap getVariableMap() {    return getPassConfig().getIntermediateState().variableMap;  }  VariableMap getPropertyMap() {    return getPassConfig().getIntermediateState().propertyMap;  }  CompilerOptions getOptions() {    return options;  }  FunctionInformationMap getFunctionalInformationMap() {    return functionInformationMap;  }  /**   * Sets the logging level for the com.google.javascript.jscomp package.   */  public static void setLoggingLevel(Level level) {    logger.setLevel(level);  }  /** Gets the DOT graph of the AST generated at the end of compilation. */  public String getAstDotGraph() throws IOException {    if (jsRoot != null) {      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);      cfa.process(null, jsRoot);      return DotFormatter.toDot(jsRoot, cfa.getCfg());    } else {      return \"\";    }  }  @Override  public ErrorManager getErrorManager() {    if (options == null) {      initOptions(newCompilerOptions());    }    return errorManager;  }  @Override  List<CompilerInput> getInputsInOrder() {    return Collections.<CompilerInput>unmodifiableList(inputs);  }  /**   * Returns an unmodifiable view of the compiler inputs indexed by id.   */  public Map<InputId, CompilerInput> getInputsById() {    return Collections.unmodifiableMap(inputsById);  }  /**   * Gets the externs in the order in which they are being processed.   */  List<CompilerInput> getExternsInOrder() {    return Collections.<CompilerInput>unmodifiableList(externs);  }  /**   * Stores the internal compiler state just before optimization is performed.   * This can be saved and restored in order to efficiently optimize multiple   * different output targets without having to perform checking multiple times.   *   * NOTE: This does not include all parts of the compiler's internal state. In   * particular, JSSourceFiles and CompilerOptions are not recorded. In   * order to recreate a Compiler instance from scratch, you would need to   * call {@code init} with the same arguments as in the initial creation before   * restoring intermediate state.   */  public static class IntermediateState implements Serializable {    private static final long serialVersionUID = 1L;    Node externsRoot;    private Node jsRoot;    private List<CompilerInput> externs;    private List<CompilerInput> inputs;    private List<JSModule> modules;    private PassConfig.State passConfigState;    private JSTypeRegistry typeRegistry;    private AbstractCompiler.LifeCycleStage lifeCycleStage;    private IntermediateState() {}  }  /**   * Returns the current internal state, excluding the input files and modules.   */  public IntermediateState getState() {    IntermediateState state = new IntermediateState();    state.externsRoot = externsRoot;    state.jsRoot = jsRoot;    state.externs = externs;    state.inputs = inputs;    state.modules = modules;    state.passConfigState = getPassConfig().getIntermediateState();    state.typeRegistry = typeRegistry;    state.lifeCycleStage = getLifeCycleStage();    return state;  }  /**   * Sets the internal state to the capture given.  Note that this assumes that   * the input files are already set up.   */  public void setState(IntermediateState state) {    externsRoot = state.externsRoot;    jsRoot = state.jsRoot;    externs = state.externs;    inputs = state.inputs;    modules = state.modules;    passes = createPassConfigInternal();    getPassConfig().setIntermediateState(state.passConfigState);    typeRegistry = state.typeRegistry;    setLifeCycleStage(state.lifeCycleStage);  }  @VisibleForTesting  List<CompilerInput> getInputsForTesting() {    return inputs;  }  @VisibleForTesting  List<CompilerInput> getExternsForTesting() {    return externs;  }  @Override  boolean hasRegExpGlobalReferences() {    return hasRegExpGlobalReferences;  }  @Override  void setHasRegExpGlobalReferences(boolean references) {    hasRegExpGlobalReferences = references;  }  @Override  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,      Node collectionRoot) {    Preconditions.checkState(collectionRoot.isScript()        || collectionRoot.isBlock());    if (globalRefMap == null) {      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),          getExternsInOrder());    }    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);  }  @Override  GlobalVarReferenceMap getGlobalVarReferences() {    return globalRefMap;  }  @Override  CompilerInput getSynthesizedExternsInput() {    if (synthesizedExternsInput == null) {      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);    }    return synthesizedExternsInput;  }  @Override  public double getProgress() {    return progress;  }  @Override  void setProgress(double newProgress) {    if (newProgress > 1.0) {      progress = 1.0;    } else if (newProgress < 0.0) {      progress = 0.0;    } else {      progress = newProgress;    }  }  /**   * Replaces one file in a hot-swap mode. The given JsAst should be made   * from a new version of a file that already was present in the last compile   * call. If the file is new, this will silently ignored.   *   * @param ast the ast of the file that is being replaced   */  public void replaceScript(JsAst ast) {    CompilerInput input = this.getInput(ast.getInputId());    if (!replaceIncrementalSourceAst(ast)) {      return;    }    Node originalRoot = input.getAstRoot(this);    processNewScript(ast, originalRoot);  }  /**   * Adds a new Script AST to the compile state. If a script for the same file   * already exists the script will not be added, instead a call to   * #replaceScript should be used.   *   * @param ast the ast of the new file   */  public void addNewScript(JsAst ast) {    if (!addNewSourceAst(ast)) {      return;    }    Node emptyScript = new Node(Token.SCRIPT);    InputId inputId = ast.getInputId();    emptyScript.setInputId(inputId);    emptyScript.setStaticSourceFile(        JSSourceFile.fromCode(inputId.getIdName(), \"\"));    processNewScript(ast, emptyScript);  }  private void processNewScript(JsAst ast, Node originalRoot) {    Node js = ast.getAstRoot(this);    Preconditions.checkNotNull(js);    runHotSwap(originalRoot, js, this.getCleanupPassConfig());    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need    // to revisit this approach to clearing GlobalNamespaces    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);    this.getTypeRegistry().clearNamedTypes();    this.removeSyntheticVarsInput();    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());  }  /**   * Execute the passes from a PassConfig instance over a single replaced file.   */  private void runHotSwap(      Node originalRoot, Node js, PassConfig passConfig) {    for (PassFactory passFactory : passConfig.getChecks()) {      runHotSwapPass(originalRoot, js, passFactory);    }  }  private void runHotSwapPass(      Node originalRoot, Node js, PassFactory passFactory) {    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);    if (pass != null) {      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());      pass.hotSwapScript(js, originalRoot);    }  }  private PassConfig getCleanupPassConfig() {    return new CleanupPasses(getOptions());  }  private void removeSyntheticVarsInput() {    String sourceName = Compiler.SYNTHETIC_EXTERNS;    removeExternInput(new InputId(sourceName));  }}\nCaused by: java.lang.IllegalStateException\n\t... 23 more\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Node node = newNode(Token.FUNCTION);\n    Node newName;\n    if (name != null) {\n        newName = transform(name);\n        newName.setLineno(functionNode.getLineno());\n        maybeSetLengthFrom(newName, name);\n    } else {\n        newName = newNode(Token.EMPTY);\n    }\n    node.addChildToBack(newName);\n\n    Node lp = newNode(Token.PARAM_LIST);\n    lp.setLineno(functionNode.getLineno());\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = functionNode.getBody() != null ? transform(functionNode.getBody()) : newNode(Token.BLOCK);\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  if (functionNode.getBody() != null) {\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n  }\n return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\n                \"unnamed function statement\",\n                sourceName,\n                functionNode.getLineno(), \n                \"\", \n                0\n            );\n\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    \n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO: Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n    \n    // If the body node is null, create an empty block to prevent errors.\n    if (bodyNode == null) {\n        bodyNode = newNode(Token.BLOCK);\n        bodyNode.setLineno(functionNode.getLineno());\n        bodyNode.setCharno(position2charno(functionNode.getAbsolutePosition()));\n    }\n\n    // When in ideMode, Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. See Rhino's Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    \n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\n                \"unnamed function statement\",\n                sourceName,\n                functionNode.getLineno(), \"\", 0);\n\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() +\n        functionNode.getAbsolutePosition();\n\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n\n    if (!bodyNode.isBlock()) { // Ensure bodyNode is a block\n        Node wrapper = newNode(Token.BLOCK);\n        wrapper.addChildToFront(bodyNode);\n        bodyNode = wrapper;\n    }\n\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  // Added missing block node creation for the function body if not present\n  if (!bodyNode.isBlock()) {\n    Node blockNode = newNode(Token.BLOCK);\n    blockNode.addChildToFront(bodyNode);\n    bodyNode = blockNode;\n  }\n  \n  // When in ideMode Rhino tries to parse some constructs the compiler\n  // doesn't support, repair it here. see Rhino's\n  // Parser#parseFunctionBodyExpr.\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  Name fnName = functionNode.getFunctionName();\n  // Properly handle a function with no name by using the function node's line number.\n  lp.setLineno(fnName != null ? fnName.getLineno() : functionNode.getLineno());\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\n                \"unnamed function statement\",\n                sourceName,\n                functionNode.getLineno(), \"\", 0);\n\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        // Create a new Name to avoid setting empty identifier later.\n        name = new Name();\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n\n    // Transform the function name node, whether it is named or unnamed\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n\n    int lparenCharno = functionNode.getLp() +\n        functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n      \n      Node block = transformBlock(new Block());\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.FUNCTION, new Name(), newNode(Token.PARAM_LIST), block);\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO: Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  if (bodyNode == null) {\n    bodyNode = newNode(Token.BLOCK);\n  }\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n\n          // Return the bare minimum to put the AST in a valid state.\n          return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.PARAM_LIST);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n        // When in ideMode Rhino tries to parse some constructs the compiler\n        // doesn't support, repair it here. see Rhino's\n        // Parser#parseFunctionBodyExpr.\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    );\n  }\n```\n#Error message: java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:642)  throw new RuntimeException(exception[0]);\n\tat com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:587)  return runCallable(callable, useThreads, options.tracer.isOn());\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:569)  return runInCompilerThread(new Callable<Result>() {      @Override      public Result call() throws Exception {        compileInternal();        return getResult();      }    });\n\tat com.google.javascript.jscomp.Compiler.compileModules(Compiler.java:560)  return compile();\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:542)  return compileModules(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSModule>newArrayList(modules),        options);\n\tat com.google.javascript.jscomp.IntegrationTest.compile(IntegrationTest.java:2080)  compiler.compile(        externs, CompilerTestCase.createModuleChain(original), options);\n\tat com.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:2041)  Compiler compiler = compile(options, original);\n\tat com.google.javascript.jscomp.IntegrationTest.testIncompleteFunction(IntegrationTest.java:1945)  test(options,        new String[] { \"var foo = {bar: function(e) }\" },        new String[] { \"var foo = {bar: function(e){}};\" },        warnings    );\nCaused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:540)  Preconditions.checkState(body.getNext() == null &&            body.isBlock());\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:489)  traverseFunction(n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:277)  traverseBranch(root, null);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:455)  t.traverse(root);\n\tat com.google.javascript.jscomp.PrepareAst.process(PrepareAst.java:70)  NodeTraversal.traverse(            compiler, root, new PrepareAnnotations(compiler));\n\tat com.google.javascript.jscomp.Compiler.prepareAst(Compiler.java:1835)  pass.process(null, root);\n\tat com.google.javascript.jscomp.JsAst.parse(JsAst.java:99)  compiler.prepareAst(root);\n\tat com.google.javascript.jscomp.JsAst.getAstRoot(JsAst.java:52)  parse(compiler);\n\tat com.google.javascript.jscomp.CompilerInput.getAstRoot(CompilerInput.java:119)  Node root = ast.getAstRoot(compiler);\n\tat com.google.javascript.jscomp.Compiler.parseInputs(Compiler.java:1302)  Node n = input.getAstRoot(this);\n\tat com.google.javascript.jscomp.Compiler.parse(Compiler.java:696)  parseInputs();\n\tat com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:650)  parse();\n\tat com.google.javascript.jscomp.Compiler.access$000(Compiler.java:71)  public class Compiler extends AbstractCompiler {  static final String SINGLETON_MODULE_NAME = \"[singleton]\";  static final DiagnosticType MODULE_DEPENDENCY_ERROR =      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",          \"Bad dependency: {0} -> {1}. \"              + \"Modules must be listed in dependency order.\");  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(      \"JSC_MISSING_ENTRY_ERROR\",      \"required entry point \\\"{0}\\\" never provided\");  CompilerOptions options = null;  private PassConfig passes = null;  // The externs inputs  private List<CompilerInput> externs;  // The JS source modules  private List<JSModule> modules;  // The graph of the JS source modules. Must be null if there are less than  // 2 modules, because we use this as a signal for which passes to run.  private JSModuleGraph moduleGraph;  // The JS source inputs  private List<CompilerInput> inputs;  // error manager to which error management is delegated  private ErrorManager errorManager;  // Warnings guard for filtering warnings.  private WarningsGuard warningsGuard;  // Parse tree root nodes  Node externsRoot;  Node jsRoot;  Node externAndJsRoot;  private Map<InputId, CompilerInput> inputsById;  /** The source code map */  private SourceMap sourceMap;  /** The externs created from the exports.  */  private String externExports = null;  /**   * Ids for function inlining so that each declared name remains   * unique.   */  private int uniqueNameId = 0;  /** Whether to use threads. */  private boolean useThreads = true;  /**   * Whether to assume there are references to the RegExp Global object   * properties.   */  private boolean hasRegExpGlobalReferences = true;  /** The function information map */  private FunctionInformationMap functionInformationMap;  /** Debugging information */  private final StringBuilder debugLog = new StringBuilder();  /** Detects Google-specific coding conventions. */  CodingConvention defaultCodingConvention = new ClosureCodingConvention();  private JSTypeRegistry typeRegistry;  private Config parserConfig = null;  private ReverseAbstractInterpreter abstractInterpreter;  private TypeValidator typeValidator;  public PerformanceTracker tracker;  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =      RhinoErrorReporter.forOldRhino(this);  // This error reporter gets the messages from the current Rhino parser.  private final ErrorReporter defaultErrorReporter =      RhinoErrorReporter.forNewRhino(this);  /** Error strings used for reporting JSErrors */  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(      \"JSC_OPTIMIZE_LOOP_ERROR\",      \"Exceeded max number of optimization iterations: {0}\");  public static final DiagnosticType MOTION_ITERATIONS_ERROR =      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",          \"Exceeded max number of code motion iterations: {0}\");  private static final long COMPILER_STACK_SIZE = 1048576L;  /**   * Logger for the whole com.google.javascript.jscomp domain -   * setting configuration for this logger affects all loggers   *  in other classes within the compiler.   */  private static final Logger logger =      Logger.getLogger(\"com.google.javascript.jscomp\");  private final PrintStream outStream;  private GlobalVarReferenceMap globalRefMap = null;  private volatile double progress = 0.0;  /**   * Creates a Compiler that reports errors and warnings to its logger.   */  public Compiler() {    this((PrintStream) null);  }  /**   * Creates n Compiler that reports errors and warnings to an output   * stream.   */  public Compiler(PrintStream stream) {    addChangeHandler(recentChange);    outStream = stream;  }  /**   * Creates a Compiler that uses a custom error manager.   */  public Compiler(ErrorManager errorManager) {    this();    setErrorManager(errorManager);  }  /**   * Sets the error manager.   *   * @param errorManager the error manager, it cannot be {@code null}   */  public void setErrorManager(ErrorManager errorManager) {    Preconditions.checkNotNull(        errorManager, \"the error manager cannot be null\");    this.errorManager = errorManager;  }  /**   * Creates a message formatter instance corresponding to the value of   * {@link CompilerOptions}.   */  private MessageFormatter createMessageFormatter() {    boolean colorize = options.shouldColorizeErrorOutput();    return options.errorFormat.toFormatter(this, colorize);  }  /**   * Initialize the compiler options. Only necessary if you're not doing   * a normal compile() job.   */  public void initOptions(CompilerOptions options) {    this.options = options;    if (errorManager == null) {      if (outStream == null) {        setErrorManager(            new LoggerErrorManager(createMessageFormatter(), logger));      } else {        PrintStreamErrorManager printer =            new PrintStreamErrorManager(createMessageFormatter(), outStream);        printer.setSummaryDetailLevel(options.summaryDetailLevel);        setErrorManager(printer);      }    }    // DiagnosticGroups override the plain checkTypes option.    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {      options.checkTypes = true;    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {      options.checkTypes = false;    } else if (!options.checkTypes) {      // If DiagnosticGroups did not override the plain checkTypes      // option, and checkTypes is enabled, then turn off the      // parser type warnings.      options.setWarningLevel(          DiagnosticGroup.forType(              RhinoErrorReporter.TYPE_PARSE_ERROR),          CheckLevel.OFF);    }    if (options.checkGlobalThisLevel.isOn() &&        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {      options.setWarningLevel(          DiagnosticGroups.GLOBAL_THIS,          options.checkGlobalThisLevel);    }    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {      options.setWarningLevel(          DiagnosticGroups.ES5_STRICT,          CheckLevel.ERROR);    }    // Initialize the warnings guard.    List<WarningsGuard> guards = Lists.newArrayList();    guards.add(        new SuppressDocWarningsGuard(            getDiagnosticGroups().getRegisteredGroups()));    guards.add(options.getWarningsGuard());    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);    // All passes must run the variable check. This synthesizes    // variables later so that the compiler doesn't crash. It also    // checks the externs file for validity. If you don't want to warn    // about missing variable declarations, we shut that specific    // error off.    if (!options.checkSymbols &&        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));    }    this.warningsGuard = composedGuards;  }  /**   * Initializes the instance state needed for a compile job.   */  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,      CompilerOptions options) {    init(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSSourceFile>newArrayList(inputs), options);  }  /**   * Initializes the instance state needed for a compile job.   */  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,      CompilerOptions options) {    JSModule module = new JSModule(SINGLETON_MODULE_NAME);    for (JSSourceFile input : inputs) {      module.add(input);    }    initModules(externs, Lists.newArrayList(module), options);  }  /**   * Initializes the instance state needed for a compile job if the sources   * are in modules.   */  public void init(JSSourceFile[] externs, JSModule[] modules,      CompilerOptions options) {    initModules(Lists.<JSSourceFile>newArrayList(externs),         Lists.<JSModule>newArrayList(modules), options);  }  /**   * Initializes the instance state needed for a compile job if the sources   * are in modules.   */  public void initModules(      List<JSSourceFile> externs, List<JSModule> modules,      CompilerOptions options) {    initOptions(options);    checkFirstModule(modules);    fillEmptyModules(modules);    this.externs = makeCompilerInput(externs, true);    // Generate the module graph, and report any errors in the module    // specification as errors.    this.modules = modules;    if (modules.size() > 1) {      try {        this.moduleGraph = new JSModuleGraph(modules);      } catch (JSModuleGraph.ModuleDependenceException e) {        // problems with the module format.  Report as an error.  The        // message gives all details.        report(JSError.make(MODULE_DEPENDENCY_ERROR,                e.getModule().getName(), e.getDependentModule().getName()));        return;      }    } else {      this.moduleGraph = null;    }    this.inputs = getAllInputsFromModules(modules);    initBasedOnOptions();    initInputsByIdMap();  }  /**   * Do any initialization that is dependent on the compiler options.   */  private void initBasedOnOptions() {    // Create the source map if necessary.    if (options.sourceMapOutputPath != null) {      sourceMap = options.sourceMapFormat.getInstance();      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);    }  }  private List<CompilerInput> makeCompilerInput(      List<JSSourceFile> files, boolean isExtern) {    List<CompilerInput> inputs = Lists.newArrayList();    for (JSSourceFile file : files) {      inputs.add(new CompilerInput(file, isExtern));    }    return inputs;  }  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",          \"At least one module must be provided\");  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",          \"Root module '{0}' must contain at least one source code input\");  /**   * Verifies that at least one module has been provided and that the first one   * has at least one source code input.   */  private void checkFirstModule(List<JSModule> modules) {    if (modules.isEmpty()) {      report(JSError.make(EMPTY_MODULE_LIST_ERROR));    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {      // The root module may only be empty if there is exactly 1 module.      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,          modules.get(0).getName()));    }  }  /**   * Empty modules get an empty \"fill\" file, so that we can move code into   * an empty module.   */  static String createFillFileName(String moduleName) {    return \"[\" + moduleName + \"]\";  }  /**   * Fill any empty modules with a place holder file. It makes any cross module   * motion easier.   */  private static void fillEmptyModules(List<JSModule> modules) {    for (JSModule module : modules) {      if (module.getInputs().isEmpty()) {        module.add(JSSourceFile.fromCode(            createFillFileName(module.getName()), \"\"));      }    }  }  /**   * Rebuilds the internal list of inputs by iterating over all modules.   * This is necessary if inputs have been added to or removed from a module   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.   */  public void rebuildInputsFromModules() {    inputs = getAllInputsFromModules(modules);    initInputsByIdMap();  }  /**   * Builds a single list of all module inputs. Verifies that it contains no   * duplicates.   */  private static List<CompilerInput> getAllInputsFromModules(      List<JSModule> modules) {    List<CompilerInput> inputs = Lists.newArrayList();    Map<String, JSModule> inputMap = Maps.newHashMap();    for (JSModule module : modules) {      for (CompilerInput input : module.getInputs()) {        String inputName = input.getName();        // NOTE(nicksantos): If an input is in more than one module,        // it will show up twice in the inputs list, and then we        // will get an error down the line.        inputs.add(input);        inputMap.put(inputName, module);      }    }    return inputs;  }  static final DiagnosticType DUPLICATE_INPUT =      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");  static final DiagnosticType DUPLICATE_EXTERN_INPUT =      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",          \"Duplicate extern input: {0}\");  /**   * Creates a map to make looking up an input by name fast. Also checks for   * duplicate inputs.   */  void initInputsByIdMap() {    inputsById = new HashMap<InputId, CompilerInput>();    for (CompilerInput input : externs) {      InputId id = input.getInputId();      CompilerInput previous = inputsById.put(id, input);      if (previous != null) {        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));      }    }    for (CompilerInput input : inputs) {      InputId id = input.getInputId();      CompilerInput previous = inputsById.put(id, input);      if (previous != null) {        report(JSError.make(DUPLICATE_INPUT, input.getName()));      }    }  }  public Result compile(      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {     return compile(extern, new JSSourceFile[] { input }, options);  }  public Result compile(      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options) {     return compile(new JSSourceFile[] { extern }, input, options);  }  public Result compile(      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {     return compile(new JSSourceFile[] { extern }, modules, options);  }  /**   * Compiles a list of inputs.   */  public Result compile(JSSourceFile[] externs,                        JSSourceFile[] inputs,                        CompilerOptions options) {    return compile(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSSourceFile>newArrayList(inputs),        options);  }  /**   * Compiles a list of inputs.   */  public Result compile(List<JSSourceFile> externs,      List<JSSourceFile> inputs, CompilerOptions options) {    // The compile method should only be called once.    Preconditions.checkState(jsRoot == null);    try {      init(externs, inputs, options);      if (hasErrors()) {        return getResult();      }      return compile();    } finally {      Tracer t = newTracer(\"generateReport\");      errorManager.generateReport();      stopTracer(t, \"generateReport\");    }  }  /**   * Compiles a list of modules.   */  public Result compile(JSSourceFile[] externs,                        JSModule[] modules,                        CompilerOptions options) {    return compileModules(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSModule>newArrayList(modules),        options);  }  /**   * Compiles a list of modules.   */  public Result compileModules(List<JSSourceFile> externs,      List<JSModule> modules, CompilerOptions options) {    // The compile method should only be called once.    Preconditions.checkState(jsRoot == null);    try {      initModules(externs, modules, options);      if (hasErrors()) {        return getResult();      }      return compile();    } finally {      Tracer t = newTracer(\"generateReport\");      errorManager.generateReport();      stopTracer(t, \"generateReport\");    }  }  private Result compile() {    return runInCompilerThread(new Callable<Result>() {      @Override      public Result call() throws Exception {        compileInternal();        return getResult();      }    });  }  /**   * Disable threads. This is for clients that run on AppEngine and   * don't have threads.   */  public void disableThreads() {    useThreads = false;  }  private <T> T runInCompilerThread(final Callable<T> callable) {    return runCallable(callable, useThreads, options.tracer.isOn());  }  static <T> T runCallableWithLargeStack(final Callable<T> callable) {    return runCallable(callable, true, false);  }  @SuppressWarnings(\"unchecked\")  static <T> T runCallable(      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {    // Under JRE 1.6, the jscompiler overflows the stack when running on some    // large or complex js code. Here we start a new thread with a larger    // stack in order to let the compiler do its thing, without having to    // increase the stack size for *every* thread (which is what -Xss does).    // Might want to add thread pool support for clients that compile a lot.    final boolean dumpTraceReport = trace;    final Object[] result = new Object[1];    final Throwable[] exception = new Throwable[1];    Runnable runnable = new Runnable() {      @Override      public void run() {        try {          if (dumpTraceReport) {            Tracer.initCurrentThreadTrace();          }          result[0] = callable.call();        } catch (Throwable e) {          exception[0] = e;        } finally {          if (dumpTraceReport) {            Tracer.logAndClearCurrentThreadTrace();          }        }      }    };    if (useLargeStackThread) {      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);      th.start();      while (true) {        try {          th.join();          break;        } catch (InterruptedException ignore) {          // ignore        }      }    } else {      runnable.run();    }    // Pass on any exception caught by the runnable object.    if (exception[0] != null) {      throw new RuntimeException(exception[0]);    }    return (T) result[0];  }  private void compileInternal() {    setProgress(0.0);    parse();    // 15 percent of the work is assumed to be for parsing (based on some    // minimal analysis on big JS projects, of course this depends on options)    setProgress(0.15);    if (hasErrors()) {      return;    }    if (!precheck()) {      return;    }    if (options.nameAnonymousFunctionsOnly) {      // TODO(nicksantos): Move this into an instrument() phase maybe?      check();      return;    }    if (!options.skipAllPasses) {      check();      if (hasErrors()) {        return;      }      if (options.isExternExportsEnabled()          || options.externExportsPath != null) {        externExports();      }      // IDE-mode is defined to stop here, before the heavy rewriting begins.      if (!options.ideMode) {        optimize();      }    }    if (options.recordFunctionInformation) {      recordFunctionInformation();    }    if (options.devMode == DevMode.START_AND_END) {      runSanityCheck();    }    setProgress(1.0);  }  public void parse() {    parseInputs();  }  PassConfig getPassConfig() {    if (passes == null) {      passes = createPassConfigInternal();    }    return passes;  }  /**   * Create the passes object. Clients should use setPassConfig instead of   * overriding this.   */  PassConfig createPassConfigInternal() {    return new DefaultPassConfig(options);  }  /**   * @param passes The PassConfig to use with this Compiler.   * @throws NullPointerException if passes is null   * @throws IllegalStateException if this.passes has already been assigned   */  public void setPassConfig(PassConfig passes) {    // Important to check for null because if setPassConfig(null) is    // called before this.passes is set, getPassConfig() will create a    // new PassConfig object and use that, which is probably not what    // the client wanted since he or she probably meant to use their    // own PassConfig object.    Preconditions.checkNotNull(passes);    if (this.passes != null) {      throw new IllegalStateException(\"this.passes has already been assigned\");    }    this.passes = passes;  }  /**   * Carry out any special checks or procedures that need to be done before   * proceeding with rest of the compilation process.   *   * @return true, to continue with compilation   */  boolean precheck() {    return true;  }  public void check() {    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);    // We are currently only interested in check-passes for progress reporting    // as it is used for IDEs, that's why the maximum progress is set to 1.0.    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));    if (options.devMode == DevMode.EVERY_PASS) {      phaseOptimizer.setSanityCheck(sanityCheck);    }    phaseOptimizer.consume(getPassConfig().getChecks());    phaseOptimizer.process(externsRoot, jsRoot);    if (hasErrors()) {      return;    }    // TODO(nicksantos): clean this up. The flow here is too hard to follow.    if (options.nameAnonymousFunctionsOnly) {      return;    }    if (options.removeTryCatchFinally) {      removeTryCatchFinally();    }    if (options.getTweakProcessing().shouldStrip() ||        !options.stripTypes.isEmpty() ||        !options.stripNameSuffixes.isEmpty() ||        !options.stripTypePrefixes.isEmpty() ||        !options.stripNamePrefixes.isEmpty()) {      stripCode(options.stripTypes, options.stripNameSuffixes,          options.stripTypePrefixes, options.stripNamePrefixes);    }    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);  }  private void externExports() {    logger.fine(\"Creating extern file for exports\");    startPass(\"externExports\");    ExternExportsPass pass = new ExternExportsPass(this);    process(pass);    externExports = pass.getGeneratedExterns();    endPass();  }  @Override  void process(CompilerPass p) {    p.process(externsRoot, jsRoot);  }  private final PassFactory sanityCheck =      new PassFactory(\"sanityCheck\", false) {    @Override    protected CompilerPass createInternal(AbstractCompiler compiler) {      return new SanityCheck(compiler);    }  };  private void maybeSanityCheck() {    if (options.devMode == DevMode.EVERY_PASS) {      runSanityCheck();    }  }  private void runSanityCheck() {    sanityCheck.create(this).process(externsRoot, jsRoot);  }  /**   * Removes try/catch/finally statements for easier debugging.   */  void removeTryCatchFinally() {    logger.fine(\"Remove try/catch/finally\");    startPass(\"removeTryCatchFinally\");    RemoveTryCatch r = new RemoveTryCatch(this);    process(r);    endPass();  }  /**   * Strips code for smaller compiled code. This is useful for removing debug   * statements to prevent leaking them publicly.   */  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {    logger.fine(\"Strip code\");    startPass(\"stripCode\");    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,        stripTypePrefixes, stripNamePrefixes);    if (options.getTweakProcessing().shouldStrip()) {      r.enableTweakStripping();    }    process(r);    endPass();  }  /**   * Runs custom passes that are designated to run at a particular time.   */  private void runCustomPasses(CustomPassExecutionTime executionTime) {    if (options.customPasses != null) {      Tracer t = newTracer(\"runCustomPasses\");      try {        for (CompilerPass p : options.customPasses.get(executionTime)) {          process(p);        }      } finally {        stopTracer(t, \"runCustomPasses\");      }    }  }  private Tracer currentTracer = null;  private String currentPassName = null;  /**   * Marks the beginning of a pass.   */  void startPass(String passName) {    Preconditions.checkState(currentTracer == null);    currentPassName = passName;    currentTracer = newTracer(passName);  }  /**   * Marks the end of a pass.   */  void endPass() {    Preconditions.checkState(currentTracer != null,        \"Tracer should not be null at the end of a pass.\");    stopTracer(currentTracer, currentPassName);    String passToCheck = currentPassName;    currentPassName = null;    currentTracer = null;    maybeSanityCheck();  }  /**   * Returns a new tracer for the given pass name.   */  Tracer newTracer(String passName) {    String comment = passName        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");    if (options.tracer.isOn()) {      tracker.recordPassStart(passName);    }    return new Tracer(\"Compiler\", comment);  }  void stopTracer(Tracer t, String passName) {    long result = t.stop();    if (options.tracer.isOn()) {      tracker.recordPassStop(passName, result);    }  }  /**   * Returns the result of the compilation.   */  public Result getResult() {    PassConfig.State state = getPassConfig().getIntermediateState();    return new Result(getErrors(), getWarnings(), debugLog.toString(),        state.variableMap, state.propertyMap,        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,        sourceMap, externExports, state.cssNames, state.idGeneratorMap);  }  /**   * Returns an array constructed from errors + temporary warnings.   */  public JSError[] getMessages() {    return getErrors();  }  /**   * Returns the array of errors (never null).   */  public JSError[] getErrors() {    return errorManager.getErrors();  }  /**   * Returns the array of warnings (never null).   */  public JSError[] getWarnings() {    return errorManager.getWarnings();  }  @Override  public Node getRoot() {    return externAndJsRoot;  }  /**   * Creates a new id for making unique names.   */  private int nextUniqueNameId() {    return uniqueNameId++;  }  /**   * Resets the unique name id counter   */  @VisibleForTesting  void resetUniqueNameId() {    uniqueNameId = 0;  }  @Override  Supplier<String> getUniqueNameIdSupplier() {    final Compiler self = this;    return new Supplier<String>() {      @Override      public String get() {        return String.valueOf(self.nextUniqueNameId());      }    };  }  @Override  boolean areNodesEqualForInlining(Node n1, Node n2) {    if (options.ambiguateProperties ||        options.disambiguateProperties) {      // The type based optimizations require that type information is preserved      // during other optimizations.      return n1.isEquivalentToTyped(n2);    } else {      return n1.isEquivalentTo(n2);    }  }  //------------------------------------------------------------------------  // Inputs  //------------------------------------------------------------------------  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler  // interface, and which ones should always be injected.  @Override  public CompilerInput getInput(InputId id) {    return inputsById.get(id);  }  /**   * Removes an input file from AST.   * @param id The id of the input to be removed.   */  protected void removeExternInput(InputId id) {    CompilerInput input = getInput(id);    if (input == null) {      return;    }    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());    inputsById.remove(id);    externs.remove(input);    Node root = input.getAstRoot(this);    if (root != null) {      root.detachFromParent();    }  }  @Override  public CompilerInput newExternInput(String name) {    SourceAst ast = new SyntheticAst(name);    if (inputsById.containsKey(ast.getInputId())) {      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);    }    CompilerInput input = new CompilerInput(ast, true);    inputsById.put(input.getInputId(), input);    externsRoot.addChildToFront(ast.getAstRoot(this));    externs.add(0, input);    return input;  }  /** Add a source input dynamically. Intended for incremental compilation. */  void addIncrementalSourceAst(JsAst ast) {    InputId id = ast.getInputId();    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());    inputsById.put(id, new CompilerInput(ast));  }  /**   * Replace a source input dynamically. Intended for incremental   * re-compilation.   *   * If the new source input doesn't parse, then keep the old input   * in the AST and return false.   *   * @return Whether the new AST was attached successfully.   */  boolean replaceIncrementalSourceAst(JsAst ast) {    CompilerInput oldInput = getInput(ast.getInputId());    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());    Node newRoot = ast.getAstRoot(this);    if (newRoot == null) {      return false;    }    Node oldRoot = oldInput.getAstRoot(this);    if (oldRoot != null) {      oldRoot.getParent().replaceChild(oldRoot, newRoot);    } else {      getRoot().getLastChild().addChildToBack(newRoot);    }    CompilerInput newInput = new CompilerInput(ast);    inputsById.put(ast.getInputId(), newInput);    JSModule module = oldInput.getModule();    if (module != null) {      module.addAfter(newInput, oldInput);      module.remove(oldInput);    }    // Verify the input id is set properly.    Preconditions.checkState(        newInput.getInputId().equals(oldInput.getInputId()));    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));    inputs.remove(oldInput);    return true;  }  /**   * Add a new source input dynamically. Intended for incremental compilation.   * <p>   * If the new source input doesn't parse, it will not be added, and a false   * will be returned.   *   * @param ast the JS Source to add.   * @return true if the source was added successfully, false otherwise.   * @throws IllegalStateException if an input for this ast already exists.   */  boolean addNewSourceAst(JsAst ast) {    CompilerInput oldInput = getInput(ast.getInputId());    if (oldInput != null) {      throw new IllegalStateException(          \"Input already exists: \" + ast.getInputId().getIdName());    }    Node newRoot = ast.getAstRoot(this);    if (newRoot == null) {      return false;    }    getRoot().getLastChild().addChildToBack(newRoot);    CompilerInput newInput = new CompilerInput(ast);    // TODO(tylerg): handle this for multiple modules at some point.    if (moduleGraph == null && !modules.isEmpty()) {      // singleton module      modules.get(0).add(newInput);    }    inputsById.put(ast.getInputId(), newInput);    return true;  }  @Override  JSModuleGraph getModuleGraph() {    return moduleGraph;  }  /**   * Gets a module graph. This will always return a module graph, even   * in the degenerate case when there's only one module.   */  JSModuleGraph getDegenerateModuleGraph() {    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;  }  @Override  public JSTypeRegistry getTypeRegistry() {    if (typeRegistry == null) {      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);    }    return typeRegistry;  }  @Override  public MemoizedScopeCreator getTypedScopeCreator() {    return getPassConfig().getTypedScopeCreator();  }  @SuppressWarnings(\"unchecked\")  DefaultPassConfig ensureDefaultPassConfig() {    PassConfig passes = getPassConfig().getBasePassConfig();    Preconditions.checkState(passes instanceof DefaultPassConfig,        \"PassConfigs must eventually delegate to the DefaultPassConfig\");    return (DefaultPassConfig) passes;  }  public SymbolTable buildKnownSymbolTable() {    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();    if (typedScopeCreator != null) {      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());      symbolTable.addSymbolsFrom(typedScopeCreator);    } else {      symbolTable.findScopes(this, externsRoot, jsRoot);    }    GlobalNamespace globalNamespace =        ensureDefaultPassConfig().getGlobalNamespace();    if (globalNamespace != null) {      symbolTable.addSymbolsFrom(globalNamespace);    }    ReferenceCollectingCallback refCollector =        new ReferenceCollectingCallback(            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);    NodeTraversal.traverse(this, getRoot(), refCollector);    symbolTable.addSymbolsFrom(refCollector);    PreprocessorSymbolTable preprocessorSymbolTable =        ensureDefaultPassConfig().getPreprocessorSymbolTable();    if (preprocessorSymbolTable != null) {      symbolTable.addSymbolsFrom(preprocessorSymbolTable);    }    symbolTable.fillNamespaceReferences();    symbolTable.fillPropertyScopes();    symbolTable.fillThisReferences(this, externsRoot, jsRoot);    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);    return symbolTable;  }  @Override  public Scope getTopScope() {    return getPassConfig().getTopScope();  }  @Override  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {    if (abstractInterpreter == null) {      ChainableReverseAbstractInterpreter interpreter =          new SemanticReverseAbstractInterpreter(              getCodingConvention(), getTypeRegistry());      if (options.closurePass) {        interpreter = new ClosureReverseAbstractInterpreter(            getCodingConvention(), getTypeRegistry())            .append(interpreter).getFirst();      }      abstractInterpreter = interpreter;    }    return abstractInterpreter;  }  @Override  TypeValidator getTypeValidator() {    if (typeValidator == null) {      typeValidator = new TypeValidator(this);    }    return typeValidator;  }  //------------------------------------------------------------------------  // Parsing  //------------------------------------------------------------------------  /**   * Parses the externs and main inputs.   *   * @return A synthetic root node whose two children are the externs root   *     and the main root   */  Node parseInputs() {    boolean devMode = options.devMode != DevMode.OFF;    // If old roots exist (we are parsing a second time), detach each of the    // individual file parse trees.    if (externsRoot != null) {      externsRoot.detachChildren();    }    if (jsRoot != null) {      jsRoot.detachChildren();    }    // Parse main js sources.    jsRoot = IR.block();    jsRoot.setIsSyntheticBlock(true);    externsRoot = IR.block();    externsRoot.setIsSyntheticBlock(true);    externAndJsRoot = IR.block(externsRoot, jsRoot);    externAndJsRoot.setIsSyntheticBlock(true);    if (options.tracer.isOn()) {      tracker = new PerformanceTracker(jsRoot,          options.tracer == TracerMode.ALL);      addChangeHandler(tracker.getCodeChangeHandler());    }    Tracer tracer = newTracer(\"parseInputs\");    try {      // Parse externs sources.      for (CompilerInput input : externs) {        Node n = input.getAstRoot(this);        if (hasErrors()) {          return null;        }        externsRoot.addChildToBack(n);      }      // Modules inferred in ProcessCommonJS pass.      if (options.transformAMDToCJSModules || options.processCommonJSModules) {        processAMDAndCommonJSModules();      }      // Check if the sources need to be re-ordered.      if (options.dependencyOptions.needsManagement()) {        for (CompilerInput input : inputs) {          input.setCompiler(this);          // Forward-declare all the provided types, so that they          // are not flagged even if they are dropped from the process.          for (String provide : input.getProvides()) {            getTypeRegistry().forwardDeclareType(provide);          }        }        try {          inputs =              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)              .manageDependencies(options.dependencyOptions, inputs);        } catch (CircularDependencyException e) {          report(JSError.make(              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));          // If in IDE mode, we ignore the error and keep going.          if (hasErrors()) {            return null;          }        } catch (MissingProvideException e) {          report(JSError.make(              MISSING_ENTRY_ERROR, e.getMessage()));          // If in IDE mode, we ignore the error and keep going.          if (hasErrors()) {            return null;          }        }      }      // Check if inputs need to be rebuilt from modules.      boolean staleInputs = false;      for (CompilerInput input : inputs) {        Node n = input.getAstRoot(this);        // Inputs can have a null AST during initial parse.        if (n == null) {          continue;        }        if (n.getJSDocInfo() != null) {          JSDocInfo info = n.getJSDocInfo();          if (info.isExterns()) {            // If the input file is explicitly marked as an externs file, then            // assume the programmer made a mistake and throw it into            // the externs pile anyways.            externsRoot.addChildToBack(n);            input.setIsExtern(true);            input.getModule().remove(input);            externs.add(input);            staleInputs = true;          } else if (info.isNoCompile()) {            input.getModule().remove(input);            staleInputs = true;          }        }      }      if (staleInputs) {        fillEmptyModules(modules);        rebuildInputsFromModules();      }      // Build the AST.      for (CompilerInput input : inputs) {        Node n = input.getAstRoot(this);        if (n == null) {          continue;        }        if (devMode) {          runSanityCheck();          if (hasErrors()) {            return null;          }        }        if (options.sourceMapOutputPath != null ||            options.nameReferenceReportPath != null) {          // Annotate the nodes in the tree with information from the          // input file. This information is used to construct the SourceMap.          SourceInformationAnnotator sia =              new SourceInformationAnnotator(                  input.getName(), options.devMode != DevMode.OFF);          NodeTraversal.traverse(this, n, sia);        }        jsRoot.addChildToBack(n);      }      if (hasErrors()) {        return null;      }      return externAndJsRoot;    } finally {      stopTracer(tracer, \"parseInputs\");    }  }  /**   * Transforms AMD and CJS modules to something closure compiler can   * process and creates JSModules and the corresponding dependency tree   * on the way.   */  private void processAMDAndCommonJSModules() {    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();    // TODO(nicksantos): Refactor module dependency resolution to work nicely    // with multiple ways to express dependencies. Directly support JSModules    // that are equivalent to a signal file and which express their deps    // directly in the source.    for (CompilerInput input : inputs) {      input.setCompiler(this);      Node root = input.getAstRoot(this);      if (root == null) {        continue;      }      if (options.transformAMDToCJSModules) {        new TransformAMDToCJSModule(this).process(null, root);      }      if (options.processCommonJSModules) {        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,            options.commonJSModulePathPrefix);        cjs.process(null, root);        JSModule m = cjs.getModule();        if (m != null) {          modulesByName.put(m.getName(), m);          modulesByInput.put(input, m);        }      }    }    if (options.processCommonJSModules) {      List<JSModule> modules = Lists.newArrayList(modulesByName.values());      if (!modules.isEmpty()) {        this.modules = modules;        this.moduleGraph = new JSModuleGraph(this.modules);      }      for (JSModule module : modules) {        for (CompilerInput input : module.getInputs()) {          for (String require : input.getRequires()) {            module.addDependency(modulesByName.get(require));          }        }      }      try {        modules = Lists.newArrayList();        for (CompilerInput input : this.moduleGraph.manageDependencies(            options.dependencyOptions, inputs)) {          modules.add(modulesByInput.get(input));        }        this.modules = modules;        this.moduleGraph = new JSModuleGraph(modules);      } catch (Exception e) {        Throwables.propagate(e);      }    }  }  public Node parse(JSSourceFile file) {    initCompilerOptionsIfTesting();    addToDebugLog(\"Parsing: \" + file.getName());    return new JsAst(file).getAstRoot(this);  }  private int syntheticCodeId = 0;  @Override  Node parseSyntheticCode(String js) {    CompilerInput input = new CompilerInput(        JSSourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));    inputsById.put(input.getInputId(), input);    return input.getAstRoot(this);  }  /**   * Allow subclasses to override the default CompileOptions object.   */  protected CompilerOptions newCompilerOptions() {    return new CompilerOptions();  }  void initCompilerOptionsIfTesting() {    if (options == null) {      // initialization for tests that don't initialize the compiler      // by the normal mechanisms.      initOptions(newCompilerOptions());    }  }  @Override  Node parseSyntheticCode(String fileName, String js) {    initCompilerOptionsIfTesting();    return parse(JSSourceFile.fromCode(fileName, js));  }  @Override  Node parseTestCode(String js) {    initCompilerOptionsIfTesting();    CompilerInput input = new CompilerInput(        JSSourceFile.fromCode(\" [testcode] \", js));    if (inputsById == null) {      inputsById = Maps.newHashMap();    }    inputsById.put(input.getInputId(), input);    return input.getAstRoot(this);  }  @Override  ErrorReporter getDefaultErrorReporter() {    return defaultErrorReporter;  }  //------------------------------------------------------------------------  // Convert back to source code  //------------------------------------------------------------------------  /**   * Converts the main parse tree back to js code.   */  public String toSource() {    return runInCompilerThread(new Callable<String>() {      @Override      public String call() throws Exception {        Tracer tracer = newTracer(\"toSource\");        try {          CodeBuilder cb = new CodeBuilder();          if (jsRoot != null) {            int i = 0;            for (Node scriptNode = jsRoot.getFirstChild();                 scriptNode != null;                 scriptNode = scriptNode.getNext()) {              toSource(cb, i++, scriptNode);            }          }          return cb.toString();        } finally {          stopTracer(tracer, \"toSource\");        }      }    });  }  /**   * Converts the parse tree for each input back to js code.   */  public String[] toSourceArray() {    return runInCompilerThread(new Callable<String[]>() {      @Override      public String[] call() throws Exception {        Tracer tracer = newTracer(\"toSourceArray\");        try {          int numInputs = inputs.size();          String[] sources = new String[numInputs];          CodeBuilder cb = new CodeBuilder();          for (int i = 0; i < numInputs; i++) {            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);            cb.reset();            toSource(cb, i, scriptNode);            sources[i] = cb.toString();          }          return sources;        } finally {          stopTracer(tracer, \"toSourceArray\");        }      }    });  }  /**   * Converts the parse tree for a module back to js code.   */  public String toSource(final JSModule module) {    return runInCompilerThread(new Callable<String>() {      @Override      public String call() throws Exception {        List<CompilerInput> inputs = module.getInputs();        int numInputs = inputs.size();        if (numInputs == 0) {          return \"\";        }        CodeBuilder cb = new CodeBuilder();        for (int i = 0; i < numInputs; i++) {          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);          if (scriptNode == null) {            throw new IllegalArgumentException(                \"Bad module: \" + module.getName());          }          toSource(cb, i, scriptNode);        }        return cb.toString();      }    });  }  /**   * Converts the parse tree for each input in a module back to js code.   */  public String[] toSourceArray(final JSModule module) {    return runInCompilerThread(new Callable<String[]>() {      @Override      public String[] call() throws Exception {        List<CompilerInput> inputs = module.getInputs();        int numInputs = inputs.size();        if (numInputs == 0) {          return new String[0];        }        String[] sources = new String[numInputs];        CodeBuilder cb = new CodeBuilder();        for (int i = 0; i < numInputs; i++) {          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);          if (scriptNode == null) {            throw new IllegalArgumentException(                \"Bad module input: \" + inputs.get(i).getName());          }          cb.reset();          toSource(cb, i, scriptNode);          sources[i] = cb.toString();        }        return sources;      }    });  }  /**   * Writes out js code from a root node. If printing input delimiters, this   * method will attach a comment to the start of the text indicating which   * input the output derived from. If there were any preserve annotations   * within the root's source, they will also be printed in a block comment   * at the beginning of the output.   */  public void toSource(final CodeBuilder cb,                       final int inputSeqNum,                       final Node root) {    runInCompilerThread(new Callable<Void>() {      @Override      public Void call() throws Exception {        if (options.printInputDelimiter) {          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {            cb.append(\"\\n\");  // Make sure that the label starts on a new line          }          Preconditions.checkState(root.isScript());          String delimiter = options.inputDelimiter;          String inputName = root.getInputId().getIdName();          String sourceName = root.getSourceFileName();          Preconditions.checkState(sourceName != null);          Preconditions.checkState(!sourceName.isEmpty());          delimiter = delimiter              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));          cb.append(delimiter)            .append(\"\\n\");        }        if (root.getJSDocInfo() != null &&            root.getJSDocInfo().getLicense() != null) {          cb.append(\"/*\\n\")            .append(root.getJSDocInfo().getLicense())            .append(\"*/\\n\");        }        // If there is a valid source map, then indicate to it that the current        // root node's mappings are offset by the given string builder buffer.        if (options.sourceMapOutputPath != null) {          sourceMap.setStartingPosition(              cb.getLineIndex(), cb.getColumnIndex());        }        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'        // for the first input file        String code = toSource(root, sourceMap, inputSeqNum == 0);        if (!code.isEmpty()) {          cb.append(code);          // In order to avoid parse ambiguity when files are concatenated          // together, all files should end in a semi-colon. Do a quick          // heuristic check if there's an obvious semi-colon already there.          int length = code.length();          char lastChar = code.charAt(length - 1);          char secondLastChar = length >= 2 ?              code.charAt(length - 2) : '\\0';          boolean hasSemiColon = lastChar == ';' ||              (lastChar == '\\n' && secondLastChar == ';');          if (!hasSemiColon) {            cb.append(\";\");          }        }        return null;      }    });  }  /**   * Generates JavaScript source code for an AST, doesn't generate source   * map info.   */  @Override  String toSource(Node n) {    initCompilerOptionsIfTesting();    return toSource(n, null, true);  }  /**   * Generates JavaScript source code for an AST.   */  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {    CodePrinter.Builder builder = new CodePrinter.Builder(n);    builder.setPrettyPrint(options.prettyPrint);    builder.setLineBreak(options.lineBreak);    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);    builder.setSourceMap(sourceMap);    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);    builder.setTagAsStrict(firstOutput &&        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);    builder.setLineLengthThreshold(options.lineLengthThreshold);    Charset charset = options.outputCharset != null ?        Charset.forName(options.outputCharset) : null;    builder.setOutputCharset(charset);    return builder.build();  }  /**   * Stores a buffer of text to which more can be appended.  This is just like a   * StringBuilder except that we also track the number of lines.   */  public static class CodeBuilder {    private final StringBuilder sb = new StringBuilder();    private int lineCount = 0;    private int colCount = 0;    /** Removes all text, but leaves the line count unchanged. */    void reset() {      sb.setLength(0);    }    /** Appends the given string to the text buffer. */    CodeBuilder append(String str) {      sb.append(str);      // Adjust the line and column information for the new text.      int index = -1;      int lastIndex = index;      while ((index = str.indexOf('\\n', index + 1)) >= 0) {        ++lineCount;        lastIndex = index;      }      if (lastIndex == -1) {        // No new lines, append the new characters added.        colCount += str.length();      } else {        colCount = str.length() - (lastIndex + 1);      }      return this;    }    /** Returns all text in the text buffer. */    @Override    public String toString() {      return sb.toString();    }    /** Returns the length of the text buffer. */    public int getLength() {      return sb.length();    }    /** Returns the (zero-based) index of the last line in the text buffer. */    int getLineIndex() {      return lineCount;    }    /** Returns the (zero-based) index of the last column in the text buffer. */    int getColumnIndex() {      return colCount;    }    /** Determines whether the text ends with the given suffix. */    boolean endsWith(String suffix) {      return (sb.length() > suffix.length())          && suffix.equals(sb.substring(sb.length() - suffix.length()));    }  }  //------------------------------------------------------------------------  // Optimizations  //------------------------------------------------------------------------  public void optimize() {    // Ideally, this pass should be the first pass run, however:    // 1) VariableReferenceCheck reports unexpected warnings if Normalize    // is done first.    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on    // unmodified local names.    normalize();    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);    if (options.devMode == DevMode.EVERY_PASS) {      phaseOptimizer.setSanityCheck(sanityCheck);    }    phaseOptimizer.consume(getPassConfig().getOptimizations());    phaseOptimizer.process(externsRoot, jsRoot);    if (hasErrors()) {      return;    }  }  @Override  void setCssRenamingMap(CssRenamingMap map) {    options.cssRenamingMap = map;  }  @Override  CssRenamingMap getCssRenamingMap() {    return options.cssRenamingMap;  }  /**   * Reprocesses the current defines over the AST.  This is used by GwtCompiler   * to generate N outputs for different targets from the same (checked) AST.   * For each target, we apply the target-specific defines by calling   * {@code processDefines} and then {@code optimize} to optimize the AST   * specifically for that target.   */  public void processDefines() {    (new DefaultPassConfig(options)).processDefines.create(this)        .process(externsRoot, jsRoot);  }  boolean isInliningForbidden() {    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||        options.propertyRenaming ==            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;  }  /** Control Flow Analysis. */  ControlFlowGraph<Node> computeCFG() {    logger.fine(\"Computing Control Flow Graph\");    Tracer tracer = newTracer(\"computeCFG\");    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);    process(cfa);    stopTracer(tracer, \"computeCFG\");    return cfa.getCfg();  }  public void normalize() {    logger.fine(\"Normalizing\");    startPass(\"normalize\");    process(new Normalize(this, false));    endPass();  }  @Override  void prepareAst(Node root) {    CompilerPass pass = new PrepareAst(this);    pass.process(null, root);  }  void recordFunctionInformation() {    logger.fine(\"Recording function information\");    startPass(\"recordFunctionInformation\");    RecordFunctionInformation recordFunctionInfoPass =        new RecordFunctionInformation(            this, getPassConfig().getIntermediateState().functionNames);    process(recordFunctionInfoPass);    functionInformationMap = recordFunctionInfoPass.getMap();    endPass();  }  protected final CodeChangeHandler.RecentChange recentChange =      new CodeChangeHandler.RecentChange();  private final List<CodeChangeHandler> codeChangeHandlers =      Lists.<CodeChangeHandler>newArrayList();  /** Name of the synthetic input that holds synthesized externs. */  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";  private CompilerInput synthesizedExternsInput = null;  @Override  void addChangeHandler(CodeChangeHandler handler) {    codeChangeHandlers.add(handler);  }  @Override  void removeChangeHandler(CodeChangeHandler handler) {    codeChangeHandlers.remove(handler);  }  /**   * All passes should call reportCodeChange() when they alter   * the JS tree structure. This is verified by CompilerTestCase.   * This allows us to optimize to a fixed point.   */  @Override  public void reportCodeChange() {    for (CodeChangeHandler handler : codeChangeHandlers) {      handler.reportChange();    }  }  @Override  public CodingConvention getCodingConvention() {    CodingConvention convention = options.getCodingConvention();    convention = convention != null ? convention : defaultCodingConvention;    return convention;  }  @Override  public boolean isIdeMode() {    return options.ideMode;  }  @Override  public boolean acceptEcmaScript5() {    switch (options.getLanguageIn()) {      case ECMASCRIPT5:      case ECMASCRIPT5_STRICT:        return true;    }    return false;  }  public LanguageMode languageMode() {    return options.getLanguageIn();  }  @Override  public boolean acceptConstKeyword() {    return options.acceptConstKeyword;  }  @Override  Config getParserConfig() {    if (parserConfig == null) {      Config.LanguageMode mode;      switch (options.getLanguageIn()) {        case ECMASCRIPT3:          mode = Config.LanguageMode.ECMASCRIPT3;          break;        case ECMASCRIPT5:          mode = Config.LanguageMode.ECMASCRIPT5;          break;        case ECMASCRIPT5_STRICT:          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;          break;        default:          throw new IllegalStateException(\"unexpected language mode\");      }      parserConfig = ParserRunner.createConfig(        isIdeMode(),        mode,        acceptConstKeyword(),        options.extraAnnotationNames);    }    return parserConfig;  }  @Override  public boolean isTypeCheckingEnabled() {    return options.checkTypes;  }  //------------------------------------------------------------------------  // Error reporting  //------------------------------------------------------------------------  /**   * The warning classes that are available from the command-line, and   * are suppressable by the {@code @suppress} annotation.   */  protected DiagnosticGroups getDiagnosticGroups() {    return new DiagnosticGroups();  }  @Override  public void report(JSError error) {    CheckLevel level = error.level;    if (warningsGuard != null) {      CheckLevel newLevel = warningsGuard.level(error);      if (newLevel != null) {        level = newLevel;      }    }    if (level.isOn()) {      errorManager.report(level, error);    }  }  @Override  public CheckLevel getErrorLevel(JSError error) {    Preconditions.checkNotNull(options);    return warningsGuard.level(error);  }  /**   * Report an internal error.   */  @Override  void throwInternalError(String message, Exception cause) {    String finalMessage =      \"INTERNAL COMPILER ERROR.\\n\" +      \"Please report this problem.\\n\" + message;    RuntimeException e = new RuntimeException(finalMessage, cause);    if (cause != null) {      e.setStackTrace(cause.getStackTrace());    }    throw e;  }  /**   * Gets the number of errors.   */  public int getErrorCount() {    return errorManager.getErrorCount();  }  /**   * Gets the number of warnings.   */  public int getWarningCount() {    return errorManager.getWarningCount();  }  @Override  boolean hasHaltingErrors() {    return !isIdeMode() && getErrorCount() > 0;  }  /**   * Consults the {@link ErrorManager} to see if we've encountered errors   * that should halt compilation. <p>   *   * If {@link CompilerOptions#ideMode} is {@code true}, this function   * always returns {@code false} without consulting the error manager. The   * error manager will continue to be told about new errors and warnings, but   * the compiler will complete compilation of all inputs.<p>   */  public boolean hasErrors() {    return hasHaltingErrors();  }  /** Called from the compiler passes, adds debug info */  @Override  void addToDebugLog(String str) {    debugLog.append(str);    debugLog.append('\\n');    logger.fine(str);  }  private SourceFile getSourceFileByName(String sourceName) {    // Here we assume that the source name is the input name, this    // is try of javascript parsed from source.    if (sourceName != null) {      CompilerInput input = inputsById.get(new InputId(sourceName));      if (input != null) {        return input.getSourceFile();      }    }    return null;  }  @Override  public String getSourceLine(String sourceName, int lineNumber) {    if (lineNumber < 1) {      return null;    }    SourceFile input = getSourceFileByName(sourceName);    if (input != null) {      return input.getLine(lineNumber);    }    return null;  }  @Override  public Region getSourceRegion(String sourceName, int lineNumber) {    if (lineNumber < 1) {      return null;    }    SourceFile input = getSourceFileByName(sourceName);    if (input != null) {      return input.getRegion(lineNumber);    }    return null;  }  //------------------------------------------------------------------------  // Package-private helpers  //------------------------------------------------------------------------  @Override  Node getNodeForCodeInsertion(JSModule module) {    if (module == null) {      if (inputs.isEmpty()) {        throw new IllegalStateException(\"No inputs\");      }      return inputs.get(0).getAstRoot(this);    }    List<CompilerInput> moduleInputs = module.getInputs();    if (moduleInputs.size() > 0) {      return moduleInputs.get(0).getAstRoot(this);    }    throw new IllegalStateException(\"Root module has no inputs\");  }  public SourceMap getSourceMap() {    return sourceMap;  }  VariableMap getVariableMap() {    return getPassConfig().getIntermediateState().variableMap;  }  VariableMap getPropertyMap() {    return getPassConfig().getIntermediateState().propertyMap;  }  CompilerOptions getOptions() {    return options;  }  FunctionInformationMap getFunctionalInformationMap() {    return functionInformationMap;  }  /**   * Sets the logging level for the com.google.javascript.jscomp package.   */  public static void setLoggingLevel(Level level) {    logger.setLevel(level);  }  /** Gets the DOT graph of the AST generated at the end of compilation. */  public String getAstDotGraph() throws IOException {    if (jsRoot != null) {      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);      cfa.process(null, jsRoot);      return DotFormatter.toDot(jsRoot, cfa.getCfg());    } else {      return \"\";    }  }  @Override  public ErrorManager getErrorManager() {    if (options == null) {      initOptions(newCompilerOptions());    }    return errorManager;  }  @Override  List<CompilerInput> getInputsInOrder() {    return Collections.<CompilerInput>unmodifiableList(inputs);  }  /**   * Returns an unmodifiable view of the compiler inputs indexed by id.   */  public Map<InputId, CompilerInput> getInputsById() {    return Collections.unmodifiableMap(inputsById);  }  /**   * Gets the externs in the order in which they are being processed.   */  List<CompilerInput> getExternsInOrder() {    return Collections.<CompilerInput>unmodifiableList(externs);  }  /**   * Stores the internal compiler state just before optimization is performed.   * This can be saved and restored in order to efficiently optimize multiple   * different output targets without having to perform checking multiple times.   *   * NOTE: This does not include all parts of the compiler's internal state. In   * particular, JSSourceFiles and CompilerOptions are not recorded. In   * order to recreate a Compiler instance from scratch, you would need to   * call {@code init} with the same arguments as in the initial creation before   * restoring intermediate state.   */  public static class IntermediateState implements Serializable {    private static final long serialVersionUID = 1L;    Node externsRoot;    private Node jsRoot;    private List<CompilerInput> externs;    private List<CompilerInput> inputs;    private List<JSModule> modules;    private PassConfig.State passConfigState;    private JSTypeRegistry typeRegistry;    private AbstractCompiler.LifeCycleStage lifeCycleStage;    private IntermediateState() {}  }  /**   * Returns the current internal state, excluding the input files and modules.   */  public IntermediateState getState() {    IntermediateState state = new IntermediateState();    state.externsRoot = externsRoot;    state.jsRoot = jsRoot;    state.externs = externs;    state.inputs = inputs;    state.modules = modules;    state.passConfigState = getPassConfig().getIntermediateState();    state.typeRegistry = typeRegistry;    state.lifeCycleStage = getLifeCycleStage();    return state;  }  /**   * Sets the internal state to the capture given.  Note that this assumes that   * the input files are already set up.   */  public void setState(IntermediateState state) {    externsRoot = state.externsRoot;    jsRoot = state.jsRoot;    externs = state.externs;    inputs = state.inputs;    modules = state.modules;    passes = createPassConfigInternal();    getPassConfig().setIntermediateState(state.passConfigState);    typeRegistry = state.typeRegistry;    setLifeCycleStage(state.lifeCycleStage);  }  @VisibleForTesting  List<CompilerInput> getInputsForTesting() {    return inputs;  }  @VisibleForTesting  List<CompilerInput> getExternsForTesting() {    return externs;  }  @Override  boolean hasRegExpGlobalReferences() {    return hasRegExpGlobalReferences;  }  @Override  void setHasRegExpGlobalReferences(boolean references) {    hasRegExpGlobalReferences = references;  }  @Override  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,      Node collectionRoot) {    Preconditions.checkState(collectionRoot.isScript()        || collectionRoot.isBlock());    if (globalRefMap == null) {      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),          getExternsInOrder());    }    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);  }  @Override  GlobalVarReferenceMap getGlobalVarReferences() {    return globalRefMap;  }  @Override  CompilerInput getSynthesizedExternsInput() {    if (synthesizedExternsInput == null) {      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);    }    return synthesizedExternsInput;  }  @Override  public double getProgress() {    return progress;  }  @Override  void setProgress(double newProgress) {    if (newProgress > 1.0) {      progress = 1.0;    } else if (newProgress < 0.0) {      progress = 0.0;    } else {      progress = newProgress;    }  }  /**   * Replaces one file in a hot-swap mode. The given JsAst should be made   * from a new version of a file that already was present in the last compile   * call. If the file is new, this will silently ignored.   *   * @param ast the ast of the file that is being replaced   */  public void replaceScript(JsAst ast) {    CompilerInput input = this.getInput(ast.getInputId());    if (!replaceIncrementalSourceAst(ast)) {      return;    }    Node originalRoot = input.getAstRoot(this);    processNewScript(ast, originalRoot);  }  /**   * Adds a new Script AST to the compile state. If a script for the same file   * already exists the script will not be added, instead a call to   * #replaceScript should be used.   *   * @param ast the ast of the new file   */  public void addNewScript(JsAst ast) {    if (!addNewSourceAst(ast)) {      return;    }    Node emptyScript = new Node(Token.SCRIPT);    InputId inputId = ast.getInputId();    emptyScript.setInputId(inputId);    emptyScript.setStaticSourceFile(        JSSourceFile.fromCode(inputId.getIdName(), \"\"));    processNewScript(ast, emptyScript);  }  private void processNewScript(JsAst ast, Node originalRoot) {    Node js = ast.getAstRoot(this);    Preconditions.checkNotNull(js);    runHotSwap(originalRoot, js, this.getCleanupPassConfig());    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need    // to revisit this approach to clearing GlobalNamespaces    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);    this.getTypeRegistry().clearNamedTypes();    this.removeSyntheticVarsInput();    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());  }  /**   * Execute the passes from a PassConfig instance over a single replaced file.   */  private void runHotSwap(      Node originalRoot, Node js, PassConfig passConfig) {    for (PassFactory passFactory : passConfig.getChecks()) {      runHotSwapPass(originalRoot, js, passFactory);    }  }  private void runHotSwapPass(      Node originalRoot, Node js, PassFactory passFactory) {    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);    if (pass != null) {      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());      pass.hotSwapScript(js, originalRoot);    }  }  private PassConfig getCleanupPassConfig() {    return new CleanupPasses(getOptions());  }  private void removeSyntheticVarsInput() {    String sourceName = Compiler.SYNTHETIC_EXTERNS;    removeExternInput(new InputId(sourceName));  }}\nCaused by: java.lang.IllegalStateException\n\t... 23 more\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nvoid replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition != null && explicitNode != null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (candidateDefinition.isExprResult() && !candidateDefinition.getFirstChild().isQualifiedName()) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.isName()) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = IR.var(nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild(candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { int indexOfDot = namespace.lastIndexOf('.'); if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter(replacementNode, parentName.replacementNode); } } if (explicitNode != null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }\n```\n\n            \n```java\nboolean destructuringObject(ObjectLiteral node, int variableType, String tempName, Node parent, List<String> destructuringNames) { boolean empty = true; int setOp = variableType == Token.CONST ? Token.SETCONST : Token.SETNAME; for (ObjectProperty prop : node.getElements()) { int lineno = 0; if (ts != null) { lineno = ts.lineno; } AstNode id = prop.getLeft(); Node rightElem = null; if (id instanceof Name) { Node s = Node.newString(((Name) id).getIdentifier()); rightElem = new Node(Token.GETPROP, createName(tempName), s); } else if (id instanceof StringLiteral) { Node s = Node.newString(((StringLiteral) id).getValue()); rightElem = new Node(Token.GETPROP, createName(tempName), s); } else if (id instanceof NumberLiteral) { Node s = createNumber((int) ((NumberLiteral) id).getNumber()); rightElem = new Node(Token.GETELEM, createName(tempName), s); } else { throw codeBug(); } rightElem.setLineno(lineno); AstNode value = prop.getRight(); if (value.getType() == Token.NAME) { String name = ((Name) value).getIdentifier(); parent.addChildToBack(new Node(setOp, createName(Token.BINDNAME, name, null), rightElem)); if (variableType != -1) { defineSymbol(variableType, name, true); destructuringNames.add(name); } } else { parent.addChildToBack(destructuringAssignmentHelper(variableType, value, rightElem, currentScriptOrFn.getNextTempName())); } empty = false; } return empty; }\n```\n\n            \n```java\nprivate Node createTryCatchFinally(Node tryBlock, Node catchBlocks, Node finallyBlock, int lineno) { boolean hasFinally = (finallyBlock != null) && (finallyBlock.getType() != Token.BLOCK || finallyBlock.hasChildren()); if (tryBlock.getType() == Token.BLOCK && !tryBlock.hasChildren() && !hasFinally) { return tryBlock; } boolean hasCatch = catchBlocks.hasChildren(); if (!hasFinally && !hasCatch) { return tryBlock; } Node handlerBlock = new Node(Token.LOCAL_BLOCK); Jump pn = new Jump(Token.TRY, tryBlock, lineno); pn.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock); if (hasCatch) { Node endCatch = Node.newTarget(); pn.addChildToBack(makeJump(Token.GOTO, endCatch)); Node catchTarget = Node.newTarget(); pn.target = catchTarget; pn.addChildToBack(catchTarget); Node catchScopeBlock = new Node(Token.LOCAL_BLOCK); Node cb = catchBlocks.getFirstChild(); boolean hasDefault = false; int scopeIndex = 0; while (cb != null) { int catchLineNo = cb.getLineno(); Node name = cb.getFirstChild(); Node cond = name.getNext(); Node catchStatement = cond.getNext(); cb.removeChild(name); cb.removeChild(cond); cb.removeChild(catchStatement); catchStatement.addChildToBack(new Node(Token.LEAVEWITH)); catchStatement.addChildToBack(makeJump(Token.GOTO, endCatch)); Node condStmt; if (cond.getType() == Token.EMPTY) { condStmt = catchStatement; hasDefault = true; } else { condStmt = createIf(cond, catchStatement, null, catchLineNo); } Node catchScope = new Node(Token.CATCH_SCOPE, name, createUseLocal(handlerBlock)); catchScope.putProp(Node.LOCAL_BLOCK_PROP, catchScopeBlock); catchScope.putIntProp(Node.CATCH_SCOPE_PROP, scopeIndex); catchScopeBlock.addChildToBack(catchScope); catchScopeBlock.addChildToBack(createWith(createUseLocal(catchScopeBlock), condStmt, catchLineNo)); cb = cb.getNext(); ++scopeIndex; } pn.addChildToBack(catchScopeBlock); if (!hasDefault) { Node rethrow = new Node(Token.RETHROW); rethrow.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock); pn.addChildToBack(rethrow); } pn.addChildToBack(endCatch); } if (hasFinally) { Node finallyTarget = Node.newTarget(); pn.setFinally(finallyTarget); pn.addChildToBack(makeJump(Token.JSR, finallyTarget)); Node finallyEnd = Node.newTarget(); pn.addChildToBack(makeJump(Token.GOTO, finallyEnd)); pn.addChildToBack(finallyTarget); Node fBlock = new Node(Token.FINALLY, finallyBlock); fBlock.putProp(Node.LOCAL_BLOCK_PROP, handlerBlock); pn.addChildToBack(fBlock); pn.addChildToBack(finallyEnd); } handlerBlock.addChildToBack(pn); return handlerBlock; }\n```\n\n            \n```java\nString getName(Node node) { switch(node.getType()) { case Token.FUNCTION: Node functionNameNode = node.getFirstChild(); return functionNameNode.getString(); case Token.GETPROP: Node lhsOfDot = node.getFirstChild(); Node rhsOfDot = lhsOfDot.getNext(); String lhsOfDotName = getName(lhsOfDot); String rhsOfDotName = getName(rhsOfDot); if (\\\"prototype\\\".equals(rhsOfDotName)) { return lhsOfDotName + delimiter; } else { return lhsOfDotName + delimiter + rhsOfDotName; } case Token.GETELEM: Node outsideBrackets = node.getFirstChild(); Node insideBrackets = outsideBrackets.getNext(); String nameOutsideBrackets = getName(outsideBrackets); String nameInsideBrackets = getName(insideBrackets); if (\\\"prototype\\\".equals(nameInsideBrackets)) { return nameOutsideBrackets + delimiter; } else { return nameOutsideBrackets + delimiter + nameInsideBrackets; } case Token.NAME: return node.getString(); case Token.STRING: return TokenStream.isJSIdentifier(node.getString()) ? node.getString() : (\\\"__\\\" + nextUniqueInt++); case Token.NUMBER: return NodeUtil.getStringValue(node); case Token.THIS: return \\\"this\\\"; case Token.CALL: return getName(node.getFirstChild()); default: StringBuilder sb = new StringBuilder(); for (Node child = node.getFirstChild(); child != null; child = child.getNext()) { if (sb.length() > 0) { sb.append(delimiter); } sb.append(getName(child)); } return sb.toString(); } }\n```\n\n            \n```java\nprivate Node transformXmlLiteral(XmlLiteral node) { Node pnXML = new Node(Token.NEW, node.getLineno()); List<XmlFragment> frags = node.getFragments(); XmlString first = (XmlString) frags.get(0); boolean anon = first.getXml().trim().startsWith(\\\"<>\\\"); pnXML.addChildToBack(createName(anon ? \\\"XMLList\\\" : \\\"XML\\\")); Node pn = null; for (XmlFragment frag : frags) { if (frag instanceof XmlString) { String xml = ((XmlString) frag).getXml(); decompiler.addName(xml); if (pn == null) { pn = createString(xml); } else { pn = createBinary(Token.ADD, pn, createString(xml)); } } else { XmlExpression xexpr = (XmlExpression) frag; boolean isXmlAttr = xexpr.isXmlAttribute(); Node expr; decompiler.addToken(Token.LC); if (xexpr.getExpression() instanceof EmptyExpression) { expr = createString(\\\"\\\"); } else { expr = transform(xexpr.getExpression()); } decompiler.addToken(Token.RC); if (isXmlAttr) { expr = createUnary(Token.ESCXMLATTR, expr); Node prepend = createBinary(Token.ADD, createString(\\\"\\\\\"\\\"), expr); expr = createBinary(Token.ADD, prepend, createString(\\\"\\\\\"\\\")); } else { expr = createUnary(Token.ESCXMLTEXT, expr); } pn = createBinary(Token.ADD, pn, expr); } } pnXML.addChildToBack(pn); return pnXML; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\n                \"unnamed function statement\",\n                sourceName,\n                functionNode.getLineno(), \"\", 0);\n\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    \n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    node.addChildToBack(newName);\n\n    if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n\n    Node lp = newNode(Token.PARAM_LIST);\n    lp.setLineno(functionNode.getLineno());\n    int lparenCharno = functionNode.getLp() +\n        functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n\n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n\n  // Correctly set the line number for the parameter list node.\n  lp.setLineno(functionNode.getLineno());\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  // When in ideMode Rhino tries to parse some constructs the compiler\n  // doesn't support, repair it here. see Rhino's\n  // Parser#parseFunctionBodyExpr.\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  if (name != null && !isUnnamedFunction) {\n    lp.setLineno(name.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  // When in ideMode Rhino tries to parse some constructs the compiler\n  // doesn't support, repair it here. see Rhino's\n  // Parser#parseFunctionBodyExpr.\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\n                \"unnamed function statement\",\n                sourceName,\n                functionNode.getLineno(), \"\", 0);\n\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO: Mark line number of paren correctly.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n\n    // Ensure lp is always created with a line number set.\n    lp.setLineno(functionNode.getLineno());\n\n    int lparenCharno = functionNode.getLp() +\n        functionNode.getAbsolutePosition();\n\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  \n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  \n  if (isUnnamedFunction) {\n    // Corrected: Ensure newName has a valid line number if it is an unnamed function.\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  \n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  \n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n  lp.setCharno(position2charno(lparenCharno));\n  \n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  \n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\n                \"unnamed function statement\",\n                sourceName,\n                functionNode.getLineno(), \"\", 0);\n\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() +\n        functionNode.getAbsolutePosition();\n\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n    if (!bodyNode.isBlock()) {\n        bodyNode = newNode(Token.BLOCK, bodyNode);\n    }\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  \n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  \n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  if (bodyNode.getToken() != Token.BLOCK) {\n    bodyNode = newNode(Token.BLOCK, bodyNode);\n  }\n\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  if (!bodyNode.isBlock()) {\n    bodyNode = newNode(Token.BLOCK, bodyNode);\n  }\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    // Old Rhino tagged the empty name node with the line number of the\n    // declaration.\n    newName.setLineno(functionNode.getLineno());\n    // TODO(bowdidge) Mark line number of paren correctly.\n    // Same problem as below - the left paren might not be on the\n    // same line as the function keyword.\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n  // The left paren's complicated because it's not represented by an\n  // AstNode, so there's nothing that has the actual line number that it\n  // appeared on.  We know the paren has to appear on the same line as the\n  // function name (or else a semicolon will be inserted.)  If there's no\n  // function name, assume the paren was on the same line as the function.\n  // TODO(bowdidge): Mark line number of paren correctly.\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  // Make sure bodyNode is a block node, even if it's empty\n  if (!bodyNode.isBlock()) {\n    bodyNode = newNode(Token.BLOCK, bodyNode);\n  }\n\n  // When in ideMode Rhino tries to parse some constructs the compiler\n  // doesn't support, repair it here. see Rhino's\n  // Parser#parseFunctionBodyExpr.\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n",
                            "\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  Name name = functionNode.getFunctionName();\n  Boolean isUnnamedFunction = false;\n  if (name == null) {\n    int functionType = functionNode.getFunctionType();\n    if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n      errorReporter.error(\n        \"unnamed function statement\",\n        sourceName,\n        functionNode.getLineno(), \"\", 0);\n\n      // Return the bare minimum to put the AST in a valid state.\n      Node node = newNode(Token.EXPR_RESULT, Node.newNumber(0));\n      node.setIsSyntheticBlock(true); // Ensure the node is marked as synthetic\n      return node;\n    }\n    name = new Name();\n    name.setIdentifier(\"\");\n    isUnnamedFunction = true;\n  }\n  Node node = newNode(Token.FUNCTION);\n  Node newName = transform(name);\n  if (isUnnamedFunction) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() +\n        functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n    maybeSetLengthFrom(newName, name);\n  }\n\n  node.addChildToBack(newName);\n  Node lp = newNode(Token.PARAM_LIST);\n\n  Name fnName = functionNode.getFunctionName();\n  if (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n  } else {\n    lp.setLineno(functionNode.getLineno());\n  }\n  int lparenCharno = functionNode.getLp() +\n      functionNode.getAbsolutePosition();\n\n  lp.setCharno(position2charno(lparenCharno));\n  for (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n  }\n  node.addChildToBack(lp);\n\n  Node bodyNode = transform(functionNode.getBody());\n  parseDirectives(bodyNode);\n  node.addChildToBack(bodyNode);\n  return node;\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "com.google.javascript.jscomp.IntegrationTest::testIncompleteFunction": {
                "path": "test/com/google/javascript/jscomp/IntegrationTest.java",
                "function_name": "testIncompleteFunction",
                "src": "  public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    );\n  }",
                "error_msg": "java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:642)\n\tat com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:587)\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:569)\n\tat com.google.javascript.jscomp.Compiler.compileModules(Compiler.java:560)\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:542)\n\tat com.google.javascript.jscomp.IntegrationTest.compile(IntegrationTest.java:2080)\n\tat com.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:2041)\n\tat com.google.javascript.jscomp.IntegrationTest.testIncompleteFunction(IntegrationTest.java:1945)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.common.base.Preconditions.checkState(Preconditions.java:129)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:540)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:489)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:277)\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:455)\n\tat com.google.javascript.jscomp.PrepareAst.process(PrepareAst.java:70)\n\tat com.google.javascript.jscomp.Compiler.prepareAst(Compiler.java:1835)\n\tat com.google.javascript.jscomp.JsAst.parse(JsAst.java:99)\n\tat com.google.javascript.jscomp.JsAst.getAstRoot(JsAst.java:52)\n\tat com.google.javascript.jscomp.CompilerInput.getAstRoot(CompilerInput.java:119)\n\tat com.google.javascript.jscomp.Compiler.parseInputs(Compiler.java:1302)\n\tat com.google.javascript.jscomp.Compiler.parse(Compiler.java:696)\n\tat com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:650)\n\tat com.google.javascript.jscomp.Compiler.access$000(Compiler.java:71)\n\tat com.google.javascript.jscomp.Compiler$1.call(Compiler.java:572)\n\tat com.google.javascript.jscomp.Compiler$1.call(Compiler.java:569)\n\tat com.google.javascript.jscomp.Compiler$2.run(Compiler.java:614)\n\tat java.lang.Thread.run(Thread.java:748)\nCaused by: java.lang.IllegalStateException\n\t... 23 more",
                "clean_error_msg": "java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:642)  throw new RuntimeException(exception[0]);\n\tat com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:587)  return runCallable(callable, useThreads, options.tracer.isOn());\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:569)  return runInCompilerThread(new Callable<Result>() {      @Override      public Result call() throws Exception {        compileInternal();        return getResult();      }    });\n\tat com.google.javascript.jscomp.Compiler.compileModules(Compiler.java:560)  return compile();\n\tat com.google.javascript.jscomp.Compiler.compile(Compiler.java:542)  return compileModules(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSModule>newArrayList(modules),        options);\n\tat com.google.javascript.jscomp.IntegrationTest.compile(IntegrationTest.java:2080)  compiler.compile(        externs, CompilerTestCase.createModuleChain(original), options);\n\tat com.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:2041)  Compiler compiler = compile(options, original);\n\tat com.google.javascript.jscomp.IntegrationTest.testIncompleteFunction(IntegrationTest.java:1945)  test(options,        new String[] { \"var foo = {bar: function(e) }\" },        new String[] { \"var foo = {bar: function(e){}};\" },        warnings    );\nCaused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\nPlease report this problem.\nnull\n\tat com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:540)  Preconditions.checkState(body.getNext() == null &&            body.isBlock());\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:489)  traverseFunction(n, parent);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:497)  traverseBranch(child, n);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:277)  traverseBranch(root, null);\n\tat com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:455)  t.traverse(root);\n\tat com.google.javascript.jscomp.PrepareAst.process(PrepareAst.java:70)  NodeTraversal.traverse(            compiler, root, new PrepareAnnotations(compiler));\n\tat com.google.javascript.jscomp.Compiler.prepareAst(Compiler.java:1835)  pass.process(null, root);\n\tat com.google.javascript.jscomp.JsAst.parse(JsAst.java:99)  compiler.prepareAst(root);\n\tat com.google.javascript.jscomp.JsAst.getAstRoot(JsAst.java:52)  parse(compiler);\n\tat com.google.javascript.jscomp.CompilerInput.getAstRoot(CompilerInput.java:119)  Node root = ast.getAstRoot(compiler);\n\tat com.google.javascript.jscomp.Compiler.parseInputs(Compiler.java:1302)  Node n = input.getAstRoot(this);\n\tat com.google.javascript.jscomp.Compiler.parse(Compiler.java:696)  parseInputs();\n\tat com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:650)  parse();\n\tat com.google.javascript.jscomp.Compiler.access$000(Compiler.java:71)  public class Compiler extends AbstractCompiler {  static final String SINGLETON_MODULE_NAME = \"[singleton]\";  static final DiagnosticType MODULE_DEPENDENCY_ERROR =      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",          \"Bad dependency: {0} -> {1}. \"              + \"Modules must be listed in dependency order.\");  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(      \"JSC_MISSING_ENTRY_ERROR\",      \"required entry point \\\"{0}\\\" never provided\");  CompilerOptions options = null;  private PassConfig passes = null;  // The externs inputs  private List<CompilerInput> externs;  // The JS source modules  private List<JSModule> modules;  // The graph of the JS source modules. Must be null if there are less than  // 2 modules, because we use this as a signal for which passes to run.  private JSModuleGraph moduleGraph;  // The JS source inputs  private List<CompilerInput> inputs;  // error manager to which error management is delegated  private ErrorManager errorManager;  // Warnings guard for filtering warnings.  private WarningsGuard warningsGuard;  // Parse tree root nodes  Node externsRoot;  Node jsRoot;  Node externAndJsRoot;  private Map<InputId, CompilerInput> inputsById;  /** The source code map */  private SourceMap sourceMap;  /** The externs created from the exports.  */  private String externExports = null;  /**   * Ids for function inlining so that each declared name remains   * unique.   */  private int uniqueNameId = 0;  /** Whether to use threads. */  private boolean useThreads = true;  /**   * Whether to assume there are references to the RegExp Global object   * properties.   */  private boolean hasRegExpGlobalReferences = true;  /** The function information map */  private FunctionInformationMap functionInformationMap;  /** Debugging information */  private final StringBuilder debugLog = new StringBuilder();  /** Detects Google-specific coding conventions. */  CodingConvention defaultCodingConvention = new ClosureCodingConvention();  private JSTypeRegistry typeRegistry;  private Config parserConfig = null;  private ReverseAbstractInterpreter abstractInterpreter;  private TypeValidator typeValidator;  public PerformanceTracker tracker;  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =      RhinoErrorReporter.forOldRhino(this);  // This error reporter gets the messages from the current Rhino parser.  private final ErrorReporter defaultErrorReporter =      RhinoErrorReporter.forNewRhino(this);  /** Error strings used for reporting JSErrors */  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(      \"JSC_OPTIMIZE_LOOP_ERROR\",      \"Exceeded max number of optimization iterations: {0}\");  public static final DiagnosticType MOTION_ITERATIONS_ERROR =      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",          \"Exceeded max number of code motion iterations: {0}\");  private static final long COMPILER_STACK_SIZE = 1048576L;  /**   * Logger for the whole com.google.javascript.jscomp domain -   * setting configuration for this logger affects all loggers   *  in other classes within the compiler.   */  private static final Logger logger =      Logger.getLogger(\"com.google.javascript.jscomp\");  private final PrintStream outStream;  private GlobalVarReferenceMap globalRefMap = null;  private volatile double progress = 0.0;  /**   * Creates a Compiler that reports errors and warnings to its logger.   */  public Compiler() {    this((PrintStream) null);  }  /**   * Creates n Compiler that reports errors and warnings to an output   * stream.   */  public Compiler(PrintStream stream) {    addChangeHandler(recentChange);    outStream = stream;  }  /**   * Creates a Compiler that uses a custom error manager.   */  public Compiler(ErrorManager errorManager) {    this();    setErrorManager(errorManager);  }  /**   * Sets the error manager.   *   * @param errorManager the error manager, it cannot be {@code null}   */  public void setErrorManager(ErrorManager errorManager) {    Preconditions.checkNotNull(        errorManager, \"the error manager cannot be null\");    this.errorManager = errorManager;  }  /**   * Creates a message formatter instance corresponding to the value of   * {@link CompilerOptions}.   */  private MessageFormatter createMessageFormatter() {    boolean colorize = options.shouldColorizeErrorOutput();    return options.errorFormat.toFormatter(this, colorize);  }  /**   * Initialize the compiler options. Only necessary if you're not doing   * a normal compile() job.   */  public void initOptions(CompilerOptions options) {    this.options = options;    if (errorManager == null) {      if (outStream == null) {        setErrorManager(            new LoggerErrorManager(createMessageFormatter(), logger));      } else {        PrintStreamErrorManager printer =            new PrintStreamErrorManager(createMessageFormatter(), outStream);        printer.setSummaryDetailLevel(options.summaryDetailLevel);        setErrorManager(printer);      }    }    // DiagnosticGroups override the plain checkTypes option.    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {      options.checkTypes = true;    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {      options.checkTypes = false;    } else if (!options.checkTypes) {      // If DiagnosticGroups did not override the plain checkTypes      // option, and checkTypes is enabled, then turn off the      // parser type warnings.      options.setWarningLevel(          DiagnosticGroup.forType(              RhinoErrorReporter.TYPE_PARSE_ERROR),          CheckLevel.OFF);    }    if (options.checkGlobalThisLevel.isOn() &&        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {      options.setWarningLevel(          DiagnosticGroups.GLOBAL_THIS,          options.checkGlobalThisLevel);    }    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {      options.setWarningLevel(          DiagnosticGroups.ES5_STRICT,          CheckLevel.ERROR);    }    // Initialize the warnings guard.    List<WarningsGuard> guards = Lists.newArrayList();    guards.add(        new SuppressDocWarningsGuard(            getDiagnosticGroups().getRegisteredGroups()));    guards.add(options.getWarningsGuard());    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);    // All passes must run the variable check. This synthesizes    // variables later so that the compiler doesn't crash. It also    // checks the externs file for validity. If you don't want to warn    // about missing variable declarations, we shut that specific    // error off.    if (!options.checkSymbols &&        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));    }    this.warningsGuard = composedGuards;  }  /**   * Initializes the instance state needed for a compile job.   */  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,      CompilerOptions options) {    init(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSSourceFile>newArrayList(inputs), options);  }  /**   * Initializes the instance state needed for a compile job.   */  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,      CompilerOptions options) {    JSModule module = new JSModule(SINGLETON_MODULE_NAME);    for (JSSourceFile input : inputs) {      module.add(input);    }    initModules(externs, Lists.newArrayList(module), options);  }  /**   * Initializes the instance state needed for a compile job if the sources   * are in modules.   */  public void init(JSSourceFile[] externs, JSModule[] modules,      CompilerOptions options) {    initModules(Lists.<JSSourceFile>newArrayList(externs),         Lists.<JSModule>newArrayList(modules), options);  }  /**   * Initializes the instance state needed for a compile job if the sources   * are in modules.   */  public void initModules(      List<JSSourceFile> externs, List<JSModule> modules,      CompilerOptions options) {    initOptions(options);    checkFirstModule(modules);    fillEmptyModules(modules);    this.externs = makeCompilerInput(externs, true);    // Generate the module graph, and report any errors in the module    // specification as errors.    this.modules = modules;    if (modules.size() > 1) {      try {        this.moduleGraph = new JSModuleGraph(modules);      } catch (JSModuleGraph.ModuleDependenceException e) {        // problems with the module format.  Report as an error.  The        // message gives all details.        report(JSError.make(MODULE_DEPENDENCY_ERROR,                e.getModule().getName(), e.getDependentModule().getName()));        return;      }    } else {      this.moduleGraph = null;    }    this.inputs = getAllInputsFromModules(modules);    initBasedOnOptions();    initInputsByIdMap();  }  /**   * Do any initialization that is dependent on the compiler options.   */  private void initBasedOnOptions() {    // Create the source map if necessary.    if (options.sourceMapOutputPath != null) {      sourceMap = options.sourceMapFormat.getInstance();      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);    }  }  private List<CompilerInput> makeCompilerInput(      List<JSSourceFile> files, boolean isExtern) {    List<CompilerInput> inputs = Lists.newArrayList();    for (JSSourceFile file : files) {      inputs.add(new CompilerInput(file, isExtern));    }    return inputs;  }  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",          \"At least one module must be provided\");  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",          \"Root module '{0}' must contain at least one source code input\");  /**   * Verifies that at least one module has been provided and that the first one   * has at least one source code input.   */  private void checkFirstModule(List<JSModule> modules) {    if (modules.isEmpty()) {      report(JSError.make(EMPTY_MODULE_LIST_ERROR));    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {      // The root module may only be empty if there is exactly 1 module.      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,          modules.get(0).getName()));    }  }  /**   * Empty modules get an empty \"fill\" file, so that we can move code into   * an empty module.   */  static String createFillFileName(String moduleName) {    return \"[\" + moduleName + \"]\";  }  /**   * Fill any empty modules with a place holder file. It makes any cross module   * motion easier.   */  private static void fillEmptyModules(List<JSModule> modules) {    for (JSModule module : modules) {      if (module.getInputs().isEmpty()) {        module.add(JSSourceFile.fromCode(            createFillFileName(module.getName()), \"\"));      }    }  }  /**   * Rebuilds the internal list of inputs by iterating over all modules.   * This is necessary if inputs have been added to or removed from a module   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.   */  public void rebuildInputsFromModules() {    inputs = getAllInputsFromModules(modules);    initInputsByIdMap();  }  /**   * Builds a single list of all module inputs. Verifies that it contains no   * duplicates.   */  private static List<CompilerInput> getAllInputsFromModules(      List<JSModule> modules) {    List<CompilerInput> inputs = Lists.newArrayList();    Map<String, JSModule> inputMap = Maps.newHashMap();    for (JSModule module : modules) {      for (CompilerInput input : module.getInputs()) {        String inputName = input.getName();        // NOTE(nicksantos): If an input is in more than one module,        // it will show up twice in the inputs list, and then we        // will get an error down the line.        inputs.add(input);        inputMap.put(inputName, module);      }    }    return inputs;  }  static final DiagnosticType DUPLICATE_INPUT =      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");  static final DiagnosticType DUPLICATE_EXTERN_INPUT =      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",          \"Duplicate extern input: {0}\");  /**   * Creates a map to make looking up an input by name fast. Also checks for   * duplicate inputs.   */  void initInputsByIdMap() {    inputsById = new HashMap<InputId, CompilerInput>();    for (CompilerInput input : externs) {      InputId id = input.getInputId();      CompilerInput previous = inputsById.put(id, input);      if (previous != null) {        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));      }    }    for (CompilerInput input : inputs) {      InputId id = input.getInputId();      CompilerInput previous = inputsById.put(id, input);      if (previous != null) {        report(JSError.make(DUPLICATE_INPUT, input.getName()));      }    }  }  public Result compile(      JSSourceFile extern, JSSourceFile input, CompilerOptions options) {     return compile(extern, new JSSourceFile[] { input }, options);  }  public Result compile(      JSSourceFile extern, JSSourceFile[] input, CompilerOptions options) {     return compile(new JSSourceFile[] { extern }, input, options);  }  public Result compile(      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {     return compile(new JSSourceFile[] { extern }, modules, options);  }  /**   * Compiles a list of inputs.   */  public Result compile(JSSourceFile[] externs,                        JSSourceFile[] inputs,                        CompilerOptions options) {    return compile(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSSourceFile>newArrayList(inputs),        options);  }  /**   * Compiles a list of inputs.   */  public Result compile(List<JSSourceFile> externs,      List<JSSourceFile> inputs, CompilerOptions options) {    // The compile method should only be called once.    Preconditions.checkState(jsRoot == null);    try {      init(externs, inputs, options);      if (hasErrors()) {        return getResult();      }      return compile();    } finally {      Tracer t = newTracer(\"generateReport\");      errorManager.generateReport();      stopTracer(t, \"generateReport\");    }  }  /**   * Compiles a list of modules.   */  public Result compile(JSSourceFile[] externs,                        JSModule[] modules,                        CompilerOptions options) {    return compileModules(Lists.<JSSourceFile>newArrayList(externs),        Lists.<JSModule>newArrayList(modules),        options);  }  /**   * Compiles a list of modules.   */  public Result compileModules(List<JSSourceFile> externs,      List<JSModule> modules, CompilerOptions options) {    // The compile method should only be called once.    Preconditions.checkState(jsRoot == null);    try {      initModules(externs, modules, options);      if (hasErrors()) {        return getResult();      }      return compile();    } finally {      Tracer t = newTracer(\"generateReport\");      errorManager.generateReport();      stopTracer(t, \"generateReport\");    }  }  private Result compile() {    return runInCompilerThread(new Callable<Result>() {      @Override      public Result call() throws Exception {        compileInternal();        return getResult();      }    });  }  /**   * Disable threads. This is for clients that run on AppEngine and   * don't have threads.   */  public void disableThreads() {    useThreads = false;  }  private <T> T runInCompilerThread(final Callable<T> callable) {    return runCallable(callable, useThreads, options.tracer.isOn());  }  static <T> T runCallableWithLargeStack(final Callable<T> callable) {    return runCallable(callable, true, false);  }  @SuppressWarnings(\"unchecked\")  static <T> T runCallable(      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {    // Under JRE 1.6, the jscompiler overflows the stack when running on some    // large or complex js code. Here we start a new thread with a larger    // stack in order to let the compiler do its thing, without having to    // increase the stack size for *every* thread (which is what -Xss does).    // Might want to add thread pool support for clients that compile a lot.    final boolean dumpTraceReport = trace;    final Object[] result = new Object[1];    final Throwable[] exception = new Throwable[1];    Runnable runnable = new Runnable() {      @Override      public void run() {        try {          if (dumpTraceReport) {            Tracer.initCurrentThreadTrace();          }          result[0] = callable.call();        } catch (Throwable e) {          exception[0] = e;        } finally {          if (dumpTraceReport) {            Tracer.logAndClearCurrentThreadTrace();          }        }      }    };    if (useLargeStackThread) {      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);      th.start();      while (true) {        try {          th.join();          break;        } catch (InterruptedException ignore) {          // ignore        }      }    } else {      runnable.run();    }    // Pass on any exception caught by the runnable object.    if (exception[0] != null) {      throw new RuntimeException(exception[0]);    }    return (T) result[0];  }  private void compileInternal() {    setProgress(0.0);    parse();    // 15 percent of the work is assumed to be for parsing (based on some    // minimal analysis on big JS projects, of course this depends on options)    setProgress(0.15);    if (hasErrors()) {      return;    }    if (!precheck()) {      return;    }    if (options.nameAnonymousFunctionsOnly) {      // TODO(nicksantos): Move this into an instrument() phase maybe?      check();      return;    }    if (!options.skipAllPasses) {      check();      if (hasErrors()) {        return;      }      if (options.isExternExportsEnabled()          || options.externExportsPath != null) {        externExports();      }      // IDE-mode is defined to stop here, before the heavy rewriting begins.      if (!options.ideMode) {        optimize();      }    }    if (options.recordFunctionInformation) {      recordFunctionInformation();    }    if (options.devMode == DevMode.START_AND_END) {      runSanityCheck();    }    setProgress(1.0);  }  public void parse() {    parseInputs();  }  PassConfig getPassConfig() {    if (passes == null) {      passes = createPassConfigInternal();    }    return passes;  }  /**   * Create the passes object. Clients should use setPassConfig instead of   * overriding this.   */  PassConfig createPassConfigInternal() {    return new DefaultPassConfig(options);  }  /**   * @param passes The PassConfig to use with this Compiler.   * @throws NullPointerException if passes is null   * @throws IllegalStateException if this.passes has already been assigned   */  public void setPassConfig(PassConfig passes) {    // Important to check for null because if setPassConfig(null) is    // called before this.passes is set, getPassConfig() will create a    // new PassConfig object and use that, which is probably not what    // the client wanted since he or she probably meant to use their    // own PassConfig object.    Preconditions.checkNotNull(passes);    if (this.passes != null) {      throw new IllegalStateException(\"this.passes has already been assigned\");    }    this.passes = passes;  }  /**   * Carry out any special checks or procedures that need to be done before   * proceeding with rest of the compilation process.   *   * @return true, to continue with compilation   */  boolean precheck() {    return true;  }  public void check() {    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);    // We are currently only interested in check-passes for progress reporting    // as it is used for IDEs, that's why the maximum progress is set to 1.0.    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));    if (options.devMode == DevMode.EVERY_PASS) {      phaseOptimizer.setSanityCheck(sanityCheck);    }    phaseOptimizer.consume(getPassConfig().getChecks());    phaseOptimizer.process(externsRoot, jsRoot);    if (hasErrors()) {      return;    }    // TODO(nicksantos): clean this up. The flow here is too hard to follow.    if (options.nameAnonymousFunctionsOnly) {      return;    }    if (options.removeTryCatchFinally) {      removeTryCatchFinally();    }    if (options.getTweakProcessing().shouldStrip() ||        !options.stripTypes.isEmpty() ||        !options.stripNameSuffixes.isEmpty() ||        !options.stripTypePrefixes.isEmpty() ||        !options.stripNamePrefixes.isEmpty()) {      stripCode(options.stripTypes, options.stripNameSuffixes,          options.stripTypePrefixes, options.stripNamePrefixes);    }    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);  }  private void externExports() {    logger.fine(\"Creating extern file for exports\");    startPass(\"externExports\");    ExternExportsPass pass = new ExternExportsPass(this);    process(pass);    externExports = pass.getGeneratedExterns();    endPass();  }  @Override  void process(CompilerPass p) {    p.process(externsRoot, jsRoot);  }  private final PassFactory sanityCheck =      new PassFactory(\"sanityCheck\", false) {    @Override    protected CompilerPass createInternal(AbstractCompiler compiler) {      return new SanityCheck(compiler);    }  };  private void maybeSanityCheck() {    if (options.devMode == DevMode.EVERY_PASS) {      runSanityCheck();    }  }  private void runSanityCheck() {    sanityCheck.create(this).process(externsRoot, jsRoot);  }  /**   * Removes try/catch/finally statements for easier debugging.   */  void removeTryCatchFinally() {    logger.fine(\"Remove try/catch/finally\");    startPass(\"removeTryCatchFinally\");    RemoveTryCatch r = new RemoveTryCatch(this);    process(r);    endPass();  }  /**   * Strips code for smaller compiled code. This is useful for removing debug   * statements to prevent leaking them publicly.   */  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {    logger.fine(\"Strip code\");    startPass(\"stripCode\");    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,        stripTypePrefixes, stripNamePrefixes);    if (options.getTweakProcessing().shouldStrip()) {      r.enableTweakStripping();    }    process(r);    endPass();  }  /**   * Runs custom passes that are designated to run at a particular time.   */  private void runCustomPasses(CustomPassExecutionTime executionTime) {    if (options.customPasses != null) {      Tracer t = newTracer(\"runCustomPasses\");      try {        for (CompilerPass p : options.customPasses.get(executionTime)) {          process(p);        }      } finally {        stopTracer(t, \"runCustomPasses\");      }    }  }  private Tracer currentTracer = null;  private String currentPassName = null;  /**   * Marks the beginning of a pass.   */  void startPass(String passName) {    Preconditions.checkState(currentTracer == null);    currentPassName = passName;    currentTracer = newTracer(passName);  }  /**   * Marks the end of a pass.   */  void endPass() {    Preconditions.checkState(currentTracer != null,        \"Tracer should not be null at the end of a pass.\");    stopTracer(currentTracer, currentPassName);    String passToCheck = currentPassName;    currentPassName = null;    currentTracer = null;    maybeSanityCheck();  }  /**   * Returns a new tracer for the given pass name.   */  Tracer newTracer(String passName) {    String comment = passName        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");    if (options.tracer.isOn()) {      tracker.recordPassStart(passName);    }    return new Tracer(\"Compiler\", comment);  }  void stopTracer(Tracer t, String passName) {    long result = t.stop();    if (options.tracer.isOn()) {      tracker.recordPassStop(passName, result);    }  }  /**   * Returns the result of the compilation.   */  public Result getResult() {    PassConfig.State state = getPassConfig().getIntermediateState();    return new Result(getErrors(), getWarnings(), debugLog.toString(),        state.variableMap, state.propertyMap,        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,        sourceMap, externExports, state.cssNames, state.idGeneratorMap);  }  /**   * Returns an array constructed from errors + temporary warnings.   */  public JSError[] getMessages() {    return getErrors();  }  /**   * Returns the array of errors (never null).   */  public JSError[] getErrors() {    return errorManager.getErrors();  }  /**   * Returns the array of warnings (never null).   */  public JSError[] getWarnings() {    return errorManager.getWarnings();  }  @Override  public Node getRoot() {    return externAndJsRoot;  }  /**   * Creates a new id for making unique names.   */  private int nextUniqueNameId() {    return uniqueNameId++;  }  /**   * Resets the unique name id counter   */  @VisibleForTesting  void resetUniqueNameId() {    uniqueNameId = 0;  }  @Override  Supplier<String> getUniqueNameIdSupplier() {    final Compiler self = this;    return new Supplier<String>() {      @Override      public String get() {        return String.valueOf(self.nextUniqueNameId());      }    };  }  @Override  boolean areNodesEqualForInlining(Node n1, Node n2) {    if (options.ambiguateProperties ||        options.disambiguateProperties) {      // The type based optimizations require that type information is preserved      // during other optimizations.      return n1.isEquivalentToTyped(n2);    } else {      return n1.isEquivalentTo(n2);    }  }  //------------------------------------------------------------------------  // Inputs  //------------------------------------------------------------------------  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler  // interface, and which ones should always be injected.  @Override  public CompilerInput getInput(InputId id) {    return inputsById.get(id);  }  /**   * Removes an input file from AST.   * @param id The id of the input to be removed.   */  protected void removeExternInput(InputId id) {    CompilerInput input = getInput(id);    if (input == null) {      return;    }    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());    inputsById.remove(id);    externs.remove(input);    Node root = input.getAstRoot(this);    if (root != null) {      root.detachFromParent();    }  }  @Override  public CompilerInput newExternInput(String name) {    SourceAst ast = new SyntheticAst(name);    if (inputsById.containsKey(ast.getInputId())) {      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);    }    CompilerInput input = new CompilerInput(ast, true);    inputsById.put(input.getInputId(), input);    externsRoot.addChildToFront(ast.getAstRoot(this));    externs.add(0, input);    return input;  }  /** Add a source input dynamically. Intended for incremental compilation. */  void addIncrementalSourceAst(JsAst ast) {    InputId id = ast.getInputId();    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());    inputsById.put(id, new CompilerInput(ast));  }  /**   * Replace a source input dynamically. Intended for incremental   * re-compilation.   *   * If the new source input doesn't parse, then keep the old input   * in the AST and return false.   *   * @return Whether the new AST was attached successfully.   */  boolean replaceIncrementalSourceAst(JsAst ast) {    CompilerInput oldInput = getInput(ast.getInputId());    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());    Node newRoot = ast.getAstRoot(this);    if (newRoot == null) {      return false;    }    Node oldRoot = oldInput.getAstRoot(this);    if (oldRoot != null) {      oldRoot.getParent().replaceChild(oldRoot, newRoot);    } else {      getRoot().getLastChild().addChildToBack(newRoot);    }    CompilerInput newInput = new CompilerInput(ast);    inputsById.put(ast.getInputId(), newInput);    JSModule module = oldInput.getModule();    if (module != null) {      module.addAfter(newInput, oldInput);      module.remove(oldInput);    }    // Verify the input id is set properly.    Preconditions.checkState(        newInput.getInputId().equals(oldInput.getInputId()));    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));    inputs.remove(oldInput);    return true;  }  /**   * Add a new source input dynamically. Intended for incremental compilation.   * <p>   * If the new source input doesn't parse, it will not be added, and a false   * will be returned.   *   * @param ast the JS Source to add.   * @return true if the source was added successfully, false otherwise.   * @throws IllegalStateException if an input for this ast already exists.   */  boolean addNewSourceAst(JsAst ast) {    CompilerInput oldInput = getInput(ast.getInputId());    if (oldInput != null) {      throw new IllegalStateException(          \"Input already exists: \" + ast.getInputId().getIdName());    }    Node newRoot = ast.getAstRoot(this);    if (newRoot == null) {      return false;    }    getRoot().getLastChild().addChildToBack(newRoot);    CompilerInput newInput = new CompilerInput(ast);    // TODO(tylerg): handle this for multiple modules at some point.    if (moduleGraph == null && !modules.isEmpty()) {      // singleton module      modules.get(0).add(newInput);    }    inputsById.put(ast.getInputId(), newInput);    return true;  }  @Override  JSModuleGraph getModuleGraph() {    return moduleGraph;  }  /**   * Gets a module graph. This will always return a module graph, even   * in the degenerate case when there's only one module.   */  JSModuleGraph getDegenerateModuleGraph() {    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;  }  @Override  public JSTypeRegistry getTypeRegistry() {    if (typeRegistry == null) {      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);    }    return typeRegistry;  }  @Override  public MemoizedScopeCreator getTypedScopeCreator() {    return getPassConfig().getTypedScopeCreator();  }  @SuppressWarnings(\"unchecked\")  DefaultPassConfig ensureDefaultPassConfig() {    PassConfig passes = getPassConfig().getBasePassConfig();    Preconditions.checkState(passes instanceof DefaultPassConfig,        \"PassConfigs must eventually delegate to the DefaultPassConfig\");    return (DefaultPassConfig) passes;  }  public SymbolTable buildKnownSymbolTable() {    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();    if (typedScopeCreator != null) {      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());      symbolTable.addSymbolsFrom(typedScopeCreator);    } else {      symbolTable.findScopes(this, externsRoot, jsRoot);    }    GlobalNamespace globalNamespace =        ensureDefaultPassConfig().getGlobalNamespace();    if (globalNamespace != null) {      symbolTable.addSymbolsFrom(globalNamespace);    }    ReferenceCollectingCallback refCollector =        new ReferenceCollectingCallback(            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);    NodeTraversal.traverse(this, getRoot(), refCollector);    symbolTable.addSymbolsFrom(refCollector);    PreprocessorSymbolTable preprocessorSymbolTable =        ensureDefaultPassConfig().getPreprocessorSymbolTable();    if (preprocessorSymbolTable != null) {      symbolTable.addSymbolsFrom(preprocessorSymbolTable);    }    symbolTable.fillNamespaceReferences();    symbolTable.fillPropertyScopes();    symbolTable.fillThisReferences(this, externsRoot, jsRoot);    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);    return symbolTable;  }  @Override  public Scope getTopScope() {    return getPassConfig().getTopScope();  }  @Override  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {    if (abstractInterpreter == null) {      ChainableReverseAbstractInterpreter interpreter =          new SemanticReverseAbstractInterpreter(              getCodingConvention(), getTypeRegistry());      if (options.closurePass) {        interpreter = new ClosureReverseAbstractInterpreter(            getCodingConvention(), getTypeRegistry())            .append(interpreter).getFirst();      }      abstractInterpreter = interpreter;    }    return abstractInterpreter;  }  @Override  TypeValidator getTypeValidator() {    if (typeValidator == null) {      typeValidator = new TypeValidator(this);    }    return typeValidator;  }  //------------------------------------------------------------------------  // Parsing  //------------------------------------------------------------------------  /**   * Parses the externs and main inputs.   *   * @return A synthetic root node whose two children are the externs root   *     and the main root   */  Node parseInputs() {    boolean devMode = options.devMode != DevMode.OFF;    // If old roots exist (we are parsing a second time), detach each of the    // individual file parse trees.    if (externsRoot != null) {      externsRoot.detachChildren();    }    if (jsRoot != null) {      jsRoot.detachChildren();    }    // Parse main js sources.    jsRoot = IR.block();    jsRoot.setIsSyntheticBlock(true);    externsRoot = IR.block();    externsRoot.setIsSyntheticBlock(true);    externAndJsRoot = IR.block(externsRoot, jsRoot);    externAndJsRoot.setIsSyntheticBlock(true);    if (options.tracer.isOn()) {      tracker = new PerformanceTracker(jsRoot,          options.tracer == TracerMode.ALL);      addChangeHandler(tracker.getCodeChangeHandler());    }    Tracer tracer = newTracer(\"parseInputs\");    try {      // Parse externs sources.      for (CompilerInput input : externs) {        Node n = input.getAstRoot(this);        if (hasErrors()) {          return null;        }        externsRoot.addChildToBack(n);      }      // Modules inferred in ProcessCommonJS pass.      if (options.transformAMDToCJSModules || options.processCommonJSModules) {        processAMDAndCommonJSModules();      }      // Check if the sources need to be re-ordered.      if (options.dependencyOptions.needsManagement()) {        for (CompilerInput input : inputs) {          input.setCompiler(this);          // Forward-declare all the provided types, so that they          // are not flagged even if they are dropped from the process.          for (String provide : input.getProvides()) {            getTypeRegistry().forwardDeclareType(provide);          }        }        try {          inputs =              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)              .manageDependencies(options.dependencyOptions, inputs);        } catch (CircularDependencyException e) {          report(JSError.make(              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));          // If in IDE mode, we ignore the error and keep going.          if (hasErrors()) {            return null;          }        } catch (MissingProvideException e) {          report(JSError.make(              MISSING_ENTRY_ERROR, e.getMessage()));          // If in IDE mode, we ignore the error and keep going.          if (hasErrors()) {            return null;          }        }      }      // Check if inputs need to be rebuilt from modules.      boolean staleInputs = false;      for (CompilerInput input : inputs) {        Node n = input.getAstRoot(this);        // Inputs can have a null AST during initial parse.        if (n == null) {          continue;        }        if (n.getJSDocInfo() != null) {          JSDocInfo info = n.getJSDocInfo();          if (info.isExterns()) {            // If the input file is explicitly marked as an externs file, then            // assume the programmer made a mistake and throw it into            // the externs pile anyways.            externsRoot.addChildToBack(n);            input.setIsExtern(true);            input.getModule().remove(input);            externs.add(input);            staleInputs = true;          } else if (info.isNoCompile()) {            input.getModule().remove(input);            staleInputs = true;          }        }      }      if (staleInputs) {        fillEmptyModules(modules);        rebuildInputsFromModules();      }      // Build the AST.      for (CompilerInput input : inputs) {        Node n = input.getAstRoot(this);        if (n == null) {          continue;        }        if (devMode) {          runSanityCheck();          if (hasErrors()) {            return null;          }        }        if (options.sourceMapOutputPath != null ||            options.nameReferenceReportPath != null) {          // Annotate the nodes in the tree with information from the          // input file. This information is used to construct the SourceMap.          SourceInformationAnnotator sia =              new SourceInformationAnnotator(                  input.getName(), options.devMode != DevMode.OFF);          NodeTraversal.traverse(this, n, sia);        }        jsRoot.addChildToBack(n);      }      if (hasErrors()) {        return null;      }      return externAndJsRoot;    } finally {      stopTracer(tracer, \"parseInputs\");    }  }  /**   * Transforms AMD and CJS modules to something closure compiler can   * process and creates JSModules and the corresponding dependency tree   * on the way.   */  private void processAMDAndCommonJSModules() {    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();    // TODO(nicksantos): Refactor module dependency resolution to work nicely    // with multiple ways to express dependencies. Directly support JSModules    // that are equivalent to a signal file and which express their deps    // directly in the source.    for (CompilerInput input : inputs) {      input.setCompiler(this);      Node root = input.getAstRoot(this);      if (root == null) {        continue;      }      if (options.transformAMDToCJSModules) {        new TransformAMDToCJSModule(this).process(null, root);      }      if (options.processCommonJSModules) {        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,            options.commonJSModulePathPrefix);        cjs.process(null, root);        JSModule m = cjs.getModule();        if (m != null) {          modulesByName.put(m.getName(), m);          modulesByInput.put(input, m);        }      }    }    if (options.processCommonJSModules) {      List<JSModule> modules = Lists.newArrayList(modulesByName.values());      if (!modules.isEmpty()) {        this.modules = modules;        this.moduleGraph = new JSModuleGraph(this.modules);      }      for (JSModule module : modules) {        for (CompilerInput input : module.getInputs()) {          for (String require : input.getRequires()) {            module.addDependency(modulesByName.get(require));          }        }      }      try {        modules = Lists.newArrayList();        for (CompilerInput input : this.moduleGraph.manageDependencies(            options.dependencyOptions, inputs)) {          modules.add(modulesByInput.get(input));        }        this.modules = modules;        this.moduleGraph = new JSModuleGraph(modules);      } catch (Exception e) {        Throwables.propagate(e);      }    }  }  public Node parse(JSSourceFile file) {    initCompilerOptionsIfTesting();    addToDebugLog(\"Parsing: \" + file.getName());    return new JsAst(file).getAstRoot(this);  }  private int syntheticCodeId = 0;  @Override  Node parseSyntheticCode(String js) {    CompilerInput input = new CompilerInput(        JSSourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));    inputsById.put(input.getInputId(), input);    return input.getAstRoot(this);  }  /**   * Allow subclasses to override the default CompileOptions object.   */  protected CompilerOptions newCompilerOptions() {    return new CompilerOptions();  }  void initCompilerOptionsIfTesting() {    if (options == null) {      // initialization for tests that don't initialize the compiler      // by the normal mechanisms.      initOptions(newCompilerOptions());    }  }  @Override  Node parseSyntheticCode(String fileName, String js) {    initCompilerOptionsIfTesting();    return parse(JSSourceFile.fromCode(fileName, js));  }  @Override  Node parseTestCode(String js) {    initCompilerOptionsIfTesting();    CompilerInput input = new CompilerInput(        JSSourceFile.fromCode(\" [testcode] \", js));    if (inputsById == null) {      inputsById = Maps.newHashMap();    }    inputsById.put(input.getInputId(), input);    return input.getAstRoot(this);  }  @Override  ErrorReporter getDefaultErrorReporter() {    return defaultErrorReporter;  }  //------------------------------------------------------------------------  // Convert back to source code  //------------------------------------------------------------------------  /**   * Converts the main parse tree back to js code.   */  public String toSource() {    return runInCompilerThread(new Callable<String>() {      @Override      public String call() throws Exception {        Tracer tracer = newTracer(\"toSource\");        try {          CodeBuilder cb = new CodeBuilder();          if (jsRoot != null) {            int i = 0;            for (Node scriptNode = jsRoot.getFirstChild();                 scriptNode != null;                 scriptNode = scriptNode.getNext()) {              toSource(cb, i++, scriptNode);            }          }          return cb.toString();        } finally {          stopTracer(tracer, \"toSource\");        }      }    });  }  /**   * Converts the parse tree for each input back to js code.   */  public String[] toSourceArray() {    return runInCompilerThread(new Callable<String[]>() {      @Override      public String[] call() throws Exception {        Tracer tracer = newTracer(\"toSourceArray\");        try {          int numInputs = inputs.size();          String[] sources = new String[numInputs];          CodeBuilder cb = new CodeBuilder();          for (int i = 0; i < numInputs; i++) {            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);            cb.reset();            toSource(cb, i, scriptNode);            sources[i] = cb.toString();          }          return sources;        } finally {          stopTracer(tracer, \"toSourceArray\");        }      }    });  }  /**   * Converts the parse tree for a module back to js code.   */  public String toSource(final JSModule module) {    return runInCompilerThread(new Callable<String>() {      @Override      public String call() throws Exception {        List<CompilerInput> inputs = module.getInputs();        int numInputs = inputs.size();        if (numInputs == 0) {          return \"\";        }        CodeBuilder cb = new CodeBuilder();        for (int i = 0; i < numInputs; i++) {          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);          if (scriptNode == null) {            throw new IllegalArgumentException(                \"Bad module: \" + module.getName());          }          toSource(cb, i, scriptNode);        }        return cb.toString();      }    });  }  /**   * Converts the parse tree for each input in a module back to js code.   */  public String[] toSourceArray(final JSModule module) {    return runInCompilerThread(new Callable<String[]>() {      @Override      public String[] call() throws Exception {        List<CompilerInput> inputs = module.getInputs();        int numInputs = inputs.size();        if (numInputs == 0) {          return new String[0];        }        String[] sources = new String[numInputs];        CodeBuilder cb = new CodeBuilder();        for (int i = 0; i < numInputs; i++) {          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);          if (scriptNode == null) {            throw new IllegalArgumentException(                \"Bad module input: \" + inputs.get(i).getName());          }          cb.reset();          toSource(cb, i, scriptNode);          sources[i] = cb.toString();        }        return sources;      }    });  }  /**   * Writes out js code from a root node. If printing input delimiters, this   * method will attach a comment to the start of the text indicating which   * input the output derived from. If there were any preserve annotations   * within the root's source, they will also be printed in a block comment   * at the beginning of the output.   */  public void toSource(final CodeBuilder cb,                       final int inputSeqNum,                       final Node root) {    runInCompilerThread(new Callable<Void>() {      @Override      public Void call() throws Exception {        if (options.printInputDelimiter) {          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {            cb.append(\"\\n\");  // Make sure that the label starts on a new line          }          Preconditions.checkState(root.isScript());          String delimiter = options.inputDelimiter;          String inputName = root.getInputId().getIdName();          String sourceName = root.getSourceFileName();          Preconditions.checkState(sourceName != null);          Preconditions.checkState(!sourceName.isEmpty());          delimiter = delimiter              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));          cb.append(delimiter)            .append(\"\\n\");        }        if (root.getJSDocInfo() != null &&            root.getJSDocInfo().getLicense() != null) {          cb.append(\"/*\\n\")            .append(root.getJSDocInfo().getLicense())            .append(\"*/\\n\");        }        // If there is a valid source map, then indicate to it that the current        // root node's mappings are offset by the given string builder buffer.        if (options.sourceMapOutputPath != null) {          sourceMap.setStartingPosition(              cb.getLineIndex(), cb.getColumnIndex());        }        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'        // for the first input file        String code = toSource(root, sourceMap, inputSeqNum == 0);        if (!code.isEmpty()) {          cb.append(code);          // In order to avoid parse ambiguity when files are concatenated          // together, all files should end in a semi-colon. Do a quick          // heuristic check if there's an obvious semi-colon already there.          int length = code.length();          char lastChar = code.charAt(length - 1);          char secondLastChar = length >= 2 ?              code.charAt(length - 2) : '\\0';          boolean hasSemiColon = lastChar == ';' ||              (lastChar == '\\n' && secondLastChar == ';');          if (!hasSemiColon) {            cb.append(\";\");          }        }        return null;      }    });  }  /**   * Generates JavaScript source code for an AST, doesn't generate source   * map info.   */  @Override  String toSource(Node n) {    initCompilerOptionsIfTesting();    return toSource(n, null, true);  }  /**   * Generates JavaScript source code for an AST.   */  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {    CodePrinter.Builder builder = new CodePrinter.Builder(n);    builder.setPrettyPrint(options.prettyPrint);    builder.setLineBreak(options.lineBreak);    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);    builder.setSourceMap(sourceMap);    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);    builder.setTagAsStrict(firstOutput &&        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);    builder.setLineLengthThreshold(options.lineLengthThreshold);    Charset charset = options.outputCharset != null ?        Charset.forName(options.outputCharset) : null;    builder.setOutputCharset(charset);    return builder.build();  }  /**   * Stores a buffer of text to which more can be appended.  This is just like a   * StringBuilder except that we also track the number of lines.   */  public static class CodeBuilder {    private final StringBuilder sb = new StringBuilder();    private int lineCount = 0;    private int colCount = 0;    /** Removes all text, but leaves the line count unchanged. */    void reset() {      sb.setLength(0);    }    /** Appends the given string to the text buffer. */    CodeBuilder append(String str) {      sb.append(str);      // Adjust the line and column information for the new text.      int index = -1;      int lastIndex = index;      while ((index = str.indexOf('\\n', index + 1)) >= 0) {        ++lineCount;        lastIndex = index;      }      if (lastIndex == -1) {        // No new lines, append the new characters added.        colCount += str.length();      } else {        colCount = str.length() - (lastIndex + 1);      }      return this;    }    /** Returns all text in the text buffer. */    @Override    public String toString() {      return sb.toString();    }    /** Returns the length of the text buffer. */    public int getLength() {      return sb.length();    }    /** Returns the (zero-based) index of the last line in the text buffer. */    int getLineIndex() {      return lineCount;    }    /** Returns the (zero-based) index of the last column in the text buffer. */    int getColumnIndex() {      return colCount;    }    /** Determines whether the text ends with the given suffix. */    boolean endsWith(String suffix) {      return (sb.length() > suffix.length())          && suffix.equals(sb.substring(sb.length() - suffix.length()));    }  }  //------------------------------------------------------------------------  // Optimizations  //------------------------------------------------------------------------  public void optimize() {    // Ideally, this pass should be the first pass run, however:    // 1) VariableReferenceCheck reports unexpected warnings if Normalize    // is done first.    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on    // unmodified local names.    normalize();    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);    if (options.devMode == DevMode.EVERY_PASS) {      phaseOptimizer.setSanityCheck(sanityCheck);    }    phaseOptimizer.consume(getPassConfig().getOptimizations());    phaseOptimizer.process(externsRoot, jsRoot);    if (hasErrors()) {      return;    }  }  @Override  void setCssRenamingMap(CssRenamingMap map) {    options.cssRenamingMap = map;  }  @Override  CssRenamingMap getCssRenamingMap() {    return options.cssRenamingMap;  }  /**   * Reprocesses the current defines over the AST.  This is used by GwtCompiler   * to generate N outputs for different targets from the same (checked) AST.   * For each target, we apply the target-specific defines by calling   * {@code processDefines} and then {@code optimize} to optimize the AST   * specifically for that target.   */  public void processDefines() {    (new DefaultPassConfig(options)).processDefines.create(this)        .process(externsRoot, jsRoot);  }  boolean isInliningForbidden() {    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||        options.propertyRenaming ==            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;  }  /** Control Flow Analysis. */  ControlFlowGraph<Node> computeCFG() {    logger.fine(\"Computing Control Flow Graph\");    Tracer tracer = newTracer(\"computeCFG\");    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);    process(cfa);    stopTracer(tracer, \"computeCFG\");    return cfa.getCfg();  }  public void normalize() {    logger.fine(\"Normalizing\");    startPass(\"normalize\");    process(new Normalize(this, false));    endPass();  }  @Override  void prepareAst(Node root) {    CompilerPass pass = new PrepareAst(this);    pass.process(null, root);  }  void recordFunctionInformation() {    logger.fine(\"Recording function information\");    startPass(\"recordFunctionInformation\");    RecordFunctionInformation recordFunctionInfoPass =        new RecordFunctionInformation(            this, getPassConfig().getIntermediateState().functionNames);    process(recordFunctionInfoPass);    functionInformationMap = recordFunctionInfoPass.getMap();    endPass();  }  protected final CodeChangeHandler.RecentChange recentChange =      new CodeChangeHandler.RecentChange();  private final List<CodeChangeHandler> codeChangeHandlers =      Lists.<CodeChangeHandler>newArrayList();  /** Name of the synthetic input that holds synthesized externs. */  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";  private CompilerInput synthesizedExternsInput = null;  @Override  void addChangeHandler(CodeChangeHandler handler) {    codeChangeHandlers.add(handler);  }  @Override  void removeChangeHandler(CodeChangeHandler handler) {    codeChangeHandlers.remove(handler);  }  /**   * All passes should call reportCodeChange() when they alter   * the JS tree structure. This is verified by CompilerTestCase.   * This allows us to optimize to a fixed point.   */  @Override  public void reportCodeChange() {    for (CodeChangeHandler handler : codeChangeHandlers) {      handler.reportChange();    }  }  @Override  public CodingConvention getCodingConvention() {    CodingConvention convention = options.getCodingConvention();    convention = convention != null ? convention : defaultCodingConvention;    return convention;  }  @Override  public boolean isIdeMode() {    return options.ideMode;  }  @Override  public boolean acceptEcmaScript5() {    switch (options.getLanguageIn()) {      case ECMASCRIPT5:      case ECMASCRIPT5_STRICT:        return true;    }    return false;  }  public LanguageMode languageMode() {    return options.getLanguageIn();  }  @Override  public boolean acceptConstKeyword() {    return options.acceptConstKeyword;  }  @Override  Config getParserConfig() {    if (parserConfig == null) {      Config.LanguageMode mode;      switch (options.getLanguageIn()) {        case ECMASCRIPT3:          mode = Config.LanguageMode.ECMASCRIPT3;          break;        case ECMASCRIPT5:          mode = Config.LanguageMode.ECMASCRIPT5;          break;        case ECMASCRIPT5_STRICT:          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;          break;        default:          throw new IllegalStateException(\"unexpected language mode\");      }      parserConfig = ParserRunner.createConfig(        isIdeMode(),        mode,        acceptConstKeyword(),        options.extraAnnotationNames);    }    return parserConfig;  }  @Override  public boolean isTypeCheckingEnabled() {    return options.checkTypes;  }  //------------------------------------------------------------------------  // Error reporting  //------------------------------------------------------------------------  /**   * The warning classes that are available from the command-line, and   * are suppressable by the {@code @suppress} annotation.   */  protected DiagnosticGroups getDiagnosticGroups() {    return new DiagnosticGroups();  }  @Override  public void report(JSError error) {    CheckLevel level = error.level;    if (warningsGuard != null) {      CheckLevel newLevel = warningsGuard.level(error);      if (newLevel != null) {        level = newLevel;      }    }    if (level.isOn()) {      errorManager.report(level, error);    }  }  @Override  public CheckLevel getErrorLevel(JSError error) {    Preconditions.checkNotNull(options);    return warningsGuard.level(error);  }  /**   * Report an internal error.   */  @Override  void throwInternalError(String message, Exception cause) {    String finalMessage =      \"INTERNAL COMPILER ERROR.\\n\" +      \"Please report this problem.\\n\" + message;    RuntimeException e = new RuntimeException(finalMessage, cause);    if (cause != null) {      e.setStackTrace(cause.getStackTrace());    }    throw e;  }  /**   * Gets the number of errors.   */  public int getErrorCount() {    return errorManager.getErrorCount();  }  /**   * Gets the number of warnings.   */  public int getWarningCount() {    return errorManager.getWarningCount();  }  @Override  boolean hasHaltingErrors() {    return !isIdeMode() && getErrorCount() > 0;  }  /**   * Consults the {@link ErrorManager} to see if we've encountered errors   * that should halt compilation. <p>   *   * If {@link CompilerOptions#ideMode} is {@code true}, this function   * always returns {@code false} without consulting the error manager. The   * error manager will continue to be told about new errors and warnings, but   * the compiler will complete compilation of all inputs.<p>   */  public boolean hasErrors() {    return hasHaltingErrors();  }  /** Called from the compiler passes, adds debug info */  @Override  void addToDebugLog(String str) {    debugLog.append(str);    debugLog.append('\\n');    logger.fine(str);  }  private SourceFile getSourceFileByName(String sourceName) {    // Here we assume that the source name is the input name, this    // is try of javascript parsed from source.    if (sourceName != null) {      CompilerInput input = inputsById.get(new InputId(sourceName));      if (input != null) {        return input.getSourceFile();      }    }    return null;  }  @Override  public String getSourceLine(String sourceName, int lineNumber) {    if (lineNumber < 1) {      return null;    }    SourceFile input = getSourceFileByName(sourceName);    if (input != null) {      return input.getLine(lineNumber);    }    return null;  }  @Override  public Region getSourceRegion(String sourceName, int lineNumber) {    if (lineNumber < 1) {      return null;    }    SourceFile input = getSourceFileByName(sourceName);    if (input != null) {      return input.getRegion(lineNumber);    }    return null;  }  //------------------------------------------------------------------------  // Package-private helpers  //------------------------------------------------------------------------  @Override  Node getNodeForCodeInsertion(JSModule module) {    if (module == null) {      if (inputs.isEmpty()) {        throw new IllegalStateException(\"No inputs\");      }      return inputs.get(0).getAstRoot(this);    }    List<CompilerInput> moduleInputs = module.getInputs();    if (moduleInputs.size() > 0) {      return moduleInputs.get(0).getAstRoot(this);    }    throw new IllegalStateException(\"Root module has no inputs\");  }  public SourceMap getSourceMap() {    return sourceMap;  }  VariableMap getVariableMap() {    return getPassConfig().getIntermediateState().variableMap;  }  VariableMap getPropertyMap() {    return getPassConfig().getIntermediateState().propertyMap;  }  CompilerOptions getOptions() {    return options;  }  FunctionInformationMap getFunctionalInformationMap() {    return functionInformationMap;  }  /**   * Sets the logging level for the com.google.javascript.jscomp package.   */  public static void setLoggingLevel(Level level) {    logger.setLevel(level);  }  /** Gets the DOT graph of the AST generated at the end of compilation. */  public String getAstDotGraph() throws IOException {    if (jsRoot != null) {      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);      cfa.process(null, jsRoot);      return DotFormatter.toDot(jsRoot, cfa.getCfg());    } else {      return \"\";    }  }  @Override  public ErrorManager getErrorManager() {    if (options == null) {      initOptions(newCompilerOptions());    }    return errorManager;  }  @Override  List<CompilerInput> getInputsInOrder() {    return Collections.<CompilerInput>unmodifiableList(inputs);  }  /**   * Returns an unmodifiable view of the compiler inputs indexed by id.   */  public Map<InputId, CompilerInput> getInputsById() {    return Collections.unmodifiableMap(inputsById);  }  /**   * Gets the externs in the order in which they are being processed.   */  List<CompilerInput> getExternsInOrder() {    return Collections.<CompilerInput>unmodifiableList(externs);  }  /**   * Stores the internal compiler state just before optimization is performed.   * This can be saved and restored in order to efficiently optimize multiple   * different output targets without having to perform checking multiple times.   *   * NOTE: This does not include all parts of the compiler's internal state. In   * particular, JSSourceFiles and CompilerOptions are not recorded. In   * order to recreate a Compiler instance from scratch, you would need to   * call {@code init} with the same arguments as in the initial creation before   * restoring intermediate state.   */  public static class IntermediateState implements Serializable {    private static final long serialVersionUID = 1L;    Node externsRoot;    private Node jsRoot;    private List<CompilerInput> externs;    private List<CompilerInput> inputs;    private List<JSModule> modules;    private PassConfig.State passConfigState;    private JSTypeRegistry typeRegistry;    private AbstractCompiler.LifeCycleStage lifeCycleStage;    private IntermediateState() {}  }  /**   * Returns the current internal state, excluding the input files and modules.   */  public IntermediateState getState() {    IntermediateState state = new IntermediateState();    state.externsRoot = externsRoot;    state.jsRoot = jsRoot;    state.externs = externs;    state.inputs = inputs;    state.modules = modules;    state.passConfigState = getPassConfig().getIntermediateState();    state.typeRegistry = typeRegistry;    state.lifeCycleStage = getLifeCycleStage();    return state;  }  /**   * Sets the internal state to the capture given.  Note that this assumes that   * the input files are already set up.   */  public void setState(IntermediateState state) {    externsRoot = state.externsRoot;    jsRoot = state.jsRoot;    externs = state.externs;    inputs = state.inputs;    modules = state.modules;    passes = createPassConfigInternal();    getPassConfig().setIntermediateState(state.passConfigState);    typeRegistry = state.typeRegistry;    setLifeCycleStage(state.lifeCycleStage);  }  @VisibleForTesting  List<CompilerInput> getInputsForTesting() {    return inputs;  }  @VisibleForTesting  List<CompilerInput> getExternsForTesting() {    return externs;  }  @Override  boolean hasRegExpGlobalReferences() {    return hasRegExpGlobalReferences;  }  @Override  void setHasRegExpGlobalReferences(boolean references) {    hasRegExpGlobalReferences = references;  }  @Override  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,      Node collectionRoot) {    Preconditions.checkState(collectionRoot.isScript()        || collectionRoot.isBlock());    if (globalRefMap == null) {      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),          getExternsInOrder());    }    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);  }  @Override  GlobalVarReferenceMap getGlobalVarReferences() {    return globalRefMap;  }  @Override  CompilerInput getSynthesizedExternsInput() {    if (synthesizedExternsInput == null) {      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);    }    return synthesizedExternsInput;  }  @Override  public double getProgress() {    return progress;  }  @Override  void setProgress(double newProgress) {    if (newProgress > 1.0) {      progress = 1.0;    } else if (newProgress < 0.0) {      progress = 0.0;    } else {      progress = newProgress;    }  }  /**   * Replaces one file in a hot-swap mode. The given JsAst should be made   * from a new version of a file that already was present in the last compile   * call. If the file is new, this will silently ignored.   *   * @param ast the ast of the file that is being replaced   */  public void replaceScript(JsAst ast) {    CompilerInput input = this.getInput(ast.getInputId());    if (!replaceIncrementalSourceAst(ast)) {      return;    }    Node originalRoot = input.getAstRoot(this);    processNewScript(ast, originalRoot);  }  /**   * Adds a new Script AST to the compile state. If a script for the same file   * already exists the script will not be added, instead a call to   * #replaceScript should be used.   *   * @param ast the ast of the new file   */  public void addNewScript(JsAst ast) {    if (!addNewSourceAst(ast)) {      return;    }    Node emptyScript = new Node(Token.SCRIPT);    InputId inputId = ast.getInputId();    emptyScript.setInputId(inputId);    emptyScript.setStaticSourceFile(        JSSourceFile.fromCode(inputId.getIdName(), \"\"));    processNewScript(ast, emptyScript);  }  private void processNewScript(JsAst ast, Node originalRoot) {    Node js = ast.getAstRoot(this);    Preconditions.checkNotNull(js);    runHotSwap(originalRoot, js, this.getCleanupPassConfig());    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need    // to revisit this approach to clearing GlobalNamespaces    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);    this.getTypeRegistry().clearNamedTypes();    this.removeSyntheticVarsInput();    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());  }  /**   * Execute the passes from a PassConfig instance over a single replaced file.   */  private void runHotSwap(      Node originalRoot, Node js, PassConfig passConfig) {    for (PassFactory passFactory : passConfig.getChecks()) {      runHotSwapPass(originalRoot, js, passFactory);    }  }  private void runHotSwapPass(      Node originalRoot, Node js, PassFactory passFactory) {    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);    if (pass != null) {      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());      pass.hotSwapScript(js, originalRoot);    }  }  private PassConfig getCleanupPassConfig() {    return new CleanupPasses(getOptions());  }  private void removeSyntheticVarsInput() {    String sourceName = Compiler.SYNTHETIC_EXTERNS;    removeExternInput(new InputId(sourceName));  }}\nCaused by: java.lang.IllegalStateException\n\t... 23 more"
            }
        },
        "evaluation_done": true,
        "context_generation_done": true,
        "evaluation_done2": true
    }
}