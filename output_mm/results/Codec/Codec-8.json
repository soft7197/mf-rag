{
    "Codec-8": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/java/org/apache/commons/codec/binary/Base64.java",
                "start_loc": 419,
                "end_loc": 425,
                "buggy_function": "    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n",
                "fixed_function": null,
                "comment": "",
                "normalized_body": [
                    "void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "void setInitialBuffer(byte[] out, int outPos, int outAvail) { if (out != null && out.length == outAvail) { buffer = out; pos = outPos; readPos = outPos; } }"
                    ],
                    [
                        0.9665049910545349,
                        "void encodeAll(String[] strings, String expectedEncoding) { for (int i = 0; i < strings.length; i++) { assertEquals(expectedEncoding, this.getEncoder().encode(strings[i])); } }"
                    ],
                    [
                        0.9447177052497864,
                        "private void flush(boolean propogate) throws IOException { int avail = base64.avail(); if (avail > 0) { byte[] buf = new byte[avail]; int c = base64.readResults(buf, 0, avail); if (c > 0) { out.write(buf, 0, c); } } if (propogate) { out.flush(); } }"
                    ],
                    [
                        0.9371064305305481,
                        "protected static char[] encodeHex(byte[] data, char[] toDigits) { int l = data.length; char[] out = new char[l << 1]; for (int i = 0, j = 0; i < l; i++) { out[j++] = toDigits[(0xF0 & data[i]) >>> 4]; out[j++] = toDigits[0x0F & data[i]]; } return out; }"
                    ],
                    [
                        0.9362969398498535,
                        "protected static boolean contains(String value, int start, int length, String[] criteria) { boolean result = false; if (start >= 0 && start + length <= value.length()) { String target = value.substring(start, start + length); for (int i = 0; i < criteria.length; i++) { if (target.equals(criteria[i])) { result = true; break; } } } return result; }"
                    ],
                    [
                        0.9357694983482361,
                        "public void testMD5Length() { String hashMe = \\\"this is some string that is longer than 16 characters\\\"; byte[] hash = DigestUtils.md5(getBytesUtf8(hashMe)); assertEquals(16, hash.length); hashMe = \\\"length < 16\\\"; hash = DigestUtils.md5(getBytesUtf8(hashMe)); assertEquals(16, hash.length); }"
                    ],
                    [
                        0.934303879737854,
                        "public static char[] encodeHex(byte[] data, boolean toLowerCase) { return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length == outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testCodec105() throws IOException {\n        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n        for (int i = 0; i < 5; i++) {\n            in.read();\n        }\n    }\n```\n#Error message from the test method 1: java.lang.ArrayIndexOutOfBoundsException: 2\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {  // Changed the condition to check if out.length is greater than or equal to outAvail\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length >= outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail && outPos <= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\n    void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n        if (out != null && out.length >= outAvail && outPos < outAvail) {\n            buffer = out;\n            pos = outPos;\n            readPos = outPos;\n        }\n    }\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n",
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && outAvail <= out.length && outPos < outAvail) {\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n"
                        ],
                        "plausible_patches": [
                            "\nvoid setInitialBuffer(byte[] out, int outPos, int outAvail) {\n    if (out != null && out.length >= outAvail) {  // Changed the condition to check if out.length is greater than or equal to outAvail\n        buffer = out;\n        pos = outPos;\n        readPos = outPos;\n    }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/java/org/apache/commons/codec/binary/Base64InputStream.java",
                "start_loc": 138,
                "end_loc": 182,
                "buggy_function": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                "fixed_function": "    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (doEncode) {\n                                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                "comment": "    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n",
                "normalized_body": [
                    "public int read(byte b[], int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0; while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } }"
                ],
                "top_similar_methods": [
                    [
                        0.9999463558197021,
                        "public int read(byte[] b, int offset, int len) throws IOException { if (b == null) { throw new NullPointerException(); } else if (offset < 0 || len < 0) { throw new IndexOutOfBoundsException(); } else if (offset > b.length || offset + len > b.length) { throw new IndexOutOfBoundsException(); } else if (len == 0) { return 0; } else { int readLen = 0; while (readLen == 0) { if (!base64.hasData()) { byte[] buf = new byte[doEncode ? 4096 : 8192]; int c = in.read(buf); if (c > 0 && b.length == len) { base64.setInitialBuffer(b, offset, len); } if (doEncode) { base64.encode(buf, 0, c); } else { base64.decode(buf, 0, c); } } readLen = base64.readResults(b, offset, len); } return readLen; } }"
                    ],
                    [
                        0.9452299475669861,
                        "public void testEncodeObjects() throws Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(); String plain = \\\"1+1 = 2\\\"; String encoded = (String) qpcodec.encode((Object) plain); assertEquals(\\\"Basic quoted-printable encoding test\\\", \\\"1+1 =3D 2\\\", encoded); byte[] plainBA = plain.getBytes(\\\"UTF-8\\\"); byte[] encodedBA = (byte[]) qpcodec.encode((Object) plainBA); encoded = new String(encodedBA); assertEquals(\\\"Basic quoted-printable encoding test\\\", \\\"1+1 =3D 2\\\", encoded); Object result = qpcodec.encode((Object) null); assertEquals(\\\"Encoding a null Object should return null\\\", null, result); try { Object dObj = new Double(3.0); qpcodec.encode(dObj); fail(\\\"Trying to url encode a Double object should cause an exception.\\\"); } catch (EncoderException ee) { } }"
                    ],
                    [
                        0.9428578615188599,
                        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } switch(modulus) { case 1: buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buffer[pos++] = PAD; buffer[pos++] = PAD; } break; case 2: buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buffer[pos++] = PAD; } break; } byte b = lineSeparator[lineSeparator.length - 1]; if (lineLength > 0 && pos > 0 && buffer[pos - 1] != b) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } }"
                    ],
                    [
                        0.9425671100616455,
                        "public void testDecodeObjects() throws Exception { QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(); String plain = \\\"1+1 =3D 2\\\"; String decoded = (String) qpcodec.decode((Object) plain); assertEquals(\\\"Basic quoted-printable decoding test\\\", \\\"1+1 = 2\\\", decoded); byte[] plainBA = plain.getBytes(\\\"UTF-8\\\"); byte[] decodedBA = (byte[]) qpcodec.decode((Object) plainBA); decoded = new String(decodedBA); assertEquals(\\\"Basic quoted-printable decoding test\\\", \\\"1+1 = 2\\\", decoded); Object result = qpcodec.decode((Object) null); assertEquals(\\\"Decoding a null Object should return null\\\", null, result); try { Object dObj = new Double(3.0); qpcodec.decode(dObj); fail(\\\"Trying to url encode a Double object should cause an exception.\\\"); } catch (DecoderException ee) { } }"
                    ],
                    [
                        0.938705563545227,
                        "public String soundex(String str) { if (str == null) { return null; } str = SoundexUtils.clean(str); if (str.length() == 0) { return str; } char[] out = { '0', '0', '0', '0' }; char last, mapped; int incount = 1, count = 1; out[0] = str.charAt(0); last = getMappingCode(str, 0); while ((incount < str.length()) && (count < out.length)) { mapped = getMappingCode(str, incount++); if (mapped != 0) { if ((mapped != '0') && (mapped != last)) { out[count++] = mapped; } last = mapped; } } return new String(out); }"
                    ],
                    [
                        0.9370436072349548,
                        "private int handleSC(String value, DoubleMetaphoneResult result, int index) { if (charAt(value, index + 2) == 'H') { if (contains(value, index + 3, 2, \\\"OO\\\", \\\"ER\\\", \\\"EN\\\", \\\"UY\\\", \\\"ED\\\", \\\"EM\\\")) { if (contains(value, index + 3, 2, \\\"ER\\\", \\\"EN\\\")) { result.append(\\\"X\\\", \\\"SK\\\"); } else { result.append(\\\"SK\\\"); } } else { if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') { result.append('X', 'S'); } else { result.append('X'); } } } else if (contains(value, index + 2, 1, \\\"I\\\", \\\"E\\\", \\\"Y\\\")) { result.append('S'); } else { result.append(\\\"SK\\\"); } return index + 3; }"
                    ],
                    [
                        0.936587929725647,
                        "public void testEncodeObjects() throws Exception { URLCodec urlCodec = new URLCodec(); String plain = \\\"Hello there!\\\"; String encoded = (String) urlCodec.encode((Object) plain); assertEquals(\\\"Basic URL encoding test\\\", \\\"Hello+there%21\\\", encoded); byte[] plainBA = plain.getBytes(\\\"UTF-8\\\"); byte[] encodedBA = (byte[]) urlCodec.encode((Object) plainBA); encoded = new String(encodedBA); assertEquals(\\\"Basic URL encoding test\\\", \\\"Hello+there%21\\\", encoded); Object result = urlCodec.encode((Object) null); assertEquals(\\\"Encoding a null Object should return null\\\", null, result); try { Object dObj = new Double(3.0); urlCodec.encode(dObj); fail(\\\"Trying to url encode a Double object should cause an exception.\\\"); } catch (EncoderException ee) { } this.validateState(urlCodec); }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec105"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>\n     * from this InputStream.\n     * \n     * @param b\n     *            destination byte array\n     * @param offset\n     *            where to start writing the bytes\n     * @param len\n     *            maximum number of bytes to read\n     * \n     * @return number of bytes read\n     * @throws IOException\n     *             if an I/O error occurs.\n     * @throws NullPointerException\n     *             if the byte array parameter is null\n     * @throws IndexOutOfBoundsException\n     *             if offset, len or buffer size are invalid\n     */\n\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            /*\n             Rationale for while-loop on (readLen == 0):\n             -----\n             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n             rare case where it returns 0, we just keep trying.\n\n             This is essentially an undocumented contract for InputStream\n             implementors that want their code to work properly with\n             java.io.InputStreamReader, since the latter hates it when\n             InputStream.read(byte[]) returns a zero.  Unfortunately our\n             readResults() call must return 0 if a large amount of the data\n             being decoded was non-base64, so this while-loop enables proper\n             interop with InputStreamReader for that scenario.\n             -----\n             This is a fix for CODEC-101\n            */\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0 && b.length == len) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testCodec105() throws IOException {\n        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n        for (int i = 0; i < 5; i++) {\n            in.read();\n        }\n    }\n```\n#Error message: java.lang.ArrayIndexOutOfBoundsException: 2\n\tat org.apache.commons.codec.binary.Base64.encode(Base64.java:497)  buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n\tat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:173)  base64.encode(buf, 0, c);\n\tat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)  int r = read(singleByte, 0, 1);\n\tat org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105(Base64InputStreamTest.java:58)  in.read();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c == -1) {\n                    return -1; // handle end of stream\n                }\n                if (c > 0) {\n                    if (doEncode) {\n                        base64.setInitialBuffer(b, offset, len);\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n",
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c == -1) {\n                        return -1;\n                    }\n                    if (c > 0) {\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                            "\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c == -1) {\n                    return -1; // End of stream reached\n                }\n                if (c > 0) {\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n",
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (c == -1) {\n                        return -1; // EOF reached\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c == -1) {\n                        return -1;\n                    }\n                    if (c > 0 && b.length >= len + offset) {\n                        base64.setInitialBuffer(b, offset, b.length - offset);\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c == -1) {\n                        return -1; // EOF\n                    }\n                    if (c > 0) {\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                            "\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0) {\n                    base64.setInitialBuffer(b, offset, len);\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n\n            // Break if end of stream is reached\n            if (readLen == 0 && !base64.hasData() && in.available() == 0) {\n                return -1;\n            }\n        }\n        return readLen;\n    }\n}\n",
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c == -1) {\n                        return -1;\n                    }\n                    if (c > 0) {\n                        base64.setInitialBuffer(b, offset, len);\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n",
                            "\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c == -1) {\n                    return -1;\n                }\n                if (c > 0) {\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n",
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c > 0) {\n                        base64.setInitialBuffer(b, offset, len);\n                    }\n                    if (c == -1) {\n                        return -1; // handle end of stream\n                    }\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    public int read(byte b[], int offset, int len) throws IOException {\n        if (b == null) {\n            throw new NullPointerException();\n        } else if (offset < 0 || len < 0) {\n            throw new IndexOutOfBoundsException();\n        } else if (offset > b.length || offset + len > b.length) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        } else {\n            int readLen = 0;\n            while (readLen == 0) {\n                if (!base64.hasData()) {\n                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n                    int c = in.read(buf);\n                    if (c == -1) {\n                        return -1;\n                    }\n                    if (c > 0) {\n                        if (doEncode) {\n                            base64.encode(buf, 0, c);\n                        } else {\n                            base64.decode(buf, 0, c);\n                        }\n                    }\n                }\n                readLen = base64.readResults(b, offset, len);\n            }\n            return readLen;\n        }\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec105": {
                "path": "src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java",
                "function_name": "testCodec105",
                "src": "    public void testCodec105() throws IOException {\n        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n        for (int i = 0; i < 5; i++) {\n            in.read();\n        }\n    }",
                "error_msg": "java.lang.ArrayIndexOutOfBoundsException: 2\n\tat org.apache.commons.codec.binary.Base64.encode(Base64.java:497)\n\tat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:173)\n\tat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)\n\tat org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105(Base64InputStreamTest.java:58)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.ArrayIndexOutOfBoundsException: 2\n\tat org.apache.commons.codec.binary.Base64.encode(Base64.java:497)  buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n\tat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:173)  base64.encode(buf, 0, c);\n\tat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)  int r = read(singleByte, 0, 1);\n\tat org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105(Base64InputStreamTest.java:58)  in.read();"
            }
        },
        "evaluation_done": true
    }
}