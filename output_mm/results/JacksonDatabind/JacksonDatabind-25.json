{
    "JacksonDatabind-25": {
        "function_num": 4,
        "functions": [
            {
                "path": "src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java",
                "start_loc": 1747,
                "end_loc": 1811,
                "buggy_function": "    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n",
                "fixed_function": "    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n",
                "comment": "    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type of field, or the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n",
                "normalized_body": [
                    "    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n"
                ],
                "top_similar_methods": [
                    [
                        0.9637706875801086,
                        "protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams, BeanPropertyDefinition[]> creatorParams) throws JsonMappingException { AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor(); if (defaultCtor != null) { if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) { creators.setDefaultCreator(defaultCtor); } } List<AnnotatedConstructor> implicitCtors = null; for (AnnotatedConstructor ctor : beanDesc.getConstructors()) { final boolean isCreator = intr.hasCreatorAnnotation(ctor); BeanPropertyDefinition[] propDefs = creatorParams.get(ctor); final int argCount = ctor.getParameterCount(); if (argCount == 1) { BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0]; boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef); if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[1]; PropertyName name = (argDef == null) ? null : argDef.getFullName(); AnnotatedParameter arg = ctor.getParameter(0); properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg, intr.findInjectableValueId(arg)); creators.addPropertyCreator(ctor, isCreator, properties); } else { _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators, ctor, isCreator, vchecker.isCreatorVisible(ctor)); if (argDef != null) { ((POJOPropertyBuilder) argDef).removeConstructors(); } } continue; } AnnotatedParameter nonAnnotatedParam = null; SettableBeanProperty[] properties = new SettableBeanProperty[argCount]; int explicitNameCount = 0; int implicitWithCreatorCount = 0; int injectCount = 0; for (int i = 0; i < argCount; ++i) { final AnnotatedParameter param = ctor.getParameter(i); BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i]; Object injectId = intr.findInjectableValueId(param); final PropertyName name = (propDef == null) ? null : propDef.getFullName(); if (propDef != null && propDef.isExplicitlyNamed()) { ++explicitNameCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } if (injectId != null) { ++injectCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param); if (unwrapper != null) { properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null); ++explicitNameCount; continue; } if (isCreator && (name != null && !name.isEmpty())) { ++implicitWithCreatorCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } if (nonAnnotatedParam == null) { nonAnnotatedParam = param; } } final int namedCount = explicitNameCount + implicitWithCreatorCount; if (isCreator || (explicitNameCount > 0) || (injectCount > 0)) { if ((namedCount + injectCount) == argCount) { creators.addPropertyCreator(ctor, isCreator, properties); continue; } if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) { creators.addDelegatingCreator(ctor, isCreator, properties); continue; } PropertyName impl = _findImplicitParamName(nonAnnotatedParam, intr); if (impl == null || impl.isEmpty()) { int ix = nonAnnotatedParam.getIndex(); if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) { throw new IllegalArgumentException(\\\"Non-static inner classes like \\\" + ctor.getDeclaringClass().getName() + \\\" can not use @JsonCreator for constructors\\\"); } throw new IllegalArgumentException(\\\"Argument #\\\" + ix + \\\" of constructor \\\" + ctor + \\\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\\\"); } } if (!creators.hasDefaultCreator()) { if (implicitCtors == null) { implicitCtors = new LinkedList<AnnotatedConstructor>(); } implicitCtors.add(ctor); } } if ((implicitCtors != null) && !creators.hasDelegatingCreator() && !creators.hasPropertyBasedCreator()) { _checkImplicitlyNamedConstructors(ctxt, beanDesc, vchecker, intr, creators, implicitCtors); } }"
                    ],
                    [
                        0.9619018584489822,
                        "protected Date parseAsISO8601(String dateStr, ParsePosition pos) { int len = dateStr.length(); char c = dateStr.charAt(len - 1); DateFormat df; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale); } } else if (c == 'Z') { df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } if (dateStr.charAt(len - 4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len - 1, \\\".000\\\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len - 3); if (c == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.delete(len - 3, len - 2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { dateStr += \\\"00\\\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { int offset = len - 5; StringBuilder sb = new StringBuilder(dateStr); switch(timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \\\"00\\\"); break; case 9: sb.insert(offset, \\\"000\\\"); break; case 8: sb.insert(offset, \\\".000\\\"); break; case 7: break; case 6: sb.insert(offset, \\\"00.000\\\"); case 5: sb.insert(offset, \\\":00.000\\\"); } dateStr = sb.toString(); } df = _formatISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { switch(timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\\\".000\\\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } } } return df.parse(dateStr, pos); }"
                    ],
                    [
                        0.9601521492004395,
                        "@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { ExternalTypeHandler.Builder extTypes = null; SettableBeanProperty[] creatorProps; if (_valueInstantiator.canCreateFromObjectWith()) { creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); for (SettableBeanProperty prop : creatorProps) { if (prop.hasValueTypeDeserializer()) { TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { if (extTypes == null) { extTypes = new ExternalTypeHandler.Builder(); } extTypes.addExternal(prop, typeDeser); } } } } else { creatorProps = null; } UnwrappedPropertyHandler unwrapped = null; for (SettableBeanProperty origProp : _beanProperties) { SettableBeanProperty prop = origProp; if (!prop.hasValueDeserializer()) { JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); if (deser == null) { deser = findDeserializer(ctxt, prop.getType(), prop); } prop = prop.withValueDeserializer(deser); } else { JsonDeserializer<Object> deser = prop.getValueDeserializer(); JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop, prop.getType()); if (cd != deser) { prop = prop.withValueDeserializer(cd); } } prop = _resolveManagedReferenceProperty(ctxt, prop); if (!(prop instanceof ManagedReferenceProperty)) { prop = _resolvedObjectIdProperty(ctxt, prop); } SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); if (u != null) { prop = u; if (unwrapped == null) { unwrapped = new UnwrappedPropertyHandler(); } unwrapped.addProperty(prop); _beanProperties.remove(prop); continue; } prop = _resolveInnerClassValuedProperty(ctxt, prop); if (prop != origProp) { _beanProperties.replace(prop); if (creatorProps != null) { for (int i = 0, len = creatorProps.length; i < len; ++i) { if (creatorProps[i] == origProp) { creatorProps[i] = prop; break; } } } } if (prop.hasValueTypeDeserializer()) { TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { if (extTypes == null) { extTypes = new ExternalTypeHandler.Builder(); } extTypes.addExternal(prop, typeDeser); _beanProperties.remove(prop); continue; } } } if (_anySetter != null && !_anySetter.hasValueDeserializer()) { _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); } if (_valueInstantiator.canCreateUsingDelegate()) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\\\"Invalid delegate-creator definition for \\\" + _beanType + \\\": value instantiator (\\\" + _valueInstantiator.getClass().getName() + \\\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\\\"); } AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME, delegateType, null, _classAnnotations, delegateCreator, PropertyMetadata.STD_OPTIONAL); TypeDeserializer td = delegateType.getTypeHandler(); if (td == null) { td = ctxt.getConfig().findTypeDeserializer(delegateType); } JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property); if (td != null) { td = td.forProperty(property); dd = new TypeWrappedDeserializer(td, dd); } _delegateDeserializer = dd; } if (creatorProps != null) { _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); } if (extTypes != null) { _externalTypeIdHandler = extTypes.build(); _nonStandardCreation = true; } _unwrappedPropertyHandler = unwrapped; if (unwrapped != null) { _nonStandardCreation = true; } _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; }"
                    ],
                    [
                        0.9600675106048584,
                        "protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams, BeanPropertyDefinition[]> creatorParams) throws JsonMappingException { final DeserializationConfig config = ctxt.getConfig(); for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { final boolean isCreator = intr.hasCreatorAnnotation(factory); final int argCount = factory.getParameterCount(); if (argCount == 0) { if (isCreator) { creators.setDefaultCreator(factory); } continue; } final BeanPropertyDefinition[] propDefs = creatorParams.get(factory); if (argCount == 1) { BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0]; boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef); if (!useProps) { _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); continue; } } else { if (!isCreator) { continue; } } AnnotatedParameter nonAnnotatedParam = null; SettableBeanProperty[] properties = new SettableBeanProperty[argCount]; int implicitNameCount = 0; int explicitNameCount = 0; int injectCount = 0; for (int i = 0; i < argCount; ++i) { final AnnotatedParameter param = factory.getParameter(i); BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i]; Object injectId = intr.findInjectableValueId(param); final PropertyName name = (propDef == null) ? null : propDef.getFullName(); if (propDef != null && propDef.isExplicitlyNamed()) { ++explicitNameCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } if (injectId != null) { ++injectCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param); if (unwrapper != null) { properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null); ++implicitNameCount; continue; } if (isCreator) { if (name != null && !name.isEmpty()) { ++implicitNameCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } } if (nonAnnotatedParam == null) { nonAnnotatedParam = param; } } final int namedCount = explicitNameCount + implicitNameCount; if (isCreator || explicitNameCount > 0 || injectCount > 0) { if ((namedCount + injectCount) == argCount) { creators.addPropertyCreator(factory, isCreator, properties); } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) { creators.addDelegatingCreator(factory, isCreator, properties); } else { throw new IllegalArgumentException(\\\"Argument #\\\" + nonAnnotatedParam.getIndex() + \\\" of factory method \\\" + factory + \\\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\\\"); } } } }"
                    ],
                    [
                        0.9592586308717728,
                        "public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException { if (_delegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { wrapInstantiationProblem(e, ctxt); } } if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { JsonToken t = p.nextToken(); if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) { return null; } final Object value = deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \\\"Attempted to unwrap single value array for single '\\\" + _valueClass.getName() + \\\"' value but there was more than a single value in the array\\\"); } return value; } if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) { JsonToken t = p.nextToken(); if (t == JsonToken.END_ARRAY) { return null; } throw ctxt.mappingException(handledType(), JsonToken.START_ARRAY); } throw ctxt.mappingException(handledType()); }"
                    ],
                    [
                        0.9590741693973541,
                        "@SuppressWarnings(\\\"incomplete-switch\\\") @Override public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { switch(p.getCurrentTokenId()) { case JsonTokenId.ID_NUMBER_INT: switch(p.getNumberType()) { case INT: case LONG: case BIG_INTEGER: return p.getBigIntegerValue(); } break; case JsonTokenId.ID_NUMBER_FLOAT: if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, \\\"java.math.BigInteger\\\"); } return p.getDecimalValue().toBigInteger(); case JsonTokenId.ID_START_ARRAY: if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { p.nextToken(); final BigInteger value = deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \\\"Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array\\\"); } return value; } break; case JsonTokenId.ID_STRING: String text = p.getText().trim(); if (text.length() == 0) { return null; } try { return new BigInteger(text); } catch (IllegalArgumentException iae) { throw ctxt.weirdStringException(text, _valueClass, \\\"not a valid representation\\\"); } } throw ctxt.mappingException(_valueClass, p.getCurrentToken()); }"
                    ],
                    [
                        0.9589018672704697,
                        "@Override public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.VALUE_STRING) { char[] buffer = jp.getTextCharacters(); int offset = jp.getTextOffset(); int len = jp.getTextLength(); char[] result = new char[len]; System.arraycopy(buffer, offset, result, 0, len); return result; } if (jp.isExpectedStartArrayToken()) { StringBuilder sb = new StringBuilder(64); while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { if (t != JsonToken.VALUE_STRING) { throw ctxt.mappingException(Character.TYPE); } String str = jp.getText(); if (str.length() != 1) { throw JsonMappingException.from(jp, \\\"Can not convert a JSON String of length \\\" + str.length() + \\\" into a char element of char array\\\"); } sb.append(str.charAt(0)); } return sb.toString().toCharArray(); } if (t == JsonToken.VALUE_EMBEDDED_OBJECT) { Object ob = jp.getEmbeddedObject(); if (ob == null) return null; if (ob instanceof char[]) { return (char[]) ob; } if (ob instanceof String) { return ((String) ob).toCharArray(); } if (ob instanceof byte[]) { return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray(); } } throw ctxt.mappingException(_valueClass); }"
                    ],
                    [
                        0.9582335203886032,
                        "protected void _addFields(Map<String, POJOPropertyBuilder> props) { final AnnotationIntrospector ai = _annotationIntrospector; final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); final boolean transientAsIgnoral = _config.isEnabled(MapperFeature.PROPAGATE_TRANSIENT_MARKER); for (AnnotatedField f : _classDef.fields()) { String implName = (ai == null) ? null : ai.findImplicitPropertyName(f); if (implName == null) { implName = f.getName(); } PropertyName pn; if (ai == null) { pn = null; } else if (_forSerialization) { pn = ai.findNameForSerialization(f); } else { pn = ai.findNameForDeserialization(f); } boolean nameExplicit = (pn != null); if (nameExplicit && pn.isEmpty()) { pn = _propNameFromSimple(implName); nameExplicit = false; } boolean visible = (pn != null); if (!visible) { visible = _visibilityChecker.isFieldVisible(f); } boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); if (f.isTransient()) { visible = false; if (transientAsIgnoral) { ignored = true; } } if (pruneFinalFields && (pn == null) && !ignored && Modifier.isFinal(f.getModifiers())) { continue; } _property(props, implName).addField(f, pn, nameExplicit, visible, ignored); } }"
                    ],
                    [
                        0.9579308480024338,
                        "protected final long _parseLongPrimitive(JsonParser p, DeserializationContext ctxt) throws IOException { switch(p.getCurrentTokenId()) { case JsonTokenId.ID_NUMBER_INT: return p.getLongValue(); case JsonTokenId.ID_NUMBER_FLOAT: if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, \\\"long\\\"); } return p.getValueAsLong(); case JsonTokenId.ID_STRING: String text = p.getText().trim(); if (text.length() == 0 || _hasTextualNull(text)) { return 0L; } try { return NumberInput.parseLong(text); } catch (IllegalArgumentException iae) { } throw ctxt.weirdStringException(text, _valueClass, \\\"not a valid long value\\\"); case JsonTokenId.ID_NULL: return 0L; case JsonTokenId.ID_START_ARRAY: if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { p.nextToken(); final long parsed = _parseLongPrimitive(p, ctxt); JsonToken t = p.nextToken(); if (t != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \\\"Attempted to unwrap single value array for single 'long' value but there was more than a single value in the array\\\"); } return parsed; } break; } throw ctxt.mappingException(_valueClass, p.getCurrentToken()); }"
                    ]
                ],
                "directly_related_tests": [
                    "com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testByteArrayTypeOverride890"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type of field, or the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testByteArrayTypeOverride890() throws Exception\n    {\n        HiddenBinaryBean890 result = MAPPER.readValue(\n                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\n        assertNotNull(result);\n        assertNotNull(result.someBytes);\n        assertEquals(byte[].class, result.someBytes.getClass());\n    }\n```\n#Error message: com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:269)  throw new JsonMappingException(iae.getMessage(), null, iae);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)  return _createAndCache2(ctxt, factory, type);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)  deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n\tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)  JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n\tat com.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)  return ctxt.findContextualValueDeserializer(type, property);\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)  deser = findDeserializer(ctxt, prop.getType(), prop);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)  ((ResolvableDeserializer)deser).resolve(ctxt);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)  return _createAndCache2(ctxt, factory, type);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)  deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)  JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,                _factory, type);\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)  deser = ctxt.findRootValueDeserializer(valueType);\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3698)  JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2714)  return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n\tat com.fasterxml.jackson.databind.deser.TestArrayDeserialization.testByteArrayTypeOverride890(TestArrayDeserialization.java:563)  HiddenBinaryBean890 result = MAPPER.readValue(                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\nCaused by: java.lang.IllegalArgumentException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:808)  throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:138)  if (!isPotentialBeanType(type.getRawClass())) {            return null;        }\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)  return factory.createBeanDeserializer(ctxt, type, beanDesc);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)  return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)  deser = _createDeserializer(ctxt, factory, type);\n\t... 47 more\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            if (type.hasRawClass(subclass)) {\n                return type; // Type is already correct\n            }\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType();\n                }\n            }\n\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                if (type.getContentType().hasRawClass(cc)) {\n                    return type; // Content type is already correct\n                }\n                try {\n                    type = (T) type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) {\n                Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            // Fix: Check if type is of array type and handle accordingly\n            if (!type.isContainerType() && type.getRawClass().isArray() && !subclass.isArray()) {\n                throw new JsonMappingException(\"Cannot narrow array type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"'\");\n            }\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }            \n\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null && !type.hasRawClass(subclass)) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType();\n                }\n            }           \n           \n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null && !type.getContentType().hasRawClass(cc)) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) {\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n",
                            "\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                if (type.hasRawClass(byte[].class)) {\n                    // Since byte[] is a special case, we should not try to narrow\n                    return type;\n                }\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }\n\n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) {\n                Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null && !type.hasRawClass(subclass)) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n         *   (not 100% why or how, but this does seem to get called more than once, which\n         *   is not good: for now, let's just avoid errors)\n         */\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }        \n       \n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n         *   (not 100% why or how, but this does seem to get called more than once, which\n         *   is not good: for now, let's just avoid errors)\n         */\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }            \n\n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType != null && contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        if (type.hasRawClass(subclass)) {\n            return type;\n        }\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType();\n            }\n        }\n\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null && !type.getContentType().hasRawClass(cc)) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        \n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    if (type.isContainerType()) {\n        JavaType keyType = type.getKeyType();\n        if (keyType != null) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, keyType);\n            if (keyClass != null) {\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n                }\n            }\n            if (keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType();\n                }\n            }\n        }\n\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            Class<?> cc = intr.findDeserializationContentType(a, contentType);\n            if (cc != null) {\n                try {\n                    type = (T) type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n                }\n            }\n            if (contentType.getValueHandler() == null) {\n                Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n    } else {\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType();\n            }\n        }\n       \n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       JavaType contentType = type.getContentType();\n       if (contentType != null && contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null && !type.hasRawClass(byte[].class)) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { \n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type of field, or the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n\n    @SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, T type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    keyType = type.getKeyType(); // just in case it's used below\n                }\n            }            \n           \n           // and finally content class; only applicable to structured types\n           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n           if (cc != null) {\n               try {\n                   type = (T) type.narrowContentsBy(cc);\n               } catch (IllegalArgumentException iae) {\n                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n               }\n           }\n           // ... as well as deserializer for contents:\n           JavaType contentType = type.getContentType();\n           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n               Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testByteArrayTypeOverride890() throws Exception\n    {\n        HiddenBinaryBean890 result = MAPPER.readValue(\n                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\n        assertNotNull(result);\n        assertNotNull(result.someBytes);\n        assertEquals(byte[].class, result.someBytes.getClass());\n    }\n```\n#Error message: com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:269)  throw new JsonMappingException(iae.getMessage(), null, iae);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)  return _createAndCache2(ctxt, factory, type);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)  deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n\tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)  JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n\tat com.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)  return ctxt.findContextualValueDeserializer(type, property);\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)  deser = findDeserializer(ctxt, prop.getType(), prop);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)  ((ResolvableDeserializer)deser).resolve(ctxt);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)  return _createAndCache2(ctxt, factory, type);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)  deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)  JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,                _factory, type);\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)  deser = ctxt.findRootValueDeserializer(valueType);\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3698)  JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2714)  return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n\tat com.fasterxml.jackson.databind.deser.TestArrayDeserialization.testByteArrayTypeOverride890(TestArrayDeserialization.java:563)  HiddenBinaryBean890 result = MAPPER.readValue(                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\nCaused by: java.lang.IllegalArgumentException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:808)  throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:138)  if (!isPotentialBeanType(type.getRawClass())) {            return null;        }\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)  return factory.createBeanDeserializer(ctxt, type, beanDesc);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)  return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)  deser = _createDeserializer(ctxt, factory, type);\n\t... 47 more\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos) { int len = dateStr.length(); char c = dateStr.charAt(len - 1); DateFormat df; if (len <= 10 && Character.isDigit(c)) { df = _formatPlain; if (df == null) { df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale); } } else if (c == 'Z') { df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } if (dateStr.charAt(len - 4) == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.insert(len - 1, \\\".000\\\"); dateStr = sb.toString(); } } else { if (hasTimeZone(dateStr)) { c = dateStr.charAt(len - 3); if (c == ':') { StringBuilder sb = new StringBuilder(dateStr); sb.delete(len - 3, len - 2); dateStr = sb.toString(); } else if (c == '+' || c == '-') { dateStr += \\\"00\\\"; } len = dateStr.length(); int timeLen = len - dateStr.lastIndexOf('T') - 6; if (timeLen < 12) { int offset = len - 5; StringBuilder sb = new StringBuilder(dateStr); switch(timeLen) { case 11: sb.insert(offset, '0'); break; case 10: sb.insert(offset, \\\"00\\\"); break; case 9: sb.insert(offset, \\\"000\\\"); break; case 8: sb.insert(offset, \\\".000\\\"); break; case 7: break; case 6: sb.insert(offset, \\\"00.000\\\"); case 5: sb.insert(offset, \\\":00.000\\\"); } dateStr = sb.toString(); } df = _formatISO8601; if (_formatISO8601 == null) { df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale); } } else { StringBuilder sb = new StringBuilder(dateStr); int timeLen = len - dateStr.lastIndexOf('T') - 1; if (timeLen < 12) { switch(timeLen) { case 11: sb.append('0'); case 10: sb.append('0'); case 9: sb.append('0'); break; default: sb.append(\\\".000\\\"); } } sb.append('Z'); dateStr = sb.toString(); df = _formatISO8601_z; if (df == null) { df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale); } } } return df.parse(dateStr, pos); }\n```\n\n            \n```java\n@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { ExternalTypeHandler.Builder extTypes = null; SettableBeanProperty[] creatorProps; if (_valueInstantiator.canCreateFromObjectWith()) { creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); for (SettableBeanProperty prop : creatorProps) { if (prop.hasValueTypeDeserializer()) { TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { if (extTypes == null) { extTypes = new ExternalTypeHandler.Builder(); } extTypes.addExternal(prop, typeDeser); } } } } else { creatorProps = null; } UnwrappedPropertyHandler unwrapped = null; for (SettableBeanProperty origProp : _beanProperties) { SettableBeanProperty prop = origProp; if (!prop.hasValueDeserializer()) { JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); if (deser == null) { deser = findDeserializer(ctxt, prop.getType(), prop); } prop = prop.withValueDeserializer(deser); } else { JsonDeserializer<Object> deser = prop.getValueDeserializer(); JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop, prop.getType()); if (cd != deser) { prop = prop.withValueDeserializer(cd); } } prop = _resolveManagedReferenceProperty(ctxt, prop); if (!(prop instanceof ManagedReferenceProperty)) { prop = _resolvedObjectIdProperty(ctxt, prop); } SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); if (u != null) { prop = u; if (unwrapped == null) { unwrapped = new UnwrappedPropertyHandler(); } unwrapped.addProperty(prop); _beanProperties.remove(prop); continue; } prop = _resolveInnerClassValuedProperty(ctxt, prop); if (prop != origProp) { _beanProperties.replace(prop); if (creatorProps != null) { for (int i = 0, len = creatorProps.length; i < len; ++i) { if (creatorProps[i] == origProp) { creatorProps[i] = prop; break; } } } } if (prop.hasValueTypeDeserializer()) { TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { if (extTypes == null) { extTypes = new ExternalTypeHandler.Builder(); } extTypes.addExternal(prop, typeDeser); _beanProperties.remove(prop); continue; } } } if (_anySetter != null && !_anySetter.hasValueDeserializer()) { _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); } if (_valueInstantiator.canCreateUsingDelegate()) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\\\"Invalid delegate-creator definition for \\\" + _beanType + \\\": value instantiator (\\\" + _valueInstantiator.getClass().getName() + \\\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\\\"); } AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME, delegateType, null, _classAnnotations, delegateCreator, PropertyMetadata.STD_OPTIONAL); TypeDeserializer td = delegateType.getTypeHandler(); if (td == null) { td = ctxt.getConfig().findTypeDeserializer(delegateType); } JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property); if (td != null) { td = td.forProperty(property); dd = new TypeWrappedDeserializer(td, dd); } _delegateDeserializer = dd; } if (creatorProps != null) { _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); } if (extTypes != null) { _externalTypeIdHandler = extTypes.build(); _nonStandardCreation = true; } _unwrappedPropertyHandler = unwrapped; if (unwrapped != null) { _nonStandardCreation = true; } _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; }\n```\n\n            \n```java\nprotected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker, AnnotationIntrospector intr, CreatorCollector creators, Map<AnnotatedWithParams, BeanPropertyDefinition[]> creatorParams) throws JsonMappingException { final DeserializationConfig config = ctxt.getConfig(); for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { final boolean isCreator = intr.hasCreatorAnnotation(factory); final int argCount = factory.getParameterCount(); if (argCount == 0) { if (isCreator) { creators.setDefaultCreator(factory); } continue; } final BeanPropertyDefinition[] propDefs = creatorParams.get(factory); if (argCount == 1) { BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0]; boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef); if (!useProps) { _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators, factory, isCreator); continue; } } else { if (!isCreator) { continue; } } AnnotatedParameter nonAnnotatedParam = null; SettableBeanProperty[] properties = new SettableBeanProperty[argCount]; int implicitNameCount = 0; int explicitNameCount = 0; int injectCount = 0; for (int i = 0; i < argCount; ++i) { final AnnotatedParameter param = factory.getParameter(i); BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i]; Object injectId = intr.findInjectableValueId(param); final PropertyName name = (propDef == null) ? null : propDef.getFullName(); if (propDef != null && propDef.isExplicitlyNamed()) { ++explicitNameCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } if (injectId != null) { ++injectCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param); if (unwrapper != null) { properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null); ++implicitNameCount; continue; } if (isCreator) { if (name != null && !name.isEmpty()) { ++implicitNameCount; properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId); continue; } } if (nonAnnotatedParam == null) { nonAnnotatedParam = param; } } final int namedCount = explicitNameCount + implicitNameCount; if (isCreator || explicitNameCount > 0 || injectCount > 0) { if ((namedCount + injectCount) == argCount) { creators.addPropertyCreator(factory, isCreator, properties); } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) { creators.addDelegatingCreator(factory, isCreator, properties); } else { throw new IllegalArgumentException(\\\"Argument #\\\" + nonAnnotatedParam.getIndex() + \\\" of factory method \\\" + factory + \\\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\\\"); } } } }\n```\n\n            \n```java\npublic Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException { if (_delegateDeserializer != null) { try { Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt)); if (_injectables != null) { injectValues(ctxt, bean); } return bean; } catch (Exception e) { wrapInstantiationProblem(e, ctxt); } } if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { JsonToken t = p.nextToken(); if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) { return null; } final Object value = deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \\\"Attempted to unwrap single value array for single '\\\" + _valueClass.getName() + \\\"' value but there was more than a single value in the array\\\"); } return value; } if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) { JsonToken t = p.nextToken(); if (t == JsonToken.END_ARRAY) { return null; } throw ctxt.mappingException(handledType(), JsonToken.START_ARRAY); } throw ctxt.mappingException(handledType()); }\n```\n\n            \n```java\n@SuppressWarnings(\\\"incomplete-switch\\\") @Override public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException { switch(p.getCurrentTokenId()) { case JsonTokenId.ID_NUMBER_INT: switch(p.getNumberType()) { case INT: case LONG: case BIG_INTEGER: return p.getBigIntegerValue(); } break; case JsonTokenId.ID_NUMBER_FLOAT: if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_FLOAT_AS_INT)) { _failDoubleToIntCoercion(p, ctxt, \\\"java.math.BigInteger\\\"); } return p.getDecimalValue().toBigInteger(); case JsonTokenId.ID_START_ARRAY: if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) { p.nextToken(); final BigInteger value = deserialize(p, ctxt); if (p.nextToken() != JsonToken.END_ARRAY) { throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \\\"Attempted to unwrap single value array for single 'BigInteger' value but there was more than a single value in the array\\\"); } return value; } break; case JsonTokenId.ID_STRING: String text = p.getText().trim(); if (text.length() == 0) { return null; } try { return new BigInteger(text); } catch (IllegalArgumentException iae) { throw ctxt.weirdStringException(text, _valueClass, \\\"not a valid representation\\\"); } } throw ctxt.mappingException(_valueClass, p.getCurrentToken()); }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(ctxt.getParser(), \"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(ctxt.getParser(),\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(ctxt.getParser(),\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }            \n\n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(ctxt.getParser(),\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    if (intr == null) {\n        return type;\n    }\n\n    // First: check class for the instance itself:\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(ctxt.getParser(), \"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), iae);\n        }\n    }\n\n    // Then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(ctxt.getParser(), \"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(ctxt.getParser(), \"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        \n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }            \n       \n       // And finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(ctxt.getParser(), \"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), iae);\n           }\n       }\n       \n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        if(!type.getRawClass().isAssignableFrom(subclass)) {\n            throw new JsonMappingException(\"Invalid type annotation: \" + subclass.getName() +\n                    \" is not a subtype of \" + type.getRawClass().getName());\n        }\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            if (!type.getKeyType().getRawClass().isAssignableFrom(keyClass)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: \" + keyClass.getName() +\n                        \" is not a subtype of \" + type.getKeyType().getRawClass().getName());\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); \n            }\n        }\n       \n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           if (!type.getContentType().getRawClass().isAssignableFrom(cc)) {\n               throw new JsonMappingException(\"Illegal content-type annotation: \" + cc.getName() +\n                       \" is not a subtype of \" + type.getContentType().getRawClass().getName());\n           }\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        if (type.hasRawClass(byte[].class)) {\n            return type;\n        }\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType();\n            }\n        }\n\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({\"unchecked\"})\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        // Ensure it is compatible type\n        if (!type.getRawClass().isAssignableFrom(subclass)) {\n            throw new JsonMappingException(\"Cannot resolve subtype \" + subclass.getName() + \" for \" + type, null);\n        }\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }\n\n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        if (type.hasRawClass(subclass)) {\n            return type;\n        }\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }            \n       \n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           if (type.getContentType().hasRawClass(cc)) {\n               return type;\n           }\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n           JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n           if (cd != null) {\n               type = (T) type.withContentValueHandler(cd);\n           }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, \n                \"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(null, \n                    \"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, \n                    \"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n            }\n        }\n       \n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, \n                    \"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType != null && contentType.getValueHandler() == null) {\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null && !type.hasRawClass(subclass)) { // Add check to ensure the subclass is different from the current class\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }\n       \n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        if (type.hasRawClass(subclass)) {\n            return type;\n        }\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(ctxt.getParser(), \n                \"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(ctxt.getParser(), \n                    \"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(ctxt.getParser(), \n                    \"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType();\n            }\n        }            \n\n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(ctxt.getParser(), \n                   \"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n",
                            "\n@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n        Annotated a, T type)\n    throws JsonMappingException\n{\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n        }\n    }\n\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                keyType = type.getKeyType(); // just in case it's used below\n            }\n        }            \n\n       // and finally content class; only applicable to structured types\n       Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n       if (cc != null) {\n           try {\n               type = (T) type.narrowContentsBy(cc);\n           } catch (IllegalArgumentException iae) {\n               throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n           }\n       }\n       // ... as well as deserializer for contents:\n       JavaType contentType = type.getContentType();\n       if (contentType.getValueHandler() == null) {\n           Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java",
                "start_loc": 468,
                "end_loc": 543,
                "buggy_function": "    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }\n",
                "fixed_function": "    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n            Annotated a, JavaType type)\n        throws JsonMappingException\n    {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = ctxt.getTypeFactory().constructSpecializedType(type, subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n            }\n        }\n\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n                }\n                try {\n                    type = ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n             *   (not 100% why or how, but this does seem to get called more than once, which\n             *   is not good: for now, let's just avoid errors)\n             */\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                if (kdDef != null) {\n                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                    if (kd != null) {\n                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n                        keyType = type.getKeyType(); // just in case it's used below\n                    }\n                }\n            }            \n            \n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                if (cdDef != null) {\n                    JsonDeserializer<?> cd = null;\n                    if (cdDef instanceof JsonDeserializer<?>) {\n                        cdDef = (JsonDeserializer<?>) cdDef;\n                    } else {\n                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                        if (cdClass != null) {\n                            cd = ctxt.deserializerInstance(a, cdClass);\n                        }\n                    }\n                    if (cd != null) {\n                        type = type.withContentValueHandler(cd);\n                    }\n                }\n            }\n        }\n        return type;\n    }\n",
                "comment": "    /**\n     * Method called to see if given method has annotations that indicate\n     * a more specific type than what the argument specifies.\n     * If annotations are present, they must specify compatible Class;\n     * instance of which can be assigned using the method. This means\n     * that the Class has to be raw class of type, or its sub-class\n     * (or, implementing class if original Class instance is an interface).\n     *\n     * @param a Method or field that the type is associated with\n     * @param type Type derived from the setter argument\n     *\n     * @return Original type if no annotations are present; or a more\n     *   specific type derived from it if type annotation(s) was found\n     *\n     * @throws JsonMappingException if invalid annotation is found\n     */\n",
                "normalized_body": [
                    "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow type \\\" + type + \\\" with concrete-type annotation (value \\\" + subclass.getName() + \\\"), method '\\\" + a.getName() + \\\"': \\\" + iae.getMessage(), null, iae); } } if (type.isContainerType()) { Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapLikeType)) { throw new JsonMappingException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map(-like) type\\\"); } try { type = ((MapLikeType) type).narrowKey(keyClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage(), null, iae); } } JavaType keyType = type.getKeyType(); if (keyType != null && keyType.getValueHandler() == null) { Object kdDef = intr.findKeyDeserializer(a); if (kdDef != null) { KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); if (kd != null) { type = ((MapLikeType) type).withKeyValueHandler(kd); keyType = type.getKeyType(); } } } Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); if (cc != null) { try { type = type.narrowContentsBy(cc); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage(), null, iae); } } JavaType contentType = type.getContentType(); if (contentType.getValueHandler() == null) { Object cdDef = intr.findContentDeserializer(a); if (cdDef != null) { JsonDeserializer<?> cd = null; if (cdDef instanceof JsonDeserializer<?>) { cdDef = (JsonDeserializer<?>) cdDef; } else { Class<?> cdClass = _verifyAsClass(cdDef, \\\"findContentDeserializer\\\", JsonDeserializer.None.class); if (cdClass != null) { cd = ctxt.deserializerInstance(a, cdClass); } } if (cd != null) { type = type.withContentValueHandler(cd); } } } } return type; }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow type \\\" + type + \\\" with concrete-type annotation (value \\\" + subclass.getName() + \\\"), method '\\\" + a.getName() + \\\"': \\\" + iae.getMessage(), null, iae); } } if (type.isContainerType()) { Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapLikeType)) { throw new JsonMappingException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map(-like) type\\\"); } try { type = ((MapLikeType) type).narrowKey(keyClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage(), null, iae); } } JavaType keyType = type.getKeyType(); if (keyType != null && keyType.getValueHandler() == null) { Object kdDef = intr.findKeyDeserializer(a); if (kdDef != null) { KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); if (kd != null) { type = ((MapLikeType) type).withKeyValueHandler(kd); keyType = type.getKeyType(); } } } Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); if (cc != null) { try { type = type.narrowContentsBy(cc); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage(), null, iae); } } JavaType contentType = type.getContentType(); if (contentType.getValueHandler() == null) { Object cdDef = intr.findContentDeserializer(a); if (cdDef != null) { JsonDeserializer<?> cd = null; if (cdDef instanceof JsonDeserializer<?>) { cdDef = (JsonDeserializer<?>) cdDef; } else { Class<?> cdClass = _verifyAsClass(cdDef, \\\"findContentDeserializer\\\", JsonDeserializer.None.class); if (cdClass != null) { cd = ctxt.deserializerInstance(a, cdClass); } } if (cd != null) { type = type.withContentValueHandler(cd); } } } } return type; }"
                    ],
                    [
                        0.9912133812904358,
                        "public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { Class<?> rawType = type.getRawClass(); if (rawType == CLASS_OBJECT) { DeserializationConfig config = ctxt.getConfig(); JavaType lt, mt; if (_factoryConfig.hasAbstractTypeResolvers()) { lt = _findRemappedType(config, List.class); mt = _findRemappedType(config, Map.class); } else { lt = mt = null; } return new UntypedObjectDeserializer(lt, mt); } if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) { return StringDeserializer.instance; } if (type.isReferenceType()) { JavaType referencedType = type.getReferencedType(); if (AtomicReference.class.isAssignableFrom(rawType)) { TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType); BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType); JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo()); return new AtomicReferenceDeserializer(referencedType, vts, deser); } } if (rawType == CLASS_ITERABLE) { TypeFactory tf = ctxt.getTypeFactory(); JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE); JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0]; CollectionType ct = tf.constructCollectionType(Collection.class, elemType); return createCollectionDeserializer(ctxt, ct, beanDesc); } if (rawType == CLASS_MAP_ENTRY) { JavaType kt = type.containedType(0); if (kt == null) { kt = TypeFactory.unknownType(); } JavaType vt = type.containedType(1); if (vt == null) { vt = TypeFactory.unknownType(); } TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler(); if (vts == null) { vts = findTypeDeserializer(ctxt.getConfig(), vt); } JsonDeserializer<Object> valueDeser = vt.getValueHandler(); KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler(); return new MapEntryDeserializer(type, keyDes, valueDeser, vts); } String clsName = rawType.getName(); if (rawType.isPrimitive() || clsName.startsWith(\\\"java.\\\")) { JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName); if (deser == null) { deser = DateDeserializers.find(rawType, clsName); } if (deser != null) { return deser; } } if (rawType == TokenBuffer.class) { return new TokenBufferDeserializer(); } JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc); if (deser != null) { return deser; } return JdkDeserializers.find(rawType, clsName); }"
                    ],
                    [
                        0.9901953041553497,
                        "protected List<BeanPropertyWriter> findBeanProperties(SerializerProvider prov, BeanDescription beanDesc, BeanSerializerBuilder builder) throws JsonMappingException { List<BeanPropertyDefinition> properties = beanDesc.findProperties(); final SerializationConfig config = prov.getConfig(); removeIgnorableTypes(config, beanDesc, properties); if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) { removeSetterlessGetters(config, beanDesc, properties); } if (properties.isEmpty()) { return null; } boolean staticTyping = usesStaticTyping(config, beanDesc, null); PropertyBuilder pb = constructPropertyBuilder(config, beanDesc); ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size()); TypeBindings typeBind = beanDesc.bindingsForBeanType(); for (BeanPropertyDefinition property : properties) { final AnnotatedMember accessor = property.getAccessor(); if (property.isTypeId()) { if (accessor != null) { if (config.canOverrideAccessModifiers()) { accessor.fixAccess(); } builder.setTypeId(accessor); } continue; } AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType(); if (refType != null && refType.isBackReference()) { continue; } if (accessor instanceof AnnotatedMethod) { result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedMethod) accessor)); } else { result.add(_constructWriter(prov, property, typeBind, pb, staticTyping, (AnnotatedField) accessor)); } } return result; }"
                    ],
                    [
                        0.9899820387363434,
                        "@Override public EnumMap<?, ?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException { if (jp.getCurrentToken() != JsonToken.START_OBJECT) { return _deserializeFromEmpty(jp, ctxt); } EnumMap result = constructMap(); final JsonDeserializer<Object> valueDes = _valueDeserializer; final TypeDeserializer typeDeser = _valueTypeDeserializer; while ((jp.nextToken()) == JsonToken.FIELD_NAME) { String keyName = jp.getCurrentName(); Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt); if (key == null) { if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { throw ctxt.weirdStringException(keyName, _enumClass, \\\"value not one of declared Enum instance names for \\\" + _mapType.getKeyType()); } jp.nextToken(); jp.skipChildren(); continue; } JsonToken t = jp.nextToken(); Object value; try { if (t == JsonToken.VALUE_NULL) { value = valueDes.getNullValue(ctxt); } else if (typeDeser == null) { value = valueDes.deserialize(jp, ctxt); } else { value = valueDes.deserializeWithType(jp, ctxt, typeDeser); } } catch (Exception e) { wrapAndThrow(e, result, keyName); return null; } result.put(key, value); } return result; }"
                    ],
                    [
                        0.9899575114250183,
                        "@Override @SuppressWarnings(\\\"unchecked\\\") public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType keyType, JsonSerializer<Object> defaultImpl) { BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass()); JsonSerializer<?> ser = null; if (_factoryConfig.hasKeySerializers()) { for (Serializers serializers : _factoryConfig.keySerializers()) { ser = serializers.findSerializer(config, keyType, beanDesc); if (ser != null) { break; } } } if (ser == null) { ser = defaultImpl; if (ser == null) { ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false); if (ser == null) { beanDesc = config.introspect(keyType); AnnotatedMethod am = beanDesc.findJsonValueMethod(); if (am != null) { final Class<?> rawType = am.getRawReturnType(); JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config, rawType, true); Method m = am.getAnnotated(); if (config.canOverrideAccessModifiers()) { ClassUtil.checkAndFixAccess(m); } ser = new JsonValueSerializer(m, delegate); } else { ser = StdKeySerializers.getDefault(); } } } } if (_factoryConfig.hasSerializerModifiers()) { for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { ser = mod.modifyKeySerializer(config, keyType, beanDesc, ser); } } return (JsonSerializer<Object>) ser; }"
                    ],
                    [
                        0.9893901646137238,
                        "public void serializePolymorphic(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> valueSer, TypeSerializer typeSer) throws IOException { if (value == null) { _serializeNull(gen); return; } if ((rootType != null) && !rootType.getRawClass().isAssignableFrom(value.getClass())) { _reportIncompatibleRootType(value, rootType); } if (valueSer == null) { if ((rootType != null) && rootType.isContainerType()) { valueSer = findValueSerializer(rootType, null); } else { valueSer = findValueSerializer(value.getClass(), null); } } final boolean wrap; PropertyName rootName = _config.getFullRootName(); if (rootName == null) { wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); if (wrap) { gen.writeStartObject(); PropertyName pname = _config.findRootName(value.getClass()); gen.writeFieldName(pname.simpleAsEncoded(_config)); } } else if (rootName.isEmpty()) { wrap = false; } else { wrap = true; gen.writeStartObject(); gen.writeFieldName(rootName.getSimpleName()); } try { valueSer.serializeWithType(value, gen, this, typeSer); if (wrap) { gen.writeEndObject(); } } catch (IOException ioe) { throw ioe; } catch (Exception e) { String msg = e.getMessage(); if (msg == null) { msg = \\\"[no message for \\\" + e.getClass().getName() + \\\"]\\\"; } throw new JsonMappingException(msg, e); } }"
                    ],
                    [
                        0.9888617992401123,
                        "@Override public final KeyDeserializer keyDeserializerInstance(Annotated ann, Object deserDef) throws JsonMappingException { if (deserDef == null) { return null; } KeyDeserializer deser; if (deserDef instanceof KeyDeserializer) { deser = (KeyDeserializer) deserDef; } else { if (!(deserDef instanceof Class)) { throw new IllegalStateException(\\\"AnnotationIntrospector returned key deserializer definition of type \\\" + deserDef.getClass().getName() + \\\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\\\"); } Class<?> deserClass = (Class<?>) deserDef; if (deserClass == KeyDeserializer.None.class || ClassUtil.isBogusClass(deserClass)) { return null; } if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { throw new IllegalStateException(\\\"AnnotationIntrospector returned Class \\\" + deserClass.getName() + \\\"; expected Class<KeyDeserializer>\\\"); } HandlerInstantiator hi = _config.getHandlerInstantiator(); deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, ann, deserClass); if (deser == null) { deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); } } if (deser instanceof ResolvableDeserializer) { ((ResolvableDeserializer) deser).resolve(this); } return deser; }"
                    ],
                    [
                        0.9884883165359497,
                        "@SuppressWarnings({ \\\"unchecked\\\" }) protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); Class<?> subclass = intr.findDeserializationType(a, type); if (subclass != null) { try { type = (T) type.narrowBy(subclass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow type \\\" + type + \\\" with concrete-type annotation (value \\\" + subclass.getName() + \\\"), method '\\\" + a.getName() + \\\"': \\\" + iae.getMessage(), null, iae); } } if (type.isContainerType()) { Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); if (keyClass != null) { if (!(type instanceof MapLikeType)) { throw new JsonMappingException(\\\"Illegal key-type annotation: type \\\" + type + \\\" is not a Map(-like) type\\\"); } try { type = (T) ((MapLikeType) type).narrowKey(keyClass); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow key type \\\" + type + \\\" with key-type annotation (\\\" + keyClass.getName() + \\\"): \\\" + iae.getMessage(), null, iae); } } JavaType keyType = type.getKeyType(); if (keyType != null && keyType.getValueHandler() == null) { Object kdDef = intr.findKeyDeserializer(a); KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); if (kd != null) { type = (T) ((MapLikeType) type).withKeyValueHandler(kd); keyType = type.getKeyType(); } } Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); if (cc != null) { try { type = (T) type.narrowContentsBy(cc); } catch (IllegalArgumentException iae) { throw new JsonMappingException(\\\"Failed to narrow content type \\\" + type + \\\" with content-type annotation (\\\" + cc.getName() + \\\"): \\\" + iae.getMessage(), null, iae); } } JavaType contentType = type.getContentType(); if (contentType.getValueHandler() == null) { Object cdDef = intr.findContentDeserializer(a); JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); if (cd != null) { type = (T) type.withContentValueHandler(cd); } } } return type; }"
                    ],
                    [
                        0.9882058501243591,
                        "protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, JavaType rootType, JsonDeserializer<Object> deser) throws IOException { PropertyName expRootName = _config.findRootName(rootType); String expSimpleName = expRootName.getSimpleName(); if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw JsonMappingException.from(p, \\\"Current token not START_OBJECT (needed to unwrap root name '\\\" + expSimpleName + \\\"'), but \\\" + p.getCurrentToken()); } if (p.nextToken() != JsonToken.FIELD_NAME) { throw JsonMappingException.from(p, \\\"Current token not FIELD_NAME (to contain expected root name '\\\" + expSimpleName + \\\"'), but \\\" + p.getCurrentToken()); } String actualName = p.getCurrentName(); if (!expSimpleName.equals(actualName)) { throw JsonMappingException.from(p, \\\"Root name '\\\" + actualName + \\\"' does not match expected ('\\\" + expSimpleName + \\\"') for type \\\" + rootType); } p.nextToken(); Object result; if (_valueToUpdate == null) { result = deser.deserialize(p, ctxt); } else { deser.deserialize(p, ctxt, _valueToUpdate); result = _valueToUpdate; } if (p.nextToken() != JsonToken.END_OBJECT) { throw JsonMappingException.from(p, \\\"Current token not END_OBJECT (to match wrapper object with root name '\\\" + expSimpleName + \\\"'), but \\\" + p.getCurrentToken()); } return result; }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java",
                "start_loc": 144,
                "end_loc": 184,
                "buggy_function": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    type = _baseType.narrowBy(type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n",
                "fixed_function": "    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType); } } else { if ((_baseType != null) && _baseType.getClass() == type.getClass()) { type = _baseType.narrowBy(type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999999403953552,
                        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType); } } else { if ((_baseType != null) && _baseType.getClass() == type.getClass()) { type = _baseType.narrowBy(type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }"
                    ],
                    [
                        0.9713813066482544,
                        "@Override public void resolve(DeserializationContext ctxt) throws JsonMappingException { if (_valueInstantiator.canCreateUsingDelegate()) { JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\\\"Invalid delegate-creator definition for \\\" + _mapType + \\\": value instantiator (\\\" + _valueInstantiator.getClass().getName() + \\\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\\\"); } _delegateDeserializer = findDeserializer(ctxt, delegateType, null); } if (_valueInstantiator.canCreateFromObjectWith()) { SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); } _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); }"
                    ],
                    [
                        0.970724880695343,
                        "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { JsonDeserializer<Object> deser; try { deser = _createDeserializer(ctxt, factory, type); } catch (IllegalArgumentException iae) { throw new JsonMappingException(iae.getMessage(), null, iae); } if (deser == null) { return null; } boolean isResolvable = (deser instanceof ResolvableDeserializer); boolean addToCache = !_hasCustomValueHandler(type) && deser.isCachable(); if (isResolvable) { _incompleteDeserializers.put(type, deser); ((ResolvableDeserializer) deser).resolve(ctxt); _incompleteDeserializers.remove(type); } if (addToCache) { _cachedDeserializers.put(type, deser); } return deser; }"
                    ],
                    [
                        0.9683617949485779,
                        "protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException { final ObjectBuffer buffer = ctxt.leaseObjectBuffer(); Object[] chunk = buffer.resetAndStart(); final JsonDeserializer<String> deser = _elementDeserializer; int ix = 0; try { while (true) { String value; if (jp.nextTextValue() == null) { JsonToken t = jp.getCurrentToken(); if (t == JsonToken.END_ARRAY) { break; } value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue(ctxt) : deser.deserialize(jp, ctxt); } else { value = deser.deserialize(jp, ctxt); } if (ix >= chunk.length) { chunk = buffer.appendCompletedChunk(chunk); ix = 0; } chunk[ix++] = value; } } catch (Exception e) { throw JsonMappingException.wrapWithPath(e, String.class, ix); } String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class); ctxt.returnObjectBuffer(buffer); return result; }"
                    ],
                    [
                        0.968277633190155,
                        "protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider, BeanProperty prop, JsonSerializer<?> existingSerializer) throws JsonMappingException { final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); if (intr != null && prop != null) { AnnotatedMember m = prop.getMember(); if (m != null) { Object convDef = intr.findSerializationContentConverter(m); if (convDef != null) { Converter<Object, Object> conv = provider.converterInstance(prop.getMember(), convDef); JavaType delegateType = conv.getOutputType(provider.getTypeFactory()); if (existingSerializer == null && !delegateType.hasRawClass(Object.class)) { existingSerializer = provider.findValueSerializer(delegateType); } return new StdDelegatingSerializer(conv, delegateType, existingSerializer); } } } return existingSerializer; }"
                    ],
                    [
                        0.9681323766708374,
                        "protected void _addCreatorParam(Map<String, POJOPropertyBuilder> props, AnnotatedParameter param) { String impl = _annotationIntrospector.findImplicitPropertyName(param); if (impl == null) { impl = \\\"\\\"; } PropertyName pn = _annotationIntrospector.findNameForDeserialization(param); boolean expl = (pn != null && !pn.isEmpty()); if (!expl) { if (impl.isEmpty()) { return; } if (!_annotationIntrospector.hasCreatorAnnotation(param.getOwner())) { return; } pn = PropertyName.construct(impl); } POJOPropertyBuilder prop = (expl && impl.isEmpty()) ? _property(props, pn) : _property(props, impl); prop.addCtor(param, pn, expl, true, false); _creatorProperties.add(prop); }"
                    ],
                    [
                        0.9673953056335449,
                        "protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException { final AnnotatedMethod getter = propDef.getGetter(); if (ctxt.canOverrideAccessModifiers()) { getter.fixAccess(); } JavaType type = getter.getType(beanDesc.bindingsForBeanType()); JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter); type = modifyTypeByAnnotation(ctxt, getter, type); type = resolveType(ctxt, beanDesc, type, getter); TypeDeserializer typeDeser = type.getTypeHandler(); SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), getter); if (propDeser != null) { prop = prop.withValueDeserializer(propDeser); } return prop; }"
                    ],
                    [
                        0.9671383500099182,
                        "public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException { final int len = value.size(); if (len == 0) { return; } int i = 0; try { final TypeSerializer typeSer = _valueTypeSerializer; PropertySerializerMap serializers = _dynamicSerializers; for (; i < len; ++i) { Object elem = value.get(i); if (elem == null) { provider.defaultSerializeNull(jgen); } else { Class<?> cc = elem.getClass(); JsonSerializer<Object> serializer = serializers.serializerFor(cc); if (serializer == null) { if (_elementType.hasGenericTypes()) { serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_elementType, cc), provider); } else { serializer = _findAndAddDynamic(serializers, cc, provider); } serializers = _dynamicSerializers; } serializer.serializeWithType(elem, jgen, provider, typeSer); } } } catch (Exception e) { wrapAndThrow(provider, e, value, i); } }"
                    ],
                    [
                        0.9669755101203918,
                        "@Override public float[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { if (!jp.isExpectedStartArrayToken()) { return handleNonArray(jp, ctxt); } ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder(); float[] chunk = builder.resetAndStart(); int ix = 0; try { while (jp.nextToken() != JsonToken.END_ARRAY) { float value = _parseFloatPrimitive(jp, ctxt); if (ix >= chunk.length) { chunk = builder.appendCompletedChunk(chunk, ix); ix = 0; } chunk[ix++] = value; } } catch (Exception e) { throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix); } return builder.completeAndClearBuffer(chunk, ix); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java",
                "start_loc": 70,
                "end_loc": 81,
                "buggy_function": "    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n    {\n        // this is the main mapping base, so let's \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n        return type.narrowBy(dst);\n    }\n",
                "fixed_function": "    @Override\n    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n    {\n        // this is the main mapping base, so let's \n        Class<?> src = type.getRawClass();\n        Class<?> dst = _mappings.get(new ClassKey(src));\n        if (dst == null) {\n            return null;\n        }\n        // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n        return config.getTypeFactory().constructSpecializedType(type, dst);\n    }\n",
                "comment": "",
                "normalized_body": [
                    "@Override public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { Class<?> src = type.getRawClass(); Class<?> dst = _mappings.get(new ClassKey(src)); if (dst == null) { return null; } return type.narrowBy(dst); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "@Override public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { Class<?> src = type.getRawClass(); Class<?> dst = _mappings.get(new ClassKey(src)); if (dst == null) { return null; } return type.narrowBy(dst); }"
                    ],
                    [
                        0.9842736721038818,
                        "@Override public void set(Object instance, Object value) throws IOException { if (_fallbackSetter == null) { throw new IllegalStateException(\\\"No fallback setter/field defined: can not use creator property for \\\" + getClass().getName()); } _fallbackSetter.set(instance, value); }"
                    ],
                    [
                        0.9838310480117798,
                        "@Override public JsonNode getSchema(SerializerProvider provider, Type typeHint) { ObjectNode o = createSchemaNode(\\\"array\\\", true); ObjectNode itemSchema = createSchemaNode(\\\"string\\\"); itemSchema.put(\\\"type\\\", \\\"string\\\"); return o.set(\\\"items\\\", itemSchema); }"
                    ],
                    [
                        0.9832047820091248,
                        "@Override public Object setAndReturn(Object instance, Object value) throws IOException { if (_fallbackSetter == null) { throw new IllegalStateException(\\\"No fallback setter/field defined: can not use creator property for \\\" + getClass().getName()); } return _fallbackSetter.setAndReturn(instance, value); }"
                    ],
                    [
                        0.9815915822982788,
                        "@Override public JsonNode getSchema(SerializerProvider provider, Type typeHint) { ObjectNode o = createSchemaNode(\\\"array\\\", true); ObjectNode itemSchema = createSchemaNode(\\\"string\\\"); return o.set(\\\"items\\\", itemSchema); }"
                    ],
                    [
                        0.9799531102180481,
                        "@Override public void setValue(Object pojo, Object value) throws IllegalArgumentException { try { _field.set(pojo, value); } catch (IllegalAccessException e) { throw new IllegalArgumentException(\\\"Failed to setValue() for field \\\" + getFullName() + \\\": \\\" + e.getMessage(), e); } }"
                    ],
                    [
                        0.97968989610672,
                        "@Override public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { if (_delegateSerializer instanceof SchemaAware) { return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint); } return super.getSchema(provider, typeHint); }"
                    ],
                    [
                        0.9794621467590332,
                        "@Override public boolean equals(Object o) { if (!(o instanceof BeanWithList)) return false; BeanWithList other = BeanWithList.class.cast(o); return _beans.equals(other._beans); }"
                    ],
                    [
                        0.9793336391448975,
                        "@Override public Iterator<AnnotatedParameter> getConstructorParameters() { if (_ctorParameters == null) { return EmptyIterator.instance(); } return new MemberIterator<AnnotatedParameter>(_ctorParameters); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            }
        ],
        "trigger_test": {
            "com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testByteArrayTypeOverride890": {
                "path": "src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java",
                "function_name": "testByteArrayTypeOverride890",
                "src": "    public void testByteArrayTypeOverride890() throws Exception\n    {\n        HiddenBinaryBean890 result = MAPPER.readValue(\n                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\n        assertNotNull(result);\n        assertNotNull(result.someBytes);\n        assertEquals(byte[].class, result.someBytes.getClass());\n    }",
                "error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:269)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)\n\tat com.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3698)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2714)\n\tat com.fasterxml.jackson.databind.deser.TestArrayDeserialization.testByteArrayTypeOverride890(TestArrayDeserialization.java:563)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: java.lang.IllegalArgumentException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:808)\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:138)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n\t... 47 more",
                "clean_error_msg": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:269)  throw new JsonMappingException(iae.getMessage(), null, iae);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)  return _createAndCache2(ctxt, factory, type);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)  deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n\tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)  JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n\tat com.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)  return ctxt.findContextualValueDeserializer(type, property);\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)  deser = findDeserializer(ctxt, prop.getType(), prop);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)  ((ResolvableDeserializer)deser).resolve(ctxt);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)  return _createAndCache2(ctxt, factory, type);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)  deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n\tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)  JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,                _factory, type);\n\tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)  deser = ctxt.findRootValueDeserializer(valueType);\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3698)  JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType);\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2714)  return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n\tat com.fasterxml.jackson.databind.deser.TestArrayDeserialization.testByteArrayTypeOverride890(TestArrayDeserialization.java:563)  HiddenBinaryBean890 result = MAPPER.readValue(                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class);\nCaused by: java.lang.IllegalArgumentException: Can not deserialize Class [B (of type array) as a Bean\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:808)  throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:138)  if (!isPotentialBeanType(type.getRawClass())) {            return null;        }\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)  return factory.createBeanDeserializer(ctxt, type, beanDesc);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)  return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc);\n\tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)  deser = _createDeserializer(ctxt, factory, type);\n\t... 47 more"
            }
        },
        "evaluation_done": true,
        "context_generation_done": true,
        "evaluation_done2": true
    }
}