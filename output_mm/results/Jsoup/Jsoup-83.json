{
    "Jsoup-83": {
        "function_num": 3,
        "functions": [
            {
                "path": "src/main/java/org/jsoup/parser/CharacterReader.java",
                "start_loc": 244,
                "end_loc": 260,
                "buggy_function": "    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n",
                "fixed_function": "    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c == '<' || c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n",
                "comment": "",
                "normalized_body": [
                    "String consumeTagName() { bufferUp(); final int start = bufPos; final int remaining = bufLength; final char[] val = charBuf; while (bufPos < remaining) { final char c = val[bufPos]; if (c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == ' ' || c == '/' || c == '>' || c == TokeniserState.nullChar) break; bufPos++; } return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \\\"\\\"; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "String consumeTagName() { bufferUp(); final int start = bufPos; final int remaining = bufLength; final char[] val = charBuf; while (bufPos < remaining) { final char c = val[bufPos]; if (c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == ' ' || c == '/' || c == '>' || c == TokeniserState.nullChar) break; bufPos++; } return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \\\"\\\"; }"
                    ],
                    [
                        0.975214958190918,
                        "final void newAttribute() { if (attributes == null) attributes = new Attributes(); if (pendingAttributeName != null) { pendingAttributeName = pendingAttributeName.trim(); if (pendingAttributeName.length() > 0) { String value; if (hasPendingAttributeValue) value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS; else if (hasEmptyAttributeValue) value = \\\"\\\"; else value = null; attributes.put(pendingAttributeName, value); } } pendingAttributeName = null; hasEmptyAttributeValue = false; hasPendingAttributeValue = false; reset(pendingAttributeValue); pendingAttributeValueS = null; }"
                    ],
                    [
                        0.9746301174163818,
                        "String consumeLetterThenDigitSequence() { bufferUp(); int start = bufPos; while (bufPos < bufLength) { char c = charBuf[bufPos]; if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c)) bufPos++; else break; } while (!isEmptyNoBufferUp()) { char c = charBuf[bufPos]; if (c >= '0' && c <= '9') bufPos++; else break; } return cacheString(charBuf, stringCache, start, bufPos - start); }"
                    ],
                    [
                        0.9681337475776672,
                        "Token read() { while (!isEmitPending) state.read(this, reader); if (charsBuilder.length() > 0) { String str = charsBuilder.toString(); charsBuilder.delete(0, charsBuilder.length()); charsString = null; return charPending.data(str); } else if (charsString != null) { Token token = charPending.data(charsString); charsString = null; return token; } else { isEmitPending = false; return emitPending; } }"
                    ],
                    [
                        0.9659403562545776,
                        "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\\\"</\\\" + t.appropriateEndTagName())) { t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); t.transition(Data); } else { t.emit(\\\"<\\\"); t.transition(Rcdata); } }"
                    ],
                    [
                        0.9647012948989868,
                        "public Node wrap(String html) { Validate.notEmpty(html); Element context = parent() instanceof Element ? (Element) parent() : null; List<Node> wrapChildren = NodeUtils.parser(this).parseFragmentInput(html, context, baseUri()); Node wrapNode = wrapChildren.get(0); if (!(wrapNode instanceof Element)) return null; Element wrap = (Element) wrapNode; Element deepest = getDeepChild(wrap); parentNode.replaceChild(this, wrap); deepest.addChildren(this); if (wrapChildren.size() > 0) { for (int i = 0; i < wrapChildren.size(); i++) { Node remainder = wrapChildren.get(i); remainder.parentNode.removeChild(remainder); wrap.appendChild(remainder); } } return this; }"
                    ],
                    [
                        0.9642329216003418,
                        "void read(Tokeniser t, CharacterReader r) { if (r.matchConsume(\\\"--\\\")) { t.createCommentPending(); t.transition(CommentStart); } else if (r.matchConsumeIgnoreCase(\\\"DOCTYPE\\\")) { t.transition(Doctype); } else if (r.matchConsume(\\\"[CDATA[\\\")) { t.createTempBuffer(); t.transition(CdataSection); } else { t.error(this); t.advanceTransition(BogusComment); } }"
                    ],
                    [
                        0.9624020457267761,
                        "public static void traverse(NodeVisitor visitor, Node root) { Node node = root; int depth = 0; while (node != null) { visitor.head(node, depth); if (node.childNodeSize() > 0) { node = node.childNode(0); depth++; } else { while (node.nextSibling() == null && depth > 0) { visitor.tail(node, depth); node = node.parentNode(); depth--; } visitor.tail(node, depth); if (node == root) break; node = node.nextSibling(); } } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    String consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    @Test public void parsesQuiteRoughAttributes() {\n        String html = \"<p =a>One<a <p>Something</p>Else\";\n        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n        Document doc = Jsoup.parse(html);\n\n        // NOTE: per spec this should be the test case. but impacts too many ppl\n        // assertEquals(\"<p =a>One<a <p>Something</a></p>\\n<a <p>Else</a>\", doc.body().html());\n\n        assertEquals(\"<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>\", TextUtil.stripNewlines(doc.body().html()));\n\n        doc = Jsoup.parse(\"<p .....>\");\n        assertEquals(\"<p .....></p>\", doc.body().html());\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: expected:<<p =a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>> but was:<<p =a>One<a[ <p>Something</a></p><a <p]>Else</a>>\n \n#Test method 2:\n```java\n    @Test public void handlesLessInTagThanAsNewTag() {\n        // out of spec, but clear author intent\n        String html = \"<p\\n<p<div id=one <span>Two\";\n        Document doc = Jsoup.parse(html);\n        assertEquals(\"<p></p><p></p><div id=\\\"one\\\"><span>Two</span></div>\", TextUtil.stripNewlines(doc.body().html()));\n    }\n```\n#Error message from the test method 2: junit.framework.AssertionFailedError: expected:<<p[></p><p></p><div id=\"one\"><span>Two</span></div]>> but was:<<p[ <p<div id=\"one\" <span>Two</p]>>\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\nString consumeTagName() {\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar || c == '<')\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n    // NOTE: out of spec, added '<' to fix common author bugs\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        // Include '<' to terminate tag name consumption\n        if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  '<'|| c ==  TokeniserState.nullChar)\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n    // NOTE: out of spec, added '<' to fix common author bugs\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == ' ' || c == '/' || c == '>' || c == '<' || c == TokeniserState.nullChar)\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n    // NOTE: out of spec, added '<' to fix common author bugs\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  '<'|| c ==  TokeniserState.nullChar)\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n        // NOTE: out of spec, added '<' to fix common author bugs\n        bufferUp();\n        final int start = bufPos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n\n        while (bufPos < remaining) {\n            final char c = val[bufPos];\n            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar || c == '<')\n                break;\n            bufPos++;\n        }\n\n        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n    }\n",
                            "\nString consumeTagName() {\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == ' ' || c == '/' || c == '>' || c == '<' || c == TokeniserState.nullChar) \n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar, '<'\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == ' ' || c == '/' || c == '>' || c == '<' || c == TokeniserState.nullChar)\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  '<'|| c == TokeniserState.nullChar)\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar || c == '<')\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n",
                            "\nString consumeTagName() {\n    bufferUp();\n    final int start = bufPos;\n    final int remaining = bufLength;\n    final char[] val = charBuf;\n\n    while (bufPos < remaining) {\n        final char c = val[bufPos];\n        if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  '<'|| c == TokeniserState.nullChar)\n            break;\n        bufPos++;\n    }\n\n    return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos - start) : \"\";\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/org/jsoup/parser/TokeniserState.java",
                "start_loc": 143,
                "end_loc": 176,
                "buggy_function": "        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                    // intended fall through to next >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendTagName(c);\n            }\n        }\n",
                "fixed_function": "        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '<': // NOTE: out of spec, but clear author intent\n                    t.error(this);\n                    r.unconsume();\n                    // intended fall through to next >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendTagName(c);\n            }\n        }\n",
                "comment": "        // from < or </ in data, will have start or end tag pending\n",
                "normalized_body": [
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInData); break; case '<': t.advanceTransition(TagOpen); break; case nullChar: t.error(this); t.emit(r.consume()); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeData(); t.emit(data); break; } }",
                    "void read(Tokeniser t, CharacterReader r) { readCharRef(t, Data); }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInRcdata); break; case '<': t.advanceTransition(RcdataLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('&', '<', nullChar); t.emit(data); break; } }",
                    "void read(Tokeniser t, CharacterReader r) { readCharRef(t, Rcdata); }",
                    "void read(Tokeniser t, CharacterReader r) { readData(t, r, this, RawtextLessthanSign); }",
                    "void read(Tokeniser t, CharacterReader r) { readData(t, r, this, ScriptDataLessthanSign); }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeTo(nullChar); t.emit(data); break; } }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '!': t.advanceTransition(MarkupDeclarationOpen); break; case '/': t.advanceTransition(EndTagOpen); break; case '?': t.advanceTransition(BogusComment); break; default: if (r.matchesLetter()) { t.createTagPending(true); t.transition(TagName); } else { t.error(this); t.emit('<'); t.transition(Data); } break; } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.emit(\\\"</\\\"); t.transition(Data); } else if (r.matchesLetter()) { t.createTagPending(false); t.transition(TagName); } else if (r.matches('>')) { t.error(this); t.advanceTransition(Data); } else { t.error(this); t.advanceTransition(BogusComment); } }",
                    "void read(Tokeniser t, CharacterReader r) { String tagName = r.consumeTagName(); t.tagPending.appendTagName(tagName); char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.tagPending.appendTagName(replacementStr); break; case eof: t.eofError(this); t.transition(Data); break; default: t.tagPending.appendTagName(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\\\"</\\\" + t.appropriateEndTagName())) { t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); t.transition(Data); } else { t.emit(\\\"<\\\"); t.transition(Rcdata); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(RCDATAEndTagName); } else { t.emit(\\\"</\\\"); t.transition(Rcdata); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name); t.dataBuffer.append(name); return; } char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': if (t.isAppropriateEndTagToken()) t.transition(BeforeAttributeName); else anythingElse(t, r); break; case '/': if (t.isAppropriateEndTagToken()) t.transition(SelfClosingStartTag); else anythingElse(t, r); break; case '>': if (t.isAppropriateEndTagToken()) { t.emitTagPending(); t.transition(Data); } else anythingElse(t, r); break; default: anythingElse(t, r); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RawtextEndTagOpen); } else { t.emit('<'); t.transition(Rawtext); } }",
                    "void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, RawtextEndTagName, Rawtext); }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, Rawtext); }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.consume()) { case '/': t.createTempBuffer(); t.transition(ScriptDataEndTagOpen); break; case '!': t.emit(\\\"<!\\\"); t.transition(ScriptDataEscapeStart); break; default: t.emit(\\\"<\\\"); r.unconsume(); t.transition(ScriptData); } }",
                    "void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, ScriptDataEndTagName, ScriptData); }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptData); }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapeStartDash); } else { t.transition(ScriptData); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapedDashDash); } else { t.transition(ScriptData); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } switch(r.current()) { case '-': t.emit('-'); t.advanceTransition(ScriptDataEscapedDash); break; case '<': t.advanceTransition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch(c) { case '-': t.emit(c); t.transition(ScriptDataEscapedDashDash); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch(c) { case '-': t.emit(c); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTempBuffer(); t.dataBuffer.append(r.current()); t.emit(\\\"<\\\" + r.current()); t.advanceTransition(ScriptDataDoubleEscapeStart); } else if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(ScriptDataEscapedEndTagOpen); } else { t.emit('<'); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(ScriptDataEscapedEndTagName); } else { t.emit(\\\"</\\\"); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptDataEscaped); }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped); }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch(c) { case '-': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedDash); break; case '<': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.emit(c); t.transition(ScriptDataDoubleEscapedDashDash); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break; default: t.emit(c); t.transition(ScriptDataDoubleEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.emit(c); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break; default: t.emit(c); t.transition(ScriptDataDoubleEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.emit('/'); t.createTempBuffer(); t.advanceTransition(ScriptDataDoubleEscapeEnd); } else { t.transition(ScriptDataDoubleEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t, r, ScriptDataEscaped, ScriptDataDoubleEscaped); }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': case '=': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { String name = r.consumeToAnySorted(attributeNameCharsSorted); t.tagPending.appendAttributeName(name); char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '=': t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': t.error(this); t.tagPending.appendAttributeName(c); break; default: t.tagPending.appendAttributeName(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '/': t.transition(SelfClosingStartTag); break; case '=': t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\\\"': t.transition(AttributeValue_doubleQuoted); break; case '&': r.unconsume(); t.transition(AttributeValue_unquoted); break; case '\\'': t.transition(AttributeValue_singleQuoted); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); t.transition(AttributeValue_unquoted); break; case eof: t.eofError(this); t.emitTagPending(); t.transition(Data); break; case '>': t.error(this); t.emitTagPending(); t.transition(Data); break; case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); t.transition(AttributeValue_unquoted); break; default: r.unconsume(); t.transition(AttributeValue_unquoted); } }",
                    "void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeDoubleValueCharsSorted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); else t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch(c) { case '\\\"': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\\\"', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; default: t.tagPending.appendAttributeValue(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeSingleValueCharsSorted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); else t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch(c) { case '\\'': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\\'', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; default: t.tagPending.appendAttributeValue(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAnySorted(attributeValueUnquoted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '&': int[] ref = t.consumeCharacterReference('>', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); break; default: t.tagPending.appendAttributeValue(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '>': t.tagPending.selfClosing = true; t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { r.unconsume(); Token.Comment comment = new Token.Comment(); comment.bogus = true; comment.data.append(r.consumeTo('>')); t.emit(comment); t.advanceTransition(Data); }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchConsume(\\\"--\\\")) { t.createCommentPending(); t.transition(CommentStart); } else if (r.matchConsumeIgnoreCase(\\\"DOCTYPE\\\")) { t.transition(Doctype); } else if (r.matchConsume(\\\"[CDATA[\\\")) { t.createTempBuffer(); t.transition(CdataSection); } else { t.error(this); t.advanceTransition(BogusComment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.transition(CommentStartDash); break; case nullChar: t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.transition(CommentStartDash); break; case nullChar: t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch(c) { case '-': t.advanceTransition(CommentEndDash); break; case nullChar: t.error(this); r.advance(); t.commentPending.data.append(replacementChar); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(r.consumeToAny('-', nullChar)); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.transition(CommentEnd); break; case nullChar: t.error(this); t.commentPending.data.append('-').append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append('-').append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '>': t.emitCommentPending(); t.transition(Data); break; case nullChar: t.error(this); t.commentPending.data.append(\\\"--\\\").append(replacementChar); t.transition(Comment); break; case '!': t.error(this); t.transition(CommentEndBang); break; case '-': t.error(this); t.commentPending.data.append('-'); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.error(this); t.commentPending.data.append(\\\"--\\\").append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.commentPending.data.append(\\\"--!\\\"); t.transition(CommentEndDash); break; case '>': t.emitCommentPending(); t.transition(Data); break; case nullChar: t.error(this); t.commentPending.data.append(\\\"--!\\\").append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(\\\"--!\\\").append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeName); break; case eof: t.eofError(this); case '>': t.error(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BeforeDoctypeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createDoctypePending(); t.transition(DoctypeName); return; } char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case nullChar: t.error(this); t.createDoctypePending(); t.doctypePending.name.append(replacementChar); t.transition(DoctypeName); break; case eof: t.eofError(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.createDoctypePending(); t.doctypePending.name.append(c); t.transition(DoctypeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.doctypePending.name.append(name); return; } char c = r.consume(); switch(c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterDoctypeName); break; case nullChar: t.error(this); t.doctypePending.name.append(replacementChar); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.name.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); return; } if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' ')) r.advance(); else if (r.matches('>')) { t.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY; t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY; t.transition(AfterDoctypeSystemKeyword); } else { t.error(this); t.doctypePending.forceQuirks = true; t.advanceTransition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypePublicIdentifier); break; case '\\\"': t.error(this); t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\\\"': t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\\"': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BetweenDoctypePublicAndSystemIdentifiers); break; case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeSystemIdentifier); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case '\\\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\\\"': t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypeSystemIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\\"': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.emitDoctypePending(); t.transition(Data); break; default: break; } }",
                    "void read(Tokeniser t, CharacterReader r) { String data = r.consumeTo(\\\"]]>\\\"); t.dataBuffer.append(data); if (r.matchConsume(\\\"]]>\\\") || r.isEmpty()) { t.emit(new Token.CData(t.dataBuffer.toString())); t.transition(Data); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInData); break; case '<': t.advanceTransition(TagOpen); break; case nullChar: t.error(this); t.emit(r.consume()); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeData(); t.emit(data); break; } }"
                    ],
                    [
                        0.9818300008773804,
                        "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInRcdata); break; case '<': t.advanceTransition(RcdataLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('&', '<', nullChar); t.emit(data); break; } }"
                    ],
                    [
                        0.979722261428833,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }"
                    ],
                    [
                        0.9793570041656494,
                        "private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) { switch(r.current()) { case '<': t.advanceTransition(advance); break; case nullChar: t.error(current); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('<', nullChar); t.emit(data); break; } }"
                    ],
                    [
                        0.9784481525421143,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BogusDoctype); } }"
                    ],
                    [
                        0.9779231548309326,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); } }"
                    ],
                    [
                        0.9775204658508301,
                        "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch(c) { case '-': t.emit(c); t.transition(ScriptDataEscapedDashDash); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }"
                    ],
                    [
                        0.9767704010009766,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.jsoup.parser.HtmlParserTest::handlesDeepStack"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n        // from < or </ in data, will have start or end tag pending\n\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                    // intended fall through to next >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: // should emit pending tag?\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendTagName(c);\n            }\n        }\n\n```\n---\n\n## Failing Test Case(s)\n\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case Tokeniser.nullChar:\n                    t.tagPending.appendTagName(Tokeniser.replacementStr);\n                    break;\n                case CharacterReader.EOF:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.tagPending.appendTagName(c);\n            }\n        }\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\0': // replacement\n            t.tagPending.appendTagName(replacementStr);\n            t.transition(Data); // add transition to Data\n            break;\n        case (char) -1: // EOF, should be -1 for end of stream\n            t.eofError(this);\n            t.emitTagPending(); // emit pending tag on EOF\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n            break; // add break for default\n    }\n}\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: // replacement\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                default: \n                    t.tagPending.appendTagName(c);\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            if (r.isEmpty()) {\n                t.emitTagPending();\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.tagPending.appendTagName(c);\n                    break;\n            }\n        }\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case 0: // replacement for null char\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.nullChar:\n            t.tagPending.appendTagName(Tokeniser.replacementStr);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n            break;\n    }\n}\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '\\0': // use character literal for nullChar\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case CharacterReader.EOF: // proper way to check EOF\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendTagName(c);\n            }\n        }\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000': // nullChar in Unicode\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.nullChar: // replacement\n            t.error(this);\n            t.tagPending.appendTagName(Tokeniser.replacementStr);\n            break;\n        case CharacterReader.eof: // should emit pending tag?\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default: // buffer underrun\n            t.tagPending.appendTagName(c);\n            t.transition(TagName);\n            break;\n    }\n}\n"
                        ],
                        "plausible_patches": [
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\0': // replacement\n            t.tagPending.appendTagName(replacementStr);\n            t.transition(Data); // add transition to Data\n            break;\n        case (char) -1: // EOF, should be -1 for end of stream\n            t.eofError(this);\n            t.emitTagPending(); // emit pending tag on EOF\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n            break; // add break for default\n    }\n}\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            if (r.isEmpty()) {\n                t.emitTagPending();\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.tagPending.appendTagName(c);\n                    break;\n            }\n        }\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case 0: // replacement for null char\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            // previous TagOpen state did NOT consume, will have a letter char in current\n            String tagName = r.consumeTagName();\n            t.tagPending.appendTagName(tagName);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '\\0': // use character literal for nullChar\n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case CharacterReader.EOF: // proper way to check EOF\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // buffer underrun\n                    t.tagPending.appendTagName(c);\n            }\n        }\n",
                            "\nvoid read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000': // nullChar in Unicode\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/org/jsoup/parser/TokeniserState.java",
                "start_loc": 552,
                "end_loc": 593,
                "buggy_function": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                    // intended fall through as if >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n",
                "fixed_function": "        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '<': // NOTE: out of spec, but clear (spec has this as a part of the attribute name)\n                    t.error(this);\n                    r.unconsume();\n                    // intended fall through as if >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n",
                "comment": "        // from tagname <xxx\n",
                "normalized_body": [
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInData); break; case '<': t.advanceTransition(TagOpen); break; case nullChar: t.error(this); t.emit(r.consume()); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeData(); t.emit(data); break; } }",
                    "void read(Tokeniser t, CharacterReader r) { readCharRef(t, Data); }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInRcdata); break; case '<': t.advanceTransition(RcdataLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('&', '<', nullChar); t.emit(data); break; } }",
                    "void read(Tokeniser t, CharacterReader r) { readCharRef(t, Rcdata); }",
                    "void read(Tokeniser t, CharacterReader r) { readData(t, r, this, RawtextLessthanSign); }",
                    "void read(Tokeniser t, CharacterReader r) { readData(t, r, this, ScriptDataLessthanSign); }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeTo(nullChar); t.emit(data); break; } }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '!': t.advanceTransition(MarkupDeclarationOpen); break; case '/': t.advanceTransition(EndTagOpen); break; case '?': t.advanceTransition(BogusComment); break; default: if (r.matchesLetter()) { t.createTagPending(true); t.transition(TagName); } else { t.error(this); t.emit('<'); t.transition(Data); } break; } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.emit(\\\"</\\\"); t.transition(Data); } else if (r.matchesLetter()) { t.createTagPending(false); t.transition(TagName); } else if (r.matches('>')) { t.error(this); t.advanceTransition(Data); } else { t.error(this); t.advanceTransition(BogusComment); } }",
                    "void read(Tokeniser t, CharacterReader r) { String tagName = r.consumeTagName(); t.tagPending.appendTagName(tagName); char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.tagPending.appendTagName(replacementStr); break; case eof: t.eofError(this); t.transition(Data); break; default: t.tagPending.appendTagName(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RCDATAEndTagOpen); } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\\\"</\\\" + t.appropriateEndTagName())) { t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName()); t.emitTagPending(); r.unconsume(); t.transition(Data); } else { t.emit(\\\"<\\\"); t.transition(Rcdata); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(RCDATAEndTagName); } else { t.emit(\\\"</\\\"); t.transition(Rcdata); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name); t.dataBuffer.append(name); return; } char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': if (t.isAppropriateEndTagToken()) t.transition(BeforeAttributeName); else anythingElse(t, r); break; case '/': if (t.isAppropriateEndTagToken()) t.transition(SelfClosingStartTag); else anythingElse(t, r); break; case '>': if (t.isAppropriateEndTagToken()) { t.emitTagPending(); t.transition(Data); } else anythingElse(t, r); break; default: anythingElse(t, r); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(RawtextEndTagOpen); } else { t.emit('<'); t.transition(Rawtext); } }",
                    "void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, RawtextEndTagName, Rawtext); }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, Rawtext); }",
                    "void read(Tokeniser t, CharacterReader r) { switch(r.consume()) { case '/': t.createTempBuffer(); t.transition(ScriptDataEndTagOpen); break; case '!': t.emit(\\\"<!\\\"); t.transition(ScriptDataEscapeStart); break; default: t.emit(\\\"<\\\"); r.unconsume(); t.transition(ScriptData); } }",
                    "void read(Tokeniser t, CharacterReader r) { readEndTag(t, r, ScriptDataEndTagName, ScriptData); }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptData); }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapeStartDash); } else { t.transition(ScriptData); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('-')) { t.emit('-'); t.advanceTransition(ScriptDataEscapedDashDash); } else { t.transition(ScriptData); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } switch(r.current()) { case '-': t.emit('-'); t.advanceTransition(ScriptDataEscapedDash); break; case '<': t.advanceTransition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch(c) { case '-': t.emit(c); t.transition(ScriptDataEscapedDashDash); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch(c) { case '-': t.emit(c); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTempBuffer(); t.dataBuffer.append(r.current()); t.emit(\\\"<\\\" + r.current()); t.advanceTransition(ScriptDataDoubleEscapeStart); } else if (r.matches('/')) { t.createTempBuffer(); t.advanceTransition(ScriptDataEscapedEndTagOpen); } else { t.emit('<'); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createTagPending(false); t.tagPending.appendTagName(r.current()); t.dataBuffer.append(r.current()); t.advanceTransition(ScriptDataEscapedEndTagName); } else { t.emit(\\\"</\\\"); t.transition(ScriptDataEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataEndTag(t, r, ScriptDataEscaped); }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped); }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch(c) { case '-': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedDash); break; case '<': t.emit(c); t.advanceTransition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; default: String data = r.consumeToAny('-', '<', nullChar); t.emit(data); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.emit(c); t.transition(ScriptDataDoubleEscapedDashDash); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break; default: t.emit(c); t.transition(ScriptDataDoubleEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.emit(c); break; case '<': t.emit(c); t.transition(ScriptDataDoubleEscapedLessthanSign); break; case '>': t.emit(c); t.transition(ScriptData); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataDoubleEscaped); break; case eof: t.eofError(this); t.transition(Data); break; default: t.emit(c); t.transition(ScriptDataDoubleEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matches('/')) { t.emit('/'); t.createTempBuffer(); t.advanceTransition(ScriptDataDoubleEscapeEnd); } else { t.transition(ScriptDataDoubleEscaped); } }",
                    "void read(Tokeniser t, CharacterReader r) { handleDataDoubleEscapeTag(t, r, ScriptDataEscaped, ScriptDataDoubleEscaped); }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': case '=': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { String name = r.consumeToAnySorted(attributeNameCharsSorted); t.tagPending.appendAttributeName(name); char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '=': t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': t.error(this); t.tagPending.appendAttributeName(c); break; default: t.tagPending.appendAttributeName(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '/': t.transition(SelfClosingStartTag); break; case '=': t.transition(BeforeAttributeValue); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeName(replacementChar); t.transition(AttributeName); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': t.error(this); t.tagPending.newAttribute(); t.tagPending.appendAttributeName(c); t.transition(AttributeName); break; default: t.tagPending.newAttribute(); r.unconsume(); t.transition(AttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\\\"': t.transition(AttributeValue_doubleQuoted); break; case '&': r.unconsume(); t.transition(AttributeValue_unquoted); break; case '\\'': t.transition(AttributeValue_singleQuoted); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); t.transition(AttributeValue_unquoted); break; case eof: t.eofError(this); t.emitTagPending(); t.transition(Data); break; case '>': t.error(this); t.emitTagPending(); t.transition(Data); break; case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); t.transition(AttributeValue_unquoted); break; default: r.unconsume(); t.transition(AttributeValue_unquoted); } }",
                    "void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeDoubleValueCharsSorted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); else t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch(c) { case '\\\"': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\\\"', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; default: t.tagPending.appendAttributeValue(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAny(attributeSingleValueCharsSorted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); else t.tagPending.setEmptyAttributeValue(); char c = r.consume(); switch(c) { case '\\'': t.transition(AfterAttributeValue_quoted); break; case '&': int[] ref = t.consumeCharacterReference('\\'', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; default: t.tagPending.appendAttributeValue(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { String value = r.consumeToAnySorted(attributeValueUnquoted); if (value.length() > 0) t.tagPending.appendAttributeValue(value); char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '&': int[] ref = t.consumeCharacterReference('>', true); if (ref != null) t.tagPending.appendAttributeValue(ref); else t.tagPending.appendAttributeValue('&'); break; case '>': t.emitTagPending(); t.transition(Data); break; case nullChar: t.error(this); t.tagPending.appendAttributeValue(replacementChar); break; case eof: t.eofError(this); t.transition(Data); break; case '\\\"': case '\\'': case '<': case '=': case '`': t.error(this); t.tagPending.appendAttributeValue(c); break; default: t.tagPending.appendAttributeValue(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '>': t.tagPending.selfClosing = true; t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { r.unconsume(); Token.Comment comment = new Token.Comment(); comment.bogus = true; comment.data.append(r.consumeTo('>')); t.emit(comment); t.advanceTransition(Data); }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchConsume(\\\"--\\\")) { t.createCommentPending(); t.transition(CommentStart); } else if (r.matchConsumeIgnoreCase(\\\"DOCTYPE\\\")) { t.transition(Doctype); } else if (r.matchConsume(\\\"[CDATA[\\\")) { t.createTempBuffer(); t.transition(CdataSection); } else { t.error(this); t.advanceTransition(BogusComment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.transition(CommentStartDash); break; case nullChar: t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.transition(CommentStartDash); break; case nullChar: t.error(this); t.commentPending.data.append(replacementChar); t.transition(Comment); break; case '>': t.error(this); t.emitCommentPending(); t.transition(Data); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.current(); switch(c) { case '-': t.advanceTransition(CommentEndDash); break; case nullChar: t.error(this); r.advance(); t.commentPending.data.append(replacementChar); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(r.consumeToAny('-', nullChar)); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.transition(CommentEnd); break; case nullChar: t.error(this); t.commentPending.data.append('-').append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append('-').append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '>': t.emitCommentPending(); t.transition(Data); break; case nullChar: t.error(this); t.commentPending.data.append(\\\"--\\\").append(replacementChar); t.transition(Comment); break; case '!': t.error(this); t.transition(CommentEndBang); break; case '-': t.error(this); t.commentPending.data.append('-'); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.error(this); t.commentPending.data.append(\\\"--\\\").append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '-': t.commentPending.data.append(\\\"--!\\\"); t.transition(CommentEndDash); break; case '>': t.emitCommentPending(); t.transition(Data); break; case nullChar: t.error(this); t.commentPending.data.append(\\\"--!\\\").append(replacementChar); t.transition(Comment); break; case eof: t.eofError(this); t.emitCommentPending(); t.transition(Data); break; default: t.commentPending.data.append(\\\"--!\\\").append(c); t.transition(Comment); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeName); break; case eof: t.eofError(this); case '>': t.error(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BeforeDoctypeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { t.createDoctypePending(); t.transition(DoctypeName); return; } char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case nullChar: t.error(this); t.createDoctypePending(); t.doctypePending.name.append(replacementChar); t.transition(DoctypeName); break; case eof: t.eofError(this); t.createDoctypePending(); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.createDoctypePending(); t.doctypePending.name.append(c); t.transition(DoctypeName); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.doctypePending.name.append(name); return; } char c = r.consume(); switch(c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(AfterDoctypeName); break; case nullChar: t.error(this); t.doctypePending.name.append(replacementChar); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.name.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); return; } if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' ')) r.advance(); else if (r.matches('>')) { t.emitDoctypePending(); t.advanceTransition(Data); } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) { t.doctypePending.pubSysKey = DocumentType.PUBLIC_KEY; t.transition(AfterDoctypePublicKeyword); } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) { t.doctypePending.pubSysKey = DocumentType.SYSTEM_KEY; t.transition(AfterDoctypeSystemKeyword); } else { t.error(this); t.doctypePending.forceQuirks = true; t.advanceTransition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypePublicIdentifier); break; case '\\\"': t.error(this); t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\\\"': t.transition(DoctypePublicIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypePublicIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\\"': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BetweenDoctypePublicAndSystemIdentifiers); break; case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case '\\\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeDoctypeSystemIdentifier); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case '\\\"': t.error(this); t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.error(this); t.transition(DoctypeSystemIdentifier_singleQuoted); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '\\\"': t.transition(DoctypeSystemIdentifier_doubleQuoted); break; case '\\'': t.transition(DoctypeSystemIdentifier_singleQuoted); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.doctypePending.forceQuirks = true; t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\\"': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BogusDoctype); } }",
                    "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.emitDoctypePending(); t.transition(Data); break; default: break; } }",
                    "void read(Tokeniser t, CharacterReader r) { String data = r.consumeTo(\\\"]]>\\\"); t.dataBuffer.append(data); if (r.matchConsume(\\\"]]>\\\") || r.isEmpty()) { t.emit(new Token.CData(t.dataBuffer.toString())); t.transition(Data); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInData); break; case '<': t.advanceTransition(TagOpen); break; case nullChar: t.error(this); t.emit(r.consume()); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeData(); t.emit(data); break; } }"
                    ],
                    [
                        0.9818300008773804,
                        "void read(Tokeniser t, CharacterReader r) { switch(r.current()) { case '&': t.advanceTransition(CharacterReferenceInRcdata); break; case '<': t.advanceTransition(RcdataLessthanSign); break; case nullChar: t.error(this); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('&', '<', nullChar); t.emit(data); break; } }"
                    ],
                    [
                        0.979722261428833,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; case eof: t.eofError(this); t.transition(Data); break; default: t.error(this); r.unconsume(); t.transition(BeforeAttributeName); } }"
                    ],
                    [
                        0.9793570041656494,
                        "private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) { switch(r.current()) { case '<': t.advanceTransition(advance); break; case nullChar: t.error(current); r.advance(); t.emit(replacementChar); break; case eof: t.emit(new Token.EOF()); break; default: String data = r.consumeToAny('<', nullChar); t.emit(data); break; } }"
                    ],
                    [
                        0.9784481525421143,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\t': case '\\n': case '\\r': case '\\f': case ' ': break; case '>': t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.error(this); t.transition(BogusDoctype); } }"
                    ],
                    [
                        0.9779231548309326,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypePublicIdentifier); break; case nullChar: t.error(this); t.doctypePending.publicIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.publicIdentifier.append(c); } }"
                    ],
                    [
                        0.9775204658508301,
                        "void read(Tokeniser t, CharacterReader r) { if (r.isEmpty()) { t.eofError(this); t.transition(Data); return; } char c = r.consume(); switch(c) { case '-': t.emit(c); t.transition(ScriptDataEscapedDashDash); break; case '<': t.transition(ScriptDataEscapedLessthanSign); break; case nullChar: t.error(this); t.emit(replacementChar); t.transition(ScriptDataEscaped); break; default: t.emit(c); t.transition(ScriptDataEscaped); } }"
                    ],
                    [
                        0.9767704010009766,
                        "void read(Tokeniser t, CharacterReader r) { char c = r.consume(); switch(c) { case '\\'': t.transition(AfterDoctypeSystemIdentifier); break; case nullChar: t.error(this); t.doctypePending.systemIdentifier.append(replacementChar); break; case '>': t.error(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; case eof: t.eofError(this); t.doctypePending.forceQuirks = true; t.emitDoctypePending(); t.transition(Data); break; default: t.doctypePending.systemIdentifier.append(c); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.jsoup.parser.HtmlParserTest::handlesDeepStack",
                    "org.jsoup.parser.HtmlParserTest::parsesQuiteRoughAttributes"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n        // from tagname <xxx\n\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                    // intended fall through as if >\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    @Test public void parsesQuiteRoughAttributes() {\n        String html = \"<p =a>One<a <p>Something</p>Else\";\n        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n        Document doc = Jsoup.parse(html);\n\n        // NOTE: per spec this should be the test case. but impacts too many ppl\n        // assertEquals(\"<p =a>One<a <p>Something</a></p>\\n<a <p>Else</a>\", doc.body().html());\n\n        assertEquals(\"<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>\", TextUtil.stripNewlines(doc.body().html()));\n\n        doc = Jsoup.parse(\"<p .....>\");\n        assertEquals(\"<p .....></p>\", doc.body().html());\n    }\n```\n#Error message: junit.framework.AssertionFailedError: expected:<<p =a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>> but was:<<p =a>One<a[ <p>Something</a></p><a <p]>Else</a>>\n\tat org.jsoup.parser.HtmlParserTest.parsesQuiteRoughAttributes(HtmlParserTest.java:66)  assertEquals(\"<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>\", TextUtil.stripNewlines(doc.body().html()));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c); // fix: append the current character to the attribute name\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '\\0':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case EOF:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        // from tagname <xxx\n\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '\\u0000':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                case (char) -1:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        // from tagname <xxx\n\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                case '<': // Fix based on provided test case\n                    t.error(this);\n                    t.emitTagPending();\n                    r.unconsume();\n                    t.transition(Data);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n",
                            "\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; // ignore whitespace\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: // A-Z, anything else\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c); // Fix: append the consumed character\n                    t.transition(AttributeName);\n            }\n        }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.jsoup.parser.HtmlParserTest::parsesQuiteRoughAttributes": {
                "path": "src/test/java/org/jsoup/parser/HtmlParserTest.java",
                "function_name": "parsesQuiteRoughAttributes",
                "src": "    @Test public void parsesQuiteRoughAttributes() {\n        String html = \"<p =a>One<a <p>Something</p>Else\";\n        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n        Document doc = Jsoup.parse(html);\n\n        // NOTE: per spec this should be the test case. but impacts too many ppl\n        // assertEquals(\"<p =a>One<a <p>Something</a></p>\\n<a <p>Else</a>\", doc.body().html());\n\n        assertEquals(\"<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>\", TextUtil.stripNewlines(doc.body().html()));\n\n        doc = Jsoup.parse(\"<p .....>\");\n        assertEquals(\"<p .....></p>\", doc.body().html());\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<<p =a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>> but was:<<p =a>One<a[ <p>Something</a></p><a <p]>Else</a>>\n\tat org.junit.Assert.assertEquals(Assert.java:115)\n\tat org.junit.Assert.assertEquals(Assert.java:144)\n\tat org.jsoup.parser.HtmlParserTest.parsesQuiteRoughAttributes(HtmlParserTest.java:66)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p =a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>> but was:<<p =a>One<a[ <p>Something</a></p><a <p]>Else</a>>\n\tat org.jsoup.parser.HtmlParserTest.parsesQuiteRoughAttributes(HtmlParserTest.java:66)  assertEquals(\"<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>\", TextUtil.stripNewlines(doc.body().html()));"
            },
            "org.jsoup.parser.TokeniserStateTest::handlesLessInTagThanAsNewTag": {
                "path": "src/test/java/org/jsoup/parser/TokeniserStateTest.java",
                "function_name": "handlesLessInTagThanAsNewTag",
                "src": "    @Test public void handlesLessInTagThanAsNewTag() {\n        // out of spec, but clear author intent\n        String html = \"<p\\n<p<div id=one <span>Two\";\n        Document doc = Jsoup.parse(html);\n        assertEquals(\"<p></p><p></p><div id=\\\"one\\\"><span>Two</span></div>\", TextUtil.stripNewlines(doc.body().html()));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: expected:<<p[></p><p></p><div id=\"one\"><span>Two</span></div]>> but was:<<p[ <p<div id=\"one\" <span>Two</p]>>\n\tat org.junit.Assert.assertEquals(Assert.java:115)\n\tat org.junit.Assert.assertEquals(Assert.java:144)\n\tat org.jsoup.parser.TokeniserStateTest.handlesLessInTagThanAsNewTag(TokeniserStateTest.java:207)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: expected:<<p[></p><p></p><div id=\"one\"><span>Two</span></div]>> but was:<<p[ <p<div id=\"one\" <span>Two</p]>>\n\tat org.jsoup.parser.TokeniserStateTest.handlesLessInTagThanAsNewTag(TokeniserStateTest.java:207)  assertEquals(\"<p></p><p></p><div id=\\\"one\\\"><span>Two</span></div>\", TextUtil.stripNewlines(doc.body().html()));"
            }
        },
        "evaluation_done": true
    }
}