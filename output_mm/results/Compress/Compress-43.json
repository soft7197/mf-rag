{
    "Compress-43": {
        "function_num": 4,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
                "start_loc": 1024,
                "end_loc": 1038,
                "buggy_function": "    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n",
                "fixed_function": "    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod(), phased)));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException { final boolean encodable = zipEncoding.canEncode(ze.getName()); final ByteBuffer name = getName(ze); if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) { addUnicodeExtraFields(ze, encodable, name); } final long localHeaderStart = streamCompressor.getTotalBytesWritten(); final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart); metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod()))); entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; writeCounted(localHeader); entry.dataStart = streamCompressor.getTotalBytesWritten(); }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException { final boolean encodable = zipEncoding.canEncode(ze.getName()); final ByteBuffer name = getName(ze); if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) { addUnicodeExtraFields(ze, encodable, name); } final long localHeaderStart = streamCompressor.getTotalBytesWritten(); final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart); metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod()))); entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; writeCounted(localHeader); entry.dataStart = streamCompressor.getTotalBytesWritten(); }"
                    ],
                    [
                        0.9798117876052856,
                        "@Test public void testArArchiveCreation() throws Exception { final File output = new File(dir, \\\"bla.ar\\\"); final File file1 = getFile(\\\"test1.xml\\\"); final File file2 = getFile(\\\"test2.xml\\\"); final OutputStream out = new FileOutputStream(output); final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"ar\\\", out); os.putArchiveEntry(new ArArchiveEntry(\\\"test1.xml\\\", file1.length())); IOUtils.copy(new FileInputStream(file1), os); os.closeArchiveEntry(); os.putArchiveEntry(new ArArchiveEntry(\\\"test2.xml\\\", file2.length())); IOUtils.copy(new FileInputStream(file2), os); os.closeArchiveEntry(); os.close(); }"
                    ],
                    [
                        0.979713499546051,
                        "@Test public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception { final String n = \\\"f\\u00f6\\u00f6/\\\"; final TarArchiveEntry t = new TarArchiveEntry(n); final ByteArrayOutputStream bos = new ByteArrayOutputStream(); final TarArchiveOutputStream tos = new TarArchiveOutputStream(bos); tos.setAddPaxHeadersForNonAsciiNames(true); tos.putArchiveEntry(t); tos.closeArchiveEntry(); tos.close(); final byte[] data = bos.toByteArray(); final TarArchiveInputStream tin = new TarArchiveInputStream(new ByteArrayInputStream(data)); final TarArchiveEntry e = tin.getNextTarEntry(); assertEquals(n, e.getName()); assertTrue(e.isDirectory()); tin.close(); }"
                    ],
                    [
                        0.9782018661499023,
                        "@Test public void testUnixModeInAddRaw() throws IOException { final File[] tmp = createTempDirAndFile(); final File a1 = File.createTempFile(\\\"unixModeBits.\\\", \\\".zip\\\", tmp[0]); final ZipArchiveOutputStream zos = new ZipArchiveOutputStream(a1); final ZipArchiveEntry archiveEntry = new ZipArchiveEntry(\\\"fred\\\"); archiveEntry.setUnixMode(0664); archiveEntry.setMethod(ZipEntry.DEFLATED); zos.addRawArchiveEntry(archiveEntry, new ByteArrayInputStream(\\\"fud\\\".getBytes())); zos.close(); final ZipFile zf1 = new ZipFile(a1); final ZipArchiveEntry fred = zf1.getEntry(\\\"fred\\\"); assertEquals(0664, fred.getUnixMode()); zf1.close(); }"
                    ],
                    [
                        0.9768741130828857,
                        "@Test public void testJarArchiveCreation() throws Exception { final File output = new File(dir, \\\"bla.jar\\\"); final File file1 = getFile(\\\"test1.xml\\\"); final File file2 = getFile(\\\"test2.xml\\\"); final OutputStream out = new FileOutputStream(output); final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"jar\\\", out); os.putArchiveEntry(new ZipArchiveEntry(\\\"testdata/test1.xml\\\")); IOUtils.copy(new FileInputStream(file1), os); os.closeArchiveEntry(); os.putArchiveEntry(new ZipArchiveEntry(\\\"testdata/test2.xml\\\")); IOUtils.copy(new FileInputStream(file2), os); os.closeArchiveEntry(); os.close(); }"
                    ],
                    [
                        0.9764984846115112,
                        "private void testArchiveWithImplodeCompression(final String filename, final String entryName) throws IOException { final ZipFile zip = new ZipFile(new File(filename)); final ZipArchiveEntry entry = zip.getEntries().nextElement(); assertEquals(\\\"entry name\\\", entryName, entry.getName()); assertTrue(\\\"entry can't be read\\\", zip.canReadEntryData(entry)); assertEquals(\\\"method\\\", ZipMethod.IMPLODING.getCode(), entry.getMethod()); final ByteArrayOutputStream bout = new ByteArrayOutputStream(); final CheckedOutputStream out = new CheckedOutputStream(bout, new CRC32()); IOUtils.copy(zip.getInputStream(entry), out); out.flush(); assertEquals(\\\"CRC32\\\", entry.getCrc(), out.getChecksum().getValue()); zip.close(); }"
                    ],
                    [
                        0.975170373916626,
                        "@Test public void testPadsOutputToFullBlockLength() throws Exception { final File f = File.createTempFile(\\\"commons-compress-padding\\\", \\\".tar\\\"); f.deleteOnExit(); final FileOutputStream fos = new FileOutputStream(f); final TarArchiveOutputStream tos = new TarArchiveOutputStream(fos); final File file1 = getFile(\\\"test1.xml\\\"); final TarArchiveEntry sEntry = new TarArchiveEntry(file1, file1.getName()); tos.putArchiveEntry(sEntry); final FileInputStream in = new FileInputStream(file1); IOUtils.copy(in, tos); in.close(); tos.closeArchiveEntry(); tos.close(); assertEquals(TarConstants.DEFAULT_BLKSIZE, f.length()); }"
                    ],
                    [
                        0.9739575386047363,
                        "private void writePackInfo(final DataOutput header) throws IOException { header.write(NID.kPackInfo); writeUint64(header, 0); writeUint64(header, 0xffffFFFFL & numNonEmptyStreams); header.write(NID.kSize); for (final SevenZArchiveEntry entry : files) { if (entry.hasStream()) { writeUint64(header, entry.getCompressedSize()); } } header.write(NID.kCRC); header.write(1); for (final SevenZArchiveEntry entry : files) { if (entry.hasStream()) { header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue())); } } header.write(NID.kEnd); }"
                    ],
                    [
                        0.973266065120697,
                        "private static void withTemporaryArchive(final String testName, final ZipOutputTest test, final boolean useRandomAccessFile) throws Throwable { final File f = getTempFile(testName); BufferedOutputStream os = null; final ZipArchiveOutputStream zos = useRandomAccessFile ? new ZipArchiveOutputStream(f) : new ZipArchiveOutputStream(os = new BufferedOutputStream(new FileOutputStream(f))); try { test.test(f, zos); } catch (final IOException ex) { System.err.println(\\\"Failed to write archive because of: \\\" + ex.getMessage() + \\\" - likely not enough disk space.\\\"); assumeTrue(false); } finally { try { zos.destroy(); } finally { if (os != null) { os.close(); } AbstractTestCase.tryHardToDelete(f); } } }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [
                    "org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n```\n\n```java\n\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n```\n\n```java\n    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n```\n\n```java\n\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n        int cdhStart = findCentralDirectory(data);\n        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n        int ddStart = cdhStart - 16;\n        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n        long crcFromLFH = ZipLong.getValue(data, 14);\n        long cSizeFromLFH = ZipLong.getValue(data, 18);\n        long sizeFromLFH = ZipLong.getValue(data, 22);\n        assertEquals(3, sizeFromLFH);\n\n        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n        assertEquals(crcFromLFH, crcFromCDH);\n        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n        assertEquals(cSizeFromLFH, cSizeFromCDH);\n        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n        assertEquals(sizeFromLFH, sizeFromCDH);\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n",
                            "\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze)));\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                     final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx =\n        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET +\n                        name.limit() - name.position() +\n                        ze.getLocalFileDataExtra().length;\n\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                        - ResourceAlignmentExtraField.BASE_SIZE) &\n                        (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n\n    System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(ze);\n\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n    // CRC\n    if (phased || !dataDescriptor) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)){\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else { // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n    // file name\n    System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n    return buf;\n}\n\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (!usesDataDescriptor(ze)) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\nprivate boolean usesDataDescriptor(final ZipArchiveEntry ze) {\n    return ze.getMethod() == DEFLATED && !ze.isRaw() && channel == null;\n}\n",
                            "\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze)));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n",
                            "\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n",
                            "\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                     final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx =\n        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET +\n                        name.limit() - name.position() +\n                        ze.getLocalFileDataExtra().length;\n\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                        - ResourceAlignmentExtraField.BASE_SIZE) &\n                        (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n\n    System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), false /* Don't use DD for raw */), buf, LFH_VERSION_NEEDED_OFFSET);\n\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, false /* Don't use DD for raw */);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n    // CRC\n    if (phased){\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)){\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else { // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n    // file name\n    System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n    return buf;\n}\n\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || usesDataDescriptor(ze.getMethod())) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return false; // Adjusting to return false for raw entries, change logic if needed.\n}\n",
                            "\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                     final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx =\n        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET +\n                        name.limit() - name.position() +\n                        ze.getLocalFileDataExtra().length;\n\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                        - ResourceAlignmentExtraField.BASE_SIZE) &\n                        (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n\n    System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n    // CRC\n    if (phased){\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)){\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else { // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n    // file name\n    System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n    return buf;\n}\n\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    if (usesDataDescriptor(ze.getMethod())) {\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n}\n\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !entry.isPhased();\n}\n",
                            "\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n",
                            "\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n",
                            "\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                     final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx =\n        (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET +\n                        name.limit() - name.position() +\n                        ze.getLocalFileDataExtra().length;\n\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                        - ResourceAlignmentExtraField.BASE_SIZE) &\n                        (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                        oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n\n    System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else { // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n    return buf;\n}\n\n/**\n * Writes the data descriptor entry.\n * @param ze the entry to write\n * @throws IOException on error\n */\n\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || !usesDataDescriptor(ze.getMethod())) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    // Ensure that we only use data descriptors for DEFLATED entries.\n    return zipMethod == DEFLATED && channel == null;\n}\n",
                            "\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        ze.setDataOffset(localHeaderStart + LFH_CRC_OFFSET); // Changed from 'entry.localDataStart' to 'ze.setDataOffset'\n        writeCounted(localHeader);\n        ze.setDataStart(streamCompressor.getTotalBytesWritten()); // Changed from 'entry.dataStart' to 'ze.setDataStart'\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
                "start_loc": 1041,
                "end_loc": 1127,
                "buggy_function": "    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n",
                "fixed_function": "    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod, phased);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException { ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID); if (oldAlignmentEx != null) { ze.removeExtraField(ResourceAlignmentExtraField.ID); } int alignment = ze.getAlignment(); if (alignment <= 0 && oldAlignmentEx != null) { alignment = oldAlignmentEx.getAlignment(); } if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) { int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length; int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1)); ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding)); } final byte[] extra = ze.getLocalFileDataExtra(); final int nameLen = name.limit() - name.position(); final int len = LFH_FILENAME_OFFSET + nameLen + extra.length; final byte[] buf = new byte[len]; System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD); final int zipMethod = ze.getMethod(); final boolean dataDescriptor = usesDataDescriptor(zipMethod); putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET); final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor); generalPurposeBit.encode(buf, LFH_GPB_OFFSET); putShort(zipMethod, buf, LFH_METHOD_OFFSET); ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET); if (phased) { putLong(ze.getCrc(), buf, LFH_CRC_OFFSET); } else if (zipMethod == DEFLATED || channel != null) { System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD); } else { putLong(ze.getCrc(), buf, LFH_CRC_OFFSET); } if (hasZip64Extra(entry.entry)) { ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET); ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET); } else if (phased) { putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET); putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET); } else if (zipMethod == DEFLATED || channel != null) { System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD); System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD); } else { putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET); putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET); } putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET); putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET); System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen); System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length); return buf; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999999403953552,
                        "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException { ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID); if (oldAlignmentEx != null) { ze.removeExtraField(ResourceAlignmentExtraField.ID); } int alignment = ze.getAlignment(); if (alignment <= 0 && oldAlignmentEx != null) { alignment = oldAlignmentEx.getAlignment(); } if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) { int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length; int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1)); ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding)); } final byte[] extra = ze.getLocalFileDataExtra(); final int nameLen = name.limit() - name.position(); final int len = LFH_FILENAME_OFFSET + nameLen + extra.length; final byte[] buf = new byte[len]; System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD); final int zipMethod = ze.getMethod(); final boolean dataDescriptor = usesDataDescriptor(zipMethod); putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET); final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor); generalPurposeBit.encode(buf, LFH_GPB_OFFSET); putShort(zipMethod, buf, LFH_METHOD_OFFSET); ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET); if (phased) { putLong(ze.getCrc(), buf, LFH_CRC_OFFSET); } else if (zipMethod == DEFLATED || channel != null) { System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD); } else { putLong(ze.getCrc(), buf, LFH_CRC_OFFSET); } if (hasZip64Extra(entry.entry)) { ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET); ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET); } else if (phased) { putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET); putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET); } else if (zipMethod == DEFLATED || channel != null) { System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD); System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD); } else { putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET); putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET); } putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET); putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET); System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen); System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length); return buf; }"
                    ],
                    [
                        0.9929523766040802,
                        "private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final EntryMetaData entryMetaData, final boolean needsZip64Extra) throws IOException { final byte[] extra = ze.getCentralDirectoryExtra(); String comm = ze.getComment(); if (comm == null) { comm = \\\"\\\"; } final ByteBuffer commentB = getEntryEncoding(ze).encode(comm); final int nameLen = name.limit() - name.position(); final int commentLen = commentB.limit() - commentB.position(); final int len = CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen; final byte[] buf = new byte[len]; System.arraycopy(CFH_SIG, 0, buf, CFH_SIG_OFFSET, WORD); putShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION), buf, CFH_VERSION_MADE_BY_OFFSET); final int zipMethod = ze.getMethod(); final boolean encodable = zipEncoding.canEncode(ze.getName()); putShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor), buf, CFH_VERSION_NEEDED_OFFSET); getGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET); putShort(zipMethod, buf, CFH_METHOD_OFFSET); ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET); putLong(ze.getCrc(), buf, CFH_CRC_OFFSET); if (ze.getCompressedSize() >= ZIP64_MAGIC || ze.getSize() >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) { ZipLong.ZIP64_MAGIC.putLong(buf, CFH_COMPRESSED_SIZE_OFFSET); ZipLong.ZIP64_MAGIC.putLong(buf, CFH_ORIGINAL_SIZE_OFFSET); } else { putLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET); putLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET); } putShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET); putShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET); putShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET); System.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT); putShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET); putLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET); if (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) { putLong(ZIP64_MAGIC, buf, CFH_LFH_OFFSET); } else { putLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET); } System.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen); final int extraStart = CFH_FILENAME_OFFSET + nameLen; System.arraycopy(extra, 0, buf, extraStart, extra.length); final int commentStart = extraStart + extra.length; System.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen); return buf; }"
                    ],
                    [
                        0.9914553761482239,
                        "public ZipArchiveEntry getNextZipEntry() throws IOException { boolean firstEntry = true; if (closed || hitCentralDirectory) { return null; } if (current != null) { closeEntry(); firstEntry = false; } long currentHeaderOffset = getBytesRead(); try { if (firstEntry) { readFirstLocalFileHeader(lfhBuf); } else { readFully(lfhBuf); } } catch (final EOFException e) { return null; } final ZipLong sig = new ZipLong(lfhBuf); if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) { hitCentralDirectory = true; skipRemainderOfArchive(); return null; } if (!sig.equals(ZipLong.LFH_SIG)) { throw new ZipException(String.format(\\\"Unexpected record signature: 0X%X\\\", sig.getValue())); } int off = WORD; current = new CurrentEntry(); final int versionMadeBy = ZipShort.getValue(lfhBuf, off); off += SHORT; current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK); final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off); final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames(); final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; current.hasDataDescriptor = gpFlag.usesDataDescriptor(); current.entry.setGeneralPurposeBit(gpFlag); off += SHORT; current.entry.setMethod(ZipShort.getValue(lfhBuf, off)); off += SHORT; final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off)); current.entry.setTime(time); off += WORD; ZipLong size = null, cSize = null; if (!current.hasDataDescriptor) { current.entry.setCrc(ZipLong.getValue(lfhBuf, off)); off += WORD; cSize = new ZipLong(lfhBuf, off); off += WORD; size = new ZipLong(lfhBuf, off); off += WORD; } else { off += 3 * WORD; } final int fileNameLen = ZipShort.getValue(lfhBuf, off); off += SHORT; final int extraLen = ZipShort.getValue(lfhBuf, off); off += SHORT; final byte[] fileName = new byte[fileNameLen]; readFully(fileName); current.entry.setName(entryEncoding.decode(fileName), fileName); final byte[] extraData = new byte[extraLen]; readFully(extraData); current.entry.setExtra(extraData); if (!hasUTF8Flag && useUnicodeExtraFields) { ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null); } processZip64Extra(size, cSize); current.entry.setLocalHeaderOffset(currentHeaderOffset); current.entry.setDataOffset(getBytesRead()); current.entry.setStreamContiguous(true); if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) { if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) { current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize())); } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) { current.in = new ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), new BoundedInputStream(in, current.entry.getCompressedSize())); } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) { current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize())); } } entriesRead++; return current.entry; }"
                    ],
                    [
                        0.9910809993743896,
                        "@Override public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException { if (finished) { throw new IOException(\\\"Stream has already been finished\\\"); } final TarArchiveEntry entry = (TarArchiveEntry) archiveEntry; final Map<String, String> paxHeaders = new HashMap<>(); final String entryName = entry.getName(); final boolean paxHeaderContainsPath = handleLongName(entry, entryName, paxHeaders, \\\"path\\\", TarConstants.LF_GNUTYPE_LONGNAME, \\\"file name\\\"); final String linkName = entry.getLinkName(); final boolean paxHeaderContainsLinkPath = linkName != null && linkName.length() > 0 && handleLongName(entry, linkName, paxHeaders, \\\"linkpath\\\", TarConstants.LF_GNUTYPE_LONGLINK, \\\"link name\\\"); if (bigNumberMode == BIGNUMBER_POSIX) { addPaxHeadersForBigNumbers(paxHeaders, entry); } else if (bigNumberMode != BIGNUMBER_STAR) { failForBigNumbers(entry); } if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsPath && !ASCII.canEncode(entryName)) { paxHeaders.put(\\\"path\\\", entryName); } if (addPaxHeadersForNonAsciiNames && !paxHeaderContainsLinkPath && (entry.isLink() || entry.isSymbolicLink()) && !ASCII.canEncode(linkName)) { paxHeaders.put(\\\"linkpath\\\", linkName); } if (paxHeaders.size() > 0) { writePaxHeaders(entry, entryName, paxHeaders); } entry.writeEntryHeader(recordBuf, zipEncoding, bigNumberMode == BIGNUMBER_STAR); writeRecord(recordBuf); currBytes = 0; if (entry.isDirectory()) { currSize = 0; } else { currSize = entry.getSize(); } currName = entryName; haveUnclosedEntry = true; }"
                    ],
                    [
                        0.9888624548912048,
                        "private boolean init(final boolean isFirstMember) throws IOException { assert isFirstMember || decompressConcatenated; final int magic0 = in.read(); final int magic1 = in.read(); if (magic0 == -1 && !isFirstMember) { return false; } if (magic0 != 31 || magic1 != 139) { throw new IOException(isFirstMember ? \\\"Input is not in the .gz format\\\" : \\\"Garbage after a valid .gz stream\\\"); } final DataInput inData = new DataInputStream(in); final int method = inData.readUnsignedByte(); if (method != Deflater.DEFLATED) { throw new IOException(\\\"Unsupported compression method \\\" + method + \\\" in the .gz header\\\"); } final int flg = inData.readUnsignedByte(); if ((flg & FRESERVED) != 0) { throw new IOException(\\\"Reserved flags are set in the .gz header\\\"); } parameters.setModificationTime(ByteUtils.fromLittleEndian(inData, 4) * 1000); switch(inData.readUnsignedByte()) { case 2: parameters.setCompressionLevel(Deflater.BEST_COMPRESSION); break; case 4: parameters.setCompressionLevel(Deflater.BEST_SPEED); break; default: break; } parameters.setOperatingSystem(inData.readUnsignedByte()); if ((flg & FEXTRA) != 0) { int xlen = inData.readUnsignedByte(); xlen |= inData.readUnsignedByte() << 8; while (xlen-- > 0) { inData.readUnsignedByte(); } } if ((flg & FNAME) != 0) { parameters.setFilename(new String(readToNull(inData), CharsetNames.ISO_8859_1)); } if ((flg & FCOMMENT) != 0) { parameters.setComment(new String(readToNull(inData), CharsetNames.ISO_8859_1)); } if ((flg & FHCRC) != 0) { inData.readShort(); } inf.reset(); crc.reset(); return true; }"
                    ],
                    [
                        0.9869835376739502,
                        "private Archive readHeaders(final byte[] password) throws IOException { ByteBuffer buf = ByteBuffer.allocate(12).order(ByteOrder.LITTLE_ENDIAN); readFully(buf); final byte[] signature = new byte[6]; buf.get(signature); if (!Arrays.equals(signature, sevenZSignature)) { throw new IOException(\\\"Bad 7z signature\\\"); } final byte archiveVersionMajor = buf.get(); final byte archiveVersionMinor = buf.get(); if (archiveVersionMajor != 0) { throw new IOException(String.format(\\\"Unsupported 7z version (%d,%d)\\\", archiveVersionMajor, archiveVersionMinor)); } final long startHeaderCrc = 0xffffFFFFL & buf.getInt(); final StartHeader startHeader = readStartHeader(startHeaderCrc); final int nextHeaderSizeInt = (int) startHeader.nextHeaderSize; if (nextHeaderSizeInt != startHeader.nextHeaderSize) { throw new IOException(\\\"cannot handle nextHeaderSize \\\" + startHeader.nextHeaderSize); } channel.position(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset); buf = ByteBuffer.allocate(nextHeaderSizeInt).order(ByteOrder.LITTLE_ENDIAN); readFully(buf); final CRC32 crc = new CRC32(); crc.update(buf.array()); if (startHeader.nextHeaderCrc != crc.getValue()) { throw new IOException(\\\"NextHeader CRC mismatch\\\"); } Archive archive = new Archive(); int nid = getUnsignedByte(buf); if (nid == NID.kEncodedHeader) { buf = readEncodedHeader(buf, archive, password); archive = new Archive(); nid = getUnsignedByte(buf); } if (nid == NID.kHeader) { readHeader(buf, archive); } else { throw new IOException(\\\"Broken or unsupported archive: no Header\\\"); } return archive; }"
                    ],
                    [
                        0.9869330823421478,
                        "private static ZipOutputTest writeBigDeflatedEntryToFile(final boolean knownSize, final Zip64Mode mode) { return new ZipOutputTest() { @Override public void test(final File f, final ZipArchiveOutputStream zos) throws IOException { if (mode != Zip64Mode.AsNeeded) { zos.setUseZip64(mode); } final byte[] buf = new byte[ONE_MILLION]; final ZipArchiveEntry zae = new ZipArchiveEntry(\\\"0\\\"); if (knownSize) { zae.setSize(FIVE_BILLION); } zae.setMethod(ZipEntry.DEFLATED); zos.putArchiveEntry(zae); for (int j = 0; j < FIVE_BILLION / 1000 / 1000; j++) { zos.write(buf); } zos.closeArchiveEntry(); zos.close(); try (RandomAccessFile a = new RandomAccessFile(f, \\\"r\\\")) { getLengthAndPositionAtCentralDirectory(a); byte[] header = new byte[12]; a.readFully(header); assertArrayEquals(\\\"CDH start\\\", new byte[] { (byte) 0x50, (byte) 0x4b, 1, 2, 45, 0, 45, 0, 0, 8, 8, 0 }, header); a.skipBytes(4); byte[] rest = new byte[26]; a.readFully(rest); assertArrayEquals(\\\"CDH rest\\\", new byte[] { (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, 1, 0, (byte) (mode == Zip64Mode.Always ? 28 : 20), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, rest); byte[] offset = new byte[4]; a.readFully(offset); if (mode == Zip64Mode.Always) { assertArrayEquals(\\\"offset\\\", new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, offset); } else { assertArrayEquals(\\\"offset\\\", new byte[] { 0, 0, 0, 0 }, offset); } assertEquals('0', a.read()); byte[] extra = new byte[12]; a.readFully(extra); assertArrayEquals(\\\"CDH extra\\\", new byte[] { 1, 0, (byte) (mode == Zip64Mode.Always ? 24 : 16), 0, 0, (byte) 0xF2, 5, (byte) 0x2A, 1, 0, 0, 0 }, extra); if (mode == Zip64Mode.Always) { a.skipBytes(8); offset = new byte[8]; a.readFully(offset); assertArrayEquals(\\\"extra offset\\\", new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }, offset); } a.seek(0); header = new byte[10]; a.readFully(header); assertArrayEquals(\\\"LFH start\\\", new byte[] { (byte) 0x50, (byte) 0x4b, 3, 4, 45, 0, 0, 8, 8, 0 }, header); a.skipBytes(4); rest = new byte[17]; a.readFully(rest); assertArrayEquals(new byte[] { (byte) 0x50, (byte) 0x6F, (byte) 0x31, (byte) 0x5c, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, 1, 0, 20, 0, (byte) '0' }, rest); extra = new byte[12]; a.readFully(extra); assertArrayEquals(new byte[] { 1, 0, 16, 0, 0, (byte) 0xF2, 5, (byte) 0x2A, 1, 0, 0, 0 }, extra); } } }; }"
                    ],
                    [
                        0.9864695966243744,
                        "private void parseTarHeader(final byte[] header, final ZipEncoding encoding, final boolean oldStyle) throws IOException { int offset = 0; name = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; mode = (int) TarUtils.parseOctalOrBinary(header, offset, MODELEN); offset += MODELEN; userId = (int) TarUtils.parseOctalOrBinary(header, offset, UIDLEN); offset += UIDLEN; groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN); offset += GIDLEN; size = TarUtils.parseOctalOrBinary(header, offset, SIZELEN); offset += SIZELEN; modTime = TarUtils.parseOctalOrBinary(header, offset, MODTIMELEN); offset += MODTIMELEN; checkSumOK = TarUtils.verifyCheckSum(header); offset += CHKSUMLEN; linkFlag = header[offset++]; linkName = oldStyle ? TarUtils.parseName(header, offset, NAMELEN) : TarUtils.parseName(header, offset, NAMELEN, encoding); offset += NAMELEN; magic = TarUtils.parseName(header, offset, MAGICLEN); offset += MAGICLEN; version = TarUtils.parseName(header, offset, VERSIONLEN); offset += VERSIONLEN; userName = oldStyle ? TarUtils.parseName(header, offset, UNAMELEN) : TarUtils.parseName(header, offset, UNAMELEN, encoding); offset += UNAMELEN; groupName = oldStyle ? TarUtils.parseName(header, offset, GNAMELEN) : TarUtils.parseName(header, offset, GNAMELEN, encoding); offset += GNAMELEN; devMajor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; devMinor = (int) TarUtils.parseOctalOrBinary(header, offset, DEVLEN); offset += DEVLEN; final int type = evaluateType(header); switch(type) { case FORMAT_OLDGNU: { offset += ATIMELEN_GNU; offset += CTIMELEN_GNU; offset += OFFSETLEN_GNU; offset += LONGNAMESLEN_GNU; offset += PAD2LEN_GNU; offset += SPARSELEN_GNU; isExtended = TarUtils.parseBoolean(header, offset); offset += ISEXTENDEDLEN_GNU; realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU); offset += REALSIZELEN_GNU; break; } case FORMAT_XSTAR: { final String xstarPrefix = oldStyle ? TarUtils.parseName(header, offset, PREFIXLEN_XSTAR) : TarUtils.parseName(header, offset, PREFIXLEN_XSTAR, encoding); if (xstarPrefix.length() > 0) { name = xstarPrefix + \\\"/\\\" + name; } break; } case FORMAT_POSIX: default: { final String prefix = oldStyle ? TarUtils.parseName(header, offset, PREFIXLEN) : TarUtils.parseName(header, offset, PREFIXLEN, encoding); if (isDirectory() && !name.endsWith(\\\"/\\\")) { name = name + \\\"/\\\"; } if (prefix.length() > 0) { name = prefix + \\\"/\\\" + name; } } } }"
                    ],
                    [
                        0.9854281544685364,
                        "private static ZipOutputTest writeSmallDeflatedEntryToStreamModeAlways(final boolean knownSize) { return new ZipOutputTest() { @Override public void test(final File f, final ZipArchiveOutputStream zos) throws IOException { zos.setUseZip64(Zip64Mode.Always); final byte[] buf = new byte[ONE_MILLION]; final ZipArchiveEntry zae = new ZipArchiveEntry(\\\"0\\\"); if (knownSize) { zae.setSize(ONE_MILLION); } zae.setMethod(ZipEntry.DEFLATED); zos.putArchiveEntry(zae); zos.write(buf); zos.closeArchiveEntry(); zos.close(); try (RandomAccessFile a = new RandomAccessFile(f, \\\"r\\\")) { getLengthAndPositionAtCentralDirectory(a); final long cfhPos = a.getFilePointer(); byte[] header = new byte[12]; a.readFully(header); assertArrayEquals(\\\"CDH start\\\", new byte[] { (byte) 0x50, (byte) 0x4b, 1, 2, 45, 0, 45, 0, 8, 8, 8, 0 }, header); a.skipBytes(4); final byte[] crc = new byte[4]; a.readFully(crc); assertArrayEquals(new byte[] { (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12 }, crc); a.skipBytes(4); byte[] rest = new byte[23]; a.readFully(rest); assertArrayEquals(\\\"CDH rest\\\", new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, 1, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) '0' }, rest); byte[] extra = new byte[12]; a.readFully(extra); assertArrayEquals(\\\"CDH extra\\\", new byte[] { 1, 0, 24, 0, (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0, 0, 0, 0, 0 }, extra); a.skipBytes(8); byte[] offset = new byte[8]; a.readFully(offset); assertArrayEquals(\\\"extra offset\\\", new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }, offset); a.seek(cfhPos - 24); byte[] dd = new byte[8]; a.readFully(dd); assertArrayEquals(\\\"DD\\\", new byte[] { (byte) 0x50, (byte) 0x4b, 7, 8, (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12 }, dd); a.skipBytes(8); dd = new byte[8]; a.readFully(dd); assertArrayEquals(\\\"DD size\\\", new byte[] { (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0, 0, 0, 0, 0 }, dd); a.seek(0); header = new byte[10]; a.readFully(header); assertArrayEquals(\\\"LFH start\\\", new byte[] { (byte) 0x50, (byte) 0x4b, 3, 4, 45, 0, 8, 8, 8, 0 }, header); a.skipBytes(4); rest = new byte[17]; a.readFully(rest); assertArrayEquals(\\\"LFH rest\\\", new byte[] { 0, 0, 0, 0, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, 1, 0, 20, 0, (byte) '0' }, rest); extra = new byte[20]; a.readFully(extra); assertArrayEquals(\\\"LFH extra\\\", new byte[] { 1, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, extra); } } }; }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [
                    "org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n```\n\n```java\n\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n```\n\n```java\n    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n```\n\n```java\n\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n        int cdhStart = findCentralDirectory(data);\n        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n        int ddStart = cdhStart - 16;\n        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n        long crcFromLFH = ZipLong.getValue(data, 14);\n        long cSizeFromLFH = ZipLong.getValue(data, 18);\n        long sizeFromLFH = ZipLong.getValue(data, 22);\n        assertEquals(3, sizeFromLFH);\n\n        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n        assertEquals(crcFromLFH, crcFromCDH);\n        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n        assertEquals(cSizeFromLFH, cSizeFromCDH);\n        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n        assertEquals(sizeFromLFH, sizeFromCDH);\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n",
                            "\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(ze);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        if (hasZip64Extra(entry.entry)){\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else {\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n",
                            "\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased || channel == null){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased || channel == null) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n",
                            "\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        // ensure dataDescriptor is false if addRawArchiveEntry is used\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, !phased && dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n",
                            "\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n",
                            "\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), false), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(ze)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
                "start_loc": 1170,
                "end_loc": 1183,
                "buggy_function": "    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n",
                "fixed_function": "    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (!usesDataDescriptor(ze.getMethod(), false)) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n",
                "comment": "    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n",
                "normalized_body": [
                    "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException { if (ze.getMethod() != DEFLATED || channel != null) { return; } writeCounted(DD_SIG); writeCounted(ZipLong.getBytes(ze.getCrc())); if (!hasZip64Extra(ze)) { writeCounted(ZipLong.getBytes(ze.getCompressedSize())); writeCounted(ZipLong.getBytes(ze.getSize())); } else { writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize())); writeCounted(ZipEightByteInteger.getBytes(ze.getSize())); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException { if (ze.getMethod() != DEFLATED || channel != null) { return; } writeCounted(DD_SIG); writeCounted(ZipLong.getBytes(ze.getCrc())); if (!hasZip64Extra(ze)) { writeCounted(ZipLong.getBytes(ze.getCompressedSize())); writeCounted(ZipLong.getBytes(ze.getSize())); } else { writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize())); writeCounted(ZipEightByteInteger.getBytes(ze.getSize())); } }"
                    ],
                    [
                        0.9835549592971802,
                        "@Test public void shouldWriteDataProperlyAfterPositionSet() throws IOException { SeekableInMemoryByteChannel c = new SeekableInMemoryByteChannel(testData); ByteBuffer inData = ByteBuffer.wrap(testData); ByteBuffer expectedData = ByteBuffer.allocate(testData.length + 5).put(testData, 0, 5).put(testData); c.position(5L); int writeCount = c.write(inData); assertEquals(testData.length, writeCount); assertArrayEquals(expectedData.array(), Arrays.copyOf(c.array(), (int) c.size())); assertEquals(testData.length + 5, c.position()); c.close(); }"
                    ],
                    [
                        0.9834133386611938,
                        "@Test public void testReadLFHSizesOnly() throws ZipException { final Zip64ExtendedInformationExtraField f = new Zip64ExtendedInformationExtraField(); final byte[] b = new byte[16]; System.arraycopy(SIZE.getBytes(), 0, b, 0, 8); System.arraycopy(CSIZE.getBytes(), 0, b, 8, 8); f.parseFromLocalFileData(b, 0, b.length); assertEquals(SIZE, f.getSize()); assertEquals(CSIZE, f.getCompressedSize()); assertNull(f.getRelativeHeaderOffset()); assertNull(f.getDiskStartNumber()); }"
                    ],
                    [
                        0.9834050536155701,
                        "private void writePackInfo(final DataOutput header) throws IOException { header.write(NID.kPackInfo); writeUint64(header, 0); writeUint64(header, 0xffffFFFFL & numNonEmptyStreams); header.write(NID.kSize); for (final SevenZArchiveEntry entry : files) { if (entry.hasStream()) { writeUint64(header, entry.getCompressedSize()); } } header.write(NID.kCRC); header.write(1); for (final SevenZArchiveEntry entry : files) { if (entry.hasStream()) { header.writeInt(Integer.reverseBytes((int) entry.getCompressedCrcValue())); } } header.write(NID.kEnd); }"
                    ],
                    [
                        0.9816993474960327,
                        "@Test public void deflatedEntries() throws Exception { final ByteArrayOutputStream baos = new ByteArrayOutputStream(); final StreamCompressor sc = StreamCompressor.create(baos); sc.deflate(new ByteArrayInputStream(\\\"AAAAAABBBBBB\\\".getBytes()), ZipEntry.DEFLATED); assertEquals(12, sc.getBytesRead()); assertEquals(8, sc.getBytesWrittenForLastEntry()); assertEquals(3299542, sc.getCrc32()); final byte[] actuals = baos.toByteArray(); final byte[] expected = new byte[] { 115, 116, 4, 1, 39, 48, 0, 0 }; assertArrayEquals(expected, actuals); }"
                    ],
                    [
                        0.9813593029975891,
                        "void blockSort(final BZip2CompressorOutputStream.Data data, final int last) { this.workLimit = WORK_FACTOR * last; this.workDone = 0; this.firstAttempt = true; if (last + 1 < 10000) { fallbackSort(data, last); } else { mainSort(data, last); if (this.firstAttempt && (this.workDone > this.workLimit)) { fallbackSort(data, last); } } final int[] fmap = data.fmap; data.origPtr = -1; for (int i = 0; i <= last; i++) { if (fmap[i] == 0) { data.origPtr = i; break; } } }"
                    ],
                    [
                        0.9808445572853088,
                        "@Override public void write(byte[] data, int off, int len) throws IOException { if (currentIndex + len > MAX_COMPRESSED_BUFFER_SIZE) { flushBuffer(); while (len > MAX_COMPRESSED_BUFFER_SIZE) { System.arraycopy(data, off, buffer, 0, MAX_COMPRESSED_BUFFER_SIZE); off += MAX_COMPRESSED_BUFFER_SIZE; len -= MAX_COMPRESSED_BUFFER_SIZE; currentIndex = MAX_COMPRESSED_BUFFER_SIZE; flushBuffer(); } } System.arraycopy(data, off, buffer, currentIndex, len); currentIndex += len; }"
                    ],
                    [
                        0.9804478883743286,
                        "@Override public int read(final byte[] buf, final int offset, int numToRead) throws IOException { int totalRead = 0; if (hasHitEOF || isDirectory() || entryOffset >= entrySize) { return -1; } if (currEntry == null) { throw new IllegalStateException(\\\"No current tar entry\\\"); } numToRead = Math.min(numToRead, available()); totalRead = is.read(buf, offset, numToRead); if (totalRead == -1) { if (numToRead > 0) { throw new IOException(\\\"Truncated TAR archive\\\"); } hasHitEOF = true; } else { count(totalRead); entryOffset += totalRead; } return totalRead; }"
                    ],
                    [
                        0.9799658060073853,
                        "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException { final StartHeader startHeader = new StartHeader(); try (DataInputStream dataInputStream = new DataInputStream(new CRC32VerifyingInputStream(new BoundedSeekableByteChannelInputStream(channel, 20), 20, startHeaderCrc))) { startHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong()); startHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong()); startHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt()); return startHeader; } }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [
                    "org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n```\n\n```java\n\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n```\n\n```java\n    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n```\n\n```java\n\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n        int cdhStart = findCentralDirectory(data);\n        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n        int ddStart = cdhStart - 16;\n        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n        long crcFromLFH = ZipLong.getValue(data, 14);\n        long cSizeFromLFH = ZipLong.getValue(data, 18);\n        long sizeFromLFH = ZipLong.getValue(data, 22);\n        assertEquals(3, sizeFromLFH);\n\n        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n        assertEquals(crcFromLFH, crcFromCDH);\n        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n        assertEquals(cSizeFromLFH, cSizeFromCDH);\n        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n        assertEquals(sizeFromLFH, sizeFromCDH);\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (!usesDataDescriptor(ze.getMethod())) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n",
                            "\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (!usesDataDescriptor(ze)) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n",
                            "\n    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null || !usesDataDescriptor(ze.getMethod())) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n",
                            "\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        // ensure data descriptor is actually used\n        if (!usesDataDescriptor(ze.getMethod())) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n",
                            "\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n",
                            "\n    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (!usesDataDescriptor(ze.getMethod())) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
                "start_loc": 1492,
                "end_loc": 1494,
                "buggy_function": "    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n",
                "fixed_function": "    private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n        return !phased && zipMethod == DEFLATED && channel == null;\n    }\n",
                "comment": "",
                "normalized_body": [
                    "private boolean usesDataDescriptor(final int zipMethod) { return zipMethod == DEFLATED && channel == null; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "private boolean usesDataDescriptor(final int zipMethod) { return zipMethod == DEFLATED && channel == null; }"
                    ],
                    [
                        0.9802768230438232,
                        "private int fmin(final int a, final int b) { return a < b ? a : b; }"
                    ],
                    [
                        0.9744967818260193,
                        "private boolean hasZip64Extra(final ZipArchiveEntry ze) { return ze.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID) != null; }"
                    ],
                    [
                        0.9721692204475403,
                        "private int versionNeededToExtractMethod(int zipMethod) { return zipMethod == DEFLATED ? DEFLATE_MIN_VERSION : INITIAL_VERSION; }"
                    ],
                    [
                        0.9683117270469666,
                        "private void test7zUnarchive(final File f, final SevenZMethod m) throws Exception { test7zUnarchive(f, m, null); }"
                    ],
                    [
                        0.9675979614257812,
                        "private boolean isFirstByteOfEocdSig(final int b) { return b == ZipArchiveOutputStream.EOCD_SIG[0]; }"
                    ],
                    [
                        0.9670203924179077,
                        "private int readNextByte(BitInputStream in) throws IOException { long b = in.readBits(8); return (int) b; }"
                    ],
                    [
                        0.9669879674911499,
                        "private void checkRoundTripOctal(final long value) { checkRoundTripOctal(value, TarConstants.SIZELEN); }"
                    ],
                    [
                        0.9660577178001404,
                        "private void prependLiteral(byte[] data) { literals.addFirst(data); }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [
                    "org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        final ByteBuffer name = getName(ze);\n\n        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n            addUnicodeExtraFields(ze, encodable, name);\n        }\n\n        final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n        final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n        metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n        writeCounted(localHeader);\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n\n```\n\n```java\n\n    private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n                                         final boolean phased, long archiveOffset) throws IOException {\n        ResourceAlignmentExtraField oldAlignmentEx =\n            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n        if (oldAlignmentEx != null) {\n            ze.removeExtraField(ResourceAlignmentExtraField.ID);\n        }\n\n        int alignment = ze.getAlignment();\n        if (alignment <= 0 && oldAlignmentEx != null) {\n            alignment = oldAlignmentEx.getAlignment();\n        }\n\n        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n            int oldLength = LFH_FILENAME_OFFSET +\n                            name.limit() - name.position() +\n                            ze.getLocalFileDataExtra().length;\n\n            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n                            - ResourceAlignmentExtraField.BASE_SIZE) &\n                            (alignment - 1));\n            ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n        }\n\n        final byte[] extra = ze.getLocalFileDataExtra();\n        final int nameLen = name.limit() - name.position();\n        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n        final byte[] buf = new byte[len];\n\n        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n\n        //store method in local variable to prevent multiple method calls\n        final int zipMethod = ze.getMethod();\n        final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n\n        putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n\n        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n\n        // compression method\n        putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n\n        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n\n        // CRC\n        if (phased){\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        }\n\n        // compressed length\n        // uncompressed length\n        if (hasZip64Extra(entry.entry)){\n            // point to ZIP64 extended information extra field for\n            // sizes, may get rewritten once sizes are known if\n            // stream is seekable\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (phased) {\n            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        } else if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else { // Stored\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n        // file name length\n        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n\n        // extra field length\n        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n\n        // file name\n        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n\n        // extra fields\n        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n\n        return buf;\n    }\n\n```\n\n```java\n    /**\n     * Writes the data descriptor entry.\n     * @param ze the entry to write\n     * @throws IOException on error\n     */\n\n    protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n        if (ze.getMethod() != DEFLATED || channel != null) {\n            return;\n        }\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (!hasZip64Extra(ze)) {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        }\n    }\n\n```\n\n```java\n\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n        int cdhStart = findCentralDirectory(data);\n        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n        int ddStart = cdhStart - 16;\n        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n        long crcFromLFH = ZipLong.getValue(data, 14);\n        long cSizeFromLFH = ZipLong.getValue(data, 18);\n        long sizeFromLFH = ZipLong.getValue(data, 22);\n        assertEquals(3, sizeFromLFH);\n\n        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n        assertEquals(crcFromLFH, crcFromCDH);\n        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n        assertEquals(cSizeFromLFH, cSizeFromCDH);\n        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n        assertEquals(sizeFromLFH, sizeFromCDH);\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED;\n    }\n",
                            "\n    private boolean usesDataDescriptor(final ZipArchiveEntry ze) {\n        return ze.getMethod() == DEFLATED && channel == null;\n    }\n",
                            "\n\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n\n",
                            "\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n",
                            "\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n",
                            "\n    private boolean usesDataDescriptor(final int zipMethod) {\n        return zipMethod == DEFLATED && channel == null;\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/DataDescriptorTest.java",
                "function_name": "doesntWriteDataDescriptorWhenAddingRawEntries",
                "src": "    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n\n        int cdhStart = findCentralDirectory(data);\n        byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n        assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n        byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n\n        int ddStart = cdhStart - 16;\n        assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n        long crcFromLFH = ZipLong.getValue(data, 14);\n        long cSizeFromLFH = ZipLong.getValue(data, 18);\n        long sizeFromLFH = ZipLong.getValue(data, 22);\n        assertEquals(3, sizeFromLFH);\n\n        long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n        assertEquals(crcFromLFH, crcFromCDH);\n        long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n        assertEquals(cSizeFromLFH, cSizeFromCDH);\n        long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n        assertEquals(sizeFromLFH, sizeFromCDH);\n    }",
                "error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\tat org.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)\n\tat org.junit.Assert.internalArrayEquals(Assert.java:473)\n\tat org.junit.Assert.assertArrayEquals(Assert.java:294)\n\tat org.junit.Assert.assertArrayEquals(Assert.java:305)\n\tat org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries(DataDescriptorTest.java:162)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n\tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\tat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\tat org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries(DataDescriptorTest.java:162)  assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);"
            }
        },
        "evaluation_done": true
    }
}