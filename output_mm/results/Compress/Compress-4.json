{
    "Compress-4": {
        "function_num": 4,
        "functions": [
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java",
                "start_loc": 334,
                "end_loc": 340,
                "buggy_function": "    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            out.close();\n            this.closed = true;\n        }\n    }\n",
                "fixed_function": "    public void close() throws IOException {\n        if (!this.closed) {\n            out.close();\n            this.closed = true;\n        }\n    }\n",
                "comment": "    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n",
                "normalized_body": [
                    "public void close() throws IOException { if (!this.closed) { this.finish(); out.close(); this.closed = true; } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public void close() throws IOException { if (!this.closed) { this.finish(); out.close(); this.closed = true; } }"
                    ],
                    [
                        0.991955041885376,
                        "public void close() throws IOException { if (!closed) { finish(); buffer.close(); out.close(); closed = true; } }"
                    ],
                    [
                        0.9837258458137512,
                        "public void close() throws IOException { finish(); if (raf != null) { raf.close(); } if (out != null) { out.close(); } }"
                    ],
                    [
                        0.9825621247291565,
                        "public void close() throws IOException { if (!closed) { closed = true; in.close(); } }"
                    ],
                    [
                        0.9821545481681824,
                        "public void close() throws IOException { if (!closed) { closed = true; input.close(); } currentEntry = null; }"
                    ],
                    [
                        0.978517472743988,
                        "public void flush() throws IOException { if (out != null) { out.flush(); } }"
                    ],
                    [
                        0.9773443937301636,
                        "public void close() throws IOException { if (out != null) { OutputStream outShadow = this.out; finish(); outShadow.close(); } }"
                    ],
                    [
                        0.9738497734069824,
                        "public void close() throws IOException { if (!this.closed) { in.close(); this.closed = true; } }"
                    ],
                    [
                        0.9727141857147217,
                        "public void flush() throws IOException { OutputStream outShadow = this.out; if (outShadow != null) { outShadow.flush(); } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java",
                "start_loc": 124,
                "end_loc": 131,
                "buggy_function": "    public void close() throws IOException {\n        if (!closed) {\n            finish();\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n",
                "fixed_function": "    public void close() throws IOException {\n        if (!closed) {\n            buffer.close();\n            out.close();\n            closed = true;\n        }\n    }\n",
                "comment": "    /**\n     * Closes the underlying OutputStream.\n     * @throws IOException on error\n     */\n",
                "normalized_body": [
                    "public void close() throws IOException { if (!closed) { finish(); buffer.close(); out.close(); closed = true; } }"
                ],
                "top_similar_methods": [
                    [
                        0.9999998807907104,
                        "public void close() throws IOException { if (!closed) { finish(); buffer.close(); out.close(); closed = true; } }"
                    ],
                    [
                        0.991955041885376,
                        "public void close() throws IOException { if (!this.closed) { this.finish(); out.close(); this.closed = true; } }"
                    ],
                    [
                        0.9851043224334717,
                        "public void close() throws IOException { if (!closed) { closed = true; input.close(); } currentEntry = null; }"
                    ],
                    [
                        0.9832119941711426,
                        "public void close() throws IOException { finish(); if (raf != null) { raf.close(); } if (out != null) { out.close(); } }"
                    ],
                    [
                        0.978032648563385,
                        "public void close() throws IOException { if (!closed) { closed = true; in.close(); } }"
                    ],
                    [
                        0.9727784395217896,
                        "public void flush() throws IOException { if (out != null) { out.flush(); } }"
                    ],
                    [
                        0.9715719223022461,
                        "public void close() throws IOException { if (out != null) { OutputStream outShadow = this.out; finish(); outShadow.close(); } }"
                    ],
                    [
                        0.9692752361297607,
                        "public void close() throws IOException { if (!this.closed) { in.close(); this.closed = true; } }"
                    ],
                    [
                        0.9648422598838806,
                        "public ArchiveEntry getNextEntry() throws IOException { if (p >= filenames.length) { return null; } return new MemoryArchiveEntry(filenames[p]); }"
                    ]
                ],
                "non_directly_related_tests": [],
                "no_relatable_failing_tests": true
            },
            {
                "path": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java",
                "start_loc": 529,
                "end_loc": 537,
                "buggy_function": "    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n",
                "fixed_function": "    public void close() throws IOException {\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n",
                "comment": "    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n",
                "normalized_body": [
                    "public void close() throws IOException { finish(); if (raf != null) { raf.close(); } if (out != null) { out.close(); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public void close() throws IOException { finish(); if (raf != null) { raf.close(); } if (out != null) { out.close(); } }"
                    ],
                    [
                        0.9852461218833923,
                        "public void close() throws IOException { if (out != null) { OutputStream outShadow = this.out; finish(); outShadow.close(); } }"
                    ],
                    [
                        0.9837256669998169,
                        "public void close() throws IOException { if (!this.closed) { this.finish(); out.close(); this.closed = true; } }"
                    ],
                    [
                        0.983211874961853,
                        "public void close() throws IOException { if (!closed) { finish(); buffer.close(); out.close(); closed = true; } }"
                    ],
                    [
                        0.981446385383606,
                        "public void close() throws IOException { if (!closed) { closed = true; input.close(); } currentEntry = null; }"
                    ],
                    [
                        0.9798126220703125,
                        "public void close() throws IOException { if (!closed) { closed = true; in.close(); } }"
                    ],
                    [
                        0.9788526296615601,
                        "public int read() throws IOException { int num = read(SINGLE, 0, 1); return num == -1 ? -1 : SINGLE[0] & BYTE_MASK; }"
                    ],
                    [
                        0.9763557314872742,
                        "public void finish() throws IOException { if (haveUnclosedEntry) { throw new IOException(\\\"This archives contains unclosed entries.\\\"); } }"
                    ],
                    [
                        0.9752161502838135,
                        "public void flush() throws IOException { OutputStream outShadow = this.out; if (outShadow != null) { outShadow.flush(); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripImplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripImplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripExplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripExplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripImplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testZipArchiveInputStreamReadsUnicodeFields",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripExplicitUnicodeExtra",
                    "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSExplicitUnicodeExtra"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        finish();\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testJarMarker() throws IOException {\n        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n        JarArchiveOutputStream out = null;\n        ZipFile zf = null;\n        try {\n\n            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n            out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n            out.closeArchiveEntry();\n            out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n            out.closeArchiveEntry();\n            out.finish();\n            out.close();\n            out = null;\n\n            zf = new ZipFile(testArchive);\n            ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n            assertNotNull(ze);\n            ZipExtraField[] fes = ze.getExtraFields();\n            assertEquals(1, fes.length);\n            assertTrue(fes[0] instanceof JarMarker);\n\n            ze = zf.getEntry(\"bar/\");\n            assertNotNull(ze);\n            fes = ze.getExtraFields();\n            assertEquals(0, fes.length);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n            ZipFile.closeQuietly(zf);\n            if (testArchive.exists()) {\n                testArchive.delete();\n            }\n        }\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:158)  this(f, encoding, true);\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:119)  this(f, ZipEncodingHelper.UTF8);\n\tat org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest.testJarMarker(JarArchiveOutputStreamTest.java:48)  zf = new ZipFile(testArchive);\n \n#Test method 2:\n```java\n    public void testCP437FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, false);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:75)  testFileRoundtrip(CP437, false, false);\n \n#Test method 3:\n```java\n    public void testUtf8FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, false);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:65)  testFileRoundtrip(UTF_8, true, false);\n \n#Test method 4:\n```java\n    public void testCP437FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, true);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:55)  testFileRoundtrip(CP437, false, true);\n \n#Test method 5:\n```java\n    public void testUtf8FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, true);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:45)  testFileRoundtrip(UTF_8, true, true);\n \n#Test method 6:\n```java\n    public void testASCIIFileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, false);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:80)  testFileRoundtrip(US_ASCII, false, false);\n \n#Test method 7:\n```java\n    public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, false);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSImplicitUnicodeExtra(UTF8ZipFilesTest.java:70)  testFileRoundtrip(UTF_8, false, false);\n \n#Test method 8:\n```java\n    public void testZipArchiveInputStreamReadsUnicodeFields()\n        throws IOException {\n        File file = File.createTempFile(\"unicode-test\", \".zip\");\n        ZipFile zf = null;\n        try {\n            createTestFile(file, US_ASCII, false, true);\n            zf = new ZipFile(file, US_ASCII, true);\n            assertNotNull(zf.getEntry(ASCII_TXT));\n            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n            assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n        } finally {\n            ZipFile.closeQuietly(zf);\n            if (file.exists()) {\n                file.delete();\n            }\n        }\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testZipArchiveInputStreamReadsUnicodeFields(UTF8ZipFilesTest.java:183)  zf = new ZipFile(file, US_ASCII, true);\n \n#Test method 9:\n```java\n    public void testASCIIFileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, true);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:60)  testFileRoundtrip(US_ASCII, false, true);\n \n#Test method 10:\n```java\n    public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, true);\n    }\n```\n#Error message: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSExplicitUnicodeExtra(UTF8ZipFilesTest.java:50)  testFileRoundtrip(UTF_8, false, true);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n/**\n * Closes this output stream and releases any system resources\n * associated with the stream.\n *\n * @exception  IOException  if an I/O error occurs.\n */\npublic void close() throws IOException {\n    if (raf != null) {\n        raf.close();\n    }\n    if (out != null) {\n        out.finish(); // Ensure finish is called before closing `out`\n        out.close();\n    }\n}\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        try {\n            if (raf != null) {\n                raf.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        } finally {\n            finish();\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        if (out != null) {\n            try {\n                finish();\n            } catch (IOException e) {\n                out.close();\n                throw e;\n            }\n            out.close();\n        }\n        if (raf != null) {\n            raf.close();\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public void close() throws IOException {\n        if (raf != null) {\n            raf.close();\n            raf = null;\n        }\n        if (out != null) {\n            out.flush();\n            out.close();\n            out = null;\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        try {\n            finish();\n        } finally {\n            try {\n                if (raf != null) {\n                    raf.close();\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public void close() throws IOException {\n        if (out != null) {\n            finish();\n            out.close();\n        }\n        if (raf != null) {\n            raf.close();\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        if (out != null) {\n            try {\n                finish();\n            } catch (IOException e) {\n                // ensure raf is closed even if finish() fails\n                if (raf != null) {\n                    raf.close();\n                }\n                throw e;\n            }\n            out.close();\n        }\n        if (raf != null) {\n            raf.close();\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        if (raf != null) {\n            raf.close();\n        }\n        if (out != null) {\n            finish();\n            out.close();\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public void close() throws IOException {\n        try {\n            finish();\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } finally {\n                    if (raf != null) {\n                        raf.close();\n                    }\n                }\n            } else if (raf != null) {\n                raf.close();\n            }\n        }\n    }\n",
                            "\n    /**\n     * Closes this output stream and releases any system resources\n     * associated with the stream.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n\n    public void close() throws IOException {\n        try {\n            if (out != null) {\n                finish();\n                out.close();\n            }\n        } finally {\n            if (raf != null) {\n                raf.close();\n            }\n        }\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java",
                "start_loc": 67,
                "end_loc": 129,
                "buggy_function": "    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        return results;\n    }\n",
                "fixed_function": "    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        out.finish();\n        return results;\n    }\n",
                "comment": "    /**\n     * Performs all changes collected in this ChangeSet on the input stream and\n     * streams the result to the output stream. Perform may be called more than once.\n     * \n     * This method finishes the stream, no other entries should be added\n     * after that.\n     * \n     * @param in\n     *            the InputStream to perform the changes on\n     * @param out\n     *            the resulting OutputStream with all modifications\n     * @throws IOException\n     *             if an read/write error occurs\n     * @return the results of this operation\n     */\n",
                "normalized_body": [
                    "public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException { ChangeSetResults results = new ChangeSetResults(); Set workingSet = new LinkedHashSet(changes); for (Iterator it = workingSet.iterator(); it.hasNext(); ) { Change change = (Change) it.next(); if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) { copyStream(change.getInput(), out, change.getEntry()); it.remove(); results.addedFromChangeSet(change.getEntry().getName()); } } ArchiveEntry entry = null; while ((entry = in.getNextEntry()) != null) { boolean copy = true; for (Iterator it = workingSet.iterator(); it.hasNext(); ) { Change change = (Change) it.next(); final int type = change.type(); final String name = entry.getName(); if (type == Change.TYPE_DELETE && name != null) { if (name.equals(change.targetFile())) { copy = false; it.remove(); results.deleted(name); break; } } else if (type == Change.TYPE_DELETE_DIR && name != null) { if (name.startsWith(change.targetFile() + \\\"/\\\")) { copy = false; results.deleted(name); break; } } } if (copy) { if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) { copyStream(in, out, entry); results.addedFromStream(entry.getName()); } } } for (Iterator it = workingSet.iterator(); it.hasNext(); ) { Change change = (Change) it.next(); if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) { copyStream(change.getInput(), out, change.getEntry()); it.remove(); results.addedFromChangeSet(change.getEntry().getName()); } } return results; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out) throws IOException { ChangeSetResults results = new ChangeSetResults(); Set workingSet = new LinkedHashSet(changes); for (Iterator it = workingSet.iterator(); it.hasNext(); ) { Change change = (Change) it.next(); if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) { copyStream(change.getInput(), out, change.getEntry()); it.remove(); results.addedFromChangeSet(change.getEntry().getName()); } } ArchiveEntry entry = null; while ((entry = in.getNextEntry()) != null) { boolean copy = true; for (Iterator it = workingSet.iterator(); it.hasNext(); ) { Change change = (Change) it.next(); final int type = change.type(); final String name = entry.getName(); if (type == Change.TYPE_DELETE && name != null) { if (name.equals(change.targetFile())) { copy = false; it.remove(); results.deleted(name); break; } } else if (type == Change.TYPE_DELETE_DIR && name != null) { if (name.startsWith(change.targetFile() + \\\"/\\\")) { copy = false; results.deleted(name); break; } } } if (copy) { if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) { copyStream(in, out, entry); results.addedFromStream(entry.getName()); } } } for (Iterator it = workingSet.iterator(); it.hasNext(); ) { Change change = (Change) it.next(); if (change.type() == Change.TYPE_ADD && !change.isReplaceMode() && !results.hasBeenAdded(change.getEntry().getName())) { copyStream(change.getInput(), out, change.getEntry()); it.remove(); results.addedFromChangeSet(change.getEntry().getName()); } } return results; }"
                    ],
                    [
                        0.9871939420700073,
                        "private void compareReads(String archiverName) throws Exception { OutputStream out1 = new ByteArrayOutputStream(); OutputStream out2 = new ByteArrayOutputStream(); OutputStream out3 = new ByteArrayOutputStream(); File file = createSingleEntryArchive(archiverName); file.deleteOnExit(); InputStream is1 = new FileInputStream(file); ArchiveInputStream ais1 = factory.createArchiveInputStream(archiverName, is1); final ArchiveEntry nextEntry = ais1.getNextEntry(); assertNotNull(nextEntry); byte[] buff = new byte[10]; long size = nextEntry.getSize(); if (size != ArchiveEntry.SIZE_UNKNOWN) { assertTrue(\\\"Size should be > 0, found: \\\" + size, size > 0); } InputStream is2 = new FileInputStream(file); ArchiveInputStream ais2 = factory.createArchiveInputStream(archiverName, is2); final ArchiveEntry nextEntry2 = ais2.getNextEntry(); assertNotNull(nextEntry2); assertEquals(\\\"Expected same entry size\\\", size, nextEntry2.getSize()); InputStream is3 = new FileInputStream(file); ArchiveInputStream ais3 = factory.createArchiveInputStream(archiverName, is3); final ArchiveEntry nextEntry3 = ais3.getNextEntry(); assertNotNull(nextEntry3); assertEquals(\\\"Expected same entry size\\\", size, nextEntry3.getSize()); int b; while ((b = ais1.read()) != -1) { out1.write(b); } ais1.close(); int bytes; while ((bytes = ais2.read(buff)) > 0) { out2.write(buff, 0, bytes); } ais2.close(); while ((bytes = ais3.read(buff, 0, buff.length)) > 0) { out3.write(buff, 0, bytes); } ais3.close(); assertEquals(\\\"out1!=out2\\\", out1.toString(), out2.toString()); assertEquals(\\\"out1!=out3\\\", out1.toString(), out3.toString()); }"
                    ],
                    [
                        0.9871097803115845,
                        "public void testZipArchiveCreation() throws Exception { final File output = new File(dir, \\\"bla.zip\\\"); final File file1 = getFile(\\\"test1.xml\\\"); final File file2 = getFile(\\\"test2.xml\\\"); final OutputStream out = new FileOutputStream(output); ArchiveOutputStream os = null; try { os = new ArchiveStreamFactory().createArchiveOutputStream(\\\"zip\\\", out); os.putArchiveEntry(new ZipArchiveEntry(\\\"testdata/test1.xml\\\")); IOUtils.copy(new FileInputStream(file1), os); os.closeArchiveEntry(); os.putArchiveEntry(new ZipArchiveEntry(\\\"testdata/test2.xml\\\")); IOUtils.copy(new FileInputStream(file2), os); os.closeArchiveEntry(); } finally { if (os != null) { os.close(); } } out.close(); List results = new ArrayList(); final InputStream is = new FileInputStream(output); ArchiveInputStream in = null; try { in = new ArchiveStreamFactory().createArchiveInputStream(\\\"zip\\\", is); ZipArchiveEntry entry = null; while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) { File outfile = new File(resultDir.getCanonicalPath() + \\\"/result/\\\" + entry.getName()); outfile.getParentFile().mkdirs(); OutputStream o = new FileOutputStream(outfile); try { IOUtils.copy(in, o); } finally { o.close(); } results.add(outfile); } } finally { if (in != null) { in.close(); } } is.close(); assertEquals(results.size(), 2); File result = (File) results.get(0); assertEquals(file1.length(), result.length()); result = (File) results.get(1); assertEquals(file2.length(), result.length()); }"
                    ],
                    [
                        0.9844734072685242,
                        "public void testDeletePlusAddSame() throws Exception { final String archivename = \\\"zip\\\"; File input = this.createArchive(archivename); ArchiveOutputStream out = null; ArchiveInputStream ais = null; File result = File.createTempFile(\\\"test\\\", \\\".\\\" + archivename); result.deleteOnExit(); File testtxt = null; try { final InputStream is = new FileInputStream(input); ais = factory.createArchiveInputStream(archivename, is); out = factory.createArchiveOutputStream(archivename, new FileOutputStream(result)); ChangeSet changes = new ChangeSet(); changes.delete(\\\"test/test3.xml\\\"); archiveListDelete(\\\"test/test3.xml\\\"); testtxt = getFile(\\\"test.txt\\\"); ArchiveEntry entry = out.createArchiveEntry(testtxt, \\\"test/test3.xml\\\"); changes.add(entry, new FileInputStream(testtxt)); archiveList.add(\\\"test/test3.xml\\\"); ChangeSetPerformer performer = new ChangeSetPerformer(changes); performer.perform(ais, out); is.close(); } finally { if (out != null) out.close(); if (ais != null) ais.close(); } ArchiveInputStream in = null; File check = null; try { final InputStream is = new FileInputStream(result); final BufferedInputStream buf = new BufferedInputStream(is); in = factory.createArchiveInputStream(buf); check = this.checkArchiveContent(in, archiveList, false); File test3xml = new File(check, \\\"result/test/test3.xml\\\"); assertEquals(testtxt.length(), test3xml.length()); BufferedReader reader = new BufferedReader(new FileReader(test3xml)); String str; while ((str = reader.readLine()) != null) { \\\"111111111111111111111111111000101011\\\".equals(str); } } finally { in.close(); rmdir(check); } }"
                    ],
                    [
                        0.9811601042747498,
                        "public void closeArchiveEntry() throws IOException { if (entry == null) { return; } long realCrc = crc.getValue(); crc.reset(); if (entry.getMethod() == DEFLATED) { def.finish(); while (!def.finished()) { deflate(); } entry.setSize(ZipUtil.adjustToLong(def.getTotalIn())); entry.setCompressedSize(ZipUtil.adjustToLong(def.getTotalOut())); entry.setCrc(realCrc); def.reset(); written += entry.getCompressedSize(); } else if (raf == null) { if (entry.getCrc() != realCrc) { throw new ZipException(\\\"bad CRC checksum for entry \\\" + entry.getName() + \\\": \\\" + Long.toHexString(entry.getCrc()) + \\\" instead of \\\" + Long.toHexString(realCrc)); } if (entry.getSize() != written - dataStart) { throw new ZipException(\\\"bad size for entry \\\" + entry.getName() + \\\": \\\" + entry.getSize() + \\\" instead of \\\" + (written - dataStart)); } } else { long size = written - dataStart; entry.setSize(size); entry.setCompressedSize(size); entry.setCrc(realCrc); } if (raf != null) { long save = raf.getFilePointer(); raf.seek(localDataStart); writeOut(ZipLong.getBytes(entry.getCrc())); writeOut(ZipLong.getBytes(entry.getCompressedSize())); writeOut(ZipLong.getBytes(entry.getSize())); raf.seek(save); } writeDataDescriptor(entry); entry = null; }"
                    ],
                    [
                        0.9808635711669922,
                        "public CpioArchiveEntry getNextCPIOEntry() throws IOException { ensureOpen(); if (this.entry != null) { closeEntry(); } byte[] magic = new byte[2]; readFully(magic, 0, magic.length); if (CpioUtil.byteArray2long(magic, false) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(false); } else if (CpioUtil.byteArray2long(magic, true) == MAGIC_OLD_BINARY) { this.entry = readOldBinaryEntry(true); } else { byte[] more_magic = new byte[4]; readFully(more_magic, 0, more_magic.length); byte[] tmp = new byte[6]; System.arraycopy(magic, 0, tmp, 0, magic.length); System.arraycopy(more_magic, 0, tmp, magic.length, more_magic.length); String magicString = ArchiveUtils.toAsciiString(tmp); if (magicString.equals(MAGIC_NEW)) { this.entry = readNewEntry(false); } else if (magicString.equals(MAGIC_NEW_CRC)) { this.entry = readNewEntry(true); } else if (magicString.equals(MAGIC_OLD_ASCII)) { this.entry = readOldAsciiEntry(); } else { throw new IOException(\\\"Unknown magic [\\\" + magicString + \\\"]. Occured at byte: \\\" + getCount()); } } this.entryBytesRead = 0; this.entryEOF = false; this.crc = 0; if (this.entry.getName().equals(CPIO_TRAILER)) { this.entryEOF = true; return null; } return this.entry; }"
                    ],
                    [
                        0.9793906211853027,
                        "private void getAndMoveToFrontDecode() throws IOException { this.origPtr = bsR(24); recvDecodingTables(); final InputStream inShadow = this.in; final Data dataShadow = this.data; final byte[] ll8 = dataShadow.ll8; final int[] unzftab = dataShadow.unzftab; final byte[] selector = dataShadow.selector; final byte[] seqToUnseq = dataShadow.seqToUnseq; final char[] yy = dataShadow.getAndMoveToFrontDecode_yy; final int[] minLens = dataShadow.minLens; final int[][] limit = dataShadow.limit; final int[][] base = dataShadow.base; final int[][] perm = dataShadow.perm; final int limitLast = this.blockSize100k * 100000; for (int i = 256; --i >= 0; ) { yy[i] = (char) i; unzftab[i] = 0; } int groupNo = 0; int groupPos = G_SIZE - 1; final int eob = this.nInUse + 1; int nextSym = getAndMoveToFrontDecode0(0); int bsBuffShadow = this.bsBuff; int bsLiveShadow = this.bsLive; int lastShadow = -1; int zt = selector[groupNo] & 0xff; int[] base_zt = base[zt]; int[] limit_zt = limit[zt]; int[] perm_zt = perm[zt]; int minLens_zt = minLens[zt]; while (nextSym != eob) { if ((nextSym == RUNA) || (nextSym == RUNB)) { int s = -1; for (int n = 1; true; n <<= 1) { if (nextSym == RUNA) { s += n; } else if (nextSym == RUNB) { s += n << 1; } else { break; } if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\\\"unexpected end of stream\\\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\\\"unexpected end of stream\\\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } final byte ch = seqToUnseq[yy[0]]; unzftab[ch & 0xff] += s + 1; while (s-- >= 0) { ll8[++lastShadow] = ch; } if (lastShadow >= limitLast) { throw new IOException(\\\"block overrun\\\"); } } else { if (++lastShadow >= limitLast) { throw new IOException(\\\"block overrun\\\"); } final char tmp = yy[nextSym - 1]; unzftab[seqToUnseq[tmp] & 0xff]++; ll8[lastShadow] = seqToUnseq[tmp]; if (nextSym <= 16) { for (int j = nextSym - 1; j > 0; ) { yy[j] = yy[--j]; } } else { System.arraycopy(yy, 0, yy, 1, nextSym - 1); } yy[0] = tmp; if (groupPos == 0) { groupPos = G_SIZE - 1; zt = selector[++groupNo] & 0xff; base_zt = base[zt]; limit_zt = limit[zt]; perm_zt = perm[zt]; minLens_zt = minLens[zt]; } else { groupPos--; } int zn = minLens_zt; while (bsLiveShadow < zn) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\\\"unexpected end of stream\\\"); } } int zvec = (bsBuffShadow >> (bsLiveShadow - zn)) & ((1 << zn) - 1); bsLiveShadow -= zn; while (zvec > limit_zt[zn]) { zn++; while (bsLiveShadow < 1) { final int thech = inShadow.read(); if (thech >= 0) { bsBuffShadow = (bsBuffShadow << 8) | thech; bsLiveShadow += 8; continue; } else { throw new IOException(\\\"unexpected end of stream\\\"); } } bsLiveShadow--; zvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1); } nextSym = perm_zt[zvec - base_zt[zn]]; } } this.last = lastShadow; this.bsLive = bsLiveShadow; this.bsBuff = bsBuffShadow; }"
                    ],
                    [
                        0.9780137538909912,
                        "protected void writeCentralFileHeader(ZipArchiveEntry ze) throws IOException { writeOut(CFH_SIG); written += WORD; writeOut(ZipShort.getBytes((ze.getPlatform() << 8) | 20)); written += SHORT; final int zipMethod = ze.getMethod(); final boolean encodable = zipEncoding.canEncode(ze.getName()); writeVersionNeededToExtractAndGeneralPurposeBits(zipMethod, !encodable && fallbackToUTF8); written += WORD; writeOut(ZipShort.getBytes(zipMethod)); written += SHORT; writeOut(ZipUtil.toDosTime(ze.getTime())); written += WORD; writeOut(ZipLong.getBytes(ze.getCrc())); writeOut(ZipLong.getBytes(ze.getCompressedSize())); writeOut(ZipLong.getBytes(ze.getSize())); written += 12; final ZipEncoding entryEncoding; if (!encodable && fallbackToUTF8) { entryEncoding = ZipEncodingHelper.UTF8_ZIP_ENCODING; } else { entryEncoding = zipEncoding; } ByteBuffer name = entryEncoding.encode(ze.getName()); writeOut(ZipShort.getBytes(name.limit())); written += SHORT; byte[] extra = ze.getCentralDirectoryExtra(); writeOut(ZipShort.getBytes(extra.length)); written += SHORT; String comm = ze.getComment(); if (comm == null) { comm = \\\"\\\"; } ByteBuffer commentB = entryEncoding.encode(comm); writeOut(ZipShort.getBytes(commentB.limit())); written += SHORT; writeOut(ZERO); written += SHORT; writeOut(ZipShort.getBytes(ze.getInternalAttributes())); written += SHORT; writeOut(ZipLong.getBytes(ze.getExternalAttributes())); written += WORD; writeOut((byte[]) offsets.get(ze)); written += WORD; writeOut(name.array(), name.arrayOffset(), name.limit()); written += name.limit(); writeOut(extra); written += extra.length; writeOut(commentB.array(), commentB.arrayOffset(), commentB.limit()); written += commentB.limit(); }"
                    ],
                    [
                        0.9768352508544922,
                        "public void testExtraFields() { AsiExtraField a = new AsiExtraField(); a.setDirectory(true); a.setMode(0755); UnrecognizedExtraField u = new UnrecognizedExtraField(); u.setHeaderId(new ZipShort(1)); u.setLocalFileDataData(new byte[0]); ZipArchiveEntry ze = new ZipArchiveEntry(\\\"test/\\\"); ze.setExtraFields(new ZipExtraField[] { a, u }); byte[] data1 = ze.getExtra(); ZipExtraField[] result = ze.getExtraFields(); assertEquals(\\\"first pass\\\", 2, result.length); assertSame(a, result[0]); assertSame(u, result[1]); UnrecognizedExtraField u2 = new UnrecognizedExtraField(); u2.setHeaderId(new ZipShort(1)); u2.setLocalFileDataData(new byte[] { 1 }); ze.addExtraField(u2); byte[] data2 = ze.getExtra(); result = ze.getExtraFields(); assertEquals(\\\"second pass\\\", 2, result.length); assertSame(a, result[0]); assertSame(u2, result[1]); assertEquals(\\\"length second pass\\\", data1.length + 1, data2.length); UnrecognizedExtraField u3 = new UnrecognizedExtraField(); u3.setHeaderId(new ZipShort(2)); u3.setLocalFileDataData(new byte[] { 1 }); ze.addExtraField(u3); result = ze.getExtraFields(); assertEquals(\\\"third pass\\\", 3, result.length); ze.removeExtraField(new ZipShort(1)); byte[] data3 = ze.getExtra(); result = ze.getExtraFields(); assertEquals(\\\"fourth pass\\\", 2, result.length); assertSame(a, result[0]); assertSame(u3, result[1]); assertEquals(\\\"length fourth pass\\\", data2.length, data3.length); try { ze.removeExtraField(new ZipShort(1)); fail(\\\"should be no such element\\\"); } catch (java.util.NoSuchElementException nse) { } }"
                    ]
                ],
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    /**\n     * Performs all changes collected in this ChangeSet on the input stream and\n     * streams the result to the output stream. Perform may be called more than once.\n     * \n     * This method finishes the stream, no other entries should be added\n     * after that.\n     * \n     * @param in\n     *            the InputStream to perform the changes on\n     * @param out\n     *            the resulting OutputStream with all modifications\n     * @throws IOException\n     *             if an read/write error occurs\n     * @return the results of this operation\n     */\n\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        return results;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testJarMarker() throws IOException {\n        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n        JarArchiveOutputStream out = null;\n        ZipFile zf = null;\n        try {\n\n            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n            out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n            out.closeArchiveEntry();\n            out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n            out.closeArchiveEntry();\n            out.finish();\n            out.close();\n            out = null;\n\n            zf = new ZipFile(testArchive);\n            ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n            assertNotNull(ze);\n            ZipExtraField[] fes = ze.getExtraFields();\n            assertEquals(1, fes.length);\n            assertTrue(fes[0] instanceof JarMarker);\n\n            ze = zf.getEntry(\"bar/\");\n            assertNotNull(ze);\n            fes = ze.getExtraFields();\n            assertEquals(0, fes.length);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n            ZipFile.closeQuietly(zf);\n            if (testArchive.exists()) {\n                testArchive.delete();\n            }\n        }\n    }\n```\n#Error message from the test method 1: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 2:\n```java\n    public void testCP437FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, false);\n    }\n```\n#Error message from the test method 2: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 3:\n```java\n    public void testUtf8FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, false);\n    }\n```\n#Error message from the test method 3: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 4:\n```java\n    public void testCP437FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, true);\n    }\n```\n#Error message from the test method 4: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 5:\n```java\n    public void testUtf8FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, true);\n    }\n```\n#Error message from the test method 5: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 6:\n```java\n    public void testASCIIFileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, false);\n    }\n```\n#Error message from the test method 6: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 7:\n```java\n    public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, false);\n    }\n```\n#Error message from the test method 7: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 8:\n```java\n    public void testZipArchiveInputStreamReadsUnicodeFields()\n        throws IOException {\n        File file = File.createTempFile(\"unicode-test\", \".zip\");\n        ZipFile zf = null;\n        try {\n            createTestFile(file, US_ASCII, false, true);\n            zf = new ZipFile(file, US_ASCII, true);\n            assertNotNull(zf.getEntry(ASCII_TXT));\n            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n            assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n        } finally {\n            ZipFile.closeQuietly(zf);\n            if (file.exists()) {\n                file.delete();\n            }\n        }\n    }\n```\n#Error message from the test method 8: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 9:\n```java\n    public void testASCIIFileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, true);\n    }\n```\n#Error message from the test method 9: java.io.IOException: central directory is empty, can't expand corrupt archive.\n \n#Test method 10:\n```java\n    public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, true);\n    }\n```\n#Error message from the test method 10: java.io.IOException: central directory is empty, can't expand corrupt archive.\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        \n        out.finish(); // Ensure the output stream is properly finished\n        out.close();  // Close the output stream after finishing\n        \n        return results;\n    }\n",
                            "\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n        throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n    \n    Set workingSet = new LinkedHashSet(changes);\n    \n    for (Iterator it = workingSet.iterator(); it.hasNext();) {\n        Change change = (Change) it.next();\n\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n\n    // Adds files which hasn't been added from the original and do not have replace mode on\n    for (Iterator it = workingSet.iterator(); it.hasNext();) {\n        Change change = (Change) it.next();\n\n        if (change.type() == Change.TYPE_ADD && \n            !change.isReplaceMode() && \n            !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    out.finish(); // Ensure the output stream is properly finished to write all necessary data\n    return results;\n}\n",
                            "\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which hasn't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n        \n        out.finish(); // Ensures the central directory is written\n        return results;\n    }\n",
                            "\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n        throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n    \n    Set<Change> workingSet = new LinkedHashSet<>(changes);\n    \n    for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n        Change change = it.next();\n\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n\n        for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n            Change change = it.next();\n\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n    \n    for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n        Change change = it.next();\n\n        if (change.type() == Change.TYPE_ADD && \n            !change.isReplaceMode() && \n            !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    out.finish();\n    return results;\n}\n",
                            "\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which haven't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        // Finish the output stream to ensure the central directory is written\n        out.finish();\n        \n        return results;\n    }\n",
                            "\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Adds files which haven't been added from the original and do not have replace mode on\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        out.finish(); // Ensure the output stream is properly finished\n        return results;\n    }\n",
                            "\n    public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n            throws IOException {\n        ChangeSetResults results = new ChangeSetResults();\n        \n        Set workingSet = new LinkedHashSet(changes);\n        \n        // Add phase\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            boolean copy = true;\n\n            // Delete phase\n            for (Iterator it = workingSet.iterator(); it.hasNext();) {\n                Change change = (Change) it.next();\n\n                final int type = change.type();\n                final String name = entry.getName();\n                if (type == Change.TYPE_DELETE && name != null) {\n                    if (name.equals(change.targetFile())) {\n                        copy = false;\n                        it.remove();\n                        results.deleted(name);\n                        break;\n                    }\n                } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                    if (name.startsWith(change.targetFile() + \"/\")) {\n                        copy = false;\n                        results.deleted(name);\n                        break;\n                    }\n                }\n            }\n\n            // Copy/Maintain phase\n            if (copy) {\n                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                    copyStream(in, out, entry);\n                    results.addedFromStream(entry.getName());\n                }\n            }\n        }\n        \n        // Final Add phase\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            if (change.type() == Change.TYPE_ADD && \n                !change.isReplaceMode() && \n                !results.hasBeenAdded(change.getEntry().getName())) {\n                copyStream(change.getInput(), out, change.getEntry());\n                it.remove();\n                results.addedFromChangeSet(change.getEntry().getName());\n            }\n        }\n\n        out.finish();\n        \n        return results;\n    }\n",
                            "\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n        throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n\n    Set workingSet = new LinkedHashSet(changes);\n\n    for (Iterator it = workingSet.iterator(); it.hasNext();) {\n        Change change = (Change) it.next();\n\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n\n    // Adds files which haven't been added from the original and do not have replace mode on\n    for (Iterator it = workingSet.iterator(); it.hasNext();) {\n        Change change = (Change) it.next();\n\n        if (change.type() == Change.TYPE_ADD && \n            !change.isReplaceMode() && \n            !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n    \n    out.finish(); // Ensure the central directory is written\n    return results;\n}\n",
                            "\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n        throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n    \n    Set<Change> workingSet = new LinkedHashSet<>(changes);\n    \n    for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n        Change change = it.next();\n\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n\n        for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n            Change change = it.next();\n\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if(type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n    \n    // Adds files which haven't been added from the original and do not have replace mode on\n    for (Iterator<Change> it = workingSet.iterator(); it.hasNext();) {\n        Change change = it.next();\n\n        if (change.type() == Change.TYPE_ADD && \n            !change.isReplaceMode() && \n            !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    out.finish(); // Make sure to finish the output stream to correctly write the central directory\n\n    return results;\n}\n",
                            "\npublic ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)\n        throws IOException {\n    ChangeSetResults results = new ChangeSetResults();\n\n    Set workingSet = new LinkedHashSet(changes);\n\n    for (Iterator it = workingSet.iterator(); it.hasNext();) {\n        Change change = (Change) it.next();\n\n        if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {\n            copyStream(change.getInput(), out, change.getEntry());\n            it.remove();\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    ArchiveEntry entry = null;\n    while ((entry = in.getNextEntry()) != null) {\n        boolean copy = true;\n\n        for (Iterator it = workingSet.iterator(); it.hasNext();) {\n            Change change = (Change) it.next();\n\n            final int type = change.type();\n            final String name = entry.getName();\n            if (type == Change.TYPE_DELETE && name != null) {\n                if (name.equals(change.targetFile())) {\n                    copy = false;\n                    it.remove();\n                    results.deleted(name);\n                    break;\n                }\n            } else if (type == Change.TYPE_DELETE_DIR && name != null) {\n                if (name.startsWith(change.targetFile() + \"/\")) {\n                    copy = false;\n                    results.deleted(name);\n                    break;\n                }\n            }\n        }\n\n        if (copy) {\n            if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {\n                copyStream(in, out, entry);\n                results.addedFromStream(entry.getName());\n            }\n        }\n    }\n\n    for (Iterator it = workingSet.iterator(); it.hasNext();) {\n        Change change = (Change) it.next();\n\n        if (change.type() == Change.TYPE_ADD &&\n            !change.isReplaceMode() &&\n            !results.hasBeenAdded(change.getEntry().getName())) {\n            copyStream(change.getInput(), out, change.getEntry());\n            results.addedFromChangeSet(change.getEntry().getName());\n        }\n    }\n\n    out.finish();\n    return results;\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker": {
                "path": "src/test/java/org/apache/commons/compress/archivers/jar/JarArchiveOutputStreamTest.java",
                "function_name": "testJarMarker",
                "src": "    public void testJarMarker() throws IOException {\n        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n        JarArchiveOutputStream out = null;\n        ZipFile zf = null;\n        try {\n\n            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n            out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n            out.closeArchiveEntry();\n            out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n            out.closeArchiveEntry();\n            out.finish();\n            out.close();\n            out = null;\n\n            zf = new ZipFile(testArchive);\n            ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n            assertNotNull(ze);\n            ZipExtraField[] fes = ze.getExtraFields();\n            assertEquals(1, fes.length);\n            assertTrue(fes[0] instanceof JarMarker);\n\n            ze = zf.getEntry(\"bar/\");\n            assertNotNull(ze);\n            fes = ze.getExtraFields();\n            assertEquals(0, fes.length);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n            ZipFile.closeQuietly(zf);\n            if (testArchive.exists()) {\n                testArchive.delete();\n            }\n        }\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:158)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:119)\n\tat org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest.testJarMarker(JarArchiveOutputStreamTest.java:48)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:158)  this(f, encoding, true);\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:119)  this(f, ZipEncodingHelper.UTF8);\n\tat org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest.testJarMarker(JarArchiveOutputStreamTest.java:48)  zf = new ZipFile(testArchive);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripImplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testCP437FileRoundtripImplicitUnicodeExtra",
                "src": "    public void testCP437FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, false);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:75)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:75)  testFileRoundtrip(CP437, false, false);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripImplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testUtf8FileRoundtripImplicitUnicodeExtra",
                "src": "    public void testUtf8FileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, false);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:65)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:65)  testFileRoundtrip(UTF_8, true, false);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testCP437FileRoundtripExplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testCP437FileRoundtripExplicitUnicodeExtra",
                "src": "    public void testCP437FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(CP437, false, true);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:55)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testCP437FileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:55)  testFileRoundtrip(CP437, false, true);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripExplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testUtf8FileRoundtripExplicitUnicodeExtra",
                "src": "    public void testUtf8FileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, true, true);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:45)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:45)  testFileRoundtrip(UTF_8, true, true);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripImplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testASCIIFileRoundtripImplicitUnicodeExtra",
                "src": "    public void testASCIIFileRoundtripImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, false);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:80)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripImplicitUnicodeExtra(UTF8ZipFilesTest.java:80)  testFileRoundtrip(US_ASCII, false, false);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSImplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testUtf8FileRoundtripNoEFSImplicitUnicodeExtra",
                "src": "    public void testUtf8FileRoundtripNoEFSImplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, false);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSImplicitUnicodeExtra(UTF8ZipFilesTest.java:70)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSImplicitUnicodeExtra(UTF8ZipFilesTest.java:70)  testFileRoundtrip(UTF_8, false, false);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testZipArchiveInputStreamReadsUnicodeFields": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testZipArchiveInputStreamReadsUnicodeFields",
                "src": "    public void testZipArchiveInputStreamReadsUnicodeFields()\n        throws IOException {\n        File file = File.createTempFile(\"unicode-test\", \".zip\");\n        ZipFile zf = null;\n        try {\n            createTestFile(file, US_ASCII, false, true);\n            zf = new ZipFile(file, US_ASCII, true);\n            assertNotNull(zf.getEntry(ASCII_TXT));\n            assertNotNull(zf.getEntry(EURO_FOR_DOLLAR_TXT));\n            assertNotNull(zf.getEntry(OIL_BARREL_TXT));\n        } finally {\n            ZipFile.closeQuietly(zf);\n            if (file.exists()) {\n                file.delete();\n            }\n        }\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testZipArchiveInputStreamReadsUnicodeFields(UTF8ZipFilesTest.java:183)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testZipArchiveInputStreamReadsUnicodeFields(UTF8ZipFilesTest.java:183)  zf = new ZipFile(file, US_ASCII, true);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testASCIIFileRoundtripExplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testASCIIFileRoundtripExplicitUnicodeExtra",
                "src": "    public void testASCIIFileRoundtripExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(US_ASCII, false, true);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:60)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testASCIIFileRoundtripExplicitUnicodeExtra(UTF8ZipFilesTest.java:60)  testFileRoundtrip(US_ASCII, false, true);"
            },
            "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testUtf8FileRoundtripNoEFSExplicitUnicodeExtra": {
                "path": "src/test/java/org/apache/commons/compress/archivers/zip/UTF8ZipFilesTest.java",
                "function_name": "testUtf8FileRoundtripNoEFSExplicitUnicodeExtra",
                "src": "    public void testUtf8FileRoundtripNoEFSExplicitUnicodeExtra()\n        throws IOException {\n        testFileRoundtrip(UTF_8, false, true);\n    }",
                "error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSExplicitUnicodeExtra(UTF8ZipFilesTest.java:50)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)  throw new IOException(\"central directory is empty, can't expand\"                                  + \" corrupt archive.\");\n\tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)  Map entriesWithoutEFS = populateFromCentralDirectory();\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFile(UTF8ZipFilesTest.java:291)  zf = new ZipFile(file, encoding, false);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testFileRoundtrip(UTF8ZipFilesTest.java:202)  testFile(file, encoding);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testUtf8FileRoundtripNoEFSExplicitUnicodeExtra(UTF8ZipFilesTest.java:50)  testFileRoundtrip(UTF_8, false, true);"
            }
        },
        "evaluation_done": true
    }
}