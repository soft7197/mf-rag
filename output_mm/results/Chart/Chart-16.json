{
    "Chart-16": {
        "function_num": 2,
        "functions": [
            {
                "path": "source/org/jfree/data/category/DefaultIntervalCategoryDataset.java",
                "start_loc": 142,
                "end_loc": 212,
                "buggy_function": "    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = null;\n                this.categoryKeys = null;\n            }\n        }\n\n    }\n",
                "fixed_function": "    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        }\n\n    }\n",
                "comment": "    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series and the\n     * supplied objects for the categories.\n     *\n     * @param seriesKeys  the series keys (if <code>null</code>, series keys\n     *         will be generated automatically).\n     * @param categoryKeys  the category keys (if <code>null</code>, category \n     *         keys will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n",
                "normalized_body": [
                    "    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = null;\n                this.categoryKeys = null;\n            }\n        }\n\n    }\n"
                ],
                "top_similar_methods": [
                    [
                        0.9375028610229492,
                        "protected void drawPrimaryLineAsPath(XYItemRendererState state, Graphics2D g2, XYPlot plot, XYDataset dataset, int pass, int series, int item, ValueAxis domainAxis, ValueAxis rangeAxis, Rectangle2D dataArea) { RectangleEdge xAxisLocation = plot.getDomainAxisEdge(); RectangleEdge yAxisLocation = plot.getRangeAxisEdge(); double x1 = dataset.getXValue(series, item); double y1 = dataset.getYValue(series, item); double transX1 = domainAxis.valueToJava2D(x1, dataArea, xAxisLocation); double transY1 = rangeAxis.valueToJava2D(y1, dataArea, yAxisLocation); if (!Double.isNaN(transX1) && !Double.isNaN(transY1)) { ControlPoint p = new ControlPoint(plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transY1 : (float) transX1, plot.getOrientation() == PlotOrientation.HORIZONTAL ? (float) transX1 : (float) transY1); if (!this.points.contains(p)) this.points.add(p); } if (item == dataset.getItemCount(series) - 1) { State s = (State) state; if (this.points.size() > 1) { ControlPoint cp0 = (ControlPoint) this.points.get(0); s.seriesPath.moveTo(cp0.x, cp0.y); if (this.points.size() == 2) { ControlPoint cp1 = (ControlPoint) this.points.get(1); s.seriesPath.lineTo(cp1.x, cp1.y); } else { int np = this.points.size(); float[] d = new float[np]; float[] x = new float[np]; float y; float t; float oldy = 0; float oldt = 0; float[] a = new float[np]; float t1; float t2; float[] h = new float[np]; for (int i = 0; i < np; i++) { ControlPoint cpi = (ControlPoint) this.points.get(i); x[i] = cpi.x; d[i] = cpi.y; } for (int i = 1; i <= np - 1; i++) { h[i] = x[i] - x[i - 1]; } float[] sub = new float[np - 1]; float[] diag = new float[np - 1]; float[] sup = new float[np - 1]; for (int i = 1; i <= np - 2; i++) { diag[i] = (h[i] + h[i + 1]) / 3; sup[i] = h[i + 1] / 6; sub[i] = h[i] / 6; a[i] = (d[i + 1] - d[i]) / h[i + 1] - (d[i] - d[i - 1]) / h[i]; } solveTridiag(sub, diag, sup, a, np - 2); oldt = x[0]; oldy = d[0]; s.seriesPath.moveTo(oldt, oldy); for (int i = 1; i <= np - 1; i++) { for (int j = 1; j <= this.precision; j++) { t1 = (h[i] * j) / this.precision; t2 = h[i] - t1; y = ((-a[i - 1] / 6 * (t2 + h[i]) * t1 + d[i - 1]) * t2 + (-a[i] / 6 * (t1 + h[i]) * t2 + d[i]) * t1) / h[i]; t = x[i - 1] + t1; s.seriesPath.lineTo(t, y); oldt = t; oldy = y; } } } drawFirstPassShape(g2, pass, series, item, s.seriesPath); } this.points = new Vector(); } }"
                    ],
                    [
                        0.9312457889318466,
                        "protected void drawHorizontalItem(Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset, int row, int column) { Number dataValue = dataset.getValue(row, column); if (dataValue == null) { return; } double value = dataValue.doubleValue(); double base = 0.0; double lclip = getLowerClip(); double uclip = getUpperClip(); if (uclip <= 0.0) { if (value >= uclip) { return; } base = uclip; if (value <= lclip) { value = lclip; } } else if (lclip <= 0.0) { if (value >= uclip) { value = uclip; } else { if (value <= lclip) { value = lclip; } } } else { if (value <= lclip) { return; } base = lclip; if (value >= uclip) { value = uclip; } } RectangleEdge edge = plot.getRangeAxisEdge(); double transX1 = rangeAxis.valueToJava2D(base, dataArea, edge); double transX2 = rangeAxis.valueToJava2D(value, dataArea, edge); double rectX = Math.min(transX1, transX2); double rectWidth = Math.abs(transX2 - transX1); double rectY = domainAxis.getCategoryMiddle(column, getColumnCount(), dataArea, plot.getDomainAxisEdge()) - state.getBarWidth() / 2.0; int seriesCount = getRowCount(); double shift = 0.0; double rectHeight = 0.0; double widthFactor = 1.0; double seriesBarWidth = getSeriesBarWidth(row); if (!Double.isNaN(seriesBarWidth)) { widthFactor = seriesBarWidth; } rectHeight = widthFactor * state.getBarWidth(); rectY = rectY + (1 - widthFactor) * state.getBarWidth() / 2.0; if (seriesCount > 1) { shift = rectHeight * 0.20 / (seriesCount - 1); } Rectangle2D bar = new Rectangle2D.Double(rectX, (rectY + ((seriesCount - 1 - row) * shift)), rectWidth, (rectHeight - (seriesCount - 1 - row) * shift * 2)); Paint itemPaint = getItemPaint(row, column); GradientPaintTransformer t = getGradientPaintTransformer(); if (t != null && itemPaint instanceof GradientPaint) { itemPaint = t.transform((GradientPaint) itemPaint, bar); } g2.setPaint(itemPaint); g2.fill(bar); if (isDrawBarOutline() && state.getBarWidth() > BAR_OUTLINE_WIDTH_THRESHOLD) { Stroke stroke = getItemOutlineStroke(row, column); Paint paint = getItemOutlinePaint(row, column); if (stroke != null && paint != null) { g2.setStroke(stroke); g2.setPaint(paint); g2.draw(bar); } } CategoryItemLabelGenerator generator = getItemLabelGenerator(row, column); if (generator != null && isItemLabelVisible(row, column)) { drawItemLabel(g2, dataset, row, column, plot, generator, bar, (transX1 > transX2)); } EntityCollection entities = state.getEntityCollection(); if (entities != null) { addItemEntity(entities, dataset, row, column, bar); } }"
                    ],
                    [
                        0.9310473650693893,
                        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) { int outerRadius = 0; int innerRadius = 0; int x1, y1, x2, y2; double a; if (info != null) { info.setPlotArea(area); } RectangleInsets insets = getInsets(); insets.trim(area); if (this.drawBorder) { drawBackground(g2, area); } int midX = (int) (area.getWidth() / 2); int midY = (int) (area.getHeight() / 2); int radius = midX; if (midY < midX) { radius = midY; } --radius; int diameter = 2 * radius; midX += (int) area.getMinX(); midY += (int) area.getMinY(); this.circle1.setFrame(midX - radius, midY - radius, diameter, diameter); this.circle2.setFrame(midX - radius + 15, midY - radius + 15, diameter - 30, diameter - 30); g2.setPaint(this.rosePaint); this.a1 = new Area(this.circle1); this.a2 = new Area(this.circle2); this.a1.subtract(this.a2); g2.fill(this.a1); g2.setPaint(this.roseCenterPaint); x1 = diameter - 30; g2.fillOval(midX - radius + 15, midY - radius + 15, x1, x1); g2.setPaint(this.roseHighlightPaint); g2.drawOval(midX - radius, midY - radius, diameter, diameter); x1 = diameter - 20; g2.drawOval(midX - radius + 10, midY - radius + 10, x1, x1); x1 = diameter - 30; g2.drawOval(midX - radius + 15, midY - radius + 15, x1, x1); x1 = diameter - 80; g2.drawOval(midX - radius + 40, midY - radius + 40, x1, x1); outerRadius = radius - 20; innerRadius = radius - 32; for (int w = 0; w < 360; w += 15) { a = Math.toRadians(w); x1 = midX - ((int) (Math.sin(a) * innerRadius)); x2 = midX - ((int) (Math.sin(a) * outerRadius)); y1 = midY - ((int) (Math.cos(a) * innerRadius)); y2 = midY - ((int) (Math.cos(a) * outerRadius)); g2.drawLine(x1, y1, x2, y2); } g2.setPaint(this.roseHighlightPaint); innerRadius = radius - 26; outerRadius = 7; for (int w = 45; w < 360; w += 90) { a = Math.toRadians(w); x1 = midX - ((int) (Math.sin(a) * innerRadius)); y1 = midY - ((int) (Math.cos(a) * innerRadius)); g2.fillOval(x1 - outerRadius, y1 - outerRadius, 2 * outerRadius, 2 * outerRadius); } for (int w = 0; w < 360; w += 90) { a = Math.toRadians(w); x1 = midX - ((int) (Math.sin(a) * innerRadius)); y1 = midY - ((int) (Math.cos(a) * innerRadius)); Polygon p = new Polygon(); p.addPoint(x1 - outerRadius, y1); p.addPoint(x1, y1 + outerRadius); p.addPoint(x1 + outerRadius, y1); p.addPoint(x1, y1 - outerRadius); g2.fillPolygon(p); } innerRadius = radius - 42; Font f = getCompassFont(radius); g2.setFont(f); g2.drawString(\\\"N\\\", midX - 5, midY - innerRadius + f.getSize()); g2.drawString(\\\"S\\\", midX - 5, midY + innerRadius - 5); g2.drawString(\\\"W\\\", midX - innerRadius + 5, midY + 5); g2.drawString(\\\"E\\\", midX + innerRadius - f.getSize(), midY + 5); y1 = radius / 2; x1 = radius / 6; Rectangle2D needleArea = new Rectangle2D.Double((midX - x1), (midY - y1), (2 * x1), (2 * y1)); int x = this.seriesNeedle.length; int current = 0; double value = 0; int i = (this.datasets.length - 1); for (; i >= 0; --i) { ValueDataset data = this.datasets[i]; if (data != null && data.getValue() != null) { value = (data.getValue().doubleValue()) % this.revolutionDistance; value = value / this.revolutionDistance * 360; current = i % x; this.seriesNeedle[current].draw(g2, needleArea, value); } } if (this.drawBorder) { drawOutline(g2, area); } }"
                    ],
                    [
                        0.9309832602739334,
                        "protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) { List ticks = new java.util.ArrayList(); Range range = getRange(); double lowerBoundVal = range.getLowerBound(); if (this.smallLogFlag && lowerBoundVal < SMALL_LOG_VALUE) { lowerBoundVal = SMALL_LOG_VALUE; } double upperBoundVal = range.getUpperBound(); int iBegCount = (int) Math.rint(switchedLog10(lowerBoundVal)); int iEndCount = (int) Math.rint(switchedLog10(upperBoundVal)); if (iBegCount == iEndCount && iBegCount > 0 && Math.pow(10, iBegCount) > lowerBoundVal) { --iBegCount; } double currentTickValue; String tickLabel; boolean zeroTickFlag = false; for (int i = iBegCount; i <= iEndCount; i++) { for (int j = 0; j < 10; ++j) { if (this.smallLogFlag) { currentTickValue = Math.pow(10, i) + (Math.pow(10, i) * j); if (this.expTickLabelsFlag || (i < 0 && currentTickValue > 0.0 && currentTickValue < 1.0)) { if (j == 0 || (i > -4 && j < 2) || currentTickValue >= upperBoundVal) { this.numberFormatterObj.setMaximumFractionDigits(-i); tickLabel = makeTickLabel(currentTickValue, true); } else { tickLabel = \\\"\\\"; } } else { tickLabel = (j < 1 || (i < 1 && j < 5) || (j < 4 - i) || currentTickValue >= upperBoundVal) ? makeTickLabel(currentTickValue) : \\\"\\\"; } } else { if (zeroTickFlag) { --j; } currentTickValue = (i >= 0) ? Math.pow(10, i) + (Math.pow(10, i) * j) : -(Math.pow(10, -i) - (Math.pow(10, -i - 1) * j)); if (!zeroTickFlag) { if (Math.abs(currentTickValue - 1.0) < 0.0001 && lowerBoundVal <= 0.0 && upperBoundVal >= 0.0) { currentTickValue = 0.0; zeroTickFlag = true; } } else { zeroTickFlag = false; } tickLabel = ((this.expTickLabelsFlag && j < 2) || j < 1 || (i < 1 && j < 5) || (j < 4 - i) || currentTickValue >= upperBoundVal) ? makeTickLabel(currentTickValue) : \\\"\\\"; } if (currentTickValue > upperBoundVal) { return ticks; } if (currentTickValue >= lowerBoundVal - SMALL_LOG_VALUE) { TextAnchor anchor = null; TextAnchor rotationAnchor = null; double angle = 0.0; if (isVerticalTickLabels()) { anchor = TextAnchor.CENTER_RIGHT; rotationAnchor = TextAnchor.CENTER_RIGHT; if (edge == RectangleEdge.TOP) { angle = Math.PI / 2.0; } else { angle = -Math.PI / 2.0; } } else { if (edge == RectangleEdge.TOP) { anchor = TextAnchor.BOTTOM_CENTER; rotationAnchor = TextAnchor.BOTTOM_CENTER; } else { anchor = TextAnchor.TOP_CENTER; rotationAnchor = TextAnchor.TOP_CENTER; } } Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); ticks.add(tick); } } } return ticks; }"
                    ],
                    [
                        0.9308581650257111,
                        "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) { boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW); boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW); if (b1 || b2) { return; } if (state == null) { state = new PlotRenderingInfo(null); } state.setPlotArea(area); RectangleInsets insets = getInsets(); insets.trim(area); AxisSpace space = calculateAxisSpace(g2, area); Rectangle2D dataArea = space.shrink(area, null); this.axisOffset.trim(dataArea); state.setDataArea(dataArea); if (getRenderer() != null) { getRenderer().drawBackground(g2, this, dataArea); } else { drawBackground(g2, dataArea); } Map axisStateMap = drawAxes(g2, area, dataArea, state); Shape savedClip = g2.getClip(); g2.clip(dataArea); drawDomainGridlines(g2, dataArea); AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis()); if (rangeAxisState == null) { if (parentState != null) { rangeAxisState = (AxisState) parentState.getSharedAxisStates().get(getRangeAxis()); } } if (rangeAxisState != null) { drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks()); } for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND); } boolean foundData = false; Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha())); DatasetRenderingOrder order = getDatasetRenderingOrder(); if (order == DatasetRenderingOrder.FORWARD) { int datasetCount = this.datasets.size(); for (int i = 0; i < datasetCount; i++) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state); } } for (int i = 0; i < datasetCount; i++) { foundData = render(g2, dataArea, i, state) || foundData; } for (int i = 0; i < datasetCount; i++) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state); } } } else { int datasetCount = this.datasets.size(); for (int i = datasetCount - 1; i >= 0; i--) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state); } } for (int i = this.datasets.size() - 1; i >= 0; i--) { foundData = render(g2, dataArea, i, state) || foundData; } for (int i = datasetCount - 1; i >= 0; i--) { CategoryItemRenderer r = getRenderer(i); if (r != null) { CategoryAxis domainAxis = getDomainAxisForDataset(i); ValueAxis rangeAxis = getRangeAxisForDataset(i); r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state); } } } for (int i = 0; i < this.renderers.size(); i++) { drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND); } for (int i = 0; i < this.renderers.size(); i++) { drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND); } drawAnnotations(g2, dataArea, state); g2.setClip(savedClip); g2.setComposite(originalComposite); if (!foundData) { drawNoDataMessage(g2, dataArea); } if (isRangeCrosshairVisible()) { drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint()); } if (getRenderer() != null) { getRenderer().drawOutline(g2, this, dataArea); } else { drawOutline(g2, dataArea); } }"
                    ],
                    [
                        0.9308034628629684,
                        "public void drawItem(Graphics2D g2, XYItemRendererState state, Rectangle2D dataArea, PlotRenderingInfo info, XYPlot plot, ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset, int series, int item, CrosshairState crosshairState, int pass) { double x = dataset.getXValue(series, item); if (!domainAxis.getRange().contains(x)) { return; } double xx = domainAxis.valueToJava2D(x, dataArea, plot.getDomainAxisEdge()); Shape entityArea = null; EntityCollection entities = null; if (info != null) { entities = info.getOwner().getEntityCollection(); } PlotOrientation orientation = plot.getOrientation(); RectangleEdge location = plot.getRangeAxisEdge(); Paint itemPaint = getItemPaint(series, item); Stroke itemStroke = getItemStroke(series, item); g2.setPaint(itemPaint); g2.setStroke(itemStroke); if (dataset instanceof OHLCDataset) { OHLCDataset hld = (OHLCDataset) dataset; double yHigh = hld.getHighValue(series, item); double yLow = hld.getLowValue(series, item); if (!Double.isNaN(yHigh) && !Double.isNaN(yLow)) { double yyHigh = rangeAxis.valueToJava2D(yHigh, dataArea, location); double yyLow = rangeAxis.valueToJava2D(yLow, dataArea, location); if (orientation == PlotOrientation.HORIZONTAL) { g2.draw(new Line2D.Double(yyLow, xx, yyHigh, xx)); entityArea = new Rectangle2D.Double(Math.min(yyLow, yyHigh), xx - 1.0, Math.abs(yyHigh - yyLow), 2.0); } else if (orientation == PlotOrientation.VERTICAL) { g2.draw(new Line2D.Double(xx, yyLow, xx, yyHigh)); entityArea = new Rectangle2D.Double(xx - 1.0, Math.min(yyLow, yyHigh), 2.0, Math.abs(yyHigh - yyLow)); } } double delta = 2.0; if (domainAxis.isInverted()) { delta = -delta; } if (getDrawOpenTicks()) { double yOpen = hld.getOpenValue(series, item); if (!Double.isNaN(yOpen)) { double yyOpen = rangeAxis.valueToJava2D(yOpen, dataArea, location); if (this.openTickPaint != null) { g2.setPaint(this.openTickPaint); } else { g2.setPaint(itemPaint); } if (orientation == PlotOrientation.HORIZONTAL) { g2.draw(new Line2D.Double(yyOpen, xx + delta, yyOpen, xx)); } else if (orientation == PlotOrientation.VERTICAL) { g2.draw(new Line2D.Double(xx - delta, yyOpen, xx, yyOpen)); } } } if (getDrawCloseTicks()) { double yClose = hld.getCloseValue(series, item); if (!Double.isNaN(yClose)) { double yyClose = rangeAxis.valueToJava2D(yClose, dataArea, location); if (this.closeTickPaint != null) { g2.setPaint(this.closeTickPaint); } else { g2.setPaint(itemPaint); } if (orientation == PlotOrientation.HORIZONTAL) { g2.draw(new Line2D.Double(yyClose, xx, yyClose, xx - delta)); } else if (orientation == PlotOrientation.VERTICAL) { g2.draw(new Line2D.Double(xx, yyClose, xx + delta, yyClose)); } } } } else { if (item > 0) { double x0 = dataset.getXValue(series, item - 1); double y0 = dataset.getYValue(series, item - 1); double y = dataset.getYValue(series, item); if (Double.isNaN(x0) || Double.isNaN(y0) || Double.isNaN(y)) { return; } double xx0 = domainAxis.valueToJava2D(x0, dataArea, plot.getDomainAxisEdge()); double yy0 = rangeAxis.valueToJava2D(y0, dataArea, location); double yy = rangeAxis.valueToJava2D(y, dataArea, location); if (orientation == PlotOrientation.HORIZONTAL) { g2.draw(new Line2D.Double(yy0, xx0, yy, xx)); } else if (orientation == PlotOrientation.VERTICAL) { g2.draw(new Line2D.Double(xx0, yy0, xx, yy)); } } } addEntity(entities, entityArea, dataset, series, item, 0.0, 0.0); }"
                    ],
                    [
                        0.9305044710636139,
                        "protected void drawStackHorizontal(List values, Comparable category, Graphics2D g2, CategoryItemRendererState state, Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryDataset dataset) { int column = dataset.getColumnIndex(category); double barX0 = domainAxis.getCategoryMiddle(column, dataset.getColumnCount(), dataArea, plot.getDomainAxisEdge()) - state.getBarWidth() / 2.0; double barW = state.getBarWidth(); List itemLabelList = new ArrayList(); boolean inverted = rangeAxis.isInverted(); int blockCount = values.size() - 1; for (int k = 0; k < blockCount; k++) { int index = (inverted ? blockCount - k - 1 : k); Object[] prev = (Object[]) values.get(index); Object[] curr = (Object[]) values.get(index + 1); int series = 0; if (curr[0] == null) { series = -((Integer) prev[0]).intValue(); } else { series = ((Integer) curr[0]).intValue(); if (series < 0) { series = -((Integer) prev[0]).intValue(); } } double v0 = ((Double) prev[1]).doubleValue(); double vv0 = rangeAxis.valueToJava2D(v0, dataArea, plot.getRangeAxisEdge()); double v1 = ((Double) curr[1]).doubleValue(); double vv1 = rangeAxis.valueToJava2D(v1, dataArea, plot.getRangeAxisEdge()); Shape[] faces = createHorizontalBlock(barX0, barW, vv0, vv1, inverted); Paint fillPaint = getItemPaint(series, column); Paint fillPaintDark = fillPaint; if (fillPaintDark instanceof Color) { fillPaintDark = ((Color) fillPaint).darker(); } boolean drawOutlines = isDrawBarOutline(); Paint outlinePaint = fillPaint; if (drawOutlines) { outlinePaint = getItemOutlinePaint(series, column); g2.setStroke(getItemOutlineStroke(series, column)); } for (int f = 0; f < 6; f++) { if (f == 5) { g2.setPaint(fillPaint); } else { g2.setPaint(fillPaintDark); } g2.fill(faces[f]); if (drawOutlines) { g2.setPaint(outlinePaint); g2.draw(faces[f]); } } itemLabelList.add(new Object[] { new Integer(series), faces[5].getBounds2D(), Boolean.valueOf(v0 < getBase()) }); EntityCollection entities = state.getEntityCollection(); if (entities != null) { addItemEntity(entities, dataset, series, column, faces[5]); } } for (int i = 0; i < itemLabelList.size(); i++) { Object[] record = (Object[]) itemLabelList.get(i); int series = ((Integer) record[0]).intValue(); Rectangle2D bar = (Rectangle2D) record[1]; boolean neg = ((Boolean) record[2]).booleanValue(); CategoryItemLabelGenerator generator = getItemLabelGenerator(series, column); if (generator != null && isItemLabelVisible(series, column)) { drawItemLabel(g2, dataset, series, column, plot, generator, bar, neg); } } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetCategoryIndex",
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetSeriesIndex",
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetRowCount",
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetRowIndex",
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetColumnCount",
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetColumnIndex",
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testCloning2"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series and the\n     * supplied objects for the categories.\n     *\n     * @param seriesKeys  the series keys (if <code>null</code>, series keys\n     *         will be generated automatically).\n     * @param categoryKeys  the category keys (if <code>null</code>, category \n     *         keys will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = null;\n                this.categoryKeys = null;\n            }\n        }\n\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testGetCategoryIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getCategoryIndex(\"ABC\"));\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)  for (int i = 0; i < this.categoryKeys.length; i++) {            if (category.equals(this.categoryKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetCategoryIndex(DefaultIntervalCategoryDatasetTests.java:415)  assertEquals(-1, empty.getCategoryIndex(\"ABC\"));\n \n#Test method 2:\n```java\n    public void testGetSeriesIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getSeriesIndex(\"ABC\"));\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getSeriesIndex(DefaultIntervalCategoryDataset.java:242)  for (int i = 0; i < this.seriesKeys.length; i++) {            if (seriesKey.equals(this.seriesKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetSeriesIndex(DefaultIntervalCategoryDatasetTests.java:375)  assertEquals(-1, empty.getSeriesIndex(\"ABC\"));\n \n#Test method 3:\n```java\n    public void testGetRowCount() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n        assertEquals(0, empty.getColumnCount());\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnCount(DefaultIntervalCategoryDataset.java:690)  return this.categoryKeys.length;\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetRowCount(DefaultIntervalCategoryDatasetTests.java:490)  assertEquals(0, empty.getColumnCount());\n \n#Test method 4:\n```java\n    public void testGetRowIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getRowIndex(\"ABC\"));\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getSeriesIndex(DefaultIntervalCategoryDataset.java:242)  for (int i = 0; i < this.seriesKeys.length; i++) {            if (seriesKey.equals(this.seriesKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getRowIndex(DefaultIntervalCategoryDataset.java:641)  return getSeriesIndex(rowKey);\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetRowIndex(DefaultIntervalCategoryDatasetTests.java:386)  assertEquals(-1, empty.getRowIndex(\"ABC\"));\n \n#Test method 5:\n```java\n    public void testGetColumnCount() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n        assertEquals(0, empty.getColumnCount());\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnCount(DefaultIntervalCategoryDataset.java:690)  return this.categoryKeys.length;\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetColumnCount(DefaultIntervalCategoryDatasetTests.java:479)  assertEquals(0, empty.getColumnCount());\n \n#Test method 6:\n```java\n    public void testGetColumnIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getColumnIndex(\"ABC\"));\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)  for (int i = 0; i < this.categoryKeys.length; i++) {            if (category.equals(this.categoryKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnIndex(DefaultIntervalCategoryDataset.java:628)  return getCategoryIndex(columnKey);\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetColumnIndex(DefaultIntervalCategoryDatasetTests.java:426)  assertEquals(-1, empty.getColumnIndex(\"ABC\"));\n \n#Test method 7:\n```java\n    public void testCloning2() {\n    \tDefaultIntervalCategoryDataset d1 \n                = new DefaultIntervalCategoryDataset(new double[0][0], \n        \t\t    new double[0][0]);\n        DefaultIntervalCategoryDataset d2 = null;\n        try {\n            d2 = (DefaultIntervalCategoryDataset) d1.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        assertTrue(d1 != d2);\n        assertTrue(d1.getClass() == d2.getClass());\n        assertTrue(d1.equals(d2));\t\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.clone(DefaultIntervalCategoryDataset.java:748)  clone.categoryKeys = (Comparable[]) this.categoryKeys.clone();\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testCloning2(DefaultIntervalCategoryDatasetTests.java:265)  d2 = (DefaultIntervalCategoryDataset) d1.clone();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n\n            // seriesKeys and categoryKeys are set to empty arrays if there is no data\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            } else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        }\n        else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                        + \"of series in the start value dataset does \"\n                        + \"not match the number of series in the end \"\n                        + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                        + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                            + \"number of categories in the start value \"\n                            + \"dataset does not match the number of \"\n                            + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                        + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        }\n        else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n    }\n",
                            "\npublic DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                      Comparable[] categoryKeys,\n                                      Number[][] starts,\n                                      Number[][] ends) {\n\n    this.startData = starts;\n    this.endData = ends;\n\n    if (starts != null && ends != null) {\n\n        String baseName = \"org.jfree.data.resources.DataPackageResources\";\n        ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n        int seriesCount = starts.length;\n        if (seriesCount != ends.length) {\n            String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n            throw new IllegalArgumentException(errMsg);\n        }\n        if (seriesCount > 0) {\n\n            // set up the series names...\n            if (seriesKeys != null) {\n\n                if (seriesKeys.length != seriesCount) {\n                    throw new IllegalArgumentException(\n                            \"The number of series keys does not \"\n                                    + \"match the number of series in the data.\");\n                }\n\n                this.seriesKeys = seriesKeys;\n            }\n            else {\n                String prefix = resources.getString(\n                        \"series.default-prefix\") + \" \";\n                this.seriesKeys = generateKeys(seriesCount, prefix);\n            }\n\n            // set up the category names...\n            int categoryCount = starts[0].length;\n            if (categoryCount != ends[0].length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                        + \"number of categories in the start value \"\n                        + \"dataset does not match the number of \"\n                        + \"categories in the end value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (categoryKeys != null) {\n                if (categoryKeys.length != categoryCount) {\n                    throw new IllegalArgumentException(\n                            \"The number of category keys does not match \"\n                                    + \"the number of categories in the data.\");\n                }\n                this.categoryKeys = categoryKeys;\n            }\n            else {\n                String prefix = resources.getString(\n                        \"categories.default-prefix\") + \" \";\n                this.categoryKeys = generateKeys(categoryCount, prefix);\n            }\n        }\n    }\n\n    if (seriesCount == 0) {\n        this.seriesKeys = new Comparable[0];\n        this.categoryKeys = new Comparable[0];\n    } else {\n        if (this.seriesKeys == null) {\n            this.seriesKeys = new Comparable[seriesCount];\n        }\n        if (this.categoryKeys == null) {\n            this.categoryKeys = new Comparable[0];\n        }\n    }\n}\n",
                            "\n    /**\n     * Constructs a DefaultIntervalCategoryDataset, populates it with data\n     * from the arrays, and uses the supplied names for the series and the\n     * supplied objects for the categories.\n     *\n     * @param seriesKeys  the series keys (if <code>null</code>, series keys\n     *         will be generated automatically).\n     * @param categoryKeys  the category keys (if <code>null</code>, category \n     *         keys will be generated automatically).\n     * @param starts  the start values data, indexed as data[series][category].\n     * @param ends  the end values data, indexed as data[series][category].\n     */\n\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            throw new IllegalArgumentException(\"Null 'starts' or 'ends' argument.\");\n        }\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null && starts.length > 0 && starts[0].length > 0) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = null;\n                this.categoryKeys = null;\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = new Comparable[0];\n                this.categoryKeys = new Comparable[0];\n            }\n        } else {\n            throw new IllegalArgumentException(\"Null 'starts' or 'ends' argument.\");\n        }\n    }\n",
                            "\n    public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n                                          Comparable[] categoryKeys,\n                                          Number[][] starts,\n                                          Number[][] ends) {\n\n        this.startData = starts;\n        this.endData = ends;\n\n        if (starts != null && ends != null && starts.length > 0 && starts[0].length > 0) {\n\n            String baseName = \"org.jfree.data.resources.DataPackageResources\";\n            ResourceBundle resources = ResourceBundle.getBundle(baseName);\n\n            int seriesCount = starts.length;\n            if (seriesCount != ends.length) {\n                String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n                    + \"of series in the start value dataset does \"\n                    + \"not match the number of series in the end \"\n                    + \"value dataset.\";\n                throw new IllegalArgumentException(errMsg);\n            }\n            if (seriesCount > 0) {\n\n                // set up the series names...\n                if (seriesKeys != null) {\n\n                    if (seriesKeys.length != seriesCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of series keys does not \"\n                                + \"match the number of series in the data.\");\n                    }\n\n                    this.seriesKeys = seriesKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"series.default-prefix\") + \" \";\n                    this.seriesKeys = generateKeys(seriesCount, prefix);\n                }\n\n                // set up the category names...\n                int categoryCount = starts[0].length;\n                if (categoryCount != ends[0].length) {\n                    String errMsg = \"DefaultIntervalCategoryDataset: the \"\n                                + \"number of categories in the start value \"\n                                + \"dataset does not match the number of \"\n                                + \"categories in the end value dataset.\";\n                    throw new IllegalArgumentException(errMsg);\n                }\n                if (categoryKeys != null) {\n                    if (categoryKeys.length != categoryCount) {\n                        throw new IllegalArgumentException(\n                                \"The number of category keys does not match \"\n                                + \"the number of categories in the data.\");\n                    }\n                    this.categoryKeys = categoryKeys;\n                }\n                else {\n                    String prefix = resources.getString(\n                            \"categories.default-prefix\") + \" \";\n                    this.categoryKeys = generateKeys(categoryCount, prefix);\n                }\n\n            }\n            else {\n                this.seriesKeys = null;\n                this.categoryKeys = null;\n            }\n        } else {\n            this.seriesKeys = new Comparable[0];\n            this.categoryKeys = new Comparable[0];\n        }\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "source/org/jfree/data/category/DefaultIntervalCategoryDataset.java",
                "start_loc": 334,
                "end_loc": 351,
                "buggy_function": "    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                "fixed_function": "    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (categoryKeys.length != getCategoryCount()) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                "comment": "    /**\n     * Sets the categories for the dataset.\n     *\n     * @param categoryKeys  an array of objects representing the categories in \n     *                      the dataset.\n     *                      \n     * @see #getRowKeys()\n     * @see #setSeriesKeys(Comparable[])\n     */\n",
                "normalized_body": [
                    "public void setCategoryKeys(Comparable[] categoryKeys) { if (categoryKeys == null) { throw new IllegalArgumentException(\\\"Null 'categoryKeys' argument.\\\"); } if (categoryKeys.length != this.startData[0].length) { throw new IllegalArgumentException(\\\"The number of categories does not match the data.\\\"); } for (int i = 0; i < categoryKeys.length; i++) { if (categoryKeys[i] == null) { throw new IllegalArgumentException(\\\"DefaultIntervalCategoryDataset.setCategoryKeys(): \\\" + \\\"null category not permitted.\\\"); } } this.categoryKeys = categoryKeys; fireDatasetChanged(); }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "public void setCategoryKeys(Comparable[] categoryKeys) { if (categoryKeys == null) { throw new IllegalArgumentException(\\\"Null 'categoryKeys' argument.\\\"); } if (categoryKeys.length != this.startData[0].length) { throw new IllegalArgumentException(\\\"The number of categories does not match the data.\\\"); } for (int i = 0; i < categoryKeys.length; i++) { if (categoryKeys[i] == null) { throw new IllegalArgumentException(\\\"DefaultIntervalCategoryDataset.setCategoryKeys(): \\\" + \\\"null category not permitted.\\\"); } } this.categoryKeys = categoryKeys; fireDatasetChanged(); }"
                    ],
                    [
                        0.9756753444671631,
                        "public static double getStdDev(Number[] data) { if (data == null) { throw new IllegalArgumentException(\\\"Null 'data' array.\\\"); } if (data.length == 0) { throw new IllegalArgumentException(\\\"Zero length 'data' array.\\\"); } double avg = calculateMean(data); double sum = 0.0; for (int counter = 0; counter < data.length; counter++) { double diff = data[counter].doubleValue() - avg; sum = sum + diff * diff; } return Math.sqrt(sum / (data.length - 1)); }"
                    ],
                    [
                        0.9741984605789185,
                        "public static double calculateQ3(List values) { if (values == null) { throw new IllegalArgumentException(\\\"Null 'values' argument.\\\"); } double result = Double.NaN; int count = values.size(); if (count > 0) { if (count % 2 == 1) { if (count > 1) { result = Statistics.calculateMedian(values, count / 2, count - 1); } else { result = Statistics.calculateMedian(values, 0, 0); } } else { result = Statistics.calculateMedian(values, count / 2, count - 1); } } return result; }"
                    ],
                    [
                        0.973948061466217,
                        "public Size2D calculateDimensions(Graphics2D g2) { double width = 0.0; double height = 0.0; Iterator iterator = this.fragments.iterator(); while (iterator.hasNext()) { TextFragment fragment = (TextFragment) iterator.next(); Size2D dimension = fragment.calculateDimensions(g2); width = width + dimension.getWidth(); height = Math.max(height, dimension.getHeight()); } return new Size2D(width, height); }"
                    ],
                    [
                        0.9734582304954529,
                        "public void add(TaskSeries series) { if (series == null) { throw new IllegalArgumentException(\\\"Null 'series' argument.\\\"); } this.data.add(series); series.addChangeListener(this); Iterator iterator = series.getTasks().iterator(); while (iterator.hasNext()) { Task task = (Task) iterator.next(); String key = task.getDescription(); int index = this.keys.indexOf(key); if (index < 0) { this.keys.add(key); } } fireDatasetChanged(); }"
                    ],
                    [
                        0.9720194339752197,
                        "public void add(RegularTimePeriod period, double open, double high, double low, double close) { if (getItemCount() > 0) { OHLCItem item0 = (OHLCItem) this.getDataItem(0); if (!period.getClass().equals(item0.getPeriod().getClass())) { throw new IllegalArgumentException(\\\"Can't mix RegularTimePeriod class types.\\\"); } } super.add(new OHLCItem(period, open, high, low, close), true); }"
                    ],
                    [
                        0.9718562364578247,
                        "public void setRangeAxis(int index, ValueAxis axis, boolean notify) { ValueAxis existing = getRangeAxis(index); if (existing != null) { existing.removeChangeListener(this); } if (axis != null) { axis.setPlot(this); } this.rangeAxes.set(index, axis); if (axis != null) { axis.configure(); axis.addChangeListener(this); } if (notify) { notifyListeners(new PlotChangeEvent(this)); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testSetCategoryKeys"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Sets the categories for the dataset.\n     *\n     * @param categoryKeys  an array of objects representing the categories in \n     *                      the dataset.\n     *                      \n     * @see #getRowKeys()\n     * @see #setSeriesKeys(Comparable[])\n     */\n\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testSetCategoryKeys() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tboolean pass = true;\n    \ttry {\n    \t\tempty.setCategoryKeys(new String[0]);\n    \t}\n    \tcatch (RuntimeException e) {\n    \t\tpass = false;\n    \t}\n    \tassertTrue(pass);\n    }\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testSetCategoryKeys(DefaultIntervalCategoryDatasetTests.java:444)  assertTrue(pass);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        \n        // Allow setting categoryKeys on an empty dataset\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        \n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\npublic void setCategoryKeys(Comparable[] categoryKeys) {\n    if (categoryKeys == null) {\n        throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n    }\n    if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n        throw new IllegalArgumentException(\n                \"The number of categories does not match the data.\");\n    }\n    for (int i = 0; i < categoryKeys.length; i++) {\n        if (categoryKeys[i] == null) {\n            throw new IllegalArgumentException(\n                \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                + \"null category not permitted.\");\n        }\n    }\n    this.categoryKeys = categoryKeys;\n    fireDatasetChanged();\n}\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && this.startData[0].length != categoryKeys.length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && this.startData[0].length != categoryKeys.length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && categoryKeys.length != this.startData[0].length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n",
                            "\n    public void setCategoryKeys(Comparable[] categoryKeys) {\n        if (categoryKeys == null) {\n            throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n        }\n        if (this.startData.length > 0 && this.startData[0].length != categoryKeys.length) {\n            throw new IllegalArgumentException(\n                    \"The number of categories does not match the data.\");\n        }\n        for (int i = 0; i < categoryKeys.length; i++) {\n            if (categoryKeys[i] == null) {\n                throw new IllegalArgumentException(\n                    \"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n                    + \"null category not permitted.\");\n            }\n        }\n        this.categoryKeys = categoryKeys;\n        fireDatasetChanged();\n    }\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetCategoryIndex": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testGetCategoryIndex",
                "src": "    public void testGetCategoryIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getCategoryIndex(\"ABC\"));\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetCategoryIndex(DefaultIntervalCategoryDatasetTests.java:415)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)  for (int i = 0; i < this.categoryKeys.length; i++) {            if (category.equals(this.categoryKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetCategoryIndex(DefaultIntervalCategoryDatasetTests.java:415)  assertEquals(-1, empty.getCategoryIndex(\"ABC\"));"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testSetCategoryKeys": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testSetCategoryKeys",
                "src": "    public void testSetCategoryKeys() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tboolean pass = true;\n    \ttry {\n    \t\tempty.setCategoryKeys(new String[0]);\n    \t}\n    \tcatch (RuntimeException e) {\n    \t\tpass = false;\n    \t}\n    \tassertTrue(pass);\n    }",
                "error_msg": "junit.framework.AssertionFailedError\n\tat junit.framework.Assert.fail(Assert.java:55)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertTrue(Assert.java:31)\n\tat junit.framework.TestCase.assertTrue(TestCase.java:201)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testSetCategoryKeys(DefaultIntervalCategoryDatasetTests.java:444)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testSetCategoryKeys(DefaultIntervalCategoryDatasetTests.java:444)  assertTrue(pass);"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetSeriesIndex": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testGetSeriesIndex",
                "src": "    public void testGetSeriesIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getSeriesIndex(\"ABC\"));\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getSeriesIndex(DefaultIntervalCategoryDataset.java:242)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetSeriesIndex(DefaultIntervalCategoryDatasetTests.java:375)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getSeriesIndex(DefaultIntervalCategoryDataset.java:242)  for (int i = 0; i < this.seriesKeys.length; i++) {            if (seriesKey.equals(this.seriesKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetSeriesIndex(DefaultIntervalCategoryDatasetTests.java:375)  assertEquals(-1, empty.getSeriesIndex(\"ABC\"));"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetRowCount": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testGetRowCount",
                "src": "    public void testGetRowCount() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n        assertEquals(0, empty.getColumnCount());\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnCount(DefaultIntervalCategoryDataset.java:690)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetRowCount(DefaultIntervalCategoryDatasetTests.java:490)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnCount(DefaultIntervalCategoryDataset.java:690)  return this.categoryKeys.length;\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetRowCount(DefaultIntervalCategoryDatasetTests.java:490)  assertEquals(0, empty.getColumnCount());"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetRowIndex": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testGetRowIndex",
                "src": "    public void testGetRowIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getRowIndex(\"ABC\"));\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getSeriesIndex(DefaultIntervalCategoryDataset.java:242)\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getRowIndex(DefaultIntervalCategoryDataset.java:641)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetRowIndex(DefaultIntervalCategoryDatasetTests.java:386)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getSeriesIndex(DefaultIntervalCategoryDataset.java:242)  for (int i = 0; i < this.seriesKeys.length; i++) {            if (seriesKey.equals(this.seriesKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getRowIndex(DefaultIntervalCategoryDataset.java:641)  return getSeriesIndex(rowKey);\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetRowIndex(DefaultIntervalCategoryDatasetTests.java:386)  assertEquals(-1, empty.getRowIndex(\"ABC\"));"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetColumnCount": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testGetColumnCount",
                "src": "    public void testGetColumnCount() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n        assertEquals(0, empty.getColumnCount());\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnCount(DefaultIntervalCategoryDataset.java:690)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetColumnCount(DefaultIntervalCategoryDatasetTests.java:479)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnCount(DefaultIntervalCategoryDataset.java:690)  return this.categoryKeys.length;\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetColumnCount(DefaultIntervalCategoryDatasetTests.java:479)  assertEquals(0, empty.getColumnCount());"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetColumnIndex": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testGetColumnIndex",
                "src": "    public void testGetColumnIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getColumnIndex(\"ABC\"));\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnIndex(DefaultIntervalCategoryDataset.java:628)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetColumnIndex(DefaultIntervalCategoryDatasetTests.java:426)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)  for (int i = 0; i < this.categoryKeys.length; i++) {            if (category.equals(this.categoryKeys[i])) {                result = i;                break;            }        }\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.getColumnIndex(DefaultIntervalCategoryDataset.java:628)  return getCategoryIndex(columnKey);\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetColumnIndex(DefaultIntervalCategoryDatasetTests.java:426)  assertEquals(-1, empty.getColumnIndex(\"ABC\"));"
            },
            "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testCloning2": {
                "path": "tests/org/jfree/data/category/junit/DefaultIntervalCategoryDatasetTests.java",
                "function_name": "testCloning2",
                "src": "    public void testCloning2() {\n    \tDefaultIntervalCategoryDataset d1 \n                = new DefaultIntervalCategoryDataset(new double[0][0], \n        \t\t    new double[0][0]);\n        DefaultIntervalCategoryDataset d2 = null;\n        try {\n            d2 = (DefaultIntervalCategoryDataset) d1.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n        assertTrue(d1 != d2);\n        assertTrue(d1.getClass() == d2.getClass());\n        assertTrue(d1.equals(d2));\t\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.clone(DefaultIntervalCategoryDataset.java:748)\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testCloning2(DefaultIntervalCategoryDatasetTests.java:265)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.category.DefaultIntervalCategoryDataset.clone(DefaultIntervalCategoryDataset.java:748)  clone.categoryKeys = (Comparable[]) this.categoryKeys.clone();\n\tat org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testCloning2(DefaultIntervalCategoryDatasetTests.java:265)  d2 = (DefaultIntervalCategoryDataset) d1.clone();"
            }
        },
        "evaluation_done": true
    }
}