{
    "Chart-2": {
        "function_num": 2,
        "functions": [
            {
                "path": "source/org/jfree/data/general/DatasetUtilities.java",
                "start_loc": 740,
                "end_loc": 785,
                "buggy_function": "    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                "fixed_function": "    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = intervalXYData.getXValue(series, item);\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                "comment": "    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n",
                "normalized_body": [
                    "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = intervalXYData.getStartXValue(series, item); double uvalue = intervalXYData.getEndXValue(series, item); boolean hasValidInterval = false; double x = intervalXYData.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); hasValidInterval = true; } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); hasValidInterval = true; } } } } else { for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } return (minimum <= maximum) ? new Range(minimum, maximum) : null; }"
                ],
                "top_similar_methods": [
                    [
                        0.9999999403953552,
                        "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = intervalXYData.getStartXValue(series, item); double uvalue = intervalXYData.getEndXValue(series, item); boolean hasValidInterval = false; double x = intervalXYData.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); hasValidInterval = true; } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); hasValidInterval = true; } } } } else { for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } return (minimum <= maximum) ? new Range(minimum, maximum) : null; }"
                    ],
                    [
                        0.9964520931243896,
                        "public static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartXValue(series, item); double uvalue = ixyd.getEndXValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                    ],
                    [
                        0.9952557682991028,
                        "public static Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval) { double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int rowCount = dataset.getRowCount(); int columnCount = dataset.getColumnCount(); if (includeInterval && dataset instanceof IntervalCategoryDataset) { IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; Number value, lvalue, uvalue; for (int row = 0; row < rowCount; row++) { for (int column = 0; column < columnCount; column++) { value = icd.getValue(row, column); double v; if ((value != null) && !Double.isNaN(v = value.doubleValue())) { minimum = Math.min(v, minimum); maximum = Math.max(v, maximum); } lvalue = icd.getStartValue(row, column); if (lvalue != null && !Double.isNaN(v = lvalue.doubleValue())) { minimum = Math.min(v, minimum); maximum = Math.max(v, maximum); } uvalue = icd.getEndValue(row, column); if (uvalue != null && !Double.isNaN(v = uvalue.doubleValue())) { minimum = Math.min(v, minimum); maximum = Math.max(v, maximum); } } } } else { for (int row = 0; row < rowCount; row++) { for (int column = 0; column < columnCount; column++) { Number value = dataset.getValue(row, column); if (value != null) { double v = value.doubleValue(); if (!Double.isNaN(v)) { minimum = Math.min(minimum, v); maximum = Math.max(maximum, v); } } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                    ],
                    [
                        0.9917596578598022,
                        "public static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } if (xRange == null) { throw new IllegalArgumentException(\\\"Null 'xRange' argument\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof OHLCDataset) { OHLCDataset ohlc = (OHLCDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ohlc.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ohlc.getLowValue(series, item); double uvalue = ohlc.getHighValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) { BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = bx.getXValue(series, item); if (xRange.contains(x)) { Number lvalue = bx.getMinRegularValue(series, item); Number uvalue = bx.getMaxRegularValue(series, item); if (lvalue != null) { minimum = Math.min(minimum, lvalue.doubleValue()); } if (uvalue != null) { maximum = Math.max(maximum, uvalue.doubleValue()); } } } } } else if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ixyd.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); double y = dataset.getYValue(series, item); if (xRange.contains(x)) { if (!Double.isNaN(y)) { minimum = Math.min(minimum, y); maximum = Math.max(maximum, y); } } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                    ],
                    [
                        0.9914653897285461,
                        "protected void applyToCategoryPlot(CategoryPlot plot) { plot.setAxisOffset(this.axisOffset); plot.setDomainGridlinePaint(this.domainGridlinePaint); plot.setRangeGridlinePaint(this.rangeGridlinePaint); plot.setRangeZeroBaselinePaint(this.baselinePaint); int domainAxisCount = plot.getDomainAxisCount(); for (int i = 0; i < domainAxisCount; i++) { CategoryAxis axis = plot.getDomainAxis(i); if (axis != null) { applyToCategoryAxis(axis); } } int rangeAxisCount = plot.getRangeAxisCount(); for (int i = 0; i < rangeAxisCount; i++) { ValueAxis axis = (ValueAxis) plot.getRangeAxis(i); if (axis != null) { applyToValueAxis(axis); } } int rendererCount = plot.getRendererCount(); for (int i = 0; i < rendererCount; i++) { CategoryItemRenderer r = plot.getRenderer(i); if (r != null) { applyToCategoryItemRenderer(r); } } if (plot instanceof CombinedDomainCategoryPlot) { CombinedDomainCategoryPlot cp = (CombinedDomainCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } if (plot instanceof CombinedRangeCategoryPlot) { CombinedRangeCategoryPlot cp = (CombinedRangeCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } }"
                    ],
                    [
                        0.9912556409835815,
                        "public static int findLiveItemsLowerBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue >= xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue < xLow) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV >= xLow) { high = mid; } else { low = mid; } } return high; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue <= xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue > xHigh) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV > xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return high; } else { int index = 0; double x = dataset.getXValue(series, index); while (index < itemCount && (x < xLow || x > xHigh)) { index++; if (index < itemCount) { x = dataset.getXValue(series, index); } } return Math.min(Math.max(0, index), itemCount - 1); } }"
                    ],
                    [
                        0.9903990030288696,
                        "public static int findLiveItemsUpperBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue > xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue <= xHigh) { return high; } int mid = (low + high) / 2; while (high - low > 1) { double midV = dataset.getXValue(series, mid); if (midV <= xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return mid; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; int mid = (low + high) / 2; double lowValue = dataset.getXValue(series, low); if (lowValue < xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue >= xLow) { return high; } while (high - low > 1) { double midV = dataset.getXValue(series, mid); if (midV >= xLow) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return mid; } else { int index = itemCount - 1; double x = dataset.getXValue(series, index); while (index >= 0 && (x < xLow || x > xHigh)) { index--; if (index >= 0) { x = dataset.getXValue(series, index); } } return Math.max(index, 0); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.jfree.data.general.junit.DatasetUtilitiesTests::testBug2849731_2"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBug2849731_2() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.0, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(0.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_2(DatasetUtilitiesTests.java:1276)  assertEquals(1.0, r.getLowerBound(), EPSILON);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        } else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        } else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return new Range(0.0, 0.0);\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        boolean foundValidValue = false;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        foundValidValue = true;\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                        foundValidValue = true;\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                        foundValidValue = true;\n                    }\n                }\n            }\n        }\n        if (!foundValidValue) {\n            return null;\n        }\n        return new Range(minimum, maximum);\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (Double.isInfinite(minimum) || Double.isInfinite(maximum)) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     */\n\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBug2849731_2() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.0, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(0.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_2(DatasetUtilitiesTests.java:1276)  assertEquals(1.0, r.getLowerBound(), EPSILON);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartXValue(series, item); double uvalue = ixyd.getEndXValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }\n```\n\n            \n```java\npublic static Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval) { double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int rowCount = dataset.getRowCount(); int columnCount = dataset.getColumnCount(); if (includeInterval && dataset instanceof IntervalCategoryDataset) { IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset; Number value, lvalue, uvalue; for (int row = 0; row < rowCount; row++) { for (int column = 0; column < columnCount; column++) { value = icd.getValue(row, column); double v; if ((value != null) && !Double.isNaN(v = value.doubleValue())) { minimum = Math.min(v, minimum); maximum = Math.max(v, maximum); } lvalue = icd.getStartValue(row, column); if (lvalue != null && !Double.isNaN(v = lvalue.doubleValue())) { minimum = Math.min(v, minimum); maximum = Math.max(v, maximum); } uvalue = icd.getEndValue(row, column); if (uvalue != null && !Double.isNaN(v = uvalue.doubleValue())) { minimum = Math.min(v, minimum); maximum = Math.max(v, maximum); } } } } else { for (int row = 0; row < rowCount; row++) { for (int column = 0; column < columnCount; column++) { Number value = dataset.getValue(row, column); if (value != null) { double v = value.doubleValue(); if (!Double.isNaN(v)) { minimum = Math.min(minimum, v); maximum = Math.max(maximum, v); } } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }\n```\n\n            \n```java\npublic static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } if (xRange == null) { throw new IllegalArgumentException(\\\"Null 'xRange' argument\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof OHLCDataset) { OHLCDataset ohlc = (OHLCDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ohlc.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ohlc.getLowValue(series, item); double uvalue = ohlc.getHighValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) { BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = bx.getXValue(series, item); if (xRange.contains(x)) { Number lvalue = bx.getMinRegularValue(series, item); Number uvalue = bx.getMaxRegularValue(series, item); if (lvalue != null) { minimum = Math.min(minimum, lvalue.doubleValue()); } if (uvalue != null) { maximum = Math.max(maximum, uvalue.doubleValue()); } } } } } else if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ixyd.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); double y = dataset.getYValue(series, item); if (xRange.contains(x)) { if (!Double.isNaN(y)) { minimum = Math.min(minimum, y); maximum = Math.max(maximum, y); } } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }\n```\n\n            \n```java\nprotected void applyToCategoryPlot(CategoryPlot plot) { plot.setAxisOffset(this.axisOffset); plot.setDomainGridlinePaint(this.domainGridlinePaint); plot.setRangeGridlinePaint(this.rangeGridlinePaint); plot.setRangeZeroBaselinePaint(this.baselinePaint); int domainAxisCount = plot.getDomainAxisCount(); for (int i = 0; i < domainAxisCount; i++) { CategoryAxis axis = plot.getDomainAxis(i); if (axis != null) { applyToCategoryAxis(axis); } } int rangeAxisCount = plot.getRangeAxisCount(); for (int i = 0; i < rangeAxisCount; i++) { ValueAxis axis = (ValueAxis) plot.getRangeAxis(i); if (axis != null) { applyToValueAxis(axis); } } int rendererCount = plot.getRendererCount(); for (int i = 0; i < rendererCount; i++) { CategoryItemRenderer r = plot.getRenderer(i); if (r != null) { applyToCategoryItemRenderer(r); } } if (plot instanceof CombinedDomainCategoryPlot) { CombinedDomainCategoryPlot cp = (CombinedDomainCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } if (plot instanceof CombinedRangeCategoryPlot) { CombinedRangeCategoryPlot cp = (CombinedRangeCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } }\n```\n\n            \n```java\npublic static int findLiveItemsLowerBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue >= xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue < xLow) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV >= xLow) { high = mid; } else { low = mid; } } return high; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue <= xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue > xHigh) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV > xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return high; } else { int index = 0; double x = dataset.getXValue(series, index); while (index < itemCount && (x < xLow || x > xHigh)) { index++; if (index < itemCount) { x = dataset.getXValue(series, index); } } return Math.min(Math.max(0, index), itemCount - 1); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\npublic static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, lvalue);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}\n",
                            "\npublic static Range iterateDomainBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue) && !Double.isNaN(uvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, lvalue);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue); // Set to lvalue directly\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY && maximum == Double.NEGATIVE_INFINITY) {\n            return null; // Adjust condition to check for initial values\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\npublic static Range iterateDomainBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, lvalue);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}\n",
                            "\npublic static Range iterateDomainBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, lvalue);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    }\n    else {\n        return new Range(minimum, maximum);\n    }\n}\n",
                            "\n    public static Range iterateDomainBounds(XYDataset dataset,\n                                            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue;\n        double uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        } else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        } else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\npublic static Range iterateDomainBounds(XYDataset dataset,\n                                        boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, lvalue);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}\n",
                            "\npublic static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    double lvalue;\n    double uvalue;\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = intervalXYData.getStartXValue(series, item);\n                uvalue = intervalXYData.getEndXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    } else {\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                lvalue = dataset.getXValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                    maximum = Math.max(maximum, lvalue);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY && maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    } else {\n        return new Range(minimum, maximum);\n    }\n}\n"
                        ],
                        "evaluation_done": true
                    }
                }
            },
            {
                "path": "source/org/jfree/data/general/DatasetUtilities.java",
                "start_loc": 1229,
                "end_loc": 1289,
                "buggy_function": "    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                "fixed_function": "    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = ixyd.getYValue(series, item);\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                "comment": "    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n",
                "normalized_body": [
                    "public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) { double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else if (includeInterval && dataset instanceof OHLCDataset) { OHLCDataset ohlc = (OHLCDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ohlc.getLowValue(series, item); double uvalue = ohlc.getHighValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else { for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value = dataset.getYValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) { double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else if (includeInterval && dataset instanceof OHLCDataset) { OHLCDataset ohlc = (OHLCDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ohlc.getLowValue(series, item); double uvalue = ohlc.getHighValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else { for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value = dataset.getYValue(series, item); if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); maximum = Math.max(maximum, value); } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                    ],
                    [
                        0.9958545565605164,
                        "public static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } if (xRange == null) { throw new IllegalArgumentException(\\\"Null 'xRange' argument\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof OHLCDataset) { OHLCDataset ohlc = (OHLCDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ohlc.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ohlc.getLowValue(series, item); double uvalue = ohlc.getHighValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) { BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = bx.getXValue(series, item); if (xRange.contains(x)) { Number lvalue = bx.getMinRegularValue(series, item); Number uvalue = bx.getMaxRegularValue(series, item); if (lvalue != null) { minimum = Math.min(minimum, lvalue.doubleValue()); } if (uvalue != null) { maximum = Math.max(maximum, uvalue.doubleValue()); } } } } } else if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ixyd.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); double y = dataset.getYValue(series, item); if (xRange.contains(x)) { if (!Double.isNaN(y)) { minimum = Math.min(minimum, y); maximum = Math.max(maximum, y); } } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                    ],
                    [
                        0.9918335676193237,
                        "public static int findLiveItemsUpperBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue > xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue <= xHigh) { return high; } int mid = (low + high) / 2; while (high - low > 1) { double midV = dataset.getXValue(series, mid); if (midV <= xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return mid; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; int mid = (low + high) / 2; double lowValue = dataset.getXValue(series, low); if (lowValue < xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue >= xLow) { return high; } while (high - low > 1) { double midV = dataset.getXValue(series, mid); if (midV >= xLow) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return mid; } else { int index = itemCount - 1; double x = dataset.getXValue(series, index); while (index >= 0 && (x < xLow || x > xHigh)) { index--; if (index >= 0) { x = dataset.getXValue(series, index); } } return Math.max(index, 0); } }"
                    ],
                    [
                        0.9915100932121277,
                        "public static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartXValue(series, item); double uvalue = ixyd.getEndXValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }"
                    ],
                    [
                        0.9910948276519775,
                        "public static int findLiveItemsLowerBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue >= xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue < xLow) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV >= xLow) { high = mid; } else { low = mid; } } return high; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue <= xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue > xHigh) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV > xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return high; } else { int index = 0; double x = dataset.getXValue(series, index); while (index < itemCount && (x < xLow || x > xHigh)) { index++; if (index < itemCount) { x = dataset.getXValue(series, index); } } return Math.min(Math.max(0, index), itemCount - 1); } }"
                    ],
                    [
                        0.9897569417953491,
                        "public static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = intervalXYData.getStartXValue(series, item); double uvalue = intervalXYData.getEndXValue(series, item); boolean hasValidInterval = false; double x = intervalXYData.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); hasValidInterval = true; } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); hasValidInterval = true; } } } } else { for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } return (minimum <= maximum) ? new Range(minimum, maximum) : null; }"
                    ],
                    [
                        0.9896934032440186,
                        "public void drawItem(Graphics2D g2, XYItemRendererState state, Rectangle2D dataArea, XYPlot plot, ValueAxis domainAxis, ValueAxis rangeAxis, XYDataset dataset, int series, int item, boolean selected, int pass) { if (!getItemVisible(series, item)) { return; } PlotOrientation orientation = plot.getOrientation(); double x = dataset.getXValue(series, item); double y = dataset.getYValue(series, item); double z = Double.NaN; if (dataset instanceof XYZDataset) { XYZDataset xyzData = (XYZDataset) dataset; z = xyzData.getZValue(series, item); } if (!Double.isNaN(z)) { RectangleEdge domainAxisLocation = plot.getDomainAxisEdge(); RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge(); double transX = domainAxis.valueToJava2D(x, dataArea, domainAxisLocation); double transY = rangeAxis.valueToJava2D(y, dataArea, rangeAxisLocation); double transDomain = 0.0; double transRange = 0.0; double zero; switch(getScaleType()) { case SCALE_ON_DOMAIN_AXIS: zero = domainAxis.valueToJava2D(0.0, dataArea, domainAxisLocation); transDomain = domainAxis.valueToJava2D(z, dataArea, domainAxisLocation) - zero; transRange = transDomain; break; case SCALE_ON_RANGE_AXIS: zero = rangeAxis.valueToJava2D(0.0, dataArea, rangeAxisLocation); transRange = zero - rangeAxis.valueToJava2D(z, dataArea, rangeAxisLocation); transDomain = transRange; break; default: double zero1 = domainAxis.valueToJava2D(0.0, dataArea, domainAxisLocation); double zero2 = rangeAxis.valueToJava2D(0.0, dataArea, rangeAxisLocation); transDomain = domainAxis.valueToJava2D(z, dataArea, domainAxisLocation) - zero1; transRange = zero2 - rangeAxis.valueToJava2D(z, dataArea, rangeAxisLocation); } transDomain = Math.abs(transDomain); transRange = Math.abs(transRange); Ellipse2D circle = null; if (orientation == PlotOrientation.VERTICAL) { circle = new Ellipse2D.Double(transX - transDomain / 2.0, transY - transRange / 2.0, transDomain, transRange); } else if (orientation == PlotOrientation.HORIZONTAL) { circle = new Ellipse2D.Double(transY - transRange / 2.0, transX - transDomain / 2.0, transRange, transDomain); } g2.setPaint(getItemPaint(series, item, selected)); g2.fill(circle); g2.setStroke(getItemOutlineStroke(series, item, selected)); g2.setPaint(getItemOutlinePaint(series, item, selected)); g2.draw(circle); if (isItemLabelVisible(series, item, selected)) { if (orientation == PlotOrientation.VERTICAL) { drawItemLabel(g2, orientation, dataset, series, item, selected, transX, transY, false); } else if (orientation == PlotOrientation.HORIZONTAL) { drawItemLabel(g2, orientation, dataset, series, item, selected, transY, transX, false); } } EntityCollection entities = null; if (state.getInfo() != null) { entities = state.getInfo().getOwner().getEntityCollection(); if (entities != null && circle.intersects(dataArea)) { addEntity(entities, circle, dataset, series, item, selected, circle.getCenterX(), circle.getCenterY()); } } int domainAxisIndex = plot.getDomainAxisIndex(domainAxis); int rangeAxisIndex = plot.getRangeAxisIndex(rangeAxis); XYCrosshairState crosshairState = state.getCrosshairState(); updateCrosshairValues(crosshairState, x, y, domainAxisIndex, rangeAxisIndex, transX, transY, orientation); } }"
                    ]
                ],
                "directly_related_tests": [
                    "org.jfree.data.general.junit.DatasetUtilitiesTests::testBug2849731_3"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBug2849731_3() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, 1.5, Double.NaN, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, Double.NaN, 2.5);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(2.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 3.5, Double.NaN);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(3.5, r.getUpperBound(), EPSILON);\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_3(DatasetUtilitiesTests.java:1299)  assertEquals(1.5, r.getLowerBound(), EPSILON);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY && maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (dataset instanceof XYIntervalSeriesCollection) {\n            // handle special case of XYIntervalSeriesCollection\n            XYIntervalSeriesCollection xyisc = (XYIntervalSeriesCollection) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = xyisc.getStartYValue(series, item);\n                    double uvalue = xyisc.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        } \n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset or if includeInterval is false\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        \n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\npublic static Range iterateRangeBounds(XYDataset dataset,\n        boolean includeInterval) {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n\n    // handle three cases by dataset type\n    if (includeInterval && dataset instanceof IntervalXYDataset) {\n        // handle special case of IntervalXYDataset\n        IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ixyd.getStartYValue(series, item);\n                double uvalue = ixyd.getEndYValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    else if (includeInterval && dataset instanceof OHLCDataset) {\n        // handle special case of OHLCDataset\n        OHLCDataset ohlc = (OHLCDataset) dataset;\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double lvalue = ohlc.getLowValue(series, item);\n                double uvalue = ohlc.getHighValue(series, item);\n                if (!Double.isNaN(lvalue)) {\n                    minimum = Math.min(minimum, lvalue);\n                }\n                if (!Double.isNaN(uvalue)) {\n                    maximum = Math.max(maximum, uvalue);\n                }\n            }\n        }\n    }\n    else {\n        // standard case - plain XYDataset\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getYValue(series, item);\n                if (!Double.isNaN(value)) {\n                    minimum = Math.min(minimum, value);\n                    maximum = Math.max(maximum, value);\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY && maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    }\n    else if (minimum == Double.POSITIVE_INFINITY) {\n        return new Range(maximum, maximum);\n    }\n    else if (maximum == Double.NEGATIVE_INFINITY) {\n        return new Range(minimum, minimum);\n    }\n    else {\n        return new Range(minimum, maximum);\n    }\n}\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (dataset != null) {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n"
                        ],
                        "evaluation_done": true
                    },
                    "2": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly <code>null</code>).\n     *\n     * @since 1.0.10\n     */\n\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBug2849731_3() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, 1.5, Double.NaN, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, Double.NaN, 2.5);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(2.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 3.5, Double.NaN);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(3.5, r.getUpperBound(), EPSILON);\n    }\n```\n#Error message: java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_3(DatasetUtilitiesTests.java:1299)  assertEquals(1.5, r.getLowerBound(), EPSILON);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic static Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } if (xRange == null) { throw new IllegalArgumentException(\\\"Null 'xRange' argument\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof OHLCDataset) { OHLCDataset ohlc = (OHLCDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ohlc.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ohlc.getLowValue(series, item); double uvalue = ohlc.getHighValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) { BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = bx.getXValue(series, item); if (xRange.contains(x)) { Number lvalue = bx.getMinRegularValue(series, item); Number uvalue = bx.getMaxRegularValue(series, item); if (lvalue != null) { minimum = Math.min(minimum, lvalue.doubleValue()); } if (uvalue != null) { maximum = Math.max(maximum, uvalue.doubleValue()); } } } } } else if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = ixyd.getXValue(series, item); if (xRange.contains(x)) { double lvalue = ixyd.getStartYValue(series, item); double uvalue = ixyd.getEndYValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); double y = dataset.getYValue(series, item); if (xRange.contains(x)) { if (!Double.isNaN(y)) { minimum = Math.min(minimum, y); maximum = Math.max(maximum, y); } } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }\n```\n\n            \n```java\npublic static int findLiveItemsUpperBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue > xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue <= xHigh) { return high; } int mid = (low + high) / 2; while (high - low > 1) { double midV = dataset.getXValue(series, mid); if (midV <= xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return mid; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; int mid = (low + high) / 2; double lowValue = dataset.getXValue(series, low); if (lowValue < xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue >= xLow) { return high; } while (high - low > 1) { double midV = dataset.getXValue(series, mid); if (midV >= xLow) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return mid; } else { int index = itemCount - 1; double x = dataset.getXValue(series, index); while (index >= 0 && (x < xLow || x > xHigh)) { index--; if (index >= 0) { x = dataset.getXValue(series, index); } } return Math.max(index, 0); } }\n```\n\n            \n```java\npublic static Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (visibleSeriesKeys == null) { throw new IllegalArgumentException(\\\"Null 'visibleSeriesKeys' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset ixyd = (IntervalXYDataset) dataset; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = ixyd.getStartXValue(series, item); double uvalue = ixyd.getEndXValue(series, item); if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); } if (!Double.isNaN(uvalue)) { maximum = Math.max(maximum, uvalue); } } } } else { Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); int series = dataset.indexOf(seriesKey); int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } if (minimum == Double.POSITIVE_INFINITY) { return null; } else { return new Range(minimum, maximum); } }\n```\n\n            \n```java\npublic static int findLiveItemsLowerBound(XYDataset dataset, int series, double xLow, double xHigh) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } if (xLow >= xHigh) { throw new IllegalArgumentException(\\\"Requires xLow < xHigh.\\\"); } int itemCount = dataset.getItemCount(series); if (itemCount <= 1) { return 0; } if (dataset.getDomainOrder() == DomainOrder.ASCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue >= xLow) { return low; } double highValue = dataset.getXValue(series, high); if (highValue < xLow) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV >= xLow) { high = mid; } else { low = mid; } } return high; } else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) { int low = 0; int high = itemCount - 1; double lowValue = dataset.getXValue(series, low); if (lowValue <= xHigh) { return low; } double highValue = dataset.getXValue(series, high); if (highValue > xHigh) { return high; } while (high - low > 1) { int mid = (low + high) / 2; double midV = dataset.getXValue(series, mid); if (midV > xHigh) { low = mid; } else { high = mid; } mid = (low + high) / 2; } return high; } else { int index = 0; double x = dataset.getXValue(series, index); while (index < itemCount && (x < xLow || x > xHigh)) { index++; if (index < itemCount) { x = dataset.getXValue(series, index); } } return Math.min(Math.max(0, index), itemCount - 1); } }\n```\n\n            \n```java\npublic static Range iterateDomainBounds(XYDataset dataset, boolean includeInterval) { if (dataset == null) { throw new IllegalArgumentException(\\\"Null 'dataset' argument.\\\"); } double minimum = Double.POSITIVE_INFINITY; double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); if (includeInterval && dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double lvalue = intervalXYData.getStartXValue(series, item); double uvalue = intervalXYData.getEndXValue(series, item); boolean hasValidInterval = false; double x = intervalXYData.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } if (!Double.isNaN(lvalue)) { minimum = Math.min(minimum, lvalue); maximum = Math.max(maximum, lvalue); hasValidInterval = true; } if (!Double.isNaN(uvalue)) { minimum = Math.min(minimum, uvalue); maximum = Math.max(maximum, uvalue); hasValidInterval = true; } } } } else { for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double x = dataset.getXValue(series, item); if (!Double.isNaN(x)) { minimum = Math.min(minimum, x); maximum = Math.max(maximum, x); } } } } return (minimum <= maximum) ? new Range(minimum, maximum) : null; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        \n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (dataset instanceof XYIntervalSeriesCollection) {\n            // handle special case for XYIntervalSeriesCollection\n            XYIntervalSeriesCollection xyInterval = (XYIntervalSeriesCollection) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = xyInterval.getYLowValue(series, item);\n                    double uvalue = xyInterval.getYHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset, boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' not permitted.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        } else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        } else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        } else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY && maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    double yValue = dataset.getYValue(series, item);  // Added this line\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                    if (!Double.isNaN(yValue)) {  // Added this block\n                        minimum = Math.min(minimum, yValue);\n                        maximum = Math.max(maximum, yValue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n",
                            "\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n"
                        ],
                        "evaluation_done": true
                    }
                }
            }
        ],
        "trigger_test": {
            "org.jfree.data.general.junit.DatasetUtilitiesTests::testBug2849731_2": {
                "path": "tests/org/jfree/data/general/junit/DatasetUtilitiesTests.java",
                "function_name": "testBug2849731_2",
                "src": "    public void testBug2849731_2() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.0, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 1.5, Double.NaN);\n        r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(0.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_2(DatasetUtilitiesTests.java:1276)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_2(DatasetUtilitiesTests.java:1276)  assertEquals(1.0, r.getLowerBound(), EPSILON);"
            },
            "org.jfree.data.general.junit.DatasetUtilitiesTests::testBug2849731_3": {
                "path": "tests/org/jfree/data/general/junit/DatasetUtilitiesTests.java",
                "function_name": "testBug2849731_3",
                "src": "    public void testBug2849731_3() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, 1.5, Double.NaN, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(1.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, 1.5, Double.NaN, Double.NaN, Double.NaN, 2.5);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(2.5, r.getUpperBound(), EPSILON);\n\n        s.add(1.0, Double.NaN, 0.5, Double.NaN, 3.5, Double.NaN);\n        r = DatasetUtilities.iterateRangeBounds(d);\n        assertEquals(1.5, r.getLowerBound(), EPSILON);\n        assertEquals(3.5, r.getUpperBound(), EPSILON);\n    }",
                "error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_3(DatasetUtilitiesTests.java:1299)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "java.lang.NullPointerException\n\tat org.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_3(DatasetUtilitiesTests.java:1299)  assertEquals(1.5, r.getLowerBound(), EPSILON);"
            }
        },
        "evaluation_done": true,
        "context_generation_done": true,
        "evaluation_done2": true
    }
}