{
    "Lang-60": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/java/org/apache/commons/lang/text/StrBuilder.java",
                "start_loc": 1671,
                "end_loc": 1679,
                "buggy_function": "    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
                "fixed_function": "    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < this.size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n",
                "comment": "    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n",
                "normalized_body": [
                    "public boolean contains(char ch) { char[] thisBuf = buffer; for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } return false; }"
                ],
                "top_similar_methods": [
                    [
                        1.0,
                        "public boolean contains(char ch) { char[] thisBuf = buffer; for (int i = 0; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return true; } } return false; }"
                    ],
                    [
                        0.9830572009086609,
                        "public Object get(int key) { Entry[] tab = table; int hash = key; int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) { if (e.hash == hash) { return e.value; } } return null; }"
                    ],
                    [
                        0.9829696416854858,
                        "public boolean containsKey(int key) { Entry[] tab = table; int hash = key; int index = (hash & 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) { if (e.hash == hash) { return true; } } return false; }"
                    ],
                    [
                        0.9821188449859619,
                        "public boolean equals(Object obj) { if (obj == this) { return true; } if (obj instanceof LongRange == false) { return false; } LongRange range = (LongRange) obj; return min == range.min && max == range.max; }"
                    ],
                    [
                        0.9816291332244873,
                        "public boolean equals(Object obj) { if (obj == this) { return true; } if (obj instanceof IntRange == false) { return false; } IntRange range = (IntRange) obj; return min == range.min && max == range.max; }"
                    ],
                    [
                        0.9803345799446106,
                        "public boolean contains(char ch) { for (Iterator it = set.iterator(); it.hasNext(); ) { CharRange range = (CharRange) it.next(); if (range.contains(ch)) { return true; } } return false; }"
                    ],
                    [
                        0.9773308038711548,
                        "public boolean overlapsRange(Range range) { if (range == null) { return false; } return range.containsLong(min) || range.containsLong(max) || containsLong(range.getMinimumLong()); }"
                    ]
                ],
                "non_directly_related_tests": [
                    "org.apache.commons.lang.text.StrBuilderTest::testLang295"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n```\n\n```java\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testLang295() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n        assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: The contains(char) method is looking beyond the end of the string\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n//-----------------------------------------------------------------------\n/**\n * Checks if the string builder contains the specified char.\n *\n * @param ch  the character to find\n * @return true if the builder contains the character\n */\n\npublic boolean contains(char ch) {\n    char[] thisBuf = buffer;\n    for (int i = 0; i < size; i++) {\n        if (thisBuf[i] == ch) {\n            return true;\n        }\n    }\n    return false;\n}\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) { // Use size instead of thisBuf.length\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) { // Use size instead of thisBuf.length\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) { // Iterate only up to 'size'\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n",
                            "\n//-----------------------------------------------------------------------\n/**\n * Checks if the string builder contains the specified char.\n *\n * @param ch  the character to find\n * @return true if the builder contains the character\n */\n\npublic boolean contains(char ch) {\n    char[] thisBuf = buffer;\n    for (int i = 0; i < size; i++) {  // Use size to stop at the correct length\n        if (thisBuf[i] == ch) {\n            return true;\n        }\n    }\n    return false;\n}\n",
                            "\n//-----------------------------------------------------------------------\n/**\n * Checks if the string builder contains the specified char.\n *\n * @param ch  the character to find\n * @return true if the builder contains the character\n */\n\npublic boolean contains(char ch) {\n    char[] thisBuf = buffer;\n    for (int i = 0; i < size; i++) {  // Use size instead of thisBuf.length\n        if (thisBuf[i] == ch) {\n            return true;\n        }\n    }\n    return false;\n}\n",
                            "\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n//-----------------------------------------------------------------------\n/**\n * Checks if the string builder contains the specified char.\n *\n * @param ch  the character to find\n * @return true if the builder contains the character\n */\n\npublic boolean contains(char ch) {\n    char[] thisBuf = buffer;\n    for (int i = 0; i < size; i++) {\n        if (thisBuf[i] == ch) {\n            return true;\n        }\n    }\n    return false;\n}\n"
                        ]
                    }
                }
            },
            {
                "path": "src/java/org/apache/commons/lang/text/StrBuilder.java",
                "start_loc": 1724,
                "end_loc": 1736,
                "buggy_function": "    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
                "fixed_function": "    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
                "comment": "    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n",
                "normalized_body": [
                    "public int indexOf(char ch, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (startIndex >= size) { return -1; } char[] thisBuf = buffer; for (int i = startIndex; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return i; } } return -1; }"
                ],
                "top_similar_methods": [
                    [
                        1.000000238418579,
                        "public int indexOf(char ch, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (startIndex >= size) { return -1; } char[] thisBuf = buffer; for (int i = startIndex; i < thisBuf.length; i++) { if (thisBuf[i] == ch) { return i; } } return -1; }"
                    ],
                    [
                        0.9823552370071411,
                        "public int indexOf(StrMatcher matcher, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (matcher == null || startIndex >= size) { return -1; } int len = size; char[] buf = buffer; for (int i = startIndex; i < len; i++) { if (matcher.isMatch(buf, i, startIndex, len) > 0) { return i; } } return -1; }"
                    ],
                    [
                        0.9783056974411011,
                        "public boolean startsWith(String str) { if (str == null) { return false; } int len = str.length(); if (len == 0) { return true; } if (len > size) { return false; } for (int i = 0; i < len; i++) { if (buffer[i] != str.charAt(i)) { return false; } } return true; }"
                    ],
                    [
                        0.9782031774520874,
                        "public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) { int len = chars.length; if (pos + len > bufferEnd) { return 0; } for (int i = 0; i < chars.length; i++, pos++) { if (chars[i] != buffer[pos]) { return 0; } } return len; }"
                    ],
                    [
                        0.9779841899871826,
                        "public StrBuilder replaceFirst(char search, char replace) { if (search != replace) { for (int i = 0; i < size; i++) { if (buffer[i] == search) { buffer[i] = replace; break; } } } return this; }"
                    ],
                    [
                        0.9754212498664856,
                        "private static boolean isDelimiter(char ch, char[] delimiters) { if (delimiters == null) { return Character.isWhitespace(ch); } for (int i = 0, isize = delimiters.length; i < isize; i++) { if (ch == delimiters[i]) { return true; } } return false; }"
                    ],
                    [
                        0.9744242429733276,
                        "public StrBuilder deleteFirst(String str) { int len = (str == null ? 0 : str.length()); if (len > 0) { int index = indexOf(str, 0); if (index >= 0) { deleteImpl(index, index + len, len); } } return this; }"
                    ]
                ],
                "non_directly_related_tests": [
                    "org.apache.commons.lang.text.StrBuilderTest::testLang295"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n    //-----------------------------------------------------------------------\n    /**\n     * Checks if the string builder contains the specified char.\n     *\n     * @param ch  the character to find\n     * @return true if the builder contains the character\n     */\n\n    public boolean contains(char ch) {\n        char[] thisBuf = buffer;\n        for (int i = 0; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n```\n\n```java\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < thisBuf.length; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testLang295() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n        assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n    }\n```\n#Error message from the test method 1: junit.framework.AssertionFailedError: The contains(char) method is looking beyond the end of the string\n\n---\n\n## Your Goal\n\nFix the buggy methods. Return only the fixed Java methods. Do not include explanations or other text.\n",
                        "patches": [
                            "\n/**\n * Searches the string builder to find the first reference to the specified char.\n * \n * @param ch  the character to find\n * @param startIndex  the index to start at, invalid index rounded to edge\n * @return the first index of the character, or -1 if not found\n */\n\npublic int indexOf(char ch, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (startIndex >= size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    for (int i = startIndex; i < size; i++) {\n        if (thisBuf[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) { // Use size instead of thisBuf.length\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) { // Use size instead of thisBuf.length\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) { // Iterate only up to 'size'\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n",
                            "\n/**\n * Searches the string builder to find the first reference to the specified char.\n * \n * @param ch  the character to find\n * @param startIndex  the index to start at, invalid index rounded to edge\n * @return the first index of the character, or -1 if not found\n */\n\npublic int indexOf(char ch, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (startIndex >= size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    for (int i = startIndex; i < size; i++) {  // Use size to stop at the correct length\n        if (thisBuf[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}\n",
                            "\n/**\n * Searches the string builder to find the first reference to the specified char.\n * \n * @param ch  the character to find\n * @param startIndex  the index to start at, invalid index rounded to edge\n * @return the first index of the character, or -1 if not found\n */\n\npublic int indexOf(char ch, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (startIndex >= size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    for (int i = startIndex; i < size; i++) {  // Use size instead of thisBuf.length\n        if (thisBuf[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}\n",
                            "\n    /**\n     * Searches the string builder to find the first reference to the specified char.\n     * \n     * @param ch  the character to find\n     * @param startIndex  the index to start at, invalid index rounded to edge\n     * @return the first index of the character, or -1 if not found\n     */\n\n    public int indexOf(char ch, int startIndex) {\n        startIndex = (startIndex < 0 ? 0 : startIndex);\n        if (startIndex >= size) {\n            return -1;\n        }\n        char[] thisBuf = buffer;\n        for (int i = startIndex; i < size; i++) {\n            if (thisBuf[i] == ch) {\n                return i;\n            }\n        }\n        return -1;\n    }\n"
                        ],
                        "plausible_patches": [
                            "\n/**\n * Searches the string builder to find the first reference to the specified char.\n * \n * @param ch  the character to find\n * @param startIndex  the index to start at, invalid index rounded to edge\n * @return the first index of the character, or -1 if not found\n */\n\npublic int indexOf(char ch, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (startIndex >= size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n    for (int i = startIndex; i < size; i++) {\n        if (thisBuf[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.lang.text.StrBuilderTest::testLang295": {
                "path": "src/test/org/apache/commons/lang/text/StrBuilderTest.java",
                "function_name": "testLang295",
                "src": "    public void testLang295() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));\n        assertEquals( \"The indexOf(char) method is looking beyond the end of the string\", -1, sb.indexOf('h'));\n    }",
                "error_msg": "junit.framework.AssertionFailedError: The contains(char) method is looking beyond the end of the string\n\tat junit.framework.Assert.fail(Assert.java:57)\n\tat junit.framework.Assert.assertTrue(Assert.java:22)\n\tat junit.framework.Assert.assertFalse(Assert.java:39)\n\tat junit.framework.TestCase.assertFalse(TestCase.java:210)\n\tat org.apache.commons.lang.text.StrBuilderTest.testLang295(StrBuilderTest.java:1748)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.AssertionFailedError: The contains(char) method is looking beyond the end of the string\n\tat org.apache.commons.lang.text.StrBuilderTest.testLang295(StrBuilderTest.java:1748)  assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h'));"
            }
        },
        "evaluation_done": true
    }
}