{
    "Lang-63": {
        "function_num": 2,
        "functions": [
            {
                "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
                "start_loc": 262,
                "end_loc": 361,
                "buggy_function": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it's contextual - if asked for no M in the format then I should probably \n// be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                "fixed_function": "    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it's contextual - if asked for no M in the format then I should probably \n// be doing no calculating here.\n            months -= 1;\n            end.add(Calendar.MONTH, 1);\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                "comment": "    /**\n     * <p>Formats the time gap as a string, using the specified format.\n     * Padding the left hand side of numbers with zeroes is optional and \n     * the timezone may be specified. \n     * \n     * @param startMillis  the start of the duration\n     * @param endMillis  the end of the duration\n     * @param format  the way in which to format the duration\n     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n     * @param timezone the millis are defined in\n     * @return the time as a String\n     */\n",
                "normalized_body": [
                    "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) { long millis = endMillis - startMillis; if (millis < 28 * DateUtils.MILLIS_PER_DAY) { return formatDuration(millis, format, padWithZeros); } Token[] tokens = lexx(format); Calendar start = Calendar.getInstance(timezone); start.setTime(new Date(startMillis)); Calendar end = Calendar.getInstance(timezone); end.setTime(new Date(endMillis)); int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); while (milliseconds < 0) { milliseconds += 1000; seconds -= 1; } while (seconds < 0) { seconds += 60; minutes -= 1; } while (minutes < 0) { minutes += 60; hours -= 1; } while (hours < 0) { hours += 24; days -= 1; } while (days < 0) { days += 31; months -= 1; } while (months < 0) { months += 12; years -= 1; } milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years); if (!Token.containsTokenWithValue(tokens, y)) { if (Token.containsTokenWithValue(tokens, M)) { months += 12 * years; years = 0; } else { days += 365 * years; years = 0; } } if (!Token.containsTokenWithValue(tokens, M)) { days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); months = 0; } if (!Token.containsTokenWithValue(tokens, d)) { hours += 24 * days; days = 0; } if (!Token.containsTokenWithValue(tokens, H)) { minutes += 60 * hours; hours = 0; } if (!Token.containsTokenWithValue(tokens, m)) { seconds += 60 * minutes; minutes = 0; } if (!Token.containsTokenWithValue(tokens, s)) { milliseconds += 1000 * seconds; seconds = 0; } return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); }"
                ],
                "top_similar_methods": [
                    [
                        1.0000001192092896,
                        "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) { long millis = endMillis - startMillis; if (millis < 28 * DateUtils.MILLIS_PER_DAY) { return formatDuration(millis, format, padWithZeros); } Token[] tokens = lexx(format); Calendar start = Calendar.getInstance(timezone); start.setTime(new Date(startMillis)); Calendar end = Calendar.getInstance(timezone); end.setTime(new Date(endMillis)); int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND); int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND); int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE); int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY); int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH); int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH); int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR); while (milliseconds < 0) { milliseconds += 1000; seconds -= 1; } while (seconds < 0) { seconds += 60; minutes -= 1; } while (minutes < 0) { minutes += 60; hours -= 1; } while (hours < 0) { hours += 24; days -= 1; } while (days < 0) { days += 31; months -= 1; } while (months < 0) { months += 12; years -= 1; } milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds); seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds); minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes); hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours); days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days); months -= reduceAndCorrect(start, end, Calendar.MONTH, months); years -= reduceAndCorrect(start, end, Calendar.YEAR, years); if (!Token.containsTokenWithValue(tokens, y)) { if (Token.containsTokenWithValue(tokens, M)) { months += 12 * years; years = 0; } else { days += 365 * years; years = 0; } } if (!Token.containsTokenWithValue(tokens, M)) { days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR); months = 0; } if (!Token.containsTokenWithValue(tokens, d)) { hours += 24 * days; days = 0; } if (!Token.containsTokenWithValue(tokens, H)) { minutes += 60 * hours; hours = 0; } if (!Token.containsTokenWithValue(tokens, m)) { seconds += 60 * minutes; minutes = 0; } if (!Token.containsTokenWithValue(tokens, s)) { milliseconds += 1000 * seconds; seconds = 0; } return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros); }"
                    ],
                    [
                        0.9776671528816223,
                        "protected List parsePattern() { DateFormatSymbols symbols = new DateFormatSymbols(mLocale); List rules = new ArrayList(); String[] ERAs = symbols.getEras(); String[] months = symbols.getMonths(); String[] shortMonths = symbols.getShortMonths(); String[] weekdays = symbols.getWeekdays(); String[] shortWeekdays = symbols.getShortWeekdays(); String[] AmPmStrings = symbols.getAmPmStrings(); int length = mPattern.length(); int[] indexRef = new int[1]; for (int i = 0; i < length; i++) { indexRef[0] = i; String token = parseToken(mPattern, indexRef); i = indexRef[0]; int tokenLen = token.length(); if (tokenLen == 0) { break; } Rule rule; char c = token.charAt(0); switch(c) { case 'G': rule = new TextField(Calendar.ERA, ERAs); break; case 'y': if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE; } break; case 'M': if (tokenLen >= 4) { rule = new TextField(Calendar.MONTH, months); } else if (tokenLen == 3) { rule = new TextField(Calendar.MONTH, shortMonths); } else if (tokenLen == 2) { rule = TwoDigitMonthField.INSTANCE; } else { rule = UnpaddedMonthField.INSTANCE; } break; case 'd': rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen); break; case 'h': rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen)); break; case 'H': rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen); break; case 'm': rule = selectNumberRule(Calendar.MINUTE, tokenLen); break; case 's': rule = selectNumberRule(Calendar.SECOND, tokenLen); break; case 'S': rule = selectNumberRule(Calendar.MILLISECOND, tokenLen); break; case 'E': rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays); break; case 'D': rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen); break; case 'F': rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen); break; case 'w': rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen); break; case 'W': rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen); break; case 'a': rule = new TextField(Calendar.AM_PM, AmPmStrings); break; case 'k': rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen)); break; case 'K': rule = selectNumberRule(Calendar.HOUR, tokenLen); break; case 'z': if (tokenLen >= 4) { rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG); } else { rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT); } break; case 'Z': if (tokenLen == 1) { rule = TimeZoneNumberRule.INSTANCE_NO_COLON; } else { rule = TimeZoneNumberRule.INSTANCE_COLON; } break; case '\\'': String sub = token.substring(1); if (sub.length() == 1) { rule = new CharacterLiteral(sub.charAt(0)); } else { rule = new StringLiteral(sub); } break; default: throw new IllegalArgumentException(\\\"Illegal pattern component: \\\" + token); } rules.add(rule); } return rules; }"
                    ],
                    [
                        0.9765288233757019,
                        "public static String formatDuration(long durationMillis, String format, boolean padWithZeros) { Token[] tokens = lexx(format); int days = 0; int hours = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; if (Token.containsTokenWithValue(tokens, d)) { days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY); durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY); } if (Token.containsTokenWithValue(tokens, H)) { hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR); durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR); } if (Token.containsTokenWithValue(tokens, m)) { minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE); durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE); } if (Token.containsTokenWithValue(tokens, s)) { seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND); durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND); } if (Token.containsTokenWithValue(tokens, S)) { milliseconds = (int) durationMillis; } return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros); }"
                    ],
                    [
                        0.9763329923152924,
                        "public void testSubtract() { Fraction f = null; Fraction f1 = null; Fraction f2 = null; f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(1, 5); f = f1.subtract(f2); assertEquals(2, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(7, 5); f2 = Fraction.getFraction(2, 5); f = f1.subtract(f2); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(3, 5); f = f1.subtract(f2); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(-4, 5); f = f1.subtract(f2); assertEquals(7, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(4, 5); f = f1.subtract(f2); assertEquals(-4, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(-4, 5); f = f1.subtract(f2); assertEquals(4, f.getNumerator()); assertEquals(5, f.getDenominator()); f1 = Fraction.getFraction(3, 5); f2 = Fraction.getFraction(1, 2); f = f1.subtract(f2); assertEquals(1, f.getNumerator()); assertEquals(10, f.getDenominator()); f1 = Fraction.getFraction(0, 5); f2 = Fraction.getFraction(1, 5); f = f2.subtract(f1); assertSame(f2, f); try { f.subtract(null); fail(\\\"expecting IllegalArgumentException\\\"); } catch (IllegalArgumentException ex) { } f1 = Fraction.getFraction(1, 32768 * 3); f2 = Fraction.getFraction(1, 59049); f = f1.subtract(f2); assertEquals(-13085, f.getNumerator()); assertEquals(1934917632, f.getDenominator()); f1 = Fraction.getFraction(Integer.MIN_VALUE, 3); f2 = Fraction.ONE_THIRD.negate(); f = f1.subtract(f2); assertEquals(Integer.MIN_VALUE + 1, f.getNumerator()); assertEquals(3, f.getDenominator()); f1 = Fraction.getFraction(Integer.MAX_VALUE, 1); f2 = Fraction.ONE; f = f1.subtract(f2); assertEquals(Integer.MAX_VALUE - 1, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f1 = Fraction.getFraction(1, Integer.MAX_VALUE); f2 = Fraction.getFraction(1, Integer.MAX_VALUE - 1); f = f1.subtract(f2); fail(\\\"expecting ArithmeticException\\\"); } catch (ArithmeticException ex) { } f1 = Fraction.getFraction(Integer.MIN_VALUE, 5); f2 = Fraction.getFraction(1, 5); try { f = f1.subtract(f2); fail(\\\"expecting ArithmeticException but got: \\\" + f.toString()); } catch (ArithmeticException ex) { } try { f = Fraction.getFraction(Integer.MIN_VALUE, 1); f = f.subtract(Fraction.ONE); fail(\\\"expecting ArithmeticException\\\"); } catch (ArithmeticException ex) { } try { f = Fraction.getFraction(Integer.MAX_VALUE, 1); f = f.subtract(Fraction.ONE.negate()); fail(\\\"expecting ArithmeticException\\\"); } catch (ArithmeticException ex) { } f1 = Fraction.getFraction(3, 327680); f2 = Fraction.getFraction(2, 59049); try { f = f1.subtract(f2); fail(\\\"expecting ArithmeticException but got: \\\" + f.toString()); } catch (ArithmeticException ex) { } }"
                    ],
                    [
                        0.9753258228302002,
                        "public void testFactory_String_improper() { Fraction f = null; f = Fraction.getFraction(\\\"0/1\\\"); assertEquals(0, f.getNumerator()); assertEquals(1, f.getDenominator()); f = Fraction.getFraction(\\\"1/5\\\"); assertEquals(1, f.getNumerator()); assertEquals(5, f.getDenominator()); f = Fraction.getFraction(\\\"1/2\\\"); assertEquals(1, f.getNumerator()); assertEquals(2, f.getDenominator()); f = Fraction.getFraction(\\\"2/3\\\"); assertEquals(2, f.getNumerator()); assertEquals(3, f.getDenominator()); f = Fraction.getFraction(\\\"7/3\\\"); assertEquals(7, f.getNumerator()); assertEquals(3, f.getDenominator()); f = Fraction.getFraction(\\\"2/4\\\"); assertEquals(2, f.getNumerator()); assertEquals(4, f.getDenominator()); try { f = Fraction.getFraction(\\\"2/d\\\"); fail(\\\"expecting NumberFormatException\\\"); } catch (NumberFormatException ex) { } try { f = Fraction.getFraction(\\\"2e/3\\\"); fail(\\\"expecting NumberFormatException\\\"); } catch (NumberFormatException ex) { } try { f = Fraction.getFraction(\\\"2/\\\"); fail(\\\"expecting NumberFormatException\\\"); } catch (NumberFormatException ex) { } try { f = Fraction.getFraction(\\\"/\\\"); fail(\\\"expecting NumberFormatException\\\"); } catch (NumberFormatException ex) { } }"
                    ],
                    [
                        0.975282222032547,
                        "public void testParse() throws Exception { Calendar now = null; now = Calendar.getInstance(); now.add(Calendar.MINUTE, -1); assertEquals(\\\"parse 1 minute ago\\\", now, CalendarUtils.parse(\\\"1 minute ago\\\"), 50); now = Calendar.getInstance(); now.add(Calendar.MINUTE, -8); assertEquals(\\\"parse 8 minutes ago\\\", now, CalendarUtils.parse(\\\"8 minutes ago\\\"), 50); now = Calendar.getInstance(); now.add(Calendar.DATE, -1); assertEquals(\\\"parse yesterday\\\", now, CalendarUtils.parse(\\\"yesterday\\\"), 50); now = Calendar.getInstance(); now.add(Calendar.DATE, 1); assertEquals(\\\"parse tomorrow\\\", now, CalendarUtils.parse(\\\"tomorrow\\\"), 50); now = Calendar.getInstance(); if (now.get(Calendar.DATE) == 1) { now.add(Calendar.DATE, -7); } else { now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK)); } assertEquals(\\\"parse last Sunday\\\", now, CalendarUtils.parse(\\\"last Sunday\\\"), 50); now = Calendar.getInstance(); now.add(Calendar.DATE, -7); assertEquals(\\\"parse last week\\\", now, CalendarUtils.parse(\\\"last week\\\"), 50); now = Calendar.getInstance(); if (now.get(Calendar.MONTH) == 0) { now.add(Calendar.MONTH, -12); } else { now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH)); } assertEquals(\\\"parse last January\\\", now, CalendarUtils.parse(\\\"last January\\\"), 50); }"
                    ],
                    [
                        0.9750816822052002,
                        "public void testTruncate() throws Exception { assertEquals(\\\"truncate year-1 failed\\\", dateParser.parse(\\\"January 1, 2002\\\"), DateUtils.truncate(date1, Calendar.YEAR)); assertEquals(\\\"truncate year-2 failed\\\", dateParser.parse(\\\"January 1, 2001\\\"), DateUtils.truncate(date2, Calendar.YEAR)); assertEquals(\\\"truncate month-1 failed\\\", dateParser.parse(\\\"February 1, 2002\\\"), DateUtils.truncate(date1, Calendar.MONTH)); assertEquals(\\\"truncate month-2 failed\\\", dateParser.parse(\\\"November 1, 2001\\\"), DateUtils.truncate(date2, Calendar.MONTH)); assertEquals(\\\"truncate semimonth-1 failed\\\", dateParser.parse(\\\"February 1, 2002\\\"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH)); assertEquals(\\\"truncate semimonth-2 failed\\\", dateParser.parse(\\\"November 16, 2001\\\"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH)); assertEquals(\\\"truncate date-1 failed\\\", dateParser.parse(\\\"February 12, 2002\\\"), DateUtils.truncate(date1, Calendar.DATE)); assertEquals(\\\"truncate date-2 failed\\\", dateParser.parse(\\\"November 18, 2001\\\"), DateUtils.truncate(date2, Calendar.DATE)); assertEquals(\\\"truncate hour-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:00:00.000\\\"), DateUtils.truncate(date1, Calendar.HOUR)); assertEquals(\\\"truncate hour-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:00:00.000\\\"), DateUtils.truncate(date2, Calendar.HOUR)); assertEquals(\\\"truncate minute-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:34:00.000\\\"), DateUtils.truncate(date1, Calendar.MINUTE)); assertEquals(\\\"truncate minute-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:23:00.000\\\"), DateUtils.truncate(date2, Calendar.MINUTE)); assertEquals(\\\"truncate second-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:34:56.000\\\"), DateUtils.truncate(date1, Calendar.SECOND)); assertEquals(\\\"truncate second-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:23:11.000\\\"), DateUtils.truncate(date2, Calendar.SECOND)); assertEquals(\\\"truncate ampm-1 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 00:00:00.000\\\"), DateUtils.truncate(dateAmPm1, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-2 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 00:00:00.000\\\"), DateUtils.truncate(dateAmPm2, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-3 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 12:00:00.000\\\"), DateUtils.truncate(dateAmPm3, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-4 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 12:00:00.000\\\"), DateUtils.truncate(dateAmPm4, Calendar.AM_PM)); assertEquals(\\\"truncate year-1 failed\\\", dateParser.parse(\\\"January 1, 2002\\\"), DateUtils.truncate((Object) date1, Calendar.YEAR)); assertEquals(\\\"truncate year-2 failed\\\", dateParser.parse(\\\"January 1, 2001\\\"), DateUtils.truncate((Object) date2, Calendar.YEAR)); assertEquals(\\\"truncate month-1 failed\\\", dateParser.parse(\\\"February 1, 2002\\\"), DateUtils.truncate((Object) date1, Calendar.MONTH)); assertEquals(\\\"truncate month-2 failed\\\", dateParser.parse(\\\"November 1, 2001\\\"), DateUtils.truncate((Object) date2, Calendar.MONTH)); assertEquals(\\\"truncate semimonth-1 failed\\\", dateParser.parse(\\\"February 1, 2002\\\"), DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH)); assertEquals(\\\"truncate semimonth-2 failed\\\", dateParser.parse(\\\"November 16, 2001\\\"), DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH)); assertEquals(\\\"truncate date-1 failed\\\", dateParser.parse(\\\"February 12, 2002\\\"), DateUtils.truncate((Object) date1, Calendar.DATE)); assertEquals(\\\"truncate date-2 failed\\\", dateParser.parse(\\\"November 18, 2001\\\"), DateUtils.truncate((Object) date2, Calendar.DATE)); assertEquals(\\\"truncate hour-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:00:00.000\\\"), DateUtils.truncate((Object) date1, Calendar.HOUR)); assertEquals(\\\"truncate hour-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:00:00.000\\\"), DateUtils.truncate((Object) date2, Calendar.HOUR)); assertEquals(\\\"truncate minute-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:34:00.000\\\"), DateUtils.truncate((Object) date1, Calendar.MINUTE)); assertEquals(\\\"truncate minute-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:23:00.000\\\"), DateUtils.truncate((Object) date2, Calendar.MINUTE)); assertEquals(\\\"truncate second-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:34:56.000\\\"), DateUtils.truncate((Object) date1, Calendar.SECOND)); assertEquals(\\\"truncate second-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:23:11.000\\\"), DateUtils.truncate((Object) date2, Calendar.SECOND)); assertEquals(\\\"truncate ampm-1 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 00:00:00.000\\\"), DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-2 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 00:00:00.000\\\"), DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-3 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 12:00:00.000\\\"), DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-4 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 12:00:00.000\\\"), DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM)); assertEquals(\\\"truncate calendar second-1 failed\\\", dateTimeParser.parse(\\\"February 12, 2002 12:34:56.000\\\"), DateUtils.truncate((Object) cal1, Calendar.SECOND)); assertEquals(\\\"truncate calendar second-2 failed\\\", dateTimeParser.parse(\\\"November 18, 2001 1:23:11.000\\\"), DateUtils.truncate((Object) cal2, Calendar.SECOND)); assertEquals(\\\"truncate ampm-1 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 00:00:00.000\\\"), DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-2 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 00:00:00.000\\\"), DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-3 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 12:00:00.000\\\"), DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM)); assertEquals(\\\"truncate ampm-4 failed\\\", dateTimeParser.parse(\\\"February 3, 2002 12:00:00.000\\\"), DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM)); try { DateUtils.truncate((Date) null, Calendar.SECOND); fail(); } catch (IllegalArgumentException ex) { } try { DateUtils.truncate((Calendar) null, Calendar.SECOND); fail(); } catch (IllegalArgumentException ex) { } try { DateUtils.truncate((Object) null, Calendar.SECOND); fail(); } catch (IllegalArgumentException ex) { } try { DateUtils.truncate(\\\"\\\", Calendar.SECOND); fail(); } catch (ClassCastException ex) { } TimeZone.setDefault(zone); dateTimeParser.setTimeZone(zone); assertEquals(\\\"truncate MET date across DST change-over\\\", dateTimeParser.parse(\\\"March 30, 2003 00:00:00.000\\\"), DateUtils.truncate(date3, Calendar.DATE)); assertEquals(\\\"truncate MET date across DST change-over\\\", dateTimeParser.parse(\\\"March 30, 2003 00:00:00.000\\\"), DateUtils.truncate((Object) cal3, Calendar.DATE)); assertEquals(\\\"truncate MET date across DST change-over\\\", dateTimeParser.parse(\\\"October 26, 2003 00:00:00.000\\\"), DateUtils.truncate(date8, Calendar.DATE)); assertEquals(\\\"truncate MET date across DST change-over\\\", dateTimeParser.parse(\\\"October 26, 2003 00:00:00.000\\\"), DateUtils.truncate((Object) cal8, Calendar.DATE)); TimeZone.setDefault(defaultZone); dateTimeParser.setTimeZone(defaultZone); Date endOfTime = new Date(Long.MAX_VALUE); GregorianCalendar endCal = new GregorianCalendar(); endCal.setTime(endOfTime); try { DateUtils.truncate(endCal, Calendar.DATE); fail(); } catch (ArithmeticException ex) { } endCal.set(Calendar.YEAR, 280000001); try { DateUtils.truncate(endCal, Calendar.DATE); fail(); } catch (ArithmeticException ex) { } endCal.set(Calendar.YEAR, 280000000); Calendar cal = DateUtils.truncate(endCal, Calendar.DATE); assertEquals(0, cal.get(Calendar.HOUR)); }"
                    ]
                ],
                "directly_related_tests": [
                    "org.apache.commons.lang.time.DurationFormatUtilsTest::testJiraLang281"
                ],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n    /**\n     * <p>Formats the time gap as a string, using the specified format.\n     * Padding the left hand side of numbers with zeroes is optional and \n     * the timezone may be specified. \n     * \n     * @param startMillis  the start of the duration\n     * @param endMillis  the end of the duration\n     * @param format  the way in which to format the duration\n     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n     * @param timezone the millis are defined in\n     * @return the time as a String\n     */\n\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            days += 31;\n//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n// Also it's contextual - if asked for no M in the format then I should probably \n// be doing no calculating here.\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testJiraLang281() {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 31);\n        cal.set(Calendar.YEAR, 2005);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        Calendar cal2 = Calendar.getInstance();\n        cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n        cal2.set(Calendar.DAY_OF_MONTH, 6);\n        cal2.set(Calendar.YEAR, 2006);\n        cal2.set(Calendar.HOUR_OF_DAY, 0);\n        cal2.set(Calendar.MINUTE, 0);\n        cal2.set(Calendar.SECOND, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n        String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n        assertEquals(\"09\", result);\n    }\n```\n#Error message: junit.framework.ComparisonFailure: expected:<[09]> but was:<[-2]>\n\tat org.apache.commons.lang.time.DurationFormatUtilsTest.testJiraLang281(DurationFormatUtilsTest.java:436)  assertEquals(\"09\", result);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            start.add(Calendar.MONTH, 1);\n            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                            "\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n        TimeZone timezone) {\n\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n\n    Token[] tokens = lexx(format);\n\n    // timezones get funky around 0, so normalizing everything to GMT \n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n\n    while (days < 0) {\n        start.add(Calendar.MONTH, 1);\n        days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n    // This next block of code adds in values that \n    // aren't requested. This allows the user to ask for the \n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n",
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        \n        // Fix to account for correct month calculation\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n        \n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            end.add(Calendar.MONTH, -1);\n            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                            "\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n        TimeZone timezone) {\n\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n\n    Token[] tokens = lexx(format);\n\n    // timezones get funky around 0, so normalizing everything to GMT \n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        start.add(Calendar.MONTH, -1);\n        days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n    // This next block of code adds in values that \n    // aren't requested. This allows the user to ask for the \n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n",
                            "\npublic static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n        TimeZone timezone) {\n\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n\n    Token[] tokens = lexx(format);\n\n    // timezones get funky around 0, so normalizing everything to GMT \n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        start.add(Calendar.MONTH, 1);\n        days = end.getActualMaximum(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH) + end.get(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n    // This next block of code adds in values that \n    // aren't requested. This allows the user to ask for the \n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n",
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            start.add(Calendar.MONTH, 1);\n            days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                days += (365 * years);\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n",
                            "\n    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n            TimeZone timezone) {\n\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n\n        Token[] tokens = lexx(format);\n\n        // timezones get funky around 0, so normalizing everything to GMT \n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTime(new Date(startMillis));\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTime(new Date(endMillis));\n\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            start.add(Calendar.MONTH, 1);\n            days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n            months -= 1;\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n\n        // This next block of code adds in values that \n        // aren't requested. This allows the user to ask for the \n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n"
                        ]
                    }
                }
            },
            {
                "path": "src/java/org/apache/commons/lang/time/DurationFormatUtils.java",
                "start_loc": 432,
                "end_loc": 443,
                "buggy_function": "    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n",
                "fixed_function": null,
                "comment": "",
                "normalized_body": [
                    "static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add(field, -1 * difference); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add(field, newdiff); return newdiff; } else { return 0; } }"
                ],
                "top_similar_methods": [
                    [
                        0.9999997615814209,
                        "static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) { end.add(field, -1 * difference); int endValue = end.get(field); int startValue = start.get(field); if (endValue < startValue) { int newdiff = startValue - endValue; end.add(field, newdiff); return newdiff; } else { return 0; } }"
                    ],
                    [
                        0.9583269357681274,
                        "public static boolean isSameLength(int[] array1, int[] array2) { if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { return false; } return true; }"
                    ],
                    [
                        0.9526068568229675,
                        "public static boolean isSameLength(long[] array1, long[] array2) { if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { return false; } return true; }"
                    ],
                    [
                        0.9516812562942505,
                        "private double chiSquare(int[] expected, int[] observed) { double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { dev = (double) (observed[i] - expected[i]); sumSq += dev * dev / (double) expected[i]; } return sumSq; }"
                    ],
                    [
                        0.9516812562942505,
                        "private double chiSquare(int[] expected, int[] observed) { double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { dev = (double) (observed[i] - expected[i]); sumSq += dev * dev / (double) expected[i]; } return sumSq; }"
                    ],
                    [
                        0.9516420364379883,
                        "public static boolean isSameLength(boolean[] array1, boolean[] array2) { if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { return false; } return true; }"
                    ],
                    [
                        0.9511900544166565,
                        "public static boolean isSameLength(short[] array1, short[] array2) { if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length != array2.length)) { return false; } return true; }"
                    ]
                ],
                "Compiling error!": true,
                "non_directly_related_tests": [],
                "generation": {
                    "1": {
                        "prompt": "You are an expert Java developer. Below are buggy method(s) from a large Java project. These methods cause one or more test failures.\nYour task is to fix the bugs in these methods. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Methods\n\n\n```java\n\n    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add( field, -1 * difference );\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n            end.add( field, newdiff );\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n\n```\n\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testJiraLang281() {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 31);\n        cal.set(Calendar.YEAR, 2005);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        Calendar cal2 = Calendar.getInstance();\n        cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n        cal2.set(Calendar.DAY_OF_MONTH, 6);\n        cal2.set(Calendar.YEAR, 2006);\n        cal2.set(Calendar.HOUR_OF_DAY, 0);\n        cal2.set(Calendar.MINUTE, 0);\n        cal2.set(Calendar.SECOND, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n        String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n        assertEquals(\"09\", result);\n    }\n```\n#Error message from the test method 1: junit.framework.ComparisonFailure: expected:<[09]> but was:<[-2]>\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
                        "patches": [
                            "\n    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add(field, -1 * difference);\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        \n        int fieldMax = end.getActualMaximum(field);\n\n        if (endValue < startValue) {\n            int newdiff = (startValue - endValue + fieldMax) % fieldMax;\n            end.add(field, newdiff);\n            return newdiff;\n        } else {\n            return 0;\n        }\n    }\n",
                            "\n    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n        end.add(field, -1 * difference);\n        int endValue = end.get(field);\n        int startValue = start.get(field);\n        if (endValue < startValue) {\n            int newdiff = startValue - endValue;\n            end.add(field, newdiff);\n            return -difference + newdiff;\n        } else {\n            return -difference;\n        }\n    }\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        end.add(field, 1); // Add one more to correct the field\n        int newdiff = end.get(field) - startValue;\n        return newdiff;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = (startValue - endValue) + (difference < 0 ? -1 : 1) * end.getActualMaximum(field);\n        end.add(field, difference < 0 ? -newdiff : newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = (startValue - endValue) + 1;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int fieldDifference = startValue - endValue;\n        end.add(field, fieldDifference);\n        return fieldDifference;\n    } else if (endValue > startValue) {\n        int maxFieldValue = end.getActualMaximum(field);\n        int newDiff = maxFieldValue + startValue - endValue + 1;\n        end.add(field, newDiff);\n        return -newDiff;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        while (endValue < startValue) {\n            end.add(field, 1);\n            endValue = end.get(field);\n        }\n        return endValue - startValue;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    int startValue = start.get(field);\n    end.add(field, -difference);\n    int endValue = end.get(field);\n\n    if (endValue < startValue) {\n        int newdiff = startValue - endValue;\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    \n    if (endValue < startValue) {\n        end.add(field, difference);\n        return difference;\n    } else {\n        return 0;\n    }\n}\n",
                            "\nstatic int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n    end.add(field, -1 * difference);\n    int endValue = end.get(field);\n    int startValue = start.get(field);\n    if (endValue < startValue) {\n        int newdiff = 1; // move forward by one to account for the underflow\n        end.add(field, newdiff);\n        return newdiff;\n    } else {\n        return 0;\n    }\n}\n"
                        ]
                    }
                }
            }
        ],
        "trigger_test": {
            "org.apache.commons.lang.time.DurationFormatUtilsTest::testJiraLang281": {
                "path": "src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java",
                "function_name": "testJiraLang281",
                "src": "    public void testJiraLang281() {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 31);\n        cal.set(Calendar.YEAR, 2005);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        Calendar cal2 = Calendar.getInstance();\n        cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n        cal2.set(Calendar.DAY_OF_MONTH, 6);\n        cal2.set(Calendar.YEAR, 2006);\n        cal2.set(Calendar.HOUR_OF_DAY, 0);\n        cal2.set(Calendar.MINUTE, 0);\n        cal2.set(Calendar.SECOND, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n        String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n        assertEquals(\"09\", result);\n    }",
                "error_msg": "junit.framework.ComparisonFailure: expected:<[09]> but was:<[-2]>\n\tat junit.framework.Assert.assertEquals(Assert.java:100)\n\tat junit.framework.Assert.assertEquals(Assert.java:107)\n\tat junit.framework.TestCase.assertEquals(TestCase.java:269)\n\tat org.apache.commons.lang.time.DurationFormatUtilsTest.testJiraLang281(DurationFormatUtilsTest.java:436)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat junit.framework.TestCase.runTest(TestCase.java:176)\n\tat junit.framework.TestCase.runBare(TestCase.java:141)\n\tat junit.framework.TestResult$1.protect(TestResult.java:122)\n\tat junit.framework.TestResult.runProtected(TestResult.java:142)\n\tat junit.framework.TestResult.run(TestResult.java:125)\n\tat junit.framework.TestCase.run(TestCase.java:129)\n\tat junit.framework.TestSuite.runTest(TestSuite.java:255)\n\tat junit.framework.TestSuite.run(TestSuite.java:250)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\tat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\tat org.apache.tools.ant.Task.perform(Task.java:348)\n\tat org.apache.tools.ant.Target.execute(Target.java:392)\n\tat org.apache.tools.ant.Target.performTasks(Target.java:413)\n\tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n\tat org.apache.tools.ant.Main.runBuild(Main.java:811)\n\tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n\tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n\tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
                "clean_error_msg": "junit.framework.ComparisonFailure: expected:<[09]> but was:<[-2]>\n\tat org.apache.commons.lang.time.DurationFormatUtilsTest.testJiraLang281(DurationFormatUtilsTest.java:436)  assertEquals(\"09\", result);"
            }
        }
    }
}