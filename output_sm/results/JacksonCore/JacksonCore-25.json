{
    "JacksonCore-25": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// Ok, let's add char to output:\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testUnquotedIssue510() throws Exception\n\n    {\n\n        // NOTE! Requires longer input buffer to trigger longer codepath\n\n        char[] fullChars = new char[4001];\n\n        for (int i = 0; i < 3998; i++) {\n\n             fullChars[i] = ' ';\n\n        }\n\n        fullChars[3998] = '{';\n\n        fullChars[3999] = 'a';\n\n        fullChars[4000] = 256;\n\n\n\n        JsonParser p = UNQUOTED_FIELDS_F.createParser(new java.io.StringReader(new String(fullChars)));\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        try {\n\n            p.nextToken();\n\n            fail(\"Should not pass\");\n\n        } catch (JsonParseException e) {\n\n            ; // should fail here\n\n        }\n\n        p.close();\n\n    }\n\n\n\n    /*\n\n    /****************************************************************\n\n    /* Secondary test methods\n\n    /****************************************************************\n\n     */\n\n    \n\n    private void _testLargeUnquoted(int mode) throws Exception\n\n    {\n\n        StringBuilder sb = new StringBuilder(5000);\n\n        sb.append(\"[\\n\");\n\n        //final int REPS = 2000;\n\n        final int REPS = 1050;\n\n        for (int i = 0; i < REPS; ++i) {\n\n            if (i > 0) {\n\n                sb.append(',');\n\n                if ((i & 7) == 0) {\n\n                    sb.append('\\n');\n\n                }\n\n            }\n\n            sb.append(\"{\");\n\n            sb.append(\"abc\").append(i&127).append(':');\n\n            sb.append((i & 1) != 0);\n\n            sb.append(\"}\\n\");\n\n        }\n\n        sb.append(\"]\");\n\n        String JSON = sb.toString();\n\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n        assertToken(JsonToken.START_ARRAY, p.nextToken());\n\n        for (int i = 0; i < REPS; ++i) {\n\n            assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n            assertEquals(\"abc\"+(i&127), p.getCurrentName());\n\n            assertToken(((i&1) != 0) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, p.nextToken());\n\n            assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        }\n\n        assertToken(JsonToken.END_ARRAY, p.nextToken());\n\n        p.close();\n\n    }\n\n\n\n    private void _testSimpleUnquoted(int mode) throws Exception\n\n    {\n\n        String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n\n        JsonParser p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"a\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"_foo\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"$\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n\n        assertEquals(\"money!\", p.getText());\n\n\n\n        // and then regular quoted one should still work too:\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\" \", p.getCurrentName());\n\n\n\n        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n\n\n\n        // Another thing, as per [Issue#102]: numbers\n\n\n\n        JSON = \"{ 123:true,4:false }\";\n\n        p = createParser(UNQUOTED_FIELDS_F, mode, JSON);\n\n\n\n        assertToken(JsonToken.START_OBJECT, p.nextToken());\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"123\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n\n\n\n        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n\n        assertEquals(\"4\", p.getCurrentName());\n\n        assertToken(JsonToken.VALUE_FALSE, p.nextToken());\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken());\n\n        p.close();\n\n    }\n\n}\n\n```\n#Error message: java.lang.ArrayIndexOutOfBoundsException: 256\n\tat com.fasterxml.jackson.core.json.ReaderBasedJsonParser._handleOddName2(ReaderBasedJsonParser.java:1964)  if (codes[i] != 0) {                    break;                }\n\tat com.fasterxml.jackson.core.json.ReaderBasedJsonParser._handleOddName(ReaderBasedJsonParser.java:1807)  return _handleOddName2(start, hash, codes);\n\tat com.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:692)  String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n\tat com.fasterxml.jackson.core.read.NonStandardUnquotedNamesTest.testUnquotedIssue510(NonStandardUnquotedNamesTest.java:49)  p.nextToken();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n// Ok, let's add char to output:\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Adjust to be the last valid index\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Adjust maxCode to be the last valid index\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Correctly set maxCode to codes.length - 1\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Adjust maxCode to be one less than length\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {  // Changed from i <= maxCode\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Fix: adjust maxCode to be one less than the length\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\n// Ok, let's add char to output:\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Adjust to be the last valid index\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Adjust maxCode to be the last valid index\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Correctly set maxCode to codes.length - 1\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Adjust maxCode to be one less than length\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i < maxCode) {  // Changed from i <= maxCode\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        outBuf[outPtr++] = c;\n\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ],
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1; // Fix: adjust maxCode to be one less than the length\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length - 1;\n\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { // acceptable for now (will error out later)\n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n        if (i <= maxCode) {\n            if (codes[i] != 0) {\n                break;\n            }\n        } else if (!Character.isJavaIdentifierPart(c)) {\n            break;\n        }\n        ++_inputPtr;\n        hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n        // Ok, let's add char to output:\n        outBuf[outPtr++] = c;\n\n        // Need more room?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    {\n        TextBuffer tb = _textBuffer;\n        char[] buf = tb.getTextBuffer();\n        int start = tb.getTextOffset();\n        int len = tb.size();\n\n        return _symbols.findSymbol(buf, start, len, hash);\n    }\n}\n"
                ]
            ]
        }
    }
}