{
    "Math-31": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* <p>\n* Evaluates the continued fraction at the value x.\n* </p>\n*\n* <p>\n* The implementation of this method is based on the modified Lentz algorithm as described\n* on page 18 ff. in:\n* <ul>\n* <li>\n*   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n*   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n*   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n* </li>\n* </ul>\n* Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n* <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n* </p>\n*\n* @param x the evaluation point.\n* @param epsilon maximum error allowed.\n* @param maxIterations maximum number of convergents\n* @return the value of the continued fraction evaluated at x.\n* @throws ConvergenceException if the algorithm fails to converge.\n*/\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a,b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testMath718() {\n\n        // for large trials the evaluation of ContinuedFraction was inaccurate\n\n        // do a sweep over several large trials to test if the current implementation is\n\n        // numerically stable.\n\n\n\n        for (int trials = 500000; trials < 20000000; trials += 100000) {\n\n            BinomialDistribution dist = new BinomialDistribution(trials, 0.5);\n\n            int p = dist.inverseCumulativeProbability(0.5);\n\n            Assert.assertEquals(trials / 2, p);\n\n        }\n\n\n\n    }\n\n```\n#Error message: org.apache.commons.math3.exception.ConvergenceException: illegal state: Continued fraction diverged to NaN for value 0.5\n\tat org.apache.commons.math3.util.ContinuedFraction.evaluate(ContinuedFraction.java:177)  throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,                                               x);\n\tat org.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:154)  ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -                FastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n\tat org.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:129)  ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n\tat org.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:50)  return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n\tat org.apache.commons.math3.distribution.BinomialDistribution.cumulativeProbability(BinomialDistribution.java:101)  ret = 1.0 - Beta.regularizedBeta(probabilityOfSuccess,                    x + 1.0, numberOfTrials - x);\n\tat org.apache.commons.math3.distribution.AbstractIntegerDistribution.checkedCumulativeProbability(AbstractIntegerDistribution.java:201)  result = cumulativeProbability(argument);\n\tat org.apache.commons.math3.distribution.AbstractIntegerDistribution.solveInverseCumulativeProbability(AbstractIntegerDistribution.java:143)  double pm = checkedCumulativeProbability(xm);\n\tat org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability(AbstractIntegerDistribution.java:116)  return solveInverseCumulativeProbability(p, lower, upper);\n\tat org.apache.commons.math3.distribution.BinomialDistributionTest.testMath718(BinomialDistributionTest.java:140)  int p = dist.inverseCumulativeProbability(0.5);\n \n#Test method 2:\n```java\n    public void testMath785() {\n\n        // this test was failing due to inaccurate results from ContinuedFraction.\n\n\n\n        try {\n\n            double prob = 0.01;\n\n            FDistribution f = new FDistribution(200000, 200000);\n\n            double result = f.inverseCumulativeProbability(prob);\n\n            Assert.assertTrue(result < 1.0);\n\n        } catch (Exception e) {\n\n            Assert.fail(\"Failing to calculate inverse cumulative probability\");\n\n        }\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: Failing to calculate inverse cumulative probability\n\tat org.apache.commons.math3.distribution.FDistributionTest.testMath785(FDistributionTest.java:156)  Assert.fail(\"Failing to calculate inverse cumulative probability\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(FastMath.abs(a), FastMath.abs(b));\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && FastMath.abs(a) > FastMath.abs(b)) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        \n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (q2 == 0) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN) || Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 1.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double dN = a + b * dPrev;\n        if (Precision.equals(dN, 0.0, small)) {\n            dN = small;\n        }\n        double cN = a + b / cPrev;\n        if (Precision.equals(cN, 0.0, small)) {\n            cN = small;\n        }\n\n        dN = 1.0 / dN;\n        double deltaN = cN * dN;\n        hN = hPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = dN;\n        cPrev = cN;\n        hPrev = hN;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = hN;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(Math.abs(a), Math.abs(b));\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && Math.abs(a) > Math.abs(b)) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN) || Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(Math.abs(a), Math.abs(b));\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (q2 == 0) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            final double scale = Math.max(Math.abs(a), Math.abs(b));\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < 5; i++) {\n                scaleFactor *= scale;\n                cN = (a / scaleFactor) * hPrev + (b / scaleFactor) * p0;\n                q2 = (a / scaleFactor) * q1 + (b / scaleFactor) * dPrev;\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (q2 == 0) {\n            q2 = small;\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (Math.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (q2 == 0.0) {\n            q2 = small;\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = hN;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(FastMath.abs(a), FastMath.abs(b));\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && FastMath.abs(a) > FastMath.abs(b)) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / scaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / scaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / scaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / scaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (q2 == 0.0) {\n            q2 = small;\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* <p>\n* Evaluates the continued fraction at the value x.\n* </p>\n*\n* <p>\n* The implementation of this method is based on the modified Lentz algorithm as described\n* on page 18 ff. in:\n* <ul>\n* <li>\n*   I. J. Thompson,  A. R. Barnett. \"Coulomb and Bessel Functions of Complex Arguments and Order.\"\n*   <a target=\"_blank\" href=\"http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf\">\n*   http://www.fresco.org.uk/papers/Thompson-JCP64p490.pdf</a>\n* </li>\n* </ul>\n* Note: the implementation uses the terms a<sub>i</sub> and b<sub>i</sub> as defined in\n* <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction / MathWorld</a>.\n* </p>\n*\n* @param x the evaluation point.\n* @param epsilon maximum error allowed.\n* @param maxIterations maximum number of convergents\n* @return the value of the continued fraction evaluated at x.\n* @throws ConvergenceException if the algorithm fails to converge.\n*/\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a,b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testMath718() {\n\n        // for large trials the evaluation of ContinuedFraction was inaccurate\n\n        // do a sweep over several large trials to test if the current implementation is\n\n        // numerically stable.\n\n\n\n        for (int trials = 500000; trials < 20000000; trials += 100000) {\n\n            BinomialDistribution dist = new BinomialDistribution(trials, 0.5);\n\n            int p = dist.inverseCumulativeProbability(0.5);\n\n            Assert.assertEquals(trials / 2, p);\n\n        }\n\n\n\n    }\n\n```\n#Error message: org.apache.commons.math3.exception.ConvergenceException: illegal state: Continued fraction diverged to NaN for value 0.5\n\tat org.apache.commons.math3.util.ContinuedFraction.evaluate(ContinuedFraction.java:177)  throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,                                               x);\n\tat org.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:154)  ret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -                FastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n\tat org.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:129)  ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n\tat org.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:50)  return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n\tat org.apache.commons.math3.distribution.BinomialDistribution.cumulativeProbability(BinomialDistribution.java:101)  ret = 1.0 - Beta.regularizedBeta(probabilityOfSuccess,                    x + 1.0, numberOfTrials - x);\n\tat org.apache.commons.math3.distribution.AbstractIntegerDistribution.checkedCumulativeProbability(AbstractIntegerDistribution.java:201)  result = cumulativeProbability(argument);\n\tat org.apache.commons.math3.distribution.AbstractIntegerDistribution.solveInverseCumulativeProbability(AbstractIntegerDistribution.java:143)  double pm = checkedCumulativeProbability(xm);\n\tat org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability(AbstractIntegerDistribution.java:116)  return solveInverseCumulativeProbability(p, lower, upper);\n\tat org.apache.commons.math3.distribution.BinomialDistributionTest.testMath718(BinomialDistributionTest.java:140)  int p = dist.inverseCumulativeProbability(0.5);\n \n#Test method 2:\n```java\n    public void testMath785() {\n\n        // this test was failing due to inaccurate results from ContinuedFraction.\n\n\n\n        try {\n\n            double prob = 0.01;\n\n            FDistribution f = new FDistribution(200000, 200000);\n\n            double result = f.inverseCumulativeProbability(prob);\n\n            Assert.assertTrue(result < 1.0);\n\n        } catch (Exception e) {\n\n            Assert.fail(\"Failing to calculate inverse cumulative probability\");\n\n        }\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: Failing to calculate inverse cumulative probability\n\tat org.apache.commons.math3.distribution.FDistributionTest.testMath785(FDistributionTest.java:156)  Assert.fail(\"Failing to calculate inverse cumulative probability\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic void saundersTest(final int n, final boolean goodb, final boolean precon, final double shift, final double pertbn) { final RealLinearOperator a = new RealLinearOperator() { @Override public RealVector operate(final RealVector x) { if (x.getDimension() != n) { throw new DimensionMismatchException(x.getDimension(), n); } final double[] y = new double[n]; for (int i = 0; i < n; i++) { y[i] = (i + 1) * 1.1 / n * x.getEntry(i); } return new ArrayRealVector(y, false); } @Override public int getRowDimension() { return n; } @Override public int getColumnDimension() { return n; } }; final double shiftm = shift; final double pertm = FastMath.abs(pertbn); final RealLinearOperator minv; if (precon) { minv = new RealLinearOperator() { @Override public int getRowDimension() { return n; } @Override public int getColumnDimension() { return n; } @Override public RealVector operate(final RealVector x) { if (x.getDimension() != n) { throw new DimensionMismatchException(x.getDimension(), n); } final double[] y = new double[n]; for (int i = 0; i < n; i++) { double d = (i + 1) * 1.1 / n; d = FastMath.abs(d - shiftm); if (i % 10 == 0) { d += pertm; } y[i] = x.getEntry(i) / d; } return new ArrayRealVector(y, false); } }; } else { minv = null; } final RealVector xtrue = new ArrayRealVector(n); for (int i = 0; i < n; i++) { xtrue.setEntry(i, n - i); } final RealVector b = a.operate(xtrue); b.combineToSelf(1.0, -shift, xtrue); final SymmLQ solver = new SymmLQ(2 * n, 1E-12, true); final RealVector x = solver.solve(a, minv, b, goodb, shift); final RealVector y = a.operate(x); final RealVector r1 = new ArrayRealVector(n); for (int i = 0; i < n; i++) { final double bi = b.getEntry(i); final double yi = y.getEntry(i); final double xi = x.getEntry(i); r1.setEntry(i, bi - yi + shift * xi); } final double enorm = x.subtract(xtrue).getNorm() / xtrue.getNorm(); final double etol = 1E-5; Assert.assertTrue(\\\"enorm=\\\" + enorm + \\\", \\\" + solver.getIterationManager().getIterations(), enorm <= etol); }\n```\n\n            \n```java\npublic int inverseCumulativeProbability(final double p) throws OutOfRangeException { if (p < 0.0 || p > 1.0) { throw new OutOfRangeException(p, 0, 1); } int lower = getSupportLowerBound(); if (p == 0.0) { return lower; } if (lower == Integer.MIN_VALUE) { if (checkedCumulativeProbability(lower) >= p) { return lower; } } else { lower -= 1; } int upper = getSupportUpperBound(); if (p == 1.0) { return upper; } final double mu = getNumericalMean(); final double sigma = FastMath.sqrt(getNumericalVariance()); final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) || Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0); if (chebyshevApplies) { double k = FastMath.sqrt((1.0 - p) / p); double tmp = mu - k * sigma; if (tmp > lower) { lower = ((int) Math.ceil(tmp)) - 1; } k = 1.0 / k; tmp = mu + k * sigma; if (tmp < upper) { upper = ((int) Math.ceil(tmp)) - 1; } } return solveInverseCumulativeProbability(p, lower, upper); }\n```\n\n            \n```java\npublic long nextPoisson(double mean) { if (mean <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean); } final double pivot = 40.0d; if (mean < pivot) { final RandomGenerator generator = getRan(); double p = FastMath.exp(-mean); long n = 0; double r = 1.0d; double rnd = 1.0d; while (n < 1000 * mean) { rnd = generator.nextDouble(); r = r * rnd; if (r >= p) { n++; } else { return n; } } return n; } else { final double lambda = FastMath.floor(mean); final double lambdaFractional = mean - lambda; final double logLambda = FastMath.log(lambda); final double logLambdaFactorial = ArithmeticUtils.factorialLog((int) lambda); final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional); final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1)); final double halfDelta = delta / 2; final double twolpd = 2 * lambda + delta; final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / 8 * lambda); final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd); final double aSum = a1 + a2 + 1; final double p1 = a1 / aSum; final double p2 = a2 / aSum; final double c1 = 1 / (8 * lambda); double x = 0; double y = 0; double v = 0; int a = 0; double t = 0; double qr = 0; double qa = 0; for (; ; ) { final double u = nextUniform(0.0, 1); if (u <= p1) { final double n = nextGaussian(0d, 1d); x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d; if (x > delta || x < -lambda) { continue; } y = x < 0 ? FastMath.floor(x) : FastMath.ceil(x); final double e = nextExponential(1d); v = -e - (n * n / 2) + c1; } else { if (u > p1 + p2) { y = lambda; break; } else { x = delta + (twolpd / delta) * nextExponential(1d); y = FastMath.ceil(x); v = -nextExponential(1d) - delta * (x + 1) / twolpd; } } a = x < 0 ? 1 : 0; t = y * (y + 1) / (2 * lambda); if (v < -t && a == 0) { y = lambda + y; break; } qr = t * ((2 * y + 1) / (6 * lambda) - 1); qa = qr - (t * t) / (3 * (lambda + a * (y + 1))); if (v < qa) { y = lambda + y; break; } if (v > qr) { continue; } if (v < y * logLambda - ArithmeticUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) { y = lambda + y; break; } } return y2 + (long) y; } }\n```\n\n            \n```java\n@Override protected PointValuePair doOptimize() { final GoalType goal = getGoalType(); final double[] guess = getStartPoint(); final int n = guess.length; final double[][] direc = new double[n][n]; for (int i = 0; i < n; i++) { direc[i][i] = 1; } final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker(); double[] x = guess; double fVal = computeObjectiveValue(x); double[] x1 = x.clone(); int iter = 0; while (true) { ++iter; double fX = fVal; double fX2 = 0; double delta = 0; int bigInd = 0; double alphaMin = 0; for (int i = 0; i < n; i++) { final double[] d = MathArrays.copyOf(direc[i]); fX2 = fVal; final UnivariatePointValuePair optimum = line.search(x, d); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection(x, d, alphaMin); x = result[0]; if ((fX2 - fVal) > delta) { delta = fX2 - fVal; bigInd = i; } } boolean stop = 2 * (fX - fVal) <= (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) + absoluteThreshold); final PointValuePair previous = new PointValuePair(x1, fX); final PointValuePair current = new PointValuePair(x, fVal); if (!stop) { if (checker != null) { stop = checker.converged(iter, previous, current); } } if (stop) { if (goal == GoalType.MINIMIZE) { return (fVal < fX) ? current : previous; } else { return (fVal > fX) ? current : previous; } } final double[] d = new double[n]; final double[] x2 = new double[n]; for (int i = 0; i < n; i++) { d[i] = x[i] - x1[i]; x2[i] = 2 * x[i] - x1[i]; } x1 = x.clone(); fX2 = computeObjectiveValue(x2); if (fX > fX2) { double t = 2 * (fX + fX2 - 2 * fVal); double temp = fX - fVal - delta; t *= temp * temp; temp = fX - fX2; t -= delta * temp * temp; if (t < 0.0) { final UnivariatePointValuePair optimum = line.search(x, d); fVal = optimum.getValue(); alphaMin = optimum.getPoint(); final double[][] result = newPointAndDirection(x, d, alphaMin); x = result[0]; final int lastInd = n - 1; direc[bigInd] = direc[lastInd]; direc[lastInd] = result[1]; } } } }\n```\n\n            \n```java\npublic double nextGamma(double shape, double scale) { if (shape < 1) { while (true) { final double u = this.nextUniform(0, 1); final double bGS = 1 + shape / FastMath.E; final double p = bGS * u; if (p <= 1) { final double x = FastMath.pow(p, 1 / shape); final double u2 = this.nextUniform(0.0, 1); if (u2 > FastMath.exp(-x)) { continue; } else { return scale * x; } } else { final double x = -1 * FastMath.log((bGS - p) / shape); final double u2 = this.nextUniform(0, 1); if (u2 > FastMath.pow(x, shape - 1)) { continue; } else { return scale * x; } } } } final RandomGenerator generator = this.getRan(); final double d = shape - 0.333333333333333333; final double c = 1.0 / (3 * FastMath.sqrt(d)); while (true) { final double x = generator.nextGaussian(); final double v = (1 + c * x) * (1 + c * x) * (1 + c * x); if (v <= 0) { continue; } final double xx = x * x; final double u = this.nextUniform(0, 1); if (u < 1 - 0.0331 * xx * xx) { return scale * d * v; } if (FastMath.log(u) < 0.5 * xx + d * (1 - v + FastMath.log(v))) { return scale * d * v; } } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 1.0; // Changed from 0.0 to 1.0\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a,b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n                                           x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                           x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        \n        if (Double.isInfinite(cN) || Double.isInfinite(q2) || Double.isNaN(cN) || Double.isNaN(q2)) {\n            double scale = Math.max(Math.abs(a), Math.abs(b));\n            if (scale <= 0.0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            cN /= scale;\n            q2 /= scale;\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN) || Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) { \n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = (hPrev / scaleFactor) + ((b / scaleFactor) * p0);\n                    q2 = (q1 / scaleFactor) + ((b / scaleFactor) * dPrev);\n                } else if (b != 0) {\n                    cN = ((a / scaleFactor) * hPrev) + (p0 / lastScaleFactor);\n                    q2 = ((a / scaleFactor) * q1) + (dPrev / lastScaleFactor);\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (Double.isNaN(cN) || Double.isNaN(q2)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        \n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n\n        if (q2 == 0) {\n            q2 = small;\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN) || Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        \n        if (q2 == 0.0) {\n            q2 = small;\n        }\n        \n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2 / cPrev;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a,b);\n            if (scale <= 0) {\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double dN = a + b * dPrev;\n        if (Precision.equals(dN, 0.0, small)) {\n            dN = small;\n        }\n        double cN = a / dN;\n        if (Precision.equals(cN, 0.0, small)) {\n            cN = small;\n        }\n        dPrev = dN;\n\n        final double deltaN = cN * hPrev;\n        hN = deltaN;\n\n        if (Double.isInfinite(hN) || Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN / hPrev - 1.0) < epsilon) {\n            break;\n        }\n\n        hPrev = hN;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                                            maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    // use the value of small as epsilon criteria for zero checks\n    if (Precision.equals(hPrev, 0.0, small)) {\n        hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = a * hPrev + b * p0;\n        double q2 = a * q1 + b * dPrev;\n        if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n            double scaleFactor = 1d;\n            double lastScaleFactor = 1d;\n            final int maxPower = 5;\n            final double scale = FastMath.max(a, b);\n            if (scale <= 0) {  // Can't scale\n                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n            }\n            for (int i = 0; i < maxPower; i++) {\n                lastScaleFactor = scaleFactor;\n                scaleFactor *= scale;\n                if (a != 0.0 && a > b) {\n                    cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n                    q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n                } else if (b != 0) {\n                    cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n                    q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n                }\n                if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n                    break;\n                }\n            }\n        }\n\n        final double deltaN = cN / q2;\n        hN = cPrev * deltaN;\n\n        if (Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n        }\n        if (Double.isNaN(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        dPrev = q1;\n        cPrev = cN / q2;\n        p0 = hPrev;\n        hPrev = cN;\n        q1 = q2;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ],
                [
                    "\npublic double evaluate(double x, double epsilon, int maxIterations) {\n    final double small = 1e-50;\n    double hPrev = getA(0, x);\n\n    if (Precision.equals(hPrev, 0.0, small)) {\n       hPrev = small;\n    }\n\n    int n = 1;\n    double dPrev = 0.0;\n    double p0 = 1.0;\n    double q1 = 1.0;\n    double cPrev = hPrev;\n    double hN = hPrev;\n\n    while (n < maxIterations) {\n        final double a = getA(n, x);\n        final double b = getB(n, x);\n\n        double cN = b + a / cPrev;\n        if (Precision.equals(cN, 0.0, small)) {\n            cN = small;\n        }\n\n        double dN = b + a * dPrev;\n        if (Precision.equals(dN, 0.0, small)) {\n            dN = small;\n        } \n        dN = 1.0 / dN;\n         \n        final double deltaN = cN * dN;\n        hN = hPrev * deltaN;\n\n        if (Double.isNaN(hN) || Double.isInfinite(hN)) {\n            throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE, x);\n        }\n\n        if (FastMath.abs(deltaN - 1.0) < epsilon) {\n            break;\n        }\n\n        cPrev = cN;\n        dPrev = dN;\n        hPrev = hN;\n        n++;\n    }\n\n    if (n >= maxIterations) {\n        throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION, maxIterations, x);\n    }\n\n    return hN;\n}\n"
                ]
            ],
            "compiler_error": true,
            "evaluation_done": true
        }
    }
}