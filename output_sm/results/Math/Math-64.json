{
    "Math-64": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Set the desired threshold for QR ranking.\n* <p>\n* If the squared norm of a column vector is smaller or equal to this threshold\n* during QR decomposition, it is considered to be a zero vector and hence the\n* rank of the matrix is reduced.\n* </p>\n* @param threshold threshold for QR ranking\n*/\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMinpackJennrichSampson() {\n\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n\n                                            64.5856498144943, 11.1517793413499,\n\n                                            new double[] {\n\n //                                            0.2578330049, 0.257829976764542\n\n                                               0.2578199266368004, 0.25782997676455244\n\n                                            }), false);\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<0.2578199266368004> but was:<0.2578330049004441>\n\tat org.apache.commons.math.optimization.general.MinpackTest.minpackTest(MinpackTest.java:504)  function.checkTheoreticalMinParams(optimum);\n\tat org.apache.commons.math.optimization.general.MinpackTest.testMinpackJennrichSampson(MinpackTest.java:325)  minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] { //                                            0.2578330049, 0.257829976764542                                               0.2578199266368004, 0.25782997676455244                                            }), false);\n \n#Test method 2:\n```java\n  public void testMinpackFreudensteinRoth() {\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n\n                                             20.0124960961895, 6.99887517584575,\n\n                                             new double[] {\n\n                                               11.4124844654993,\n\n                                               -0.896827913731509\n\n                                             }), false);\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n\n                                             12432.833948863, 6.9988751744895,\n\n                                             new double[] {\n\n                                                11.41300466147456,\n\n                                                -0.896796038685959\n\n                                             }), false);\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n\n                                             11426454.595762, 6.99887517242903,\n\n                                             new double[] {\n\n                                                 11.412781785788564,\n\n                                                 -0.8968051074920405\n\n                                             }), false);\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<11.41300466147456> but was:<11.4121122022341>\n\tat org.apache.commons.math.optimization.general.MinpackTest.minpackTest(MinpackTest.java:504)  function.checkTheoreticalMinParams(optimum);\n\tat org.apache.commons.math.optimization.general.MinpackTest.testMinpackFreudensteinRoth(MinpackTest.java:152)  minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                                11.41300466147456,                                                -0.896796038685959                                             }), false);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    updateResidualsAndCost();\n\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        qTy(residuals);\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            return current;\n        }\n\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            if (ratio >= 1.0e-4) {\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n            } else {\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    updateResidualsAndCost();\n\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        qTy(residuals);\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            return current;\n        }\n\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            if (ratio >= 1.0e-4) {\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n            } else {\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                \n                // Corrected this line\n                point[pj] = oldX[pj] - lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n                if (checker == null) {\n                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                        (preRed <= costRelativeTolerance) &&\n                        (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                }\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point.clone(), objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point.clone(), objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point.clone(), objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point.clone(), objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Set the desired threshold for QR ranking.\n* <p>\n* If the squared norm of a column vector is smaller or equal to this threshold\n* during QR decomposition, it is considered to be a zero vector and hence the\n* rank of the matrix is reduced.\n* </p>\n* @param threshold threshold for QR ranking\n*/\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testMinpackJennrichSampson() {\n\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n\n                                            64.5856498144943, 11.1517793413499,\n\n                                            new double[] {\n\n //                                            0.2578330049, 0.257829976764542\n\n                                               0.2578199266368004, 0.25782997676455244\n\n                                            }), false);\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<0.2578199266368004> but was:<0.2578330049004441>\n\tat org.apache.commons.math.optimization.general.MinpackTest.minpackTest(MinpackTest.java:504)  function.checkTheoreticalMinParams(optimum);\n\tat org.apache.commons.math.optimization.general.MinpackTest.testMinpackJennrichSampson(MinpackTest.java:325)  minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },                                            64.5856498144943, 11.1517793413499,                                            new double[] { //                                            0.2578330049, 0.257829976764542                                               0.2578199266368004, 0.25782997676455244                                            }), false);\n \n#Test method 2:\n```java\n  public void testMinpackFreudensteinRoth() {\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n\n                                             20.0124960961895, 6.99887517584575,\n\n                                             new double[] {\n\n                                               11.4124844654993,\n\n                                               -0.896827913731509\n\n                                             }), false);\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n\n                                             12432.833948863, 6.9988751744895,\n\n                                             new double[] {\n\n                                                11.41300466147456,\n\n                                                -0.896796038685959\n\n                                             }), false);\n\n    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n\n                                             11426454.595762, 6.99887517242903,\n\n                                             new double[] {\n\n                                                 11.412781785788564,\n\n                                                 -0.8968051074920405\n\n                                             }), false);\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<11.41300466147456> but was:<11.4121122022341>\n\tat org.apache.commons.math.optimization.general.MinpackTest.minpackTest(MinpackTest.java:504)  function.checkTheoreticalMinParams(optimum);\n\tat org.apache.commons.math.optimization.general.MinpackTest.testMinpackFreudensteinRoth(MinpackTest.java:152)  minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },                                             12432.833948863, 6.9988751744895,                                             new double[] {                                                11.41300466147456,                                                -0.896796038685959                                             }), false);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\n@Override public void estimate(EstimationProblem problem) throws EstimationException { initializeEstimate(problem); solvedCols = Math.min(rows, cols); diagR = new double[cols]; jacNorm = new double[cols]; beta = new double[cols]; permutation = new int[cols]; lmDir = new double[cols]; double delta = 0; double xNorm = 0; double[] diag = new double[cols]; double[] oldX = new double[cols]; double[] oldRes = new double[rows]; double[] work1 = new double[cols]; double[] work2 = new double[cols]; double[] work3 = new double[cols]; updateResidualsAndCost(); lmPar = 0; boolean firstIteration = true; while (true) { updateJacobian(); qrDecomposition(); qTy(residuals); for (int k = 0; k < solvedCols; ++k) { int pk = permutation[k]; jacobian[k * cols + pk] = diagR[pk]; } if (firstIteration) { xNorm = 0; for (int k = 0; k < cols; ++k) { double dk = jacNorm[k]; if (dk == 0) { dk = 1.0; } double xk = dk * parameters[k].getEstimate(); xNorm += xk * xk; diag[k] = dk; } xNorm = Math.sqrt(xNorm); delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm); } double maxCosine = 0; if (cost != 0) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = jacNorm[pj]; if (s != 0) { double sum = 0; int index = pj; for (int i = 0; i <= j; ++i) { sum += jacobian[index] * residuals[i]; index += cols; } maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost)); } } } if (maxCosine <= orthoTolerance) { return; } for (int j = 0; j < cols; ++j) { diag[j] = Math.max(diag[j], jacNorm[j]); } for (double ratio = 0; ratio < 1.0e-4; ) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; oldX[pj] = parameters[pj].getEstimate(); } double previousCost = cost; double[] tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; determineLMParameter(oldRes, delta, diag, work1, work2, work3); double lmNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; lmDir[pj] = -lmDir[pj]; parameters[pj].setEstimate(oldX[pj] + lmDir[pj]); double s = diag[pj] * lmDir[pj]; lmNorm += s * s; } lmNorm = Math.sqrt(lmNorm); if (firstIteration) { delta = Math.min(delta, lmNorm); } updateResidualsAndCost(); double actRed = -1.0; if (0.1 * cost < previousCost) { double r = cost / previousCost; actRed = 1.0 - r * r; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double dirJ = lmDir[pj]; work1[j] = 0; int index = pj; for (int i = 0; i <= j; ++i) { work1[i] += jacobian[index] * dirJ; index += cols; } } double coeff1 = 0; for (int j = 0; j < solvedCols; ++j) { coeff1 += work1[j] * work1[j]; } double pc2 = previousCost * previousCost; coeff1 = coeff1 / pc2; double coeff2 = lmPar * lmNorm * lmNorm / pc2; double preRed = coeff1 + 2 * coeff2; double dirDer = -(coeff1 + coeff2); ratio = (preRed == 0) ? 0 : (actRed / preRed); if (ratio <= 0.25) { double tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5; if ((0.1 * cost >= previousCost) || (tmp < 0.1)) { tmp = 0.1; } delta = tmp * Math.min(delta, 10.0 * lmNorm); lmPar /= tmp; } else if ((lmPar == 0) || (ratio >= 0.75)) { delta = 2 * lmNorm; lmPar *= 0.5; } if (ratio >= 1.0e-4) { firstIteration = false; xNorm = 0; for (int k = 0; k < cols; ++k) { double xK = diag[k] * parameters[k].getEstimate(); xNorm += xK * xK; } xNorm = Math.sqrt(xNorm); } else { cost = previousCost; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; parameters[pj].setEstimate(oldX[pj]); } tmpVec = residuals; residuals = oldRes; oldRes = tmpVec; } if (((Math.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance) && (ratio <= 2.0)) || (delta <= parRelativeTolerance * xNorm)) { return; } if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) { throw new EstimationException(\\\"cost relative tolerance is too small ({0}),\\\" + \\\" no further reduction in the\\\" + \\\" sum of squares is possible\\\", costRelativeTolerance); } else if (delta <= 2.2204e-16 * xNorm) { throw new EstimationException(\\\"parameters relative tolerance is too small\\\" + \\\" ({0}), no further improvement in\\\" + \\\" the approximate solution is possible\\\", parRelativeTolerance); } else if (maxCosine <= 2.2204e-16) { throw new EstimationException(\\\"orthogonality tolerance is too small ({0}),\\\" + \\\" solution is orthogonal to the jacobian\\\", orthoTolerance); } } } }\n```\n\n            \n```java\n@Override public double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][y0.length]; final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; double hNew = 0; boolean firstTime = true; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); double error = 0; for (boolean loop = true; loop; ) { if (firstTime || !fsal) { computeDerivatives(stepStart, y, yDotK[0]); } if (firstTime) { final double[] scale = new double[mainSetDimension]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); } } hNew = initializeStep(equations, forward, getOrder(), scale, stepStart, y, yDotK[0], yTmp, yDotK[1]); firstTime = false; } stepSize = hNew; for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } error = estimateError(yDotK, y, yTmp, stepSize); if (error <= 1.0) { interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); hNew = 0; stepSize = 0; loop = false; } else { hNew = dt; } } else { loop = false; } } else { final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); hNew = filterStep(stepSize * factor, forward, false); } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (fsal) { System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length); } if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } if (!lastStep) { stepSize = filterStep(stepSize, forward, true); final double factor = Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp))); final double scaledH = stepSize * factor; final double nextT = stepStart + scaledH; final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t); hNew = filterStep(scaledH, forward, nextIsLast); } } final double stopTime = stepStart; resetInternalState(); return stopTime; }\n```\n\n            \n```java\nprivate void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3) { for (int j = 0; j < rank; ++j) { lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < cols; ++j) { lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) { int pk = permutation[k]; double ypk = lmDir[pk] / diagR[pk]; int index = pk; for (int i = 0; i < k; ++i) { lmDir[permutation[i]] -= ypk * jacobian[index]; index += cols; } lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work1[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double fp = dxNorm - delta; if (fp <= 0.1 * delta) { lmPar = 0; return; } double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; int index = pj; for (int i = 0; i < j; ++i) { sum += jacobian[index] * work1[permutation[i]]; index += cols; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; int index = pj; for (int i = 0; i <= j; ++i) { sum += jacobian[index] * qy[i]; index += cols; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) { paru = 2.2251e-308 / Math.min(delta, 0.1); } lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) { if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta; if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { return; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] /= work2[j]; double tmp = work1[pj]; for (int i = j + 1; i < solvedCols; ++i) { work1[permutation[i]] -= jacobian[i * cols + pj] * tmp; } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { double s = work1[permutation[j]]; sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) { parl = Math.max(parl, lmPar); } else if (fp < 0) { paru = Math.min(paru, lmPar); } lmPar = Math.max(parl, lmPar + correction); } }\n```\n\n            \n```java\nprivate void determineLMParameter(double[] qy, double delta, double[] diag, double[] work1, double[] work2, double[] work3) { for (int j = 0; j < rank; ++j) { lmDir[permutation[j]] = qy[j]; } for (int j = rank; j < cols; ++j) { lmDir[permutation[j]] = 0; } for (int k = rank - 1; k >= 0; --k) { int pk = permutation[k]; double ypk = lmDir[pk] / diagR[pk]; for (int i = 0; i < k; ++i) { lmDir[permutation[i]] -= ypk * jacobian[i][pk]; } lmDir[pk] = ypk; } double dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work1[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double fp = dxNorm - delta; if (fp <= 0.1 * delta) { lmPar = 0; return; } double sum2; double parl = 0; if (rank == solvedCols) { for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] *= diag[pj] / dxNorm; } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i < j; ++i) { sum += jacobian[i][pj] * work1[permutation[i]]; } double s = (work1[pj] - sum) / diagR[pj]; work1[pj] = s; sum2 += s * s; } parl = fp / (delta * sum2); } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double sum = 0; for (int i = 0; i <= j; ++i) { sum += jacobian[i][pj] * qy[i]; } sum /= diag[pj]; sum2 += sum * sum; } double gNorm = Math.sqrt(sum2); double paru = gNorm / delta; if (paru == 0) { paru = 2.2251e-308 / Math.min(delta, 0.1); } lmPar = Math.min(paru, Math.max(lmPar, parl)); if (lmPar == 0) { lmPar = gNorm / dxNorm; } for (int countdown = 10; countdown >= 0; --countdown) { if (lmPar == 0) { lmPar = Math.max(2.2251e-308, 0.001 * paru); } double sPar = Math.sqrt(lmPar); for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = sPar * diag[pj]; } determineLMDirection(qy, work1, work2, work3); dxNorm = 0; for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; double s = diag[pj] * lmDir[pj]; work3[pj] = s; dxNorm += s * s; } dxNorm = Math.sqrt(dxNorm); double previousFP = fp; fp = dxNorm - delta; if ((Math.abs(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) { return; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] = work3[pj] * diag[pj] / dxNorm; } for (int j = 0; j < solvedCols; ++j) { int pj = permutation[j]; work1[pj] /= work2[j]; double tmp = work1[pj]; for (int i = j + 1; i < solvedCols; ++i) { work1[permutation[i]] -= jacobian[i][pj] * tmp; } } sum2 = 0; for (int j = 0; j < solvedCols; ++j) { double s = work1[permutation[j]]; sum2 += s * s; } double correction = fp / (delta * sum2); if (fp > 0) { parl = Math.max(parl, lmPar); } else if (fp < 0) { paru = Math.min(paru, lmPar); } lmPar = Math.max(parl, lmPar + correction); } }\n```\n\n            \n```java\npublic double integrate(final FirstOrderDifferentialEquations equations, final double t0, final double[] y0, final double t, final double[] y) throws DerivativeException, IntegratorException { sanityChecks(equations, t0, y0, t, y); setEquations(equations); resetEvaluations(); final boolean forward = t > t0; final int stages = c.length + 1; if (y != y0) { System.arraycopy(y0, 0, y, 0, y0.length); } final double[][] yDotK = new double[stages][]; for (int i = 0; i < stages; ++i) { yDotK[i] = new double[y0.length]; } final double[] yTmp = new double[y0.length]; AbstractStepInterpolator interpolator; if (requiresDenseOutput() || (!eventsHandlersManager.isEmpty())) { final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy(); rki.reinitialize(this, yTmp, yDotK, forward); interpolator = rki; } else { interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward); } interpolator.storeTime(t0); stepStart = t0; stepSize = forward ? step : -step; for (StepHandler handler : stepHandlers) { handler.reset(); } CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager); boolean lastStep = false; while (!lastStep) { interpolator.shift(); for (boolean loop = true; loop; ) { computeDerivatives(stepStart, y, yDotK[0]); for (int k = 1; k < stages; ++k) { for (int j = 0; j < y0.length; ++j) { double sum = a[k - 1][0] * yDotK[0][j]; for (int l = 1; l < k; ++l) { sum += a[k - 1][l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]); } for (int j = 0; j < y0.length; ++j) { double sum = b[0] * yDotK[0][j]; for (int l = 1; l < stages; ++l) { sum += b[l] * yDotK[l][j]; } yTmp[j] = y[j] + stepSize * sum; } interpolator.storeTime(stepStart + stepSize); if (manager.evaluateStep(interpolator)) { final double dt = manager.getEventTime() - stepStart; if (Math.abs(dt) <= Math.ulp(stepStart)) { interpolator.storeTime(stepStart); System.arraycopy(y, 0, yTmp, 0, y0.length); stepSize = 0; loop = false; } else { stepSize = dt; } } else { loop = false; } } final double nextStep = stepStart + stepSize; System.arraycopy(yTmp, 0, y, 0, y0.length); manager.stepAccepted(nextStep, y); lastStep = manager.stop(); interpolator.storeTime(nextStep); for (StepHandler handler : stepHandlers) { handler.handleStep(interpolator, lastStep); } stepStart = nextStep; if (manager.reset(stepStart, y) && !lastStep) { computeDerivatives(stepStart, y, yDotK[0]); } stepSize = forward ? step : -step; } final double stopTime = stepStart; stepStart = Double.NaN; stepSize = Double.NaN; return stopTime; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                point[pj] = oldX[pj] - lmDir[pj]; // Fix: Correct calculation of point\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n                if (checker == null) {\n                    if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n                } else {\n                    if (checker.converged(getIterations(), previous, current)) {\n                        return current;\n                    }\n                }\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            \n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double delta   = 0;\n    double xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[cols];\n    double[] oldX = new double[cols];\n    double[] oldRes = new double[rows];\n    double[] work1 = new double[cols];\n    double[] work2 = new double[cols];\n    double[] work3 = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec = residuals;\n                residuals = oldRes;\n                oldRes = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                     (preRed <= costRelativeTolerance) &&\n                     (ratio <= 2.0)) ||\n                    (delta <= parRelativeTolerance * xNorm)) {\n                    return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && \n                (preRed <= 2.2204e-16) && \n                (ratio <= 2.0)) {\n                throw new OptimizationException(\n                        LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(\n                        LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16) {\n                throw new OptimizationException(\n                        LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point.clone(), objective.clone());\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals.clone();\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point.clone(), objective.clone());\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n                }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n\n            // tests for termination and stringent tolerances\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker==null) {\n            \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                return current;\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                return current;\n            } else if (maxCosine <= 2.2204e-16)  {\n                return current;\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker == null) {\n                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n               }\n            } else {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ],
                [
                    "\nprotected VectorialPointValuePair doOptimize()\n    throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    // arrays shared with the other private methods\n    solvedCols  = Math.min(rows, cols);\n    diagR       = new double[cols];\n    jacNorm     = new double[cols];\n    beta        = new double[cols];\n    permutation = new int[cols];\n    lmDir       = new double[cols];\n\n    // local point\n    double   delta   = 0;\n    double   xNorm   = 0;\n    double[] diag    = new double[cols];\n    double[] oldX    = new double[cols];\n    double[] oldRes  = new double[rows];\n    double[] work1   = new double[cols];\n    double[] work2   = new double[cols];\n    double[] work3   = new double[cols];\n\n    // evaluate the function at the starting point and calculate its norm\n    updateResidualsAndCost();\n\n    // outer loop\n    lmPar = 0;\n    boolean firstIteration = true;\n    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n    while (true) {\n        incrementIterationsCounter();\n\n        // compute the Q.R. decomposition of the jacobian matrix\n        VectorialPointValuePair previous = current;\n        updateJacobian();\n        qrDecomposition();\n\n        // compute Qt.res\n        qTy(residuals);\n        // now we don't need Q anymore,\n        // so let jacobian contain the R matrix with its diagonal elements\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            jacobian[k][pk] = diagR[pk];\n        }\n\n        if (firstIteration) {\n\n            // scale the point according to the norms of the columns\n            // of the initial jacobian\n            xNorm = 0;\n            for (int k = 0; k < cols; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * point[k];\n                xNorm  += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = Math.sqrt(xNorm);\n\n            // initialize the step bound delta\n            delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n        }\n\n        // check orthogonality between function vector and jacobian columns\n        double maxCosine = 0;\n        if (cost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int    pj = permutation[j];\n                double s  = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += jacobian[i][pj] * residuals[i];\n                    }\n                    maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            // convergence has been reached\n            return current;\n        }\n\n        // rescale if necessary\n        for (int j = 0; j < cols; ++j) {\n            diag[j] = Math.max(diag[j], jacNorm[j]);\n        }\n\n        // inner loop\n        for (double ratio = 0; ratio < 1.0e-4;) {\n\n            // save the state\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = point[pj];\n            }\n            double previousCost = cost;\n            double[] tmpVec = residuals;\n            residuals = oldRes;\n            oldRes    = tmpVec;\n\n            // determine the Levenberg-Marquardt parameter\n            determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n            // compute the new point and the norm of the evolution direction\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                point[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm  += s * s;\n            }\n            lmNorm = Math.sqrt(lmNorm);\n            // on the first iteration, adjust the initial step bound.\n            if (firstIteration) {\n                delta = Math.min(delta, lmNorm);\n            }\n\n            // evaluate the function at x + p and calculate its norm\n            updateResidualsAndCost();\n            current = new VectorialPointValuePair(point, objective);\n\n            // compute the scaled actual reduction\n            double actRed = -1.0;\n            if (0.1 * cost < previousCost) {\n                double r = cost / previousCost;\n                actRed = 1.0 - r * r;\n            }\n\n            // compute the scaled predicted reduction\n            // and the scaled directional derivative\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += jacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n            double preRed = coeff1 + 2 * coeff2;\n            double dirDer = -(coeff1 + coeff2);\n\n            // ratio of the actual to the predicted reduction\n            ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n            // update the step bound\n            if (ratio <= 0.25) {\n                double tmp =\n                    (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                    if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n                        tmp = 0.1;\n                    }\n                    delta = tmp * Math.min(delta, 10.0 * lmNorm);\n                    lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n\n            // test for successful iteration.\n            if (ratio >= 1.0e-4) {\n                // successful iteration, update the norm\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < cols; ++k) {\n                    double xK = diag[k] * point[k];\n                    xNorm    += xK * xK;\n                }\n                xNorm = Math.sqrt(xNorm);\n\n                // tests for convergence.\n                // we use the vectorial convergence checker\n            } else {\n                // failed iteration, reset the previous values\n                cost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    point[pj] = oldX[pj];\n                }\n                tmpVec    = residuals;\n                residuals = oldRes;\n                oldRes    = tmpVec;\n            }\n            if (checker != null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                    return current;\n                }\n            }\n            if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                    (preRed <= costRelativeTolerance) &&\n                    (ratio <= 2.0)) ||\n                   (delta <= parRelativeTolerance * xNorm)) {\n                   return current;\n            }\n            // tests for termination and stringent tolerances\n            // (2.2204e-16 is the machine epsilon for IEEE754)\n            if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                        costRelativeTolerance);\n            } else if (delta <= 2.2204e-16 * xNorm) {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                        parRelativeTolerance);\n            } else if (maxCosine <= 2.2204e-16)  {\n                throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                        orthoTolerance);\n            }\n\n        }\n\n    }\n\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}