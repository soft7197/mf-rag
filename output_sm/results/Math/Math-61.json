{
    "Math-61": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testMean() {\n\n        PoissonDistribution dist;\n\n        try {\n\n            dist = new PoissonDistributionImpl(-1);\n\n            fail(\"negative mean: NotStrictlyPositiveException expected\");\n\n        } catch(NotStrictlyPositiveException ex) {\n\n            // Expected.\n\n        }\n\n\n\n        dist = new PoissonDistributionImpl(10.0);\n\n        assertEquals(10.0, dist.getMean(), 0.0);\n\n    }\n\n```\n#Error message: org.apache.commons.math.MathRuntimeException$4: the Poisson mean must be positive (-1)\n\tat org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(MathRuntimeException.java:387)  return new IllegalArgumentException() {            /** Serializable version identifier. */            private static final long serialVersionUID = -4284649691002411505L;            /** {@inheritDoc} */            @Override            public String getMessage() {                return buildMessage(Locale.US, pattern, arguments);            }            /** {@inheritDoc} */            @Override            public String getLocalizedMessage() {                return buildMessage(Locale.getDefault(), pattern, arguments);            }        };\n\tat org.apache.commons.math.distribution.PoissonDistributionImpl.<init>(PoissonDistributionImpl.java:94)  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n\tat org.apache.commons.math.distribution.PoissonDistributionImpl.<init>(PoissonDistributionImpl.java:80)  this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n\tat org.apache.commons.math.distribution.PoissonDistributionTest.testMean(PoissonDistributionTest.java:140)  dist = new PoissonDistributionImpl(-1);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ]
            ],
            "compiler_error": true,
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testMean() {\n\n        PoissonDistribution dist;\n\n        try {\n\n            dist = new PoissonDistributionImpl(-1);\n\n            fail(\"negative mean: NotStrictlyPositiveException expected\");\n\n        } catch(NotStrictlyPositiveException ex) {\n\n            // Expected.\n\n        }\n\n\n\n        dist = new PoissonDistributionImpl(10.0);\n\n        assertEquals(10.0, dist.getMean(), 0.0);\n\n    }\n\n```\n#Error message: org.apache.commons.math.MathRuntimeException$4: the Poisson mean must be positive (-1)\n\tat org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(MathRuntimeException.java:387)  return new IllegalArgumentException() {            /** Serializable version identifier. */            private static final long serialVersionUID = -4284649691002411505L;            /** {@inheritDoc} */            @Override            public String getMessage() {                return buildMessage(Locale.US, pattern, arguments);            }            /** {@inheritDoc} */            @Override            public String getLocalizedMessage() {                return buildMessage(Locale.getDefault(), pattern, arguments);            }        };\n\tat org.apache.commons.math.distribution.PoissonDistributionImpl.<init>(PoissonDistributionImpl.java:94)  throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n\tat org.apache.commons.math.distribution.PoissonDistributionImpl.<init>(PoissonDistributionImpl.java:80)  this(p, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n\tat org.apache.commons.math.distribution.PoissonDistributionTest.testMean(PoissonDistributionTest.java:140)  dist = new PoissonDistributionImpl(-1);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\n@Test public void testMinimumIsOnIntervalBoundary() throws MathException { final UnivariateRealFunction func = new UnivariateRealFunction() { public double value(double x) throws FunctionEvaluationException { return x * x; } }; final BracketFinder bFind = new BracketFinder(); bFind.search(func, GoalType.MINIMIZE, 0, 1); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); bFind.search(func, GoalType.MINIMIZE, -1, 0); Assert.assertTrue(bFind.getLo() <= 0); Assert.assertTrue(0 <= bFind.getHi()); }\n```\n\n            \n```java\npublic void testGetSetRowVectorLarge() { int n = 3 * BlockFieldMatrix.BLOCK_SIZE; FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(FractionField.getInstance(), n, n); FieldVector<Fraction> sub = new ArrayFieldVector<Fraction>(n, new Fraction(1)); m.setRowVector(2, sub); for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { if (i != 2) { assertEquals(new Fraction(0), m.getEntry(i, j)); } else { assertEquals(new Fraction(1), m.getEntry(i, j)); } } } assertEquals(sub, m.getRowVector(2)); }\n```\n\n            \n```java\nprivate void doTest(MultivariateRealFunction func, double[] optimum, double[] init, GoalType goal, double fTol, double pointTol) throws MathException { final MultivariateRealOptimizer optim = new PowellOptimizer(fTol, Math.ulp(1d)); optim.setMaxEvaluations(1000); final RealPointValuePair result = optim.optimize(func, goal, init); final double[] found = result.getPoint(); for (int i = 0, dim = optimum.length; i < dim; i++) { Assert.assertEquals(optimum[i], found[i], pointTol); } }\n```\n\n            \n```java\npublic static <T extends FieldElement<T>> FieldMatrix<T> createColumnFieldMatrix(final T[] columnData) { final int nRows = columnData.length; if (nRows == 0) { throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW); } final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1); for (int i = 0; i < nRows; ++i) { m.setEntry(i, 0, columnData[i]); } return m; }\n```\n\n            \n```java\n@Test public void testFlatten() { final List<Object> orig = new ArrayList<Object>(); final Object[] struct = new Object[] { new Object[] { new Object[] { create(orig), create(orig) }, create(orig), new Object[] { create(orig) } }, create(orig), new Object[] { create(orig), new Object[] { create(orig), create(orig) } }, create(orig) }; Object[] flat = ArgUtils.flatten(struct); Assert.assertEquals(flat.length, orig.size()); for (int i = 0, max = orig.size(); i < max; i++) { Assert.assertEquals(orig.get(i), flat[i]); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ],
                [
                    "\n/**\n* Create a new Poisson distribution with the given mean, convergence criterion\n* and maximum number of iterations.\n*\n* @param p the Poisson mean\n* @param epsilon the convergence criteria for cumulative probabilites\n* @param maxIterations the maximum number of iterations for cumulative probabilites\n* @since 2.1\n*/\npublic PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n        }\n        mean = p;\n        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n        this.epsilon = epsilon;\n        this.maxIterations = maxIterations;\n    }\n"
                ]
            ],
            "compiler_error": true,
            "evaluation_done": true
        },
        "iteration_done": true
    }
}