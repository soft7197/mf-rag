{
    "Lang-31": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* <p>Checks if the CharSequence contains any character in the given\n* set of characters.</p>\n*\n* <p>A <code>null</code> CharSequence will return <code>false</code>.\n* A <code>null</code> or zero length search array will return <code>false</code>.</p>\n*\n* <pre>\n* StringUtils.containsAny(null, *)                = false\n* StringUtils.containsAny(\"\", *)                  = false\n* StringUtils.containsAny(*, null)                = false\n* StringUtils.containsAny(*, [])                  = false\n* StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n* StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n* StringUtils.containsAny(\"aba\", ['z'])           = false\n* </pre>\n*\n* @param cs  the CharSequence to check, may be null\n* @param searchChars  the chars to search for, may be null\n* @return the <code>true</code> if any of the chars are found,\n* <code>false</code> if no match or null input\n* @since 2.4\n*/\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tchar ch = cs.charAt(i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == ch) {\n\t\t\t\t\t// ch is a supplementary character\n\t\t\t\t\t// ch is in the Basic Multilingual Plane\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n\tpublic void testContainsAnyCharArrayWithSupplementaryChars() {\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000, CharU20000.toCharArray()));\n\n\t\t// Sanity check:\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\n\t\tassertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n\n\t\t// Test:\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000.toCharArray()));\n\n\t}\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<false> but was:<true>\n\tat org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAnyCharArrayWithSupplementaryChars(StringUtilsEqualsIndexOfTest.java:696)  assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001.toCharArray()));\n \n#Test method 2:\n```java\n\tpublic void testContainsAnyStringWithSupplementaryChars() {\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20000));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000 + CharU20001, CharU20001));\n\n\t\tassertEquals(true, StringUtils.containsAny(CharU20000, CharU20000));\n\n\t\t// Sanity check:\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001));\n\n\t\tassertEquals(0, CharU20000.indexOf(CharU20001.charAt(0)));\n\n\t\tassertEquals(-1, CharU20000.indexOf(CharU20001.charAt(1)));\n\n\t\t// Test:\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n\n\t\tassertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n\n\t}\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<false> but was:<true>\n\tat org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAnyStringWithSupplementaryChars(StringUtilsEqualsIndexOfTest.java:680)  assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tint codePoint = Character.codePointAt(cs, i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (Character.codePointAt(searchChars, j) == codePoint) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (Character.isSupplementaryCodePoint(codePoint)) {\n\t\t\ti++; // Skip the next char as it's part of the current code point\n\t\t}\n\t}\n\treturn false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (Character.charCount(codePoint) == 1 && searchChars[j] == codePoint) {\n                return true;\n            }\n        }\n        if (Character.charCount(codePoint) == 2) {\n            i++; // Skip the next char as it's part of the surrogate pair\n        }\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (Character.codePointAt(searchChars, j) == codePoint) {\n                return true;\n            }\n        }\n        if (Character.isSupplementaryCodePoint(codePoint)) {\n            i++;\n        }\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (codePoint == searchChars[j]) {\n                return true;\n            }\n        }\n        if (Character.isSupplementaryCodePoint(codePoint)) {\n            i++;\n        }\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; ) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (searchChars[j] == codePoint) {\n                return true;\n            }\n        }\n        i += Character.charCount(codePoint);\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tint codePoint = Character.codePointAt(cs, i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (searchChars[j] == codePoint) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (Character.isSupplementaryCodePoint(codePoint)) {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        int charCount = Character.charCount(codePoint);\n\n        for (int j = 0; j < searchLength; j++) {\n            if (searchChars[j] == codePoint) {\n                return true;\n            }\n        }\n\n        i += charCount - 1; // Adjust the index for supplementary characters\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (Character.codePointAt(searchChars, j) == codePoint) {\n                return true;\n            }\n        }\n        if (Character.isSupplementaryCodePoint(codePoint)) {\n            i++; // Skip the next char as it's part of the current code point\n        }\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    \n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; ) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (searchChars[j] == codePoint) {\n                return true;\n            }\n        }\n        i += Character.charCount(codePoint);\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (codePoint == searchChars[j]) {\n                return true;\n            }\n        }\n        if (Character.isSupplementaryCodePoint(codePoint)) {\n            i++;\n        }\n    }\n    return false;\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tint codePoint = Character.codePointAt(cs, i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (Character.codePointAt(searchChars, j) == codePoint) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (Character.isSupplementaryCodePoint(codePoint)) {\n\t\t\ti++; // Skip the next char as it's part of the current code point\n\t\t}\n\t}\n\treturn false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (Character.codePointAt(searchChars, j) == codePoint) {\n                return true;\n            }\n        }\n        if (Character.isSupplementaryCodePoint(codePoint)) {\n            i++;\n        }\n    }\n    return false;\n}\n"
                ],
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n        return false;\n    }\n    int csLength = cs.length();\n    int searchLength = searchChars.length;\n    for (int i = 0; i < csLength; i++) {\n        int codePoint = Character.codePointAt(cs, i);\n        for (int j = 0; j < searchLength; j++) {\n            if (Character.codePointAt(searchChars, j) == codePoint) {\n                return true;\n            }\n        }\n        if (Character.isSupplementaryCodePoint(codePoint)) {\n            i++; // Skip the next char as it's part of the current code point\n        }\n    }\n    return false;\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\npublic static boolean containsAny(CharSequence cs, char[] searchChars) {\n\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n\t\treturn false;\n\t}\n\tint csLength = cs.length();\n\tint searchLength = searchChars.length;\n\tfor (int i = 0; i < csLength; i++) {\n\t\tint codePoint = Character.codePointAt(cs, i);\n\t\tfor (int j = 0; j < searchLength; j++) {\n\t\t\tif (Character.codePointAt(searchChars, j) == codePoint) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (Character.isSupplementaryCodePoint(codePoint)) {\n\t\t\ti++; // Skip the next char as it's part of the current code point\n\t\t}\n\t}\n\treturn false;\n}\n"
                ]
            ]
        }
    }
}