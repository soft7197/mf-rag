{
    "Compress-12": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Get the next entry in this tar archive. This will skip\n* over any remaining data in the current entry, if there\n* is one, and place the input stream at the header of the\n* next entry, and read the header and instantiate a new\n* TarEntry from the header bytes and return that entry.\n* If there are no more entries in the archive, null will\n* be returned to indicate that the end of the archive has\n* been reached.\n*\n* @return The next TarEntry in the archive, or null.\n* @throws IOException on error\n*/\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testCOMPRESS178() throws Exception {\n\n        final File input = getFile(\"COMPRESS-178.tar\");\n\n        final InputStream is = new FileInputStream(input);\n\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n\n        try {\n\n            in.getNextEntry();\n\n            fail(\"Expected IOException\");\n\n        } catch (IOException e) {\n\n            Throwable t = e.getCause();\n\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n\n        }\n\n        in.close();\n\n    }\n\n```\n#Error message: \tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:99)  throw new IllegalArgumentException(                        exceptionMessage(buffer, offset, length, start, currentByte));\n\tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctalOrBinary(TarUtils.java:130)  return parseOctal(buffer, offset, length);\n\tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:815)  groupId = (int) TarUtils.parseOctalOrBinary(header, offset, GIDLEN);\n\tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:314)  parseTarHeader(headerBuf);\n\tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:198)  currEntry = new TarArchiveEntry(headerBuf);\n\tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextEntry(TarArchiveInputStream.java:395)  return getNextTarEntry();\n\tat org.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178(TarTestCase.java:309)  in.getNextEntry();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header\", e);\n    }\n    \n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchive(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Failed to parse tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchive(byte[] headerBuf) {\n    for (byte b : headerBuf) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n    \n    // Check if header is all zeros, indicating EOF\n    boolean isEOF = true;\n    for (byte b : headerBuf) {\n        if (b != 0) {\n            isEOF = false;\n            break;\n        }\n    }\n    if (isEOF) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuilder longName = new StringBuilder();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ \n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ \n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (headerBuf == null || isEOFRecord(headerBuf)) {\n        hasHitEOF = true;\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header\", e);\n    }\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (headerBuf == null || hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header detected\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || headerBuf == null || !TarArchiveEntry.isValidHeader(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchiveRecord(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Error parsing tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchiveRecord(byte[] record) {\n    for (byte b : record) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEOFRecord(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextTarEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEOFRecord(byte[] headerBuf) {\n    for (byte b : headerBuf) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchiveBlock(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) { // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) { // Process sparse files\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchiveBlock(byte[] headerBuf) {\n    for (byte b : headerBuf) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header\", e);\n    }\n    \n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchive(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Failed to parse tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchive(byte[] headerBuf) {\n    for (byte b : headerBuf) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (headerBuf == null || hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header detected\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchiveRecord(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Error parsing tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchiveRecord(byte[] record) {\n    for (byte b : record) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header\", e);\n    }\n    \n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchive(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Failed to parse tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        // read in the name\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            // Bugzilla: 40334\n            // Malformed tar file - long entry name not followed by entry\n            return null;\n        }\n        // remove trailing null terminator\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()){ // Process Pax headers\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()){ // Process sparse files\n        readGNUSparse();\n    }\n\n    // If the size of the next element in the archive has changed\n    // due to a new size being reported in the posix header\n    // information, we update entrySize here so that it contains\n    // the correct value.\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchive(byte[] headerBuf) {\n    for (byte b : headerBuf) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (headerBuf == null || hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Invalid tar header detected\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n\n        if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n"
                ],
                [
                    "\npublic TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n\n        readBuf = null;\n    }\n\n    byte[] headerBuf = getRecord();\n\n    if (hasHitEOF || isEndOfArchiveRecord(headerBuf)) {\n        currEntry = null;\n        return null;\n    }\n\n    try {\n        currEntry = new TarArchiveEntry(headerBuf);\n    } catch (IllegalArgumentException e) {\n        throw new IOException(\"Error parsing tar header\", e);\n    }\n\n    entryOffset = 0;\n    entrySize = currEntry.getSize();\n\n    if (currEntry.isGNULongNameEntry()) {\n        StringBuffer longName = new StringBuffer();\n        byte[] buf = new byte[SMALL_BUFFER_SIZE];\n        int length = 0;\n        while ((length = read(buf)) >= 0) {\n            longName.append(new String(buf, 0, length));\n        }\n        getNextEntry();\n        if (currEntry == null) {\n            return null;\n        }\n        if (longName.length() > 0\n            && longName.charAt(longName.length() - 1) == 0) {\n            longName.deleteCharAt(longName.length() - 1);\n        }\n        currEntry.setName(longName.toString());\n    }\n\n    if (currEntry.isPaxHeader()) {\n        paxHeaders();\n    }\n\n    if (currEntry.isGNUSparse()) {\n        readGNUSparse();\n    }\n\n    entrySize = currEntry.getSize();\n    return currEntry;\n}\n\nprivate boolean isEndOfArchiveRecord(byte[] record) {\n    for (byte b : record) {\n        if (b != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n"
                ]
            ]
        }
    }
}