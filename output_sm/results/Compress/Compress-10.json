{
    "Compress-10": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Walks through all recorded entries and adds the data available\n* from the local file header.\n*\n* <p>Also records the offsets for the data to read from the\n* entries.</p>\n*/\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n\n        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n\n        File archive = new File(new URI(zip.toString()));\n\n        ZipFile zf = null;\n\n        try {\n\n            zf = new ZipFile(archive, null, true);\n\n            assertCanRead(zf, ASCII_TXT);\n\n            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n\n            assertCanRead(zf, OIL_BARREL_TXT);\n\n        } finally {\n\n            ZipFile.closeQuietly(zf);\n\n        }\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: InputStream is null\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.assertCanRead(UTF8ZipFilesTest.java:144)  assertNotNull(\"InputStream is null\", is);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive(UTF8ZipFilesTest.java:133)  assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> updatedEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        updatedEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(updatedEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry ze : new ArrayList<>(entries.keySet())) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        newEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(newEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> tempEntries = new HashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        tempEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(tempEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n                entries.put(ze, offsetEntry);  // Reinsert entry with updated key\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> \n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry originalZe : entries.keySet()) {\n        ZipArchiveEntry ze = new ZipArchiveEntry(originalZe);\n        OffsetEntry offsetEntry = entries.get(originalZe);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(originalZe)) {\n            String orig = originalZe.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(originalZe);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        newEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(newEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : new ArrayList<>(entries.keySet())) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : new ArrayList<>(entries.keySet())) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> \n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, \n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        newEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(newEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    Map<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n        \n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        \n        newEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(newEntries);\n}\n"
                ]
            ],
            "compiler_error": true,
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Walks through all recorded entries and adds the data available\n* from the local file header.\n*\n* <p>Also records the offsets for the data to read from the\n* entries.</p>\n*/\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n\n        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n\n        File archive = new File(new URI(zip.toString()));\n\n        ZipFile zf = null;\n\n        try {\n\n            zf = new ZipFile(archive, null, true);\n\n            assertCanRead(zf, ASCII_TXT);\n\n            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n\n            assertCanRead(zf, OIL_BARREL_TXT);\n\n        } finally {\n\n            ZipFile.closeQuietly(zf);\n\n        }\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: InputStream is null\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.assertCanRead(UTF8ZipFilesTest.java:144)  assertNotNull(\"InputStream is null\", is);\n\tat org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive(UTF8ZipFilesTest.java:133)  assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprivate static ZipOutputTest writeSmallDeflatedEntryToFile(final boolean knownSize, final Zip64Mode mode) { return new ZipOutputTest() { public void test(File f, ZipArchiveOutputStream zos) throws IOException { if (mode != Zip64Mode.AsNeeded) { zos.setUseZip64(mode); } byte[] buf = new byte[ONE_MILLION]; ZipArchiveEntry zae = new ZipArchiveEntry(\\\"0\\\"); if (knownSize) { zae.setSize(ONE_MILLION); } zae.setMethod(ZipArchiveEntry.DEFLATED); zos.putArchiveEntry(zae); zos.write(buf); zos.closeArchiveEntry(); zos.close(); RandomAccessFile a = new RandomAccessFile(f, \\\"r\\\"); try { getLengthAndPositionAtCentralDirectory(a); byte[] header = new byte[12]; a.readFully(header); assertArrayEquals(new byte[] { (byte) 0x50, (byte) 0x4b, 1, 2, 20, 0, 10, 0, 0, 8, 8, 0 }, header); a.skipBytes(4); byte[] crc = new byte[4]; a.readFully(crc); assertArrayEquals(new byte[] { (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12 }, crc); a.skipBytes(4); byte[] rest = new byte[23]; a.readFully(rest); assertArrayEquals(new byte[] { (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) '0' }, rest); a.seek(0); header = new byte[10]; a.readFully(header); assertArrayEquals(new byte[] { (byte) 0x50, (byte) 0x4b, 3, 4, 10, 0, 0, 8, 8, 0 }, header); a.skipBytes(4); crc = new byte[4]; a.readFully(crc); assertArrayEquals(new byte[] { (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12 }, crc); a.skipBytes(4); rest = new byte[9]; a.readFully(rest); boolean hasExtra = mode == Zip64Mode.AsNeeded && !knownSize; assertArrayEquals(new byte[] { (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0, 1, 0, (byte) (!hasExtra ? 0 : 20), 0, (byte) '0' }, rest); if (hasExtra) { byte[] extra = new byte[12]; a.readFully(extra); assertArrayEquals(new byte[] { 1, 0, 16, 0, (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0, 0, 0, 0, 0 }, extra); } } finally { a.close(); } } }; }\n```\n\n            \n```java\nprivate boolean readBlock(boolean decompress) throws IOException { boolean success = true; if (in == null) { throw new IOException(\\\"input buffer is closed\\\"); } if (!isCompressed || (currBlkIdx == -1)) { success = readFully(blockBuffer, 0, blockSize); bytesRead += blockSize; } else { if (!readFully(blockBuffer, 0, 4)) { return false; } bytesRead += 4; int h = DumpArchiveUtil.convert32(blockBuffer, 0); boolean compressed = (h & 0x01) == 0x01; if (!compressed) { success = readFully(blockBuffer, 0, blockSize); bytesRead += blockSize; } else { int flags = (h >> 1) & 0x07; int length = (h >> 4) & 0x0FFFFFFF; byte[] compBuffer = new byte[length]; success = readFully(compBuffer, 0, length); bytesRead += length; if (!decompress) { Arrays.fill(blockBuffer, (byte) 0); } else { switch(DumpArchiveConstants.COMPRESSION_TYPE.find(flags & 0x03)) { case ZLIB: try { Inflater inflator = new Inflater(); inflator.setInput(compBuffer, 0, compBuffer.length); length = inflator.inflate(blockBuffer); if (length != blockSize) { throw new ShortFileException(); } inflator.end(); } catch (DataFormatException e) { throw new DumpArchiveException(\\\"bad data\\\", e); } break; case BZLIB: throw new UnsupportedCompressionAlgorithmException(\\\"BZLIB2\\\"); case LZO: throw new UnsupportedCompressionAlgorithmException(\\\"LZO\\\"); default: throw new UnsupportedCompressionAlgorithmException(); } } } } currBlkIdx++; readOffset = 0; return success; }\n```\n\n            \n```java\nprivate void readCentralDirectoryEntry(Map<ZipArchiveEntry, NameAndComment> noUTF8Flag) throws IOException { byte[] cfh = new byte[CFH_LEN]; archive.readFully(cfh); int off = 0; ZipArchiveEntry ze = new ZipArchiveEntry(); int versionMadeBy = ZipShort.getValue(cfh, off); off += SHORT; ze.setPlatform((versionMadeBy >> BYTE_SHIFT) & NIBLET_MASK); off += SHORT; final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(cfh, off); final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames(); final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding; ze.setGeneralPurposeBit(gpFlag); off += SHORT; ze.setMethod(ZipShort.getValue(cfh, off)); off += SHORT; long time = ZipUtil.dosToJavaTime(ZipLong.getValue(cfh, off)); ze.setTime(time); off += WORD; ze.setCrc(ZipLong.getValue(cfh, off)); off += WORD; ze.setCompressedSize(ZipLong.getValue(cfh, off)); off += WORD; ze.setSize(ZipLong.getValue(cfh, off)); off += WORD; int fileNameLen = ZipShort.getValue(cfh, off); off += SHORT; int extraLen = ZipShort.getValue(cfh, off); off += SHORT; int commentLen = ZipShort.getValue(cfh, off); off += SHORT; int diskStart = ZipShort.getValue(cfh, off); off += SHORT; ze.setInternalAttributes(ZipShort.getValue(cfh, off)); off += SHORT; ze.setExternalAttributes(ZipLong.getValue(cfh, off)); off += WORD; byte[] fileName = new byte[fileNameLen]; archive.readFully(fileName); ze.setName(entryEncoding.decode(fileName), fileName); OffsetEntry offset = new OffsetEntry(); offset.headerOffset = ZipLong.getValue(cfh, off); entries.put(ze, offset); nameMap.put(ze.getName(), ze); byte[] cdExtraData = new byte[extraLen]; archive.readFully(cdExtraData); ze.setCentralDirectoryExtra(cdExtraData); setSizesAndOffsetFromZip64Extra(ze, offset, diskStart); byte[] comment = new byte[commentLen]; archive.readFully(comment); ze.setComment(entryEncoding.decode(comment)); if (!hasUTF8Flag && useUnicodeExtraFields) { noUTF8Flag.put(ze, new NameAndComment(fileName, comment)); } }\n```\n\n            \n```java\nprivate static ZipOutputTest writeSmallDeflatedEntryToStream(final boolean knownSize, final Zip64Mode mode) { return new ZipOutputTest() { public void test(File f, ZipArchiveOutputStream zos) throws IOException { if (mode != Zip64Mode.AsNeeded) { zos.setUseZip64(mode); } byte[] buf = new byte[ONE_MILLION]; ZipArchiveEntry zae = new ZipArchiveEntry(\\\"0\\\"); if (knownSize) { zae.setSize(ONE_MILLION); } zae.setMethod(ZipArchiveEntry.DEFLATED); zos.putArchiveEntry(zae); zos.write(buf); zos.closeArchiveEntry(); zos.close(); RandomAccessFile a = new RandomAccessFile(f, \\\"r\\\"); try { getLengthAndPositionAtCentralDirectory(a); long cfhPos = a.getFilePointer(); byte[] header = new byte[12]; a.readFully(header); assertArrayEquals(new byte[] { (byte) 0x50, (byte) 0x4b, 1, 2, 20, 0, 20, 0, 8, 8, 8, 0 }, header); a.skipBytes(4); byte[] crc = new byte[4]; a.readFully(crc); assertArrayEquals(new byte[] { (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12 }, crc); a.skipBytes(4); byte[] rest = new byte[23]; a.readFully(rest); assertArrayEquals(new byte[] { (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) '0' }, rest); a.seek(cfhPos - 16); byte[] dd = new byte[8]; a.readFully(dd); assertArrayEquals(new byte[] { (byte) 0x50, (byte) 0x4b, 7, 8, (byte) 0x9E, (byte) 0xCB, (byte) 0x79, (byte) 0x12 }, dd); a.skipBytes(4); dd = new byte[4]; a.readFully(dd); assertArrayEquals(new byte[] { (byte) 0x40, (byte) 0x42, (byte) 0x0F, 0 }, dd); a.seek(0); header = new byte[10]; a.readFully(header); assertArrayEquals(new byte[] { (byte) 0x50, (byte) 0x4b, 3, 4, 20, 0, 8, 8, 8, 0 }, header); a.skipBytes(4); rest = new byte[17]; a.readFully(rest); assertArrayEquals(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, (byte) '0' }, rest); } finally { a.close(); } } }; }\n```\n\n            \n```java\npublic void testExplicitFileEntry() throws Exception { File[] tmp = createTempDirAndFile(); File archive = null; TarArchiveOutputStream tos = null; TarArchiveInputStream tis = null; FileInputStream fis = null; try { archive = File.createTempFile(\\\"test.\\\", \\\".tar\\\", tmp[0]); archive.deleteOnExit(); tos = new TarArchiveOutputStream(new FileOutputStream(archive)); TarArchiveEntry in = new TarArchiveEntry(\\\"foo\\\"); in.setModTime(tmp[1].lastModified()); in.setSize(tmp[1].length()); tos.putArchiveEntry(in); byte[] b = new byte[(int) tmp[1].length()]; fis = new FileInputStream(tmp[1]); while (fis.read(b) > 0) { tos.write(b); } fis.close(); fis = null; tos.closeArchiveEntry(); tos.close(); tos = null; tis = new TarArchiveInputStream(new FileInputStream(archive)); TarArchiveEntry out = tis.getNextTarEntry(); tis.close(); tis = null; assertNotNull(out); assertEquals(\\\"foo\\\", out.getName()); assertEquals(tmp[1].length(), out.getSize()); assertEquals(tmp[1].lastModified() / 1000, out.getLastModifiedDate().getTime() / 1000); assertFalse(out.isDirectory()); } finally { if (tis != null) { tis.close(); } if (tos != null) { tos.close(); } tryHardToDelete(archive); if (fis != null) { fis.close(); } tryHardToDelete(tmp[1]); rmdir(tmp[0]); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> originalEntries = new LinkedHashMap<>(entries);\n    for (ZipArchiveEntry ze : originalEntries.keySet()) {\n        OffsetEntry offsetEntry = originalEntries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n    entries.clear();\n    entries.putAll(originalEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    Map<ZipArchiveEntry, OffsetEntry> tmpEntries = new LinkedHashMap<>();\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        \n        tmpEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(tmpEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : new ArrayList<>(entries.keySet())) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\n/**\n* Walks through all recorded entries and adds the data available\n* from the local file header.\n*\n* <p>Also records the offsets for the data to read from the\n* entries.</p>\n*/\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> updatedEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        updatedEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(updatedEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        // Error might be that entriesWithoutUTF8Flag.get(ze) returns null\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            if (nc != null) {\n                String orig = ze.getName();\n                ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name, nc.comment);\n                if (!orig.equals(ze.getName())) {\n                    nameMap.remove(orig);\n                    nameMap.put(ze.getName(), ze);\n                }\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        newEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(newEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment> entriesWithoutUTF8Flag)\n    throws IOException {\n    // Map needs to be reconstructed in order to keep central directory order\n    Map<ZipArchiveEntry, OffsetEntry> entriesCopy = new LinkedHashMap<>(entries);\n\n    for (ZipArchiveEntry ze : entriesCopy.keySet()) {\n        OffsetEntry offsetEntry = entriesCopy.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    // changing the name of a ZipArchiveEntry is going to change\n    // the hashcode - see COMPRESS-164\n    // Map needs to be reconstructed in order to keep central\n    // directory order\n    Map<ZipArchiveEntry, OffsetEntry> updatedEntries = new LinkedHashMap<>();\n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        String originalName = ze.getName();\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!originalName.equals(ze.getName())) {\n                nameMap.remove(originalName);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        updatedEntries.put(ze, offsetEntry);\n    }\n    entries.clear();\n    entries.putAll(updatedEntries);\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    for (ZipArchiveEntry ze : new ArrayList<>(entries.keySet())) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n                                        entriesWithoutUTF8Flag)\n    throws IOException {\n    Map<ZipArchiveEntry, OffsetEntry> newEntries = new LinkedHashMap<>();\n    \n    for (ZipArchiveEntry ze : entries.keySet()) {\n        OffsetEntry offsetEntry = entries.get(ze);\n        long offset = offsetEntry.headerOffset;\n        archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n        byte[] b = new byte[SHORT];\n        archive.readFully(b);\n        int fileNameLen = ZipShort.getValue(b);\n        archive.readFully(b);\n        int extraFieldLen = ZipShort.getValue(b);\n        int lenToSkip = fileNameLen;\n        while (lenToSkip > 0) {\n            int skipped = archive.skipBytes(lenToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip file name in\"\n                                           + \" local file header\");\n            }\n            lenToSkip -= skipped;\n        }\n        byte[] localExtraData = new byte[extraFieldLen];\n        archive.readFully(localExtraData);\n        ze.setExtra(localExtraData);\n        offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n            + SHORT + SHORT + fileNameLen + extraFieldLen;\n\n        if (entriesWithoutUTF8Flag.containsKey(ze)) {\n            String orig = ze.getName();\n            NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n            ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n                                                     nc.comment);\n            if (!orig.equals(ze.getName())) {\n                nameMap.remove(orig);\n                nameMap.put(ze.getName(), ze);\n            }\n        }\n        \n        newEntries.put(ze, offsetEntry);\n    }\n    \n    entries.clear();\n    entries.putAll(newEntries);\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}