{
    "Compress-35": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n* <blockquote>\n* The checksum is calculated by taking the sum of the unsigned byte values\n* of the header block with the eight checksum bytes taken to be ascii\n* spaces (decimal value 32). It is stored as a six digit octal number with\n* leading zeroes followed by a NUL and then a space. Various\n* implementations do not adhere to this format. For better compatibility,\n* ignore leading and trailing whitespace, and get the first six digits. In\n* addition, some historic tar implementations treated bytes as signed.\n* Implementations typically calculate the checksum both ways, and treat it\n* as good if either the signed or unsigned sum matches the included\n* checksum.\n* </blockquote>\n* <p>\n* The return value of this method should be treated as a best-effort\n* heuristic rather than an absolute and final truth. The checksum\n* verification logic may well evolve over time as more special cases\n* are encountered.\n*\n* @param header tar header\n* @return whether the checksum is reasonably good\n* @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n* @since 1.5\n*/\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testCOMPRESS335() throws Exception {\n\n        final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n\n        assertNotNull(tar);\n\n        assertTrue(tar instanceof TarArchiveInputStream);\n\n    }\n\n```\n#Error message: org.apache.commons.compress.archivers.ArchiveException: No Archiver found for the stream signature\n\tat org.apache.commons.compress.archivers.ArchiveStreamFactory.createArchiveInputStream(ArchiveStreamFactory.java:397)  throw new ArchiveException(\"No Archiver found for the stream signature\");\n\tat org.apache.commons.compress.DetectArchiverTestCase.getStreamFor(DetectArchiverTestCase.java:101)  return factory.createArchiveInputStream(                   new BufferedInputStream(new FileInputStream(                       getFile(resource))));\n\tat org.apache.commons.compress.DetectArchiverTestCase.testCOMPRESS335(DetectArchiverTestCase.java:60)  final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte)b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte) b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    boolean inChecksumField = false;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            inChecksumField = true;\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        } else {\n            inChecksumField = false;\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    boolean foundNull = false;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (b == 0) {\n                foundNull = true;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return (storedSum == unsignedSum || storedSum == signedSum) && foundNull;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    boolean foundNonSpace = false;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (b == ' ' || b == 0) {\n                if (digits > 0 && !foundNonSpace) {\n                    foundNonSpace = true;\n                }\n            } else {\n                foundNonSpace = true;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    boolean foundNull = false;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (b == 0 || b == ' ') {\n                foundNull = (b == 0);\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return (digits == 6 && foundNull) && (storedSum == unsignedSum || storedSum == signedSum);\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    boolean foundNull = false;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (b == 0 && !foundNull) {\n                foundNull = true;\n            } else if (b != ' ' && b != 0) {\n                break;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                break;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte) b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0 && (b == '\\0' || b == ' ')) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte) b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Wikipedia <a href=\"http://en.wikipedia.org/wiki/Tar_(file_format)#File_header\">says</a>:\n* <blockquote>\n* The checksum is calculated by taking the sum of the unsigned byte values\n* of the header block with the eight checksum bytes taken to be ascii\n* spaces (decimal value 32). It is stored as a six digit octal number with\n* leading zeroes followed by a NUL and then a space. Various\n* implementations do not adhere to this format. For better compatibility,\n* ignore leading and trailing whitespace, and get the first six digits. In\n* addition, some historic tar implementations treated bytes as signed.\n* Implementations typically calculate the checksum both ways, and treat it\n* as good if either the signed or unsigned sum matches the included\n* checksum.\n* </blockquote>\n* <p>\n* The return value of this method should be treated as a best-effort\n* heuristic rather than an absolute and final truth. The checksum\n* verification logic may well evolve over time as more special cases\n* are encountered.\n*\n* @param header tar header\n* @return whether the checksum is reasonably good\n* @see <a href=\"https://issues.apache.org/jira/browse/COMPRESS-191\">COMPRESS-191</a>\n* @since 1.5\n*/\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits++ < 6) {\n                storedSum = storedSum * 8 + b - '0';\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testCOMPRESS335() throws Exception {\n\n        final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n\n        assertNotNull(tar);\n\n        assertTrue(tar instanceof TarArchiveInputStream);\n\n    }\n\n```\n#Error message: org.apache.commons.compress.archivers.ArchiveException: No Archiver found for the stream signature\n\tat org.apache.commons.compress.archivers.ArchiveStreamFactory.createArchiveInputStream(ArchiveStreamFactory.java:397)  throw new ArchiveException(\"No Archiver found for the stream signature\");\n\tat org.apache.commons.compress.DetectArchiverTestCase.getStreamFor(DetectArchiverTestCase.java:101)  return factory.createArchiveInputStream(                   new BufferedInputStream(new FileInputStream(                       getFile(resource))));\n\tat org.apache.commons.compress.DetectArchiverTestCase.testCOMPRESS335(DetectArchiverTestCase.java:60)  final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprivate static long getLengthAndPositionAtCentralDirectory(RandomAccessFile a) throws IOException { final long end = a.length(); a.seek(end - 22 - 20); byte[] sig = new byte[4]; a.readFully(sig); if (sig[0] != (byte) 0x50 || sig[1] != (byte) 0x4b || sig[2] != 6 || sig[3] != 7) { return getLengthAndPositionAtCentralDirectory32(a, end); } long cdOffsetLoc = end - 22 - 20 - 56 + 48; a.seek(cdOffsetLoc); byte[] cdOffset = new byte[8]; a.readFully(cdOffset); a.seek(ZipEightByteInteger.getLongValue(cdOffset)); return end; }\n```\n\n            \n```java\n@Override public int read(byte[] b, int off, int len) throws IOException { if ((len % recordSize) != 0) { throw new IllegalArgumentException(\\\"all reads must be multiple of record size (\\\" + recordSize + \\\" bytes.\\\"); } int bytes = 0; while (bytes < len) { if ((readOffset == blockSize) && !readBlock(true)) { return -1; } int n = 0; if ((readOffset + (len - bytes)) <= blockSize) { n = len - bytes; } else { n = blockSize - readOffset; } System.arraycopy(blockBuffer, readOffset, b, off, n); readOffset += n; bytes += n; off += n; } return bytes; }\n```\n\n            \n```java\nstatic byte[] long2byteArray(final long number, final int length, final boolean swapHalfWord) { byte[] ret = new byte[length]; int pos = 0; long tmp_number = 0; if (length % 2 != 0 || length < 2) { throw new UnsupportedOperationException(); } tmp_number = number; for (pos = length - 1; pos >= 0; pos--) { ret[pos] = (byte) (tmp_number & 0xFF); tmp_number >>= 8; } if (!swapHalfWord) { byte tmp = 0; for (pos = 0; pos < length; pos++) { tmp = ret[pos]; ret[pos++] = ret[pos]; ret[pos] = tmp; } } return ret; }\n```\n\n            \n```java\nprotected File createSingleEntryArchive(String archivename) throws Exception { ArchiveOutputStream out = null; OutputStream stream = null; archiveList = new ArrayList<String>(); try { archive = File.createTempFile(\\\"empty\\\", \\\".\\\" + archivename); archive.deleteOnExit(); stream = new FileOutputStream(archive); out = factory.createArchiveOutputStream(archivename, stream); addArchiveEntry(out, \\\"test1.xml\\\", getFile(\\\"test1.xml\\\")); out.finish(); } finally { if (out != null) { out.close(); } else if (stream != null) { stream.close(); } } return archive; }\n```\n\n            \n```java\nprotected byte[] getLongNameData() throws IOException { ByteArrayOutputStream longName = new ByteArrayOutputStream(); int length = 0; while ((length = read(SMALL_BUF)) >= 0) { longName.write(SMALL_BUF, 0, length); } getNextEntry(); if (currEntry == null) { return null; } byte[] longNameData = longName.toByteArray(); length = longNameData.length; while (length > 0 && longNameData[length - 1] == 0) { --length; } if (length != longNameData.length) { byte[] l = new byte[length]; System.arraycopy(longNameData, 0, l, 0, length); longNameData = l; } return longNameData; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (b == 0 || b == ' ') {\n                // Intentionally stop processing if null or space is encountered\n                break;\n            }\n            b = ' '; // treat as a space for checksum calculation\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte) b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (b == 0 || b == ' ') {\n                if (digits > 0) {\n                    break;\n                }\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + (b - '0');\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                break;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte) b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == ((unsignedSum < 0) ? -unsignedSum : unsignedSum) ||\n           storedSum == ((signedSum < 0) ? -signedSum : signedSum);\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0 && b == '\\0') {\n                digits = 6; // complete once we hit the null character\n                b = ' ';\n            } else {\n                b = ' ';\n            }\n        }\n        unsignedSum += 0xff & b;\n        signedSum += b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ],
                [
                    "\npublic static boolean verifyCheckSum(byte[] header) {\n    long storedSum = 0;\n    long unsignedSum = 0;\n    long signedSum = 0;\n\n    int digits = 0;\n    for (int i = 0; i < header.length; i++) {\n        byte b = header[i];\n        if (CHKSUM_OFFSET <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n            if ('0' <= b && b <= '7' && digits < 6) {\n                storedSum = storedSum * 8 + b - '0';\n                digits++;\n            } else if (digits > 0) {\n                digits = 6;\n            }\n            b = ' ';\n        }\n        unsignedSum += 0xff & b;\n        signedSum += (byte) b;\n    }\n    return storedSum == unsignedSum || storedSum == signedSum;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}