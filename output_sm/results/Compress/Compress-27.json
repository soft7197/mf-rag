{
    "Compress-27": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Parse an octal string from a buffer.\n*\n* <p>Leading spaces are ignored.\n* The buffer must contain a trailing space or NUL,\n* and may contain an additional trailing space or NUL.</p>\n*\n* <p>The input buffer is allowed to contain all NULs,\n* in which case the method returns 0L\n* (this allows for missing fields).</p>\n*\n* <p>To work-around some tar implementations that insert a\n* leading NUL this method returns 0 if it detects a leading NUL\n* since Commons Compress 1.4.</p>\n*\n* @param buffer The buffer from which to parse.\n* @param offset The offset into the buffer from which to parse.\n* @param length The maximum number of bytes to parse - must be at least 2 bytes.\n* @return The long value of the octal string.\n* @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n*/\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testParseOctal() throws Exception{\n\n        long value; \n\n        byte [] buffer;\n\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL_OVERFLOW, value);\n\n        buffer[buffer.length - 1] = ' ';\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL, value);\n\n        buffer[buffer.length-1]=0;\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(MAX_OCTAL, value);\n\n        buffer=new byte[]{0,0};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n        buffer=new byte[]{0,' '};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n        buffer=new byte[]{' ',0};\n\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n        assertEquals(0, value);\n\n    }\n\n```\n#Error message: \tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:134)  throw new IllegalArgumentException(                    exceptionMessage(buffer, offset, length, start, trailer));\n\tat org.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal(TarUtilsTest.java:68)  value = TarUtils.parseOctal(buffer,0, buffer.length);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (end > start && (trailer == 0 || trailer == ' ')) {\n        end--;\n        if (end > start) {\n            trailer = buffer[end - 1];\n        }\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        if (end > start) {\n            trailer = buffer[end - 1];\n        }\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        if (end > start) {\n            trailer = buffer[end - 1];\n        }\n    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end || (end == offset + length && (trailer != 0 && trailer != ' '))) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        return 0L; // Return 0 if the buffer is just spaces or NULs\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = (end > start) ? buffer[end - 1] : trailer;\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    boolean foundNonZero = false;\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        if (foundNonZero) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        } else {\n            return 0L;\n        }\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        if (result != 0) {\n            foundNonZero = true;\n        }\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (end > start && (trailer == 0 || trailer == ' ')) {\n        end--;\n        if (end > start) {\n            trailer = buffer[end - 1];\n        }\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        return 0L; // Return 0 if the buffer is just spaces or NULs\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = (end > start) ? buffer[end - 1] : trailer;\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    boolean foundNonZero = false;\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        if (foundNonZero) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        } else {\n            return 0L;\n        }\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        if (result != 0) {\n            foundNonZero = true;\n        }\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (end > start && (trailer == 0 || trailer == ' ')) {\n        end--;\n        if (end > start) {\n            trailer = buffer[end - 1];\n        }\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end) {\n        if (buffer[start] == ' ') {\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = (end > start) ? buffer[end - 1] : trailer;\n    }\n    if (start == end) {\n        return 0L;\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0');\n    }\n\n    return result;\n}\n"
                ],
                [
                    "\npublic static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n\n    boolean foundNonZero = false;\n\n    // Trim all trailing NULs and spaces.\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    if (start == end) {\n        if (foundNonZero) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        } else {\n            return 0L;\n        }\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7'){\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        if (result != 0) {\n            foundNonZero = true;\n        }\n    }\n\n    return result;\n}\n"
                ]
            ]
        }
    }
}