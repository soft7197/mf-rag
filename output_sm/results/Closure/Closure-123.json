{
    "Closure-123": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testPrintInOperatorInForLoop() {\n\n    // Check for in expression in for's init expression.\n\n    // Check alone, with + (higher precedence), with ?: (lower precedence),\n\n    // and with conditional.\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a); i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a);i;);\");\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) ? 0 : 1; i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)?0:1;i;);\");\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) + 1; i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)+1;i;);\");\n\n    assertPrint(\"var a={};for (var i = (\\\"length\\\" in a|| \\\"size\\\" in a);;);\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)||(\\\"size\\\"in a);;);\");\n\n    assertPrint(\"var a={};for (var i = a || a || (\\\"size\\\" in a);;);\",\n\n        \"var a={};for(var i=a||a||(\\\"size\\\"in a);;);\");\n\n\n\n    // Test works with unary operators and calls.\n\n    assertPrint(\"var a={}; for (var i = -(\\\"length\\\" in a); i;) {}\",\n\n        \"var a={};for(var i=-(\\\"length\\\"in a);i;);\");\n\n    assertPrint(\"var a={};function b_(p){ return p;};\" +\n\n        \"for(var i=1,j=b_(\\\"length\\\" in a);;) {}\",\n\n        \"var a={};function b_(p){return p}\" +\n\n            \"for(var i=1,j=b_(\\\"length\\\"in a);;);\");\n\n\n\n    // Test we correctly handle an in operator in the test clause.\n\n    assertPrint(\"var a={}; for (;(\\\"length\\\" in a);) {}\",\n\n        \"var a={};for(;\\\"length\\\"in a;);\");\n\n\n\n    // Test we correctly handle an in operator inside a comma.\n\n    assertPrintSame(\"for(x,(y in z);;)foo()\");\n\n    assertPrintSame(\"for(var x,w=(y in z);;)foo()\");\n\n\n\n    // And in operator inside a hook.\n\n    assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n\n  }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<for(a=c?0:[(0 in d)];;)foo()> but was:<for(a=c?0:[0 in d];;)foo()>\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:480)  assertEquals(expected,        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrintSame(CodePrinterTest.java:485)  assertPrint(js, js);\n\tat com.google.javascript.jscomp.CodePrinterTest.testPrintInOperatorInForLoop(CodePrinterTest.java:471)  assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, NodeUtil.precedence(type), Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        addExpr(first.getNext(), 0, getContextForNoInOperator(context)); // Fix for test case\n        add(\";\");\n        addExpr(first.getNext().getNext(), 0, getContextForNoInOperator(context)); // Fix for test case\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      // Ensure the IN operator is correctly parenthesized in a ternary expression\n      if (last.getType() == Token.IN) {\n        addExpr(last, 0, Context.START_OF_EXPR);\n      } else {\n        addExpr(last, 1, rhsContext);\n      }\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      if (first.getNext().getType() == Token.IN) {\n        addExpr(first.getNext(), 0, rhsContext);\n      } else {\n        addExpr(first.getNext(), 1, rhsContext);\n      }\n      cc.addOp(\":\", true);\n      if (last.getType() == Token.IN) {\n        addExpr(last, 0, rhsContext);\n      } else {\n        addExpr(last, 1, rhsContext);\n      }\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        addExpr(first.getNext(), NodeUtil.precedence(Token.IN), Context.OTHER);\n        add(\";\");\n        addExpr(first.getNext().getNext(), NodeUtil.precedence(Token.IN), Context.OTHER);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testPrintInOperatorInForLoop() {\n\n    // Check for in expression in for's init expression.\n\n    // Check alone, with + (higher precedence), with ?: (lower precedence),\n\n    // and with conditional.\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a); i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a);i;);\");\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) ? 0 : 1; i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)?0:1;i;);\");\n\n    assertPrint(\"var a={}; for (var i = (\\\"length\\\" in a) + 1; i;) {}\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)+1;i;);\");\n\n    assertPrint(\"var a={};for (var i = (\\\"length\\\" in a|| \\\"size\\\" in a);;);\",\n\n        \"var a={};for(var i=(\\\"length\\\"in a)||(\\\"size\\\"in a);;);\");\n\n    assertPrint(\"var a={};for (var i = a || a || (\\\"size\\\" in a);;);\",\n\n        \"var a={};for(var i=a||a||(\\\"size\\\"in a);;);\");\n\n\n\n    // Test works with unary operators and calls.\n\n    assertPrint(\"var a={}; for (var i = -(\\\"length\\\" in a); i;) {}\",\n\n        \"var a={};for(var i=-(\\\"length\\\"in a);i;);\");\n\n    assertPrint(\"var a={};function b_(p){ return p;};\" +\n\n        \"for(var i=1,j=b_(\\\"length\\\" in a);;) {}\",\n\n        \"var a={};function b_(p){return p}\" +\n\n            \"for(var i=1,j=b_(\\\"length\\\"in a);;);\");\n\n\n\n    // Test we correctly handle an in operator in the test clause.\n\n    assertPrint(\"var a={}; for (;(\\\"length\\\" in a);) {}\",\n\n        \"var a={};for(;\\\"length\\\"in a;);\");\n\n\n\n    // Test we correctly handle an in operator inside a comma.\n\n    assertPrintSame(\"for(x,(y in z);;)foo()\");\n\n    assertPrintSame(\"for(var x,w=(y in z);;)foo()\");\n\n\n\n    // And in operator inside a hook.\n\n    assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n\n  }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<for(a=c?0:[(0 in d)];;)foo()> but was:<for(a=c?0:[0 in d];;)foo()>\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:480)  assertEquals(expected,        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrintSame(CodePrinterTest.java:485)  assertPrint(js, js);\n\tat com.google.javascript.jscomp.CodePrinterTest.testPrintInOperatorInForLoop(CodePrinterTest.java:471)  assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\n@Override public void visit(NodeTraversal t, Node n, Node parent) { JSType childType; JSType leftType, rightType; Node left, right; boolean typeable = true; switch(n.getType()) { case Token.CAST: Node expr = n.getFirstChild(); JSType exprType = getJSType(expr); JSType castType = getJSType(n); if (!expr.isObjectLit()) { validator.expectCanCast(t, n, castType, exprType); } ensureTyped(t, n, castType); if (castType.isSubtype(exprType) || expr.isObjectLit()) { expr.setJSType(castType); } break; case Token.NAME: typeable = visitName(t, n, parent); break; case Token.PARAM_LIST: typeable = false; break; case Token.COMMA: ensureTyped(t, n, getJSType(n.getLastChild())); break; case Token.TRUE: case Token.FALSE: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.THIS: ensureTyped(t, n, t.getScope().getTypeOfThis()); break; case Token.NULL: ensureTyped(t, n, NULL_TYPE); break; case Token.NUMBER: ensureTyped(t, n, NUMBER_TYPE); break; case Token.STRING: ensureTyped(t, n, STRING_TYPE); break; case Token.STRING_KEY: typeable = false; break; case Token.GETTER_DEF: case Token.SETTER_DEF: break; case Token.ARRAYLIT: ensureTyped(t, n, ARRAY_TYPE); break; case Token.REGEXP: ensureTyped(t, n, REGEXP_TYPE); break; case Token.GETPROP: visitGetProp(t, n, parent); typeable = !(parent.isAssign() && parent.getFirstChild() == n); break; case Token.GETELEM: visitGetElem(t, n); typeable = false; break; case Token.VAR: visitVar(t, n); typeable = false; break; case Token.NEW: visitNew(t, n); break; case Token.CALL: visitCall(t, n); typeable = !parent.isExprResult(); break; case Token.RETURN: visitReturn(t, n); typeable = false; break; case Token.DEC: case Token.INC: left = n.getFirstChild(); checkPropCreation(t, left); validator.expectNumber(t, left, getJSType(left), \\\"increment/decrement\\\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.NOT: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.VOID: ensureTyped(t, n, VOID_TYPE); break; case Token.TYPEOF: ensureTyped(t, n, STRING_TYPE); break; case Token.BITNOT: childType = getJSType(n.getFirstChild()); if (!childType.matchesInt32Context()) { report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()), childType.toString()); } ensureTyped(t, n, NUMBER_TYPE); break; case Token.POS: case Token.NEG: left = n.getFirstChild(); validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\"); ensureTyped(t, n, NUMBER_TYPE); break; case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: { left = n.getFirstChild(); right = n.getLastChild(); if (left.isTypeOf()) { if (right.isString()) { checkTypeofString(t, right, right.getString()); } } else if (right.isTypeOf() && left.isString()) { checkTypeofString(t, left, left.getString()); } leftType = getJSType(left); rightType = getJSType(right); JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined(); JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined(); TernaryValue result = TernaryValue.UNKNOWN; if (n.getType() == Token.EQ || n.getType() == Token.NE) { result = leftTypeRestricted.testForEquality(rightTypeRestricted); if (n.isNE()) { result = result.not(); } } else { if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) { result = n.getType() == Token.SHEQ ? TernaryValue.FALSE : TernaryValue.TRUE; } } if (result != TernaryValue.UNKNOWN) { report(t, n, DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString()); } ensureTyped(t, n, BOOLEAN_TYPE); break; } case Token.LT: case Token.LE: case Token.GT: case Token.GE: leftType = getJSType(n.getFirstChild()); rightType = getJSType(n.getLastChild()); if (rightType.isNumber()) { validator.expectNumber(t, n, leftType, \\\"left side of numeric comparison\\\"); } else if (leftType.isNumber()) { validator.expectNumber(t, n, rightType, \\\"right side of numeric comparison\\\"); } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) { } else { String message = \\\"left side of comparison\\\"; validator.expectString(t, n, leftType, message); validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(STRING_TYPE)); message = \\\"right side of comparison\\\"; validator.expectString(t, n, rightType, message); validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(STRING_TYPE)); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.IN: left = n.getFirstChild(); right = n.getLastChild(); rightType = getJSType(right); validator.expectString(t, left, getJSType(left), \\\"left side of 'in'\\\"); validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\"); if (rightType.isStruct()) { report(t, right, IN_USED_WITH_STRUCT); } ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.INSTANCEOF: left = n.getFirstChild(); right = n.getLastChild(); rightType = getJSType(right).restrictByNotNullOrUndefined(); validator.expectAnyObject(t, left, getJSType(left), \\\"deterministic instanceof yields false\\\"); validator.expectActualObject(t, right, rightType, \\\"instanceof requires an object\\\"); ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.ASSIGN: visitAssign(t, n); typeable = false; break; case Token.ASSIGN_LSH: case Token.ASSIGN_RSH: case Token.ASSIGN_URSH: case Token.ASSIGN_DIV: case Token.ASSIGN_MOD: case Token.ASSIGN_BITOR: case Token.ASSIGN_BITXOR: case Token.ASSIGN_BITAND: case Token.ASSIGN_SUB: case Token.ASSIGN_ADD: case Token.ASSIGN_MUL: checkPropCreation(t, n.getFirstChild()); case Token.LSH: case Token.RSH: case Token.URSH: case Token.DIV: case Token.MOD: case Token.BITOR: case Token.BITXOR: case Token.BITAND: case Token.SUB: case Token.ADD: case Token.MUL: visitBinaryOperator(n.getType(), t, n); break; case Token.DELPROP: ensureTyped(t, n, BOOLEAN_TYPE); break; case Token.CASE: JSType switchType = getJSType(parent.getFirstChild()); JSType caseType = getJSType(n.getFirstChild()); validator.expectSwitchMatchesCase(t, n, switchType, caseType); typeable = false; break; case Token.WITH: { Node child = n.getFirstChild(); childType = getJSType(child); validator.expectObject(t, child, childType, \\\"with requires an object\\\"); typeable = false; break; } case Token.FUNCTION: visitFunction(t, n); break; case Token.LABEL: case Token.LABEL_NAME: case Token.SWITCH: case Token.BREAK: case Token.CATCH: case Token.TRY: case Token.SCRIPT: case Token.EXPR_RESULT: case Token.BLOCK: case Token.EMPTY: case Token.DEFAULT_CASE: case Token.CONTINUE: case Token.DEBUGGER: case Token.THROW: typeable = false; break; case Token.DO: case Token.IF: case Token.WHILE: typeable = false; break; case Token.FOR: if (NodeUtil.isForIn(n)) { Node obj = n.getChildAtIndex(1); if (getJSType(obj).isStruct()) { report(t, obj, IN_USED_WITH_STRUCT); } } typeable = false; break; case Token.AND: case Token.HOOK: case Token.OBJECTLIT: case Token.OR: if (n.getJSType() != null) { ensureTyped(t, n); } else { if ((n.isObjectLit()) && (parent.getJSType() instanceof EnumType)) { ensureTyped(t, n, parent.getJSType()); } else { ensureTyped(t, n); } } if (n.isObjectLit()) { JSType typ = getJSType(n); for (Node key : n.children()) { visitObjLitKey(t, key, n, typ); } } break; default: report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType())); ensureTyped(t, n); break; } typeable = typeable && !inExterns; if (typeable) { doPercentTypedAccounting(t, n); } checkNoTypeCheckSection(n, false); }\n```\n\n            \n```java\nprivate void parseFunctionParams(FunctionNode fnNode) throws IOException { if (matchToken(Token.RP)) { fnNode.setRp(ts.tokenBeg - fnNode.getPosition()); return; } Map<String, Node> destructuring = null; Set<String> paramNames = new HashSet<String>(); do { int tt = peekToken(); if (tt == Token.LB || tt == Token.LC) { AstNode expr = destructuringPrimaryExpr(); markDestructuring(expr); fnNode.addParam(expr); if (destructuring == null) { destructuring = new HashMap<String, Node>(); } String pname = currentScriptOrFn.getNextTempName(); defineSymbol(Token.LP, pname, false); destructuring.put(pname, expr); } else { if (mustMatchToken(Token.NAME, \\\"msg.no.parm\\\")) { fnNode.addParam(createNameNode()); String paramName = ts.getString(); defineSymbol(Token.LP, paramName); if (this.inUseStrictDirective) { if (\\\"eval\\\".equals(paramName) || \\\"arguments\\\".equals(paramName)) { reportError(\\\"msg.bad.id.strict\\\", paramName); } if (paramNames.contains(paramName)) addError(\\\"msg.dup.param.strict\\\", paramName); paramNames.add(paramName); } } else { fnNode.addParam(makeErrorNode()); } } } while (matchToken(Token.COMMA)); if (destructuring != null) { Node destructuringNode = new Node(Token.COMMA); for (Map.Entry<String, Node> param : destructuring.entrySet()) { Node assign = createDestructuringAssignment(Token.VAR, param.getValue(), createName(param.getKey())); destructuringNode.addChildToBack(assign); } fnNode.putProp(Node.DESTRUCTURING_PARAMS, destructuringNode); } if (mustMatchToken(Token.RP, \\\"msg.no.paren.after.parms\\\")) { fnNode.setRp(ts.tokenBeg - fnNode.getPosition()); } }\n```\n\n            \n```java\nprivate void visitExpression(Node node, int contextFlags) { int type = node.getType(); Node child = node.getFirstChild(); int savedStackDepth = stackDepth; switch(type) { case Token.FUNCTION: { int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP); FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex); if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) { throw Kit.codeBug(); } addIndexOp(Icode_CLOSURE_EXPR, fnIndex); stackChange(1); } break; case Token.LOCAL_LOAD: { int localIndex = getLocalBlockRef(node); addIndexOp(Token.LOCAL_LOAD, localIndex); stackChange(1); } break; case Token.COMMA: { Node lastChild = node.getLastChild(); while (child != lastChild) { visitExpression(child, 0); addIcode(Icode_POP); stackChange(-1); child = child.getNext(); } visitExpression(child, contextFlags & ECF_TAIL); } break; case Token.USE_STACK: stackChange(1); break; case Token.REF_CALL: case Token.CALL: case Token.NEW: { if (type == Token.NEW) { visitExpression(child, 0); } else { generateCallFunAndThis(child); } int argCount = 0; while ((child = child.getNext()) != null) { visitExpression(child, 0); ++argCount; } int callType = node.getIntProp(Node.SPECIALCALL_PROP, Node.NON_SPECIALCALL); if (type != Token.REF_CALL && callType != Node.NON_SPECIALCALL) { addIndexOp(Icode_CALLSPECIAL, argCount); addUint8(callType); addUint8(type == Token.NEW ? 1 : 0); addUint16(lineNumber & 0xFFFF); } else { if (type == Token.CALL && (contextFlags & ECF_TAIL) != 0 && !compilerEnv.isGenerateDebugInfo() && !itsInTryFlag) { type = Icode_TAIL_CALL; } addIndexOp(type, argCount); } if (type == Token.NEW) { stackChange(-argCount); } else { stackChange(-1 - argCount); } if (argCount > itsData.itsMaxCalleeArgs) { itsData.itsMaxCalleeArgs = argCount; } } break; case Token.AND: case Token.OR: { visitExpression(child, 0); addIcode(Icode_DUP); stackChange(1); int afterSecondJumpStart = iCodeTop; int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ; addGotoOp(jump); stackChange(-1); addIcode(Icode_POP); stackChange(-1); child = child.getNext(); visitExpression(child, contextFlags & ECF_TAIL); resolveForwardGoto(afterSecondJumpStart); } break; case Token.HOOK: { Node ifThen = child.getNext(); Node ifElse = ifThen.getNext(); visitExpression(child, 0); int elseJumpStart = iCodeTop; addGotoOp(Token.IFNE); stackChange(-1); visitExpression(ifThen, contextFlags & ECF_TAIL); int afterElseJumpStart = iCodeTop; addGotoOp(Token.GOTO); resolveForwardGoto(elseJumpStart); stackDepth = savedStackDepth; visitExpression(ifElse, contextFlags & ECF_TAIL); resolveForwardGoto(afterElseJumpStart); } break; case Token.GETPROP: case Token.GETPROPNOWARN: visitExpression(child, 0); child = child.getNext(); addStringOp(type, child.getString()); break; case Token.DELPROP: boolean isName = child.getType() == Token.BINDNAME; visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); if (isName) { addIcode(Icode_DELNAME); } else { addToken(Token.DELPROP); } stackChange(-1); break; case Token.GETELEM: case Token.BITAND: case Token.BITOR: case Token.BITXOR: case Token.LSH: case Token.RSH: case Token.URSH: case Token.ADD: case Token.SUB: case Token.MOD: case Token.DIV: case Token.MUL: case Token.EQ: case Token.NE: case Token.SHEQ: case Token.SHNE: case Token.IN: case Token.INSTANCEOF: case Token.LE: case Token.LT: case Token.GE: case Token.GT: visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); addToken(type); stackChange(-1); break; case Token.POS: case Token.NEG: case Token.NOT: case Token.BITNOT: case Token.TYPEOF: case Token.VOID: visitExpression(child, 0); if (type == Token.VOID) { addIcode(Icode_POP); addIcode(Icode_UNDEF); } else { addToken(type); } break; case Token.GET_REF: case Token.DEL_REF: visitExpression(child, 0); addToken(type); break; case Token.SETPROP: case Token.SETPROP_OP: { visitExpression(child, 0); child = child.getNext(); String property = child.getString(); child = child.getNext(); if (type == Token.SETPROP_OP) { addIcode(Icode_DUP); stackChange(1); addStringOp(Token.GETPROP, property); stackChange(-1); } visitExpression(child, 0); addStringOp(Token.SETPROP, property); stackChange(-1); } break; case Token.SETELEM: case Token.SETELEM_OP: visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); child = child.getNext(); if (type == Token.SETELEM_OP) { addIcode(Icode_DUP2); stackChange(2); addToken(Token.GETELEM); stackChange(-1); stackChange(-1); } visitExpression(child, 0); addToken(Token.SETELEM); stackChange(-2); break; case Token.SET_REF: case Token.SET_REF_OP: visitExpression(child, 0); child = child.getNext(); if (type == Token.SET_REF_OP) { addIcode(Icode_DUP); stackChange(1); addToken(Token.GET_REF); stackChange(-1); } visitExpression(child, 0); addToken(Token.SET_REF); stackChange(-1); break; case Token.STRICT_SETNAME: case Token.SETNAME: { String name = child.getString(); visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); addStringOp(type, name); stackChange(-1); } break; case Token.SETCONST: { String name = child.getString(); visitExpression(child, 0); child = child.getNext(); visitExpression(child, 0); addStringOp(Icode_SETCONST, name); stackChange(-1); } break; case Token.TYPEOFNAME: { int index = -1; if (itsInFunctionFlag && !itsData.itsNeedsActivation) index = scriptOrFn.getIndexForNameNode(node); if (index == -1) { addStringOp(Icode_TYPEOFNAME, node.getString()); stackChange(1); } else { addVarOp(Token.GETVAR, index); stackChange(1); addToken(Token.TYPEOF); } } break; case Token.BINDNAME: case Token.NAME: case Token.STRING: addStringOp(type, node.getString()); stackChange(1); break; case Token.INC: case Token.DEC: visitIncDec(node, child); break; case Token.NUMBER: { double num = node.getDouble(); int inum = (int) num; if (inum == num) { if (inum == 0) { addIcode(Icode_ZERO); if (1.0 / num < 0.0) { addToken(Token.NEG); } } else if (inum == 1) { addIcode(Icode_ONE); } else if ((short) inum == inum) { addIcode(Icode_SHORTNUMBER); addUint16(inum & 0xFFFF); } else { addIcode(Icode_INTNUMBER); addInt(inum); } } else { int index = getDoubleIndex(num); addIndexOp(Token.NUMBER, index); } stackChange(1); } break; case Token.GETVAR: { if (itsData.itsNeedsActivation) Kit.codeBug(); int index = scriptOrFn.getIndexForNameNode(node); addVarOp(Token.GETVAR, index); stackChange(1); } break; case Token.SETVAR: { if (itsData.itsNeedsActivation) Kit.codeBug(); int index = scriptOrFn.getIndexForNameNode(child); child = child.getNext(); visitExpression(child, 0); addVarOp(Token.SETVAR, index); } break; case Token.SETCONSTVAR: { if (itsData.itsNeedsActivation) Kit.codeBug(); int index = scriptOrFn.getIndexForNameNode(child); child = child.getNext(); visitExpression(child, 0); addVarOp(Token.SETCONSTVAR, index); } break; case Token.NULL: case Token.THIS: case Token.THISFN: case Token.FALSE: case Token.TRUE: addToken(type); stackChange(1); break; case Token.ENUM_NEXT: case Token.ENUM_ID: addIndexOp(type, getLocalBlockRef(node)); stackChange(1); break; case Token.REGEXP: { int index = node.getExistingIntProp(Node.REGEXP_PROP); addIndexOp(Token.REGEXP, index); stackChange(1); } break; case Token.ARRAYLIT: case Token.OBJECTLIT: visitLiteral(node, child); break; case Token.ARRAYCOMP: visitArrayComprehension(node, child, child.getNext()); break; case Token.REF_SPECIAL: visitExpression(child, 0); addStringOp(type, (String) node.getProp(Node.NAME_PROP)); break; case Token.REF_MEMBER: case Token.REF_NS_MEMBER: case Token.REF_NAME: case Token.REF_NS_NAME: { int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0); int childCount = 0; do { visitExpression(child, 0); ++childCount; child = child.getNext(); } while (child != null); addIndexOp(type, memberTypeFlags); stackChange(1 - childCount); } break; case Token.DOTQUERY: { int queryPC; updateLineNumber(node); visitExpression(child, 0); addIcode(Icode_ENTERDQ); stackChange(-1); queryPC = iCodeTop; visitExpression(child.getNext(), 0); addBackwardGoto(Icode_LEAVEDQ, queryPC); } break; case Token.DEFAULTNAMESPACE: case Token.ESCXMLATTR: case Token.ESCXMLTEXT: visitExpression(child, 0); addToken(type); break; case Token.YIELD: if (child != null) { visitExpression(child, 0); } else { addIcode(Icode_UNDEF); stackChange(1); } addToken(Token.YIELD); addUint16(node.getLineno() & 0xFFFF); break; case Token.WITHEXPR: { Node enterWith = node.getFirstChild(); Node with = enterWith.getNext(); visitExpression(enterWith.getFirstChild(), 0); addToken(Token.ENTERWITH); stackChange(-1); visitExpression(with.getFirstChild(), 0); addToken(Token.LEAVEWITH); break; } default: throw badTree(node); } if (savedStackDepth + 1 != stackDepth) { Kit.codeBug(); } }\n```\n\n            \n```java\nprivate void generateStatement(Node node) { updateLineNumber(node); int type = node.getType(); Node child = node.getFirstChild(); switch(type) { case Token.LOOP: case Token.LABEL: case Token.WITH: case Token.SCRIPT: case Token.BLOCK: case Token.EMPTY: if (compilerEnv.isGenerateObserverCount()) { addInstructionCount(1); } while (child != null) { generateStatement(child); child = child.getNext(); } break; case Token.LOCAL_BLOCK: { boolean prevLocal = inLocalBlock; inLocalBlock = true; int local = getNewWordLocal(); if (isGenerator) { cfw.add(ByteCode.ACONST_NULL); cfw.addAStore(local); } node.putIntProp(Node.LOCAL_PROP, local); while (child != null) { generateStatement(child); child = child.getNext(); } releaseWordLocal((short) local); node.removeProp(Node.LOCAL_PROP); inLocalBlock = prevLocal; break; } case Token.FUNCTION: { int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP); OptFunctionNode ofn = OptFunctionNode.get(scriptOrFn, fnIndex); int t = ofn.fnode.getFunctionType(); if (t == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) { visitFunction(ofn, t); } else { if (t != FunctionNode.FUNCTION_STATEMENT) { throw Codegen.badTree(); } } break; } case Token.TRY: visitTryCatchFinally((Jump) node, child); break; case Token.CATCH_SCOPE: { cfw.setStackTop((short) 0); int local = getLocalBlockRegister(node); int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP); String name = child.getString(); child = child.getNext(); generateExpression(child, node); if (scopeIndex == 0) { cfw.add(ByteCode.ACONST_NULL); } else { cfw.addALoad(local); } cfw.addPush(name); cfw.addALoad(contextLocal); cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"newCatchScope\\\", \\\"(Ljava/lang/Throwable;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\"Ljava/lang/String;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); cfw.addAStore(local); } break; case Token.THROW: generateExpression(child, node); if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); generateThrowJavaScriptException(); break; case Token.RETHROW: if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); cfw.addALoad(getLocalBlockRegister(node)); cfw.add(ByteCode.ATHROW); break; case Token.RETURN_RESULT: case Token.RETURN: if (!isGenerator) { if (child != null) { generateExpression(child, node); } else if (type == Token.RETURN) { Codegen.pushUndefined(cfw); } else { if (popvLocal < 0) throw Codegen.badTree(); cfw.addALoad(popvLocal); } } if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); if (epilogueLabel == -1) { if (!hasVarsInRegs) throw Codegen.badTree(); epilogueLabel = cfw.acquireLabel(); } cfw.add(ByteCode.GOTO, epilogueLabel); break; case Token.SWITCH: if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); visitSwitch((Jump) node, child); break; case Token.ENTERWITH: generateExpression(child, node); cfw.addALoad(contextLocal); cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"enterWith\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); cfw.addAStore(variableObjectLocal); incReferenceWordLocal(variableObjectLocal); break; case Token.LEAVEWITH: cfw.addALoad(variableObjectLocal); addScriptRuntimeInvoke(\\\"leaveWith\\\", \\\"(Lorg/mozilla/javascript/Scriptable;\\\" + \\\")Lorg/mozilla/javascript/Scriptable;\\\"); cfw.addAStore(variableObjectLocal); decReferenceWordLocal(variableObjectLocal); break; case Token.ENUM_INIT_KEYS: case Token.ENUM_INIT_VALUES: case Token.ENUM_INIT_ARRAY: generateExpression(child, node); cfw.addALoad(contextLocal); int enumType = type == Token.ENUM_INIT_KEYS ? ScriptRuntime.ENUMERATE_KEYS : type == Token.ENUM_INIT_VALUES ? ScriptRuntime.ENUMERATE_VALUES : ScriptRuntime.ENUMERATE_ARRAY; cfw.addPush(enumType); addScriptRuntimeInvoke(\\\"enumInit\\\", \\\"(Ljava/lang/Object;\\\" + \\\"Lorg/mozilla/javascript/Context;\\\" + \\\"I\\\" + \\\")Ljava/lang/Object;\\\"); cfw.addAStore(getLocalBlockRegister(node)); break; case Token.EXPR_VOID: if (child.getType() == Token.SETVAR) { visitSetVar(child, child.getFirstChild(), false); } else if (child.getType() == Token.SETCONSTVAR) { visitSetConstVar(child, child.getFirstChild(), false); } else if (child.getType() == Token.YIELD) { generateYieldPoint(child, false); } else { generateExpression(child, node); if (node.getIntProp(Node.ISNUMBER_PROP, -1) != -1) cfw.add(ByteCode.POP2); else cfw.add(ByteCode.POP); } break; case Token.EXPR_RESULT: generateExpression(child, node); if (popvLocal < 0) { popvLocal = getNewWordLocal(); } cfw.addAStore(popvLocal); break; case Token.TARGET: { if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); int label = getTargetLabel(node); cfw.markLabel(label); if (compilerEnv.isGenerateObserverCount()) saveCurrentCodeOffset(); } break; case Token.JSR: case Token.GOTO: case Token.IFEQ: case Token.IFNE: if (compilerEnv.isGenerateObserverCount()) addInstructionCount(); visitGoto((Jump) node, type, child); break; case Token.FINALLY: { if (!isGenerator) { break; } if (compilerEnv.isGenerateObserverCount()) saveCurrentCodeOffset(); cfw.setStackTop((short) 1); int finallyRegister = getNewWordLocal(); int finallyStart = cfw.acquireLabel(); int finallyEnd = cfw.acquireLabel(); cfw.markLabel(finallyStart); generateIntegerWrap(); cfw.addAStore(finallyRegister); while (child != null) { generateStatement(child); child = child.getNext(); } cfw.addALoad(finallyRegister); cfw.add(ByteCode.CHECKCAST, \\\"java/lang/Integer\\\"); generateIntegerUnwrap(); FinallyReturnPoint ret = finallys.get(node); ret.tableLabel = cfw.acquireLabel(); cfw.add(ByteCode.GOTO, ret.tableLabel); releaseWordLocal((short) finallyRegister); cfw.markLabel(finallyEnd); } break; case Token.DEBUGGER: break; default: throw Codegen.badTree(); } }\n```\n\n            \n```java\nprivate JsDocToken parseAnnotation(JsDocToken token, List<ExtendedTypeInfo> extendedTypes) { JSTypeExpression type; int lineno = stream.getLineno(); int charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName, stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch(annotation) { case NG_INJECT: if (jsdocBuilder.isNgInjectRecorded()) { parser.addParserWarning(\\\"msg.jsdoc.nginject.extra\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.recordNgInject(true); } return eatTokensUntilEOL(); case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } return token; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning(\\\"msg.jsdoc.consistidgen\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case STRUCT: if (!jsdocBuilder.recordStruct()) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case DICT: if (!jsdocBuilder.recordDict()) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } return eatTokensUntilEOL(); case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\", stream.getLineno(), stream.getCharno()); } ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; return token; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\", stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", stream.getLineno(), stream.getCharno()); } } return eatTokensUntilEOL(); case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\", stream.getLineno(), stream.getCharno()); return eatTokensUntilEOL(); } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; return token; } case FILE_OVERVIEW: String fileOverview = \\\"\\\"; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview)) { parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\", stream.getLineno(), stream.getCharno()); } return token; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; return token; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode(\\\"number\\\")); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } token = eatTokensUntilEOL(token); return token; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning(\\\"msg.jsdoc.export\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning(\\\"msg.jsdoc.expose\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning(\\\"msg.jsdoc.externs\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { extendedTypes.add(new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState(annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\", lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning(\\\"msg.end.annotation.expected\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno); } token = eatTokensUntilEOL(token); return token; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning(\\\"msg.jsdoc.hidden\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\", stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\", stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\", stream.getLineno(), stream.getCharno()); } return token; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning(\\\"msg.jsdoc.noalias\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case NOT_IMPLEMENTED: return eatTokensUntilEOL(); case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning(\\\"msg.jsdoc.override\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordTypeNode(token)); if (type == null) { return eatTokensUntilEOL(); } } token = current(); jsdocBuilder.recordThrowType(type); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } return token; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression(parseAndRecordParamTypeNode(token)); if (type == null) { return eatTokensUntilEOL(); } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning(\\\"msg.missing.variable.name\\\", lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\"); } else if (type != null) { type = JSTypeExpression.makeOptionalArg(type); } } if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name, lineno, charno); } else { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); return token; } jsdocBuilder.markName(name, sourceFile, lineno, charno); if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } return token; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case MODIFIES: token = parseModifiesTag(next()); return token; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\", stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } return token; case STABLEIDGENERATOR: if (!jsdocBuilder.recordStableIdGenerator()) { parser.addParserWarning(\\\"msg.jsdoc.stableidgen\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case SUPPRESS: token = parseSuppressTag(next()); return token; case TEMPLATE: { ExtractionInfo templateInfo = extractSingleLineBlock(); List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string)); if (names.size() == 0 || names.get(0).length() == 0) { parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeNames(names)) { parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; return token; } case IDGENERATOR: token = parseIdGeneratorTag(next()); return token; case WIZACTION: if (!jsdocBuilder.recordWizaction()) { parser.addParserWarning(\\\"msg.jsdoc.wizaction\\\", stream.getLineno(), stream.getCharno()); } return eatTokensUntilEOL(); case DISPOSES: { ExtractionInfo templateInfo = extractSingleLineBlock(); List<String> names = Lists.newArrayList(Splitter.on(',').trimResults().split(templateInfo.string)); if (names.size() == 0 || names.get(0).length() == 0) { parser.addTypeWarning(\\\"msg.jsdoc.disposeparameter.missing\\\", stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordDisposesParameter(names)) { parser.addTypeWarning(\\\"msg.jsdoc.disposeparameter.error\\\", stream.getLineno(), stream.getCharno()); } token = templateInfo.token; return token; } case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\", stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\", stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; return token; case CONSTANT: case DEFINE: case RETURN: case PRIVATE: case PROTECTED: case PUBLIC: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; boolean hasType = lookAheadForTypeAnnotation(); boolean isAlternateTypeAnnotation = (annotation == Annotation.PRIVATE || annotation == Annotation.PROTECTED || annotation == Annotation.PUBLIC || annotation == Annotation.CONSTANT); boolean canSkipTypeAnnotation = (isAlternateTypeAnnotation || annotation == Annotation.RETURN); type = null; if (hasType || !canSkipTypeAnnotation) { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); } type = createJSTypeExpression(typeNode); } boolean hasError = type == null && !canSkipTypeAnnotation; if (!hasError) { if ((type != null && isAlternateTypeAnnotation) || annotation == Annotation.TYPE) { if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } } switch(annotation) { case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning(\\\"msg.jsdoc.const\\\", stream.getLineno(), stream.getCharno()); } break; case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning(\\\"msg.jsdoc.define\\\", lineno, charno); } return recordDescription(token); case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.private\\\", lineno, charno); } return recordDescription(token); case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.protected\\\", lineno, charno); } return recordDescription(token); case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning(\\\"msg.jsdoc.visibility.public\\\", lineno, charno); } return recordDescription(token); case RETURN: if (type == null) { type = createJSTypeExpression(newNode(Token.QMARK)); } if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); break; } if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription(returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } return token; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", lineno, charno); } break; } } return eatTokensUntilEOL(); } } return next(); }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = (context == Context.IN_FOR_INIT_CLAUSE) ? context : Context.OTHER;\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        addExpr(first, 0, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      if (last.getType() == Token.IN) {\n        add(\"(\");\n        addExpr(last, 1, rhsContext);\n        add(\")\");\n      } else {\n        addExpr(last, 1, rhsContext);\n      }\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = (type == Token.IN && context != Context.IN_FOR_INIT_CLAUSE) ? Context.OTHER : getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (first.isNumber()) {\n        cc.addNumber(-first.getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      if (last.getType() == Token.IN) {\n        add(\"(\", context); // Fix for failing test case\n        addExpr(last, 1, rhsContext);\n        add(\")\", context);\n      } else {\n        addExpr(last, 1, rhsContext);\n      }\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type && NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() || !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      if (!n.isQuotedString() && TokenStream.isJSIdentifier(name)\n          && NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = getContextForNoInOperator(context);\n\n    // Handle associativity.\n    if (last.getType() == type && NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() || !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\" in \");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = context;\n    if (type == Token.IN) {\n      rhsContext = Context.IN_FOR_INIT_CLAUSE;\n    } else if (!context.equals(Context.IN_FOR_INIT_CLAUSE)) {\n      rhsContext = getContextForNoInOperator(context);\n    }\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ],
                [
                    "\n/**\n* Insert a ECMASCRIPT 5 strict annotation.\n*/\nvoid add(Node n, Context context) {\n  if (!cc.continueProcessing()) {\n    return;\n  }\n\n  int type = n.getType();\n  String opstr = NodeUtil.opToStr(type);\n  int childCount = n.getChildCount();\n  Node first = n.getFirstChild();\n  Node last = n.getLastChild();\n\n  // Handle all binary operators\n  if (opstr != null && first != last) {\n    Preconditions.checkState(\n        childCount == 2,\n        \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n        opstr, childCount);\n    int p = NodeUtil.precedence(type);\n\n    // For right-hand-side of operations, only pass context if it's\n    // the IN_FOR_INIT_CLAUSE one.\n    Context rhsContext = context == Context.IN_FOR_INIT_CLAUSE ? context : getContextForNoInOperator(context);\n\n    // Handle associativity.\n    // e.g. if the parse tree is a * (b * c),\n    // we can simply generate a * b * c.\n    if (last.getType() == type &&\n        NodeUtil.isAssociative(type)) {\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n      // Assignments are the only right-associative binary operators\n      addExpr(first, p, context);\n      cc.addOp(opstr, true);\n      addExpr(last, p, rhsContext);\n    } else {\n      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n    }\n    return;\n  }\n\n  cc.startSourceMapping(n);\n\n  switch (type) {\n    case Token.TRY: {\n      Preconditions.checkState(first.getNext().isBlock() &&\n              !first.getNext().hasMoreThanOneChild());\n      Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n      add(\"try\");\n      add(first, Context.PRESERVE_BLOCK);\n\n      // second child contains the catch block, or nothing if there\n      // isn't a catch block\n      Node catchblock = first.getNext().getFirstChild();\n      if (catchblock != null) {\n        add(catchblock);\n      }\n\n      if (childCount == 3) {\n        add(\"finally\");\n        add(last, Context.PRESERVE_BLOCK);\n      }\n      break;\n    }\n\n    case Token.CATCH:\n      Preconditions.checkState(childCount == 2);\n      add(\"catch(\");\n      add(first);\n      add(\")\");\n      add(last, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.THROW:\n      Preconditions.checkState(childCount == 1);\n      add(\"throw\");\n      add(first);\n\n      // Must have a ';' after a throw statement, otherwise safari can't\n      // parse this.\n      cc.endStatement(true);\n      break;\n\n    case Token.RETURN:\n      add(\"return\");\n      if (childCount == 1) {\n        add(first);\n      } else {\n        Preconditions.checkState(childCount == 0);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.VAR:\n      if (first != null) {\n        add(\"var \");\n        addList(first, false, getContextForNoInOperator(context));\n      }\n      break;\n\n    case Token.LABEL_NAME:\n      Preconditions.checkState(!n.getString().isEmpty());\n      addIdentifier(n.getString());\n      break;\n\n    case Token.NAME:\n      if (first == null || first.isEmpty()) {\n        addIdentifier(n.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        addIdentifier(n.getString());\n        cc.addOp(\"=\", true);\n        if (first.isComma()) {\n          addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n        } else {\n          // Add expression, consider nearby code at lowest level of\n          // precedence.\n          addExpr(first, 0, getContextForNoInOperator(context));\n        }\n      }\n      break;\n\n    case Token.ARRAYLIT:\n      add(\"[\");\n      addArrayList(first);\n      add(\"]\");\n      break;\n\n    case Token.PARAM_LIST:\n      add(\"(\");\n      addList(first);\n      add(\")\");\n      break;\n\n    case Token.COMMA:\n      Preconditions.checkState(childCount == 2);\n      unrollBinaryOperator(n, Token.COMMA, \",\", context,\n          getContextForNoInOperator(context), 0, 0);\n      break;\n\n    case Token.NUMBER:\n      Preconditions.checkState(childCount == 0);\n      cc.addNumber(n.getDouble());\n      break;\n\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.NOT:\n    case Token.BITNOT:\n    case Token.POS: {\n      // All of these unary operators are right-associative\n      Preconditions.checkState(childCount == 1);\n      cc.addOp(NodeUtil.opToStrNoFail(type), false);\n      addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      break;\n    }\n\n    case Token.NEG: {\n      Preconditions.checkState(childCount == 1);\n\n      // It's important to our sanity checker that the code\n      // we print produces the same AST as the code we parse back.\n      // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n      if (n.getFirstChild().isNumber()) {\n        cc.addNumber(-n.getFirstChild().getDouble());\n      } else {\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n      }\n\n      break;\n    }\n\n    case Token.HOOK: {\n      Preconditions.checkState(childCount == 3);\n      int p = NodeUtil.precedence(type);\n      Context rhsContext = Context.OTHER;\n      addExpr(first, p + 1, context);\n      cc.addOp(\"?\", true);\n      addExpr(first.getNext(), 1, rhsContext);\n      cc.addOp(\":\", true);\n      addExpr(last, 1, rhsContext);\n      break;\n    }\n\n    case Token.REGEXP:\n      if (!first.isString() ||\n          !last.isString()) {\n        throw new Error(\"Expected children to be strings\");\n      }\n\n      String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n      // I only use one .add because whitespace matters\n      if (childCount == 2) {\n        add(regexp + last.getString());\n      } else {\n        Preconditions.checkState(childCount == 1);\n        add(regexp);\n      }\n      break;\n\n    case Token.FUNCTION:\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      Preconditions.checkState(childCount == 3);\n      boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n      if (funcNeedsParens) {\n        add(\"(\");\n      }\n\n      add(\"function\");\n      add(first);\n\n      add(first.getNext());\n      add(last, Context.PRESERVE_BLOCK);\n      cc.endFunction(context == Context.STATEMENT);\n\n      if (funcNeedsParens) {\n        add(\")\");\n      }\n      break;\n\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n      Preconditions.checkState(n.getParent().isObjectLit());\n      Preconditions.checkState(childCount == 1);\n      Preconditions.checkState(first.isFunction());\n\n      // Get methods are unnamed\n      Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n      if (type == Token.GETTER_DEF) {\n        // Get methods have no parameters.\n        Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n        add(\"get \");\n      } else {\n        // Set methods have one parameter.\n        Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n        add(\"set \");\n      }\n\n      // The name is on the GET or SET node.\n      String name = n.getString();\n      Node fn = first;\n      Node parameters = fn.getChildAtIndex(1);\n      Node body = fn.getLastChild();\n\n      // Add the property name.\n      if (!n.isQuotedString() &&\n          TokenStream.isJSIdentifier(name) &&\n          // do not encode literally any non-literal characters that were\n          // Unicode escaped.\n          NodeUtil.isLatin(name)) {\n        add(name);\n      } else {\n        // Determine if the string is a simple number.\n        double d = getSimpleNumber(name);\n        if (!Double.isNaN(d)) {\n          cc.addNumber(d);\n        } else {\n          addJsString(n);\n        }\n      }\n\n      add(parameters);\n      add(body, Context.PRESERVE_BLOCK);\n      break;\n\n    case Token.SCRIPT:\n    case Token.BLOCK: {\n      if (n.getClass() != Node.class) {\n        throw new Error(\"Unexpected Node subclass.\");\n      }\n      boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n      if (preserveBlock) {\n        cc.beginBlock();\n      }\n\n      boolean preferLineBreaks =\n          type == Token.SCRIPT ||\n          (type == Token.BLOCK &&\n              !preserveBlock &&\n              n.getParent() != null &&\n              n.getParent().isScript());\n      for (Node c = first; c != null; c = c.getNext()) {\n        add(c, Context.STATEMENT);\n\n        // VAR doesn't include ';' since it gets used in expressions\n        if (c.isVar()) {\n          cc.endStatement();\n        }\n\n        if (c.isFunction()) {\n          cc.maybeLineBreak();\n        }\n\n        // Prefer to break lines in between top-level statements\n        // because top-level statements are more homogeneous.\n        if (preferLineBreaks) {\n          cc.notePreferredLineBreak();\n        }\n      }\n      if (preserveBlock) {\n        cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n      }\n      break;\n    }\n\n    case Token.FOR:\n      if (childCount == 4) {\n        add(\"for(\");\n        if (first.isVar()) {\n          add(first, Context.IN_FOR_INIT_CLAUSE);\n        } else {\n          addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n        }\n        add(\";\");\n        add(first.getNext());\n        add(\";\");\n        add(first.getNext().getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        Preconditions.checkState(childCount == 3);\n        add(\"for(\");\n        add(first);\n        add(\"in\");\n        add(first.getNext());\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      }\n      break;\n\n    case Token.DO:\n      Preconditions.checkState(childCount == 2);\n      add(\"do\");\n      addNonEmptyStatement(first, Context.OTHER, false);\n      add(\"while(\");\n      add(last);\n      add(\")\");\n      cc.endStatement();\n      break;\n\n    case Token.WHILE:\n      Preconditions.checkState(childCount == 2);\n      add(\"while(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.EMPTY:\n      Preconditions.checkState(childCount == 0);\n      break;\n\n    case Token.GETPROP: {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n      Preconditions.checkState(\n          last.isString(),\n          \"Bad GETPROP: RHS should be STRING\");\n      boolean needsParens = (first.isNumber());\n      if (needsParens) {\n        add(\"(\");\n      }\n      addExpr(first, NodeUtil.precedence(type), context);\n      if (needsParens) {\n        add(\")\");\n      }\n      if (this.languageMode == LanguageMode.ECMASCRIPT3\n          && TokenStream.isKeyword(last.getString())) {\n        // Check for ECMASCRIPT3 keywords.\n        add(\"[\");\n        add(last);\n        add(\"]\");\n      } else {\n        add(\".\");\n        addIdentifier(last.getString());\n      }\n      break;\n    }\n\n    case Token.GETELEM:\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad GETELEM: expected 2 children but got %s\", childCount);\n      addExpr(first, NodeUtil.precedence(type), context);\n      add(\"[\");\n      add(first.getNext());\n      add(\"]\");\n      break;\n\n    case Token.WITH:\n      Preconditions.checkState(childCount == 2);\n      add(\"with(\");\n      add(first);\n      add(\")\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), false);\n      break;\n\n    case Token.INC:\n    case Token.DEC: {\n      Preconditions.checkState(childCount == 1);\n      String o = type == Token.INC ? \"++\" : \"--\";\n      int postProp = n.getIntProp(Node.INCRDECR_PROP);\n      // A non-zero post-prop value indicates a post inc/dec, default of zero\n      // is a pre-inc/dec.\n      if (postProp != 0) {\n        addExpr(first, NodeUtil.precedence(type), context);\n        cc.addOp(o, false);\n      } else {\n        cc.addOp(o, false);\n        add(first);\n      }\n      break;\n    }\n\n    case Token.CALL:\n      // We have two special cases here:\n      // 1) If the left hand side of the call is a direct reference to eval,\n      // then it must have a DIRECT_EVAL annotation. If it does not, then\n      // that means it was originally an indirect call to eval, and that\n      // indirectness must be preserved.\n      // 2) If the left hand side of the call is a property reference,\n      // then the call must not a FREE_CALL annotation. If it does, then\n      // that means it was originally an call without an explicit this and\n      // that must be preserved.\n      if (isIndirectEval(first)\n          || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n        add(\"(0,\");\n        addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n        add(\")\");\n      } else {\n        addExpr(first, NodeUtil.precedence(type), context);\n      }\n      add(\"(\");\n      addList(first.getNext());\n      add(\")\");\n      break;\n\n    case Token.IF:\n      boolean hasElse = childCount == 3;\n      boolean ambiguousElseClause =\n          context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n      if (ambiguousElseClause) {\n        cc.beginBlock();\n      }\n\n      add(\"if(\");\n      add(first);\n      add(\")\");\n\n      if (hasElse) {\n        addNonEmptyStatement(\n            first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n        add(\"else\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n      } else {\n        addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n        Preconditions.checkState(childCount == 2);\n      }\n\n      if (ambiguousElseClause) {\n        cc.endBlock();\n      }\n      break;\n\n    case Token.NULL:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"null\");\n      break;\n\n    case Token.THIS:\n      Preconditions.checkState(childCount == 0);\n      add(\"this\");\n      break;\n\n    case Token.FALSE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"false\");\n      break;\n\n    case Token.TRUE:\n      Preconditions.checkState(childCount == 0);\n      cc.addConstant(\"true\");\n      break;\n\n    case Token.CONTINUE:\n      Preconditions.checkState(childCount <= 1);\n      add(\"continue\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.DEBUGGER:\n      Preconditions.checkState(childCount == 0);\n      add(\"debugger\");\n      cc.endStatement();\n      break;\n\n    case Token.BREAK:\n      Preconditions.checkState(childCount <= 1);\n      add(\"break\");\n      if (childCount == 1) {\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(\" \");\n        add(first);\n      }\n      cc.endStatement();\n      break;\n\n    case Token.EXPR_RESULT:\n      Preconditions.checkState(childCount == 1);\n      add(first, Context.START_OF_EXPR);\n      cc.endStatement();\n      break;\n\n    case Token.NEW:\n      add(\"new \");\n      int precedence = NodeUtil.precedence(type);\n\n      // If the first child contains a CALL, then claim higher precedence\n      // to force parentheses. Otherwise, when parsed, NEW will bind to the\n      // first viable parentheses (don't traverse into functions).\n      if (NodeUtil.containsType(\n          first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n        precedence = NodeUtil.precedence(first.getType()) + 1;\n      }\n      addExpr(first, precedence, Context.OTHER);\n\n      // '()' is optional when no arguments are present\n      Node next = first.getNext();\n      if (next != null) {\n        add(\"(\");\n        addList(next);\n        add(\")\");\n      }\n      break;\n\n    case Token.STRING_KEY:\n      Preconditions.checkState(\n          childCount == 1, \"Object lit key must have 1 child\");\n      addJsString(n);\n      break;\n\n    case Token.STRING:\n      Preconditions.checkState(\n          childCount == 0, \"A string may not have children\");\n      addJsString(n);\n      break;\n\n    case Token.DELPROP:\n      Preconditions.checkState(childCount == 1);\n      add(\"delete \");\n      add(first);\n      break;\n\n    case Token.OBJECTLIT: {\n      boolean needsParens = (context == Context.START_OF_EXPR);\n      if (needsParens) {\n        add(\"(\");\n      }\n      add(\"{\");\n      for (Node c = first; c != null; c = c.getNext()) {\n        if (c != first) {\n          cc.listSeparator();\n        }\n\n        if (c.isGetterDef() || c.isSetterDef()) {\n          add(c);\n        } else {\n          Preconditions.checkState(c.isStringKey());\n          String key = c.getString();\n          // Object literal property names don't have to be quoted if they\n          // are not JavaScript keywords\n          if (!c.isQuotedString()\n              && !(languageMode == LanguageMode.ECMASCRIPT3\n                  && TokenStream.isKeyword(key))\n              && TokenStream.isJSIdentifier(key)\n              // do not encode literally any non-literal characters that\n              // were Unicode escaped.\n              && NodeUtil.isLatin(key)) {\n            add(key);\n          } else {\n            // Determine if the string is a simple number.\n            double d = getSimpleNumber(key);\n            if (!Double.isNaN(d)) {\n              cc.addNumber(d);\n            } else {\n              addExpr(c, 1, Context.OTHER);\n            }\n          }\n          add(\":\");\n          addExpr(c.getFirstChild(), 1, Context.OTHER);\n        }\n      }\n      add(\"}\");\n      if (needsParens) {\n        add(\")\");\n      }\n      break;\n    }\n\n    case Token.SWITCH:\n      add(\"switch(\");\n      add(first);\n      add(\")\");\n      cc.beginBlock();\n      addAllSiblings(first.getNext());\n      cc.endBlock(context == Context.STATEMENT);\n      break;\n\n    case Token.CASE:\n      Preconditions.checkState(childCount == 2);\n      add(\"case \");\n      add(first);\n      addCaseBody(last);\n      break;\n\n    case Token.DEFAULT_CASE:\n      Preconditions.checkState(childCount == 1);\n      add(\"default\");\n      addCaseBody(first);\n      break;\n\n    case Token.LABEL:\n      Preconditions.checkState(childCount == 2);\n      if (!first.isLabelName()) {\n        throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n      }\n      add(first);\n      add(\":\");\n      addNonEmptyStatement(\n          last, getContextForNonEmptyExpression(context), true);\n      break;\n\n    case Token.CAST:\n      add(\"(\");\n      add(first);\n      add(\")\");\n      break;\n\n    default:\n      throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n  }\n\n  cc.endSourceMapping(n);\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}