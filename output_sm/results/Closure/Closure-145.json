{
    "Closure-145": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n      // For labels with block children, we need to ensure that a\n      // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n      // are skipped. \n        // Either a empty statement or an block with more than one child,\n        // way it isn't a FUNCTION or DO.\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testFunctionSafariCompatiblity() {\n\n    // Functions within IFs cause syntax errors on Safari.\n\n    assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n\n\n    assertPrint(\"function(){if(e1)function goo(){return true}else foo()}\",\n\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n\n\n    assertPrint(\"if(e1){function goo(){return true}}\",\n\n        \"if(e1){function goo(){return true}}\");\n\n\n\n    assertPrint(\"if(e1)function goo(){return true}\",\n\n        \"if(e1){function goo(){return true}}\");\n\n\n\n    assertPrint(\"if(e1)A:function goo(){return true}\",\n\n        \"if(e1){A:function goo(){return true}}\");\n\n  }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<if(e1)[{A:function goo(){return true}]}> but was:<if(e1)[A:function goo(){return true]}>\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:342)  assertEquals(expected,        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n\tat com.google.javascript.jscomp.CodePrinterTest.testFunctionSafariCompatiblity(CodePrinterTest.java:958)  assertPrint(\"if(e1)A:function goo(){return true}\",        \"if(e1){A:function goo(){return true}}\");\n \n#Test method 2:\n```java\n  public void testDoLoopIECompatiblity() {\n\n    // Do loops within IFs cause syntax errors in IE6 and IE7.\n\n    assertPrint(\"function(){if(e1){do foo();while(e2)}else foo()}\",\n\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n\n\n    assertPrint(\"function(){if(e1)do foo();while(e2)else foo()}\",\n\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n\n\n    assertPrint(\"if(x){do{foo()}while(y)}else bar()\",\n\n        \"if(x){do foo();while(y)}else bar()\");\n\n\n\n    assertPrint(\"if(x)do{foo()}while(y);else bar()\",\n\n        \"if(x){do foo();while(y)}else bar()\");\n\n\n\n    assertPrint(\"if(x){do{foo()}while(y)}\",\n\n        \"if(x){do foo();while(y)}\");\n\n\n\n    assertPrint(\"if(x)do{foo()}while(y);\",\n\n        \"if(x){do foo();while(y)}\");\n\n\n\n    assertPrint(\"if(x)A:do{foo()}while(y);\",\n\n        \"if(x){A:do foo();while(y)}\");\n\n    \n\n    assertPrint(\"var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);\",\n\n        \"var i=0;a:do{b:do{i++;break b}while(0)}while(0)\");\n\n  }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<if(x)[{A:do foo();while(y)}]> but was:<if(x)[A:do foo();while(y)]>\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:342)  assertEquals(expected,        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n\tat com.google.javascript.jscomp.CodePrinterTest.testDoLoopIECompatiblity(CodePrinterTest.java:937)  assertPrint(\"if(x)A:do{foo()}while(y);\",        \"if(x){A:do foo();while(y)}\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    // Either a empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL && n.hasChildren()) {\n        Node firstChild = n.getFirstChild();\n        return firstChild.getType() == Token.FUNCTION || firstChild.getType() == Token.DO;\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // Ensure that a labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getFirstChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // Ensure that a labeled FUNCTION or DO isn't generated when extraneous BLOCKs are skipped.\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getFirstChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // Check if the node itself is a FUNCTION or DO\n    if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {\n        return true;\n    }\n    // If the node is a label, check its child\n    if (n.getType() == Token.LABEL && n.hasOneChild()) {\n        Node child = n.getFirstChild();\n        return child.getType() == Token.FUNCTION || child.getType() == Token.DO;\n    }\n    return false;\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    // Either an empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getLastChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    // Either an empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getFirstChild();\n        if (labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO)) {\n            return true;\n        }\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    // Either an empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getLastChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    // Either a empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getFirstChild();\n        return labeledNode != null && \n               (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped. \n    // Either a empty statement or an block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getFirstChild();\n        return labeledNode != null && \n               (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node child = n.getFirstChild();\n        return child != null && (child.getType() == Token.FUNCTION || child.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n      // For labels with block children, we need to ensure that a\n      // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n      // are skipped. \n        // Either a empty statement or an block with more than one child,\n        // way it isn't a FUNCTION or DO.\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testFunctionSafariCompatiblity() {\n\n    // Functions within IFs cause syntax errors on Safari.\n\n    assertPrint(\"function(){if(e1){function goo(){return true}}else foo()}\",\n\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n\n\n    assertPrint(\"function(){if(e1)function goo(){return true}else foo()}\",\n\n        \"function(){if(e1){function goo(){return true}}else foo()}\");\n\n\n\n    assertPrint(\"if(e1){function goo(){return true}}\",\n\n        \"if(e1){function goo(){return true}}\");\n\n\n\n    assertPrint(\"if(e1)function goo(){return true}\",\n\n        \"if(e1){function goo(){return true}}\");\n\n\n\n    assertPrint(\"if(e1)A:function goo(){return true}\",\n\n        \"if(e1){A:function goo(){return true}}\");\n\n  }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<if(e1)[{A:function goo(){return true}]}> but was:<if(e1)[A:function goo(){return true]}>\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:342)  assertEquals(expected,        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n\tat com.google.javascript.jscomp.CodePrinterTest.testFunctionSafariCompatiblity(CodePrinterTest.java:958)  assertPrint(\"if(e1)A:function goo(){return true}\",        \"if(e1){A:function goo(){return true}}\");\n \n#Test method 2:\n```java\n  public void testDoLoopIECompatiblity() {\n\n    // Do loops within IFs cause syntax errors in IE6 and IE7.\n\n    assertPrint(\"function(){if(e1){do foo();while(e2)}else foo()}\",\n\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n\n\n    assertPrint(\"function(){if(e1)do foo();while(e2)else foo()}\",\n\n        \"function(){if(e1){do foo();while(e2)}else foo()}\");\n\n\n\n    assertPrint(\"if(x){do{foo()}while(y)}else bar()\",\n\n        \"if(x){do foo();while(y)}else bar()\");\n\n\n\n    assertPrint(\"if(x)do{foo()}while(y);else bar()\",\n\n        \"if(x){do foo();while(y)}else bar()\");\n\n\n\n    assertPrint(\"if(x){do{foo()}while(y)}\",\n\n        \"if(x){do foo();while(y)}\");\n\n\n\n    assertPrint(\"if(x)do{foo()}while(y);\",\n\n        \"if(x){do foo();while(y)}\");\n\n\n\n    assertPrint(\"if(x)A:do{foo()}while(y);\",\n\n        \"if(x){A:do foo();while(y)}\");\n\n    \n\n    assertPrint(\"var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);\",\n\n        \"var i=0;a:do{b:do{i++;break b}while(0)}while(0)\");\n\n  }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<if(x)[{A:do foo();while(y)}]> but was:<if(x)[A:do foo();while(y)]>\n\tat com.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:342)  assertEquals(expected,        parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n\tat com.google.javascript.jscomp.CodePrinterTest.testDoLoopIECompatiblity(CodePrinterTest.java:937)  assertPrint(\"if(x)A:do{foo()}while(y);\",        \"if(x){A:do foo();while(y)}\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprivate boolean isValidReference(Reference reference) { return !reference.isDeclaration() && !reference.isLvalue(); }\n```\n\n            \n```java\nprivate static int indexOfSeparator(String name) { return name.lastIndexOf(ContextualRenamer.UNIQUE_ID_SEPARATOR); }\n```\n\n            \n```java\nprivate void assertRedeclare(String js) { testSame(js, VariableReferenceCheck.REDECLARED_VARIABLE); }\n```\n\n            \n```java\nprivate void assertUndeclared(String js) { testSame(js, VariableReferenceCheck.UNDECLARED_REFERENCE); }\n```\n\n            \n```java\nprivate boolean isGlobalNameReference(String name, Scope s) { String topVarName = getTopVarName(name); return isGlobalVarReference(topVarName, s); }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getLastChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs\n    // are skipped. \n    // Either an empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() != Token.LABEL) {\n        return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n    }\n    \n    Node labeledNode = n.getFirstChild();\n    return (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getFirstChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node firstChild = n.getFirstChild().getNext();\n        return firstChild != null && (firstChild.getType() == Token.FUNCTION || firstChild.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // Either an empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.BLOCK && n.hasOneChild()) {\n        n = n.getFirstChild();\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node child = n.getFirstChild();\n        return child != null && (child.getType() == Token.FUNCTION || child.getType() == Token.DO);\n    }\n    return n.getType() == Token.FUNCTION || n.getType() == Token.DO;\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // For labels with block children, we need to ensure that a\n    // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n    // are skipped.\n    // Either an empty statement or a block with more than one child,\n    // way it isn't a FUNCTION or DO.\n    if (n.getType() == Token.LABEL && n.getFirstChild() != null) {\n        n = n.getFirstChild();\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node firstChild = n.getFirstChild();\n        if (firstChild != null) {\n            int firstChildType = firstChild.getType();\n            return firstChildType == Token.FUNCTION || firstChildType == Token.DO;\n        }\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // A labeled statement with a single FUNCTION or DO should not be treated as if the label is missing\n    if (n.getType() == Token.LABEL) {\n        Node labeledStatement = n.getLastChild();\n        return labeledStatement != null && (labeledStatement.getType() == Token.FUNCTION || labeledStatement.getType() == Token.DO);\n    }\n    return n.getType() == Token.FUNCTION || n.getType() == Token.DO;\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getLastChild();\n        return labeledNode != null && \n               (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getLastChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node firstChild = n.getFirstChild().getNext();\n        return firstChild != null && (firstChild.getType() == Token.FUNCTION || firstChild.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // A labeled statement with a single FUNCTION or DO should not be treated as if the label is missing\n    if (n.getType() == Token.LABEL) {\n        Node labeledStatement = n.getLastChild();\n        return labeledStatement != null && (labeledStatement.getType() == Token.FUNCTION || labeledStatement.getType() == Token.DO);\n    }\n    return n.getType() == Token.FUNCTION || n.getType() == Token.DO;\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node labeledNode = n.getLastChild();\n        return labeledNode != null && (labeledNode.getType() == Token.FUNCTION || labeledNode.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n        Node firstChild = n.getFirstChild().getNext();\n        return firstChild != null && (firstChild.getType() == Token.FUNCTION || firstChild.getType() == Token.DO);\n    }\n    return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n}\n"
                ],
                [
                    "\n/**\n* @return Whether the Node is a DO or FUNCTION (with or without\n* labels).\n*/\nprivate boolean isOneExactlyFunctionOrDo(Node n) {\n    // A labeled statement with a single FUNCTION or DO should not be treated as if the label is missing\n    if (n.getType() == Token.LABEL) {\n        Node labeledStatement = n.getLastChild();\n        return labeledStatement != null && (labeledStatement.getType() == Token.FUNCTION || labeledStatement.getType() == Token.DO);\n    }\n    return n.getType() == Token.FUNCTION || n.getType() == Token.DO;\n}\n"
                ]
            ]
        }
    }
}