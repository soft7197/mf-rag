{
    "Closure-48": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Declare the symbol for a qualified name in the global scope.\n*\n* @param info The doc info for this property.\n* @param n A top-level GETPROP node (it should not be contained inside\n*     another GETPROP).\n* @param parent The parent of {@code n}.\n* @param rhsValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue586() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */\" +\n\n        \"var MyClass = function() {};\" +\n\n        \"/** @param {boolean} success */\" +\n\n        \"MyClass.prototype.fn = function(success) {};\" +\n\n        \"MyClass.prototype.test = function() {\" +\n\n        \"  this.fn();\" +\n\n        \"  this.fn = function() {};\" +\n\n        \"};\",\n\n        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n\n        \"Function requires at least 1 argument(s) \" +\n\n        \"and no more than 1 argument(s).\");\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected a warning\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9391)  assertTrue(\"expected a warning\", warnings.length > 0);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9371)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9309)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue586(TypeCheckTest.java:5443)  testTypes(        \"/** @constructor */\" +        \"var MyClass = function() {};\" +        \"/** @param {boolean} success */\" +        \"MyClass.prototype.fn = function(success) {};\" +        \"MyClass.prototype.test = function() {\" +        \"  this.fn();\" +        \"  this.fn = function() {};\" +        \"};\",        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +        \"Function requires at least 1 argument(s) \" +        \"and no more than 1 argument(s).\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n\n  // Adding a check for function arity\n  if (rhsValue != null && rhsValue.isFunction()) {\n    FunctionType functionType = (FunctionType) rhsValue.getJSType();\n    Node parameters = functionType.getParametersNode();\n    int numParams = parameters == null ? 0 : parameters.getChildCount();\n    if (numParams > 0) {\n      t.getCompiler().report(t.makeError(n, FUNCTION_CALL_HAS_TOO_FEW_ARGUMENTS, qName, Integer.toString(numParams)));\n    }\n  }\n}\n"
                ],
                [
                    "\n/**\n* Declare the symbol for a qualified name in the global scope.\n*\n* @param info The doc info for this property.\n* @param n A top-level GETPROP node (it should not be contained inside\n*     another GETPROP).\n* @param parent The parent of {@code n}.\n* @param rhsValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction()) {\n    // We need to ensure that function types are declared properly\n    FunctionType functionType = rhsValue.getJSType().toMaybeFunctionType();\n    if (functionType != null) {\n      defineSlot(n, parent, functionType, false);\n    }\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction()) {\n    defineSlot(n, parent, valueType, true);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else {\n    defineSlot(n, parent, valueType, true);\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  }\n\n  if (rhsValue != null && rhsValue.isFunction()) {\n    FunctionType functionType = rhsValue.getJSType().toMaybeFunctionType();\n    if (functionType != null && functionType.getMinArguments() > 0) {\n      defineSlot(n, parent, valueType, inferred);\n    }\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction()) {\n    FunctionType rhsFunctionType = rhsValue.getJSType().toMaybeFunctionType();\n    if (rhsFunctionType != null && rhsFunctionType.getTypeOfThis().isSubtype(getNativeType(OBJECT_TYPE))) {\n      defineSlot(n, parent, valueType, inferred);\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      defineSlot(n, parent, rhsValue.getJSType(), true);\n    }\n  }\n}\n"
                ],
                [
                    "\n/**\n* Declare the symbol for a qualified name in the global scope.\n*\n* @param info The doc info for this property.\n* @param n A top-level GETPROP node (it should not be contained inside\n*     another GETPROP).\n* @param parent The parent of {@code n}.\n* @param rhsValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, rhsValue.getJSType(), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n/**\n* Declare the symbol for a qualified name in the global scope.\n*\n* @param info The doc info for this property.\n* @param n A top-level GETPROP node (it should not be contained inside\n*     another GETPROP).\n* @param parent The parent of {@code n}.\n* @param rhsValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction()) {\n    // Fix: Handle function reassignments by setting inferred to false\n    defineSlot(n, parent, valueType, false);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ]
            ],
            "compiler_error": true,
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Declare the symbol for a qualified name in the global scope.\n*\n* @param info The doc info for this property.\n* @param n A top-level GETPROP node (it should not be contained inside\n*     another GETPROP).\n* @param parent The parent of {@code n}.\n* @param rhsValue The node that {@code n} is being initialized to,\n*     or {@code null} if this is a stub declaration.\n*/\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE(nicksantos): Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // In a dynamic language with first-class functions, it's very difficult\n  // to know which one the user intended without looking at lots of\n  // contextual information (the second example demonstrates a small case\n  // of this, but there are some really pathological cases as well).\n  //\n  // The current algorithm checks if either the declaration has\n  // jsdoc type information, or @const with a known type,\n  // or a function literal with a name we haven't seen before.\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testIssue586() throws Exception {\n\n    testTypes(\n\n        \"/** @constructor */\" +\n\n        \"var MyClass = function() {};\" +\n\n        \"/** @param {boolean} success */\" +\n\n        \"MyClass.prototype.fn = function(success) {};\" +\n\n        \"MyClass.prototype.test = function() {\" +\n\n        \"  this.fn();\" +\n\n        \"  this.fn = function() {};\" +\n\n        \"};\",\n\n        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n\n        \"Function requires at least 1 argument(s) \" +\n\n        \"and no more than 1 argument(s).\");\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected a warning\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9391)  assertTrue(\"expected a warning\", warnings.length > 0);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9371)  testTypes(DEFAULT_EXTERNS, js, description, isError);\n\tat com.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9309)  testTypes(js, description, false);\n\tat com.google.javascript.jscomp.TypeCheckTest.testIssue586(TypeCheckTest.java:5443)  testTypes(        \"/** @constructor */\" +        \"var MyClass = function() {};\" +        \"/** @param {boolean} success */\" +        \"MyClass.prototype.fn = function(success) {};\" +        \"MyClass.prototype.test = function() {\" +        \"  this.fn();\" +        \"  this.fn = function() {};\" +        \"};\",        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +        \"Function requires at least 1 argument(s) \" +        \"and no more than 1 argument(s).\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\n@Override public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.VAR: Node name; for (name = n.getFirstChild(); name != null; name = name.getNext()) { if (inExterns) { scope.declareSlot(name.getString(), n, createType(name, scope)); } else { scope.declareSlot(name.getString(), n); if (name.getFirstChild() != null) { addActions(createAssignmentActions(name, name.getFirstChild(), n)); } } } break; case Token.GETPROP: if (inExterns) { ConcreteType type = inferConcreteType(getTopScope(), n); if (type.isNone()) { ConcreteScope scope = (ConcreteScope) inferConcreteType(getTopScope(), n.getFirstChild()).getScope(); if (scope != null) { type = createType(n.getJSType()); if (type.isNone() || type.isAll()) { break; } type = createUnionWithSubTypes(type); Node nameNode = n.getLastChild(); scope.declareSlot(nameNode.getString(), n, type); } } } break; case Token.FUNCTION: if (NodeUtil.isFunctionDeclaration(n)) { if (!n.getJSType().isNoObjectType()) { ConcreteFunctionType type = createConcreteFunction(n, scope); scope.declareSlot(n.getFirstChild().getString(), n, type); if (inExterns && type.getInstanceType() != null) { allInstantiatedTypes.add(type.getInstanceType()); } } } break; case Token.ASSIGN: Node lhs = n.getFirstChild(); if (inExterns) { ConcreteScope scope; if (lhs.isGetProp()) { ConcreteType type = inferConcreteType(getTopScope(), lhs.getFirstChild()); scope = (ConcreteScope) type.getScope(); } else { scope = getTopScope(); } if (scope == null) break; ConcreteType type = inferConcreteType(getTopScope(), n); if (type.isNone() || type.isAll()) { break; } if (type.isFunction()) { JSType lhsType = lhs.getJSType(); if (lhsType == null) { break; } FunctionType funType = lhsType.restrictByNotNullOrUndefined().toMaybeFunctionType(); if (funType == null) { break; } ConcreteType retType = createType(funType.getReturnType()); retType = createUnionWithSubTypes(retType); ConcreteType newret = type.toFunction().getReturnSlot().getType().unionWith(retType); ((ConcreteScope) type.getScope()).declareSlot(ConcreteFunctionType.RETURN_SLOT_NAME, n, newret); } scope.declareSlot(lhs.getLastChild().getString(), n, type); } else { addActions(createAssignmentActions(lhs, n.getLastChild(), n)); } break; case Token.NEW: case Token.CALL: Node receiver = n.getFirstChild(); if (receiver.isGetProp()) { Node first = receiver.getFirstChild(); if (\\\"call\\\".equals(first.getNext().getString())) { if (first.isGetProp()) { addAction(new FunctionCallBuilder(first, receiver.getNext()).setPropName(first.getFirstChild().getNext().getString()).setIsCallFunction().build()); } else { addAction(new FunctionCallBuilder(first, receiver.getNext()).setIsCallFunction().build()); } } else { addAction(new FunctionCallBuilder(first, receiver.getNext()).setPropName(first.getNext().getString()).build()); } } else { addAction(new FunctionCallBuilder(receiver, receiver.getNext()).setIsNewCall(n.isNew()).build()); } break; case Token.NAME: if (parent.isCatch() && parent.getFirstChild() == n) { scope.declareSlot(n.getString(), n, createUnionWithSubTypes(createType(getTypeRegistry().getType(\\\"Error\\\")).toInstance())); } break; case Token.RETURN: if (n.getFirstChild() != null) { addAction(new VariableAssignAction((ConcreteSlot) scope.getOwnSlot(ConcreteFunctionType.RETURN_SLOT_NAME), n.getFirstChild())); } break; } Collection<Action> actions = getImplicitActions(n); if (actions != null) { for (Action action : actions) { addAction(action); } } }\n```\n\n            \n```java\nprivate JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope).restrictByNotNullOrUndefined(); case Token.QMARK: Node firstChild = n.getFirstChild(); if (firstChild == null) { return getNativeType(UNKNOWN_TYPE); } return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope)); case Token.EQUALS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if (resolveMode != ResolveMode.LAZY_NAMES) { namedType = namedType.resolveInternal(reporter, scope); } if ((namedType instanceof ObjectType) && !(nonNullableTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); if (typeList != null && (\\\"Array\\\".equals(n.getString()) || \\\"Object\\\".equals(n.getString()))) { JSType parameterType = createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope); namedType = new ParameterizedType(this, (ObjectType) namedType, parameterType); if (typeList.hasMoreThanOneChild()) { JSType indexType = createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope); namedType = new IndexedType(this, (ObjectType) namedType, indexType); } } return createDefaultObjectUnion(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; boolean isConstructor = false; Node current = n.getFirstChild(); if (current.getType() == Token.THIS || current.getType() == Token.NEW) { Node contextNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodesInternal(contextNode, sourceName, scope).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(ScriptRuntime.getMessage0(current.getType() == Token.THIS ? \\\"msg.jsdoc.function.thisnotobject\\\" : \\\"msg.jsdoc.function.newnotobject\\\"), sourceName, contextNode.getLineno(), contextNode.getCharno()); } isConstructor = current.getType() == Token.NEW; current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.PARAM_LIST) { Node args = current.getFirstChild(); for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope)); } } else { JSType type = createFromTypeNodesInternal(arg, sourceName, scope); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodesInternal(current, sourceName, scope); return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).setIsConstructor(isConstructor).build(); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }\n```\n\n            \n```java\n@Override public void visit(NodeTraversal traversal, Node node, Node parent) { String messageKey; boolean isVar; Node msgNode, msgNodeParent; switch(node.getType()) { case Token.NAME: if ((parent != null) && (parent.isVar())) { messageKey = node.getString(); isVar = true; } else { return; } msgNode = node.getFirstChild(); msgNodeParent = node; break; case Token.ASSIGN: isVar = false; Node getProp = node.getFirstChild(); if (getProp.getType() != Token.GETPROP) { return; } Node propNode = getProp.getLastChild(); messageKey = propNode.getString(); msgNode = node.getLastChild(); msgNodeParent = node; break; case Token.CALL: if (MSG_FUNCTION_NAME.equals(node.getFirstChild().getQualifiedName())) { googMsgNodes.put(node, traversal.getSourceName()); } return; default: return; } boolean isNewStyleMessage = msgNode != null && msgNode.isCall(); if (!isMessageName(messageKey, isNewStyleMessage)) { return; } if (msgNode == null) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_VALUE, messageKey)); return; } if (isNewStyleMessage) { googMsgNodes.remove(msgNode); } else if (style != JsMessage.Style.LEGACY) { compiler.report(traversal.makeError(node, checkLevel, MESSAGE_NOT_INITIALIZED_USING_NEW_SYNTAX)); } boolean isUnnamedMsg = isUnnamedMessageName(messageKey); Builder builder = new Builder(isUnnamedMsg ? null : messageKey); builder.setSourceName(traversal.getSourceName()); try { if (isVar) { extractMessageFromVariable(builder, node, parent, parent.getParent()); } else { extractMessageFromProperty(builder, node.getFirstChild(), node); } } catch (MalformedException ex) { compiler.report(traversal.makeError(ex.getNode(), MESSAGE_TREE_MALFORMED, ex.getMessage())); return; } JsMessage extractedMessage = builder.build(idGenerator); if (needToCheckDuplications && !isUnnamedMsg && !extractedMessage.isExternal()) { checkIfMessageDuplicated(traversal.getSourceName(), messageKey, msgNode); } if (extractedMessage.isEmpty()) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_TEXT, messageKey)); } String desc = extractedMessage.getDesc(); if (isNewStyleMessage && (desc == null || desc.trim().isEmpty()) && !extractedMessage.isExternal()) { compiler.report(traversal.makeError(node, MESSAGE_HAS_NO_DESCRIPTION, messageKey)); } JsMessageDefinition msgDefinition = new JsMessageDefinition(node, msgNode, msgNodeParent); processJsMessage(extractedMessage, msgDefinition); }\n```\n\n            \n```java\n@Override public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.CALL: boolean isExpr = parent.isExprResult(); Node left = n.getFirstChild(); if (left.isGetProp()) { Node name = left.getFirstChild(); if (name.isName() && GOOG.equals(name.getString())) { String methodName = name.getNext().getString(); if (\\\"base\\\".equals(methodName)) { processBaseClassCall(t, n); } else if (!isExpr) { break; } else if (\\\"require\\\".equals(methodName)) { processRequireCall(t, n, parent); } else if (\\\"provide\\\".equals(methodName)) { processProvideCall(t, n, parent); } else if (\\\"exportSymbol\\\".equals(methodName)) { Node arg = left.getNext(); if (arg.isString()) { int dot = arg.getString().indexOf('.'); if (dot == -1) { exportedVariables.add(arg.getString()); } else { exportedVariables.add(arg.getString().substring(0, dot)); } } } else if (\\\"addDependency\\\".equals(methodName)) { CodingConvention convention = compiler.getCodingConvention(); List<String> typeDecls = convention.identifyTypeDeclarationCall(n); if (typeDecls != null) { for (String typeDecl : typeDecls) { compiler.getTypeRegistry().forwardDeclareType(typeDecl); } } parent.replaceChild(n, Node.newNumber(0)); compiler.reportCodeChange(); } else if (\\\"setCssNameMapping\\\".equals(methodName)) { processSetCssNameMapping(t, n, parent); } } } break; case Token.ASSIGN: case Token.NAME: handleCandidateProvideDefinition(t, n, parent); break; case Token.EXPR_RESULT: handleTypedefDefinition(t, n, parent); break; case Token.FUNCTION: if (t.inGlobalScope() && !NodeUtil.isFunctionExpression(n)) { String name = n.getFirstChild().getString(); ProvidedName pn = providedNames.get(name); if (pn != null) { compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name)); } } break; case Token.NEW: trySimplifyNewDate(t, n, parent); break; case Token.GETPROP: if (n.getFirstChild().isName() && parent.getType() != Token.CALL && parent.getType() != Token.ASSIGN && \\\"goog.base\\\".equals(n.getQualifiedName())) { reportBadBaseClassUse(t, n, \\\"May only be called directly.\\\"); } break; } }\n```\n\n            \n```java\nprivate void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) { if (hasUnknownOrEmptySupertype(ctorType)) { return; } FunctionType superClass = ctorType.getSuperClassConstructor(); boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName); boolean superInterfacesHasProperty = false; if (ctorType.isInterface()) { for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) { superInterfacesHasProperty = superInterfacesHasProperty || interfaceType.hasProperty(propertyName); } } boolean declaredOverride = info != null && info.isOverride(); boolean foundInterfaceProperty = false; if (ctorType.isConstructor()) { for (JSType implementedInterface : ctorType.getAllImplementedInterfaces()) { if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) { continue; } FunctionType interfaceType = implementedInterface.toObjectType().getConstructor(); Preconditions.checkNotNull(interfaceType); boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName); foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty; if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString())); } } } if (!declaredOverride && !superClassHasProperty && !superInterfacesHasProperty) { return; } JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null; if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) { compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString())); } if (!declaredOverride) { return; } if (superClassHasProperty) { JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName); if (!propertyType.canAssignTo(superClassPropType)) { compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString())); } } else if (superInterfacesHasProperty) { for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) { if (interfaceType.hasProperty(propertyName)) { JSType superPropertyType = interfaceType.getPropertyType(propertyName); if (!propertyType.canAssignTo(superPropertyType)) { topInstanceType = interfaceType.getConstructor().getTopMostDefiningType(propertyName); compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superPropertyType.toString(), propertyType.toString())); } } } } else if (!foundInterfaceProperty) { compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString())); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isFunction() &&\n             !scope.isDeclared(qName, false)) {\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  // Precedence of type information on GETPROPs:\n  // 1) @type annnotation / @enum annotation\n  // 2) ASSIGN to FUNCTION literal\n  // 3) @param/@return annotation (with no function literal)\n  // 4) ASSIGN to something marked @const\n  // 5) ASSIGN to anything else\n  //\n  // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n  // the function has jsdoc or has not been declared before.\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  // Determining type for #1 + #2 + #3 + #4\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    // Determining type for #5\n    valueType = rhsValue.getJSType();\n  }\n  // Function prototypes are special.\n  // It's a common JS idiom to do:\n  // F.prototype = { ... };\n  // So if F does not have an explicitly declared super type,\n  // allow F.prototype to be redefined arbitrarily.\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      // If the programmer has declared that F inherits from Super,\n      // and they assign F.prototype to an object literal,\n      // then they are responsible for making sure that the object literal's\n      // implicit prototype is set up appropriately. We just obey\n      // the @extends tag.\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        // If the programmer has declared that F inherits from Super,\n        // and they assign F.prototype to some arbitrary expression,\n        // there's not much we can do. We just ignore the expression,\n        // and hope they've annotated their code in a way to tell us\n        // what props are going to be on that prototype.\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  // NOTE: We are adding a check here for function assignment.\n  boolean isFunctionAssignment = rhsValue != null && rhsValue.isFunction();\n  \n  // NOTE: Determining whether a property is declared or not\n  // is really really obnoxious.\n  //\n  // The problem is that there are two (equally valid) coding styles:\n  //\n  // (function() {\n  //   /* The authoritative definition of goog.bar. */\n  //   goog.bar = function() {};\n  // })();\n  //\n  // function f() {\n  //   goog.bar();\n  //   /* Reset goog.bar to a no-op. */\n  //   goog.bar = function() {};\n  // }\n  //\n  // FUNCTION literals are special because TypedScopeCreator is very smart\n  // about getting as much type information as possible for them.\n\n  boolean inferred = true;\n  if (info != null) {\n    // Determining declaration for #1 + #3 + #4\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    // Determining declaration for #2\n    inferred = !(!isFunctionAssignment &&\n        rhsValue != null &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      // Only declare this as an official property if it has not been\n      // declared yet.\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        // If the property is undeclared or inferred, declare it now.\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    // If the property is already declared, the error will be\n    // caught when we try to declare it in the current scope.\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    // We declare these for delegate proxy method properties.\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, true)));\n  }\n  \n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  // Update scope undeclaration condition\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null && qVar.getScope() == scope && !qVar.isTypeInferred()) {\n      scope.undeclare(qVar);\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n  \n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n  \n  // New logic for handling argument count mismatch warnings\n  if (rhsValue != null && rhsValue.isFunction()) {\n    FunctionType fType = (FunctionType) rhsValue.getJSType();\n    Node paramNode = rhsValue.getSecondChild();\n    int requiredArgCount = fType.getMinArguments();\n    // Ensure there is a warning if the function has required arguments but none were provided\n    if (requiredArgCount > 0 && paramNode.numChildren() == 0) {\n      compiler.report(t.makeError(paramNode, \"Function requires at least \" + requiredArgCount +\n          \" argument(s) and no more than \" + fType.getMaxArguments() + \" argument(s).\"));\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n  \n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n\n  // Fix for incorrect function parameter check\n  if (info != null && rhsValue != null && rhsValue.isFunction()) {\n    FunctionType functionType = JSType.toMaybeFunctionType(rhsValue.getJSType());\n    if (functionType != null &&\n        functionType.getMinArguments() > n.getChildCount() - 1) {\n      t.getCompiler().report(\n          JSError.make(n, FunctionType.PARAMETER_MISMATCH, qName));\n    }\n  }\n}\n"
                ],
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null &&\n          rhsValue != null &&\n          rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n    Node n, Node parent, Node rhsValue) {\n  Node ownerNode = n.getFirstChild();\n  String ownerName = ownerNode.getQualifiedName();\n  String qName = n.getQualifiedName();\n  String propName = n.getLastChild().getString();\n  Preconditions.checkArgument(qName != null && ownerName != null);\n\n  JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n  if (valueType == null && rhsValue != null) {\n    valueType = rhsValue.getJSType();\n  }\n\n  if (\"prototype\".equals(propName)) {\n    Var qVar = scope.getVar(qName);\n    if (qVar != null) {\n      ObjectType qVarType = ObjectType.cast(qVar.getType());\n      if (qVarType != null && rhsValue != null && rhsValue.isObjectLit()) {\n        typeRegistry.resetImplicitPrototype(\n            rhsValue.getJSType(), qVarType.getImplicitPrototype());\n      } else if (!qVar.isTypeInferred()) {\n        return;\n      }\n      if (qVar.getScope() == scope) {\n        scope.undeclare(qVar);\n      }\n    }\n  }\n\n  if (valueType == null) {\n    if (parent.isExprResult()) {\n      stubDeclarations.add(new StubDeclaration(\n          n,\n          t.getInput() != null && t.getInput().isExtern(),\n          ownerName));\n    }\n\n    return;\n  }\n\n  boolean inferred = true;\n  if (info != null) {\n    inferred = !(info.hasType()\n        || info.hasEnumParameterType()\n        || (info.isConstant() && valueType != null\n            && !valueType.isUnknownType())\n        || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n  }\n\n  if (inferred) {\n    inferred = !(rhsValue != null &&\n        rhsValue.isFunction() &&\n        (info != null || !scope.isDeclared(qName, false)));\n  }\n\n  if (!inferred) {\n    ObjectType ownerType = getObjectSlot(ownerName);\n    if (ownerType != null) {\n      boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n      if ((!ownerType.hasOwnProperty(propName) ||\n           ownerType.isPropertyTypeInferred(propName)) &&\n          ((isExtern && !ownerType.isNativeObjectType()) ||\n           !ownerType.isInstanceType())) {\n        ownerType.defineDeclaredProperty(propName, valueType, n);\n      }\n    }\n\n    defineSlot(n, parent, valueType, inferred);\n  } else if (rhsValue != null && rhsValue.isTrue()) {\n    FunctionType ownerType =\n        JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n    if (ownerType != null) {\n      JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n      String delegateName = codingConvention.getDelegateSuperclassName();\n      JSType delegateType = delegateName == null ?\n          null : typeRegistry.getType(delegateName);\n      if (delegateType != null &&\n          ownerTypeOfThis.isSubtype(delegateType)) {\n        defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n      }\n    }\n  }\n}\n"
                ]
            ]
        },
        "iteration_done": true
    }
}