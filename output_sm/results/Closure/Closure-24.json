{
    "Closure-24": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n      String name = n.getString();\n      Var aliasVar = scope.getVar(name);\n      aliases.put(name, aliasVar);\n\n      String qualifiedName =\n          aliasVar.getInitialValue().getQualifiedName();\n      transformation.addAlias(name, qualifiedName);\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else {\n      // TODO(robbyw): Support using locals for private variables.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n    }\n  }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testNonAliasLocal() {\n\n    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog.dom + 10\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog['dom']\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog.dom, y = 10\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"function f() {}\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:932)  assertEquals(\"There should be one error. \" + errors,          1, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScopedFailure(ScopedAliasesTest.java:359)  test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testNonAliasLocal(ScopedAliasesTest.java:413)  testScopedFailure(\"function f() {}\",        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    } else if (parent.isFunction()) {\n      // Report non-alias local variables in functions as well.\n      report(t, n, ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // Report an error if the variable is not an alias.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue() != null ? aliasVar.getInitialValue().getQualifiedName() : null;\n        if (qualifiedName != null) {\n          transformation.addAlias(name, qualifiedName);\n        }\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else if (!n.hasChildren() || !n.getFirstChild().isQualifiedName()) {\n        // If the variable is not an alias (i.e., it does not have children or\n        // the children aren't qualified names), report the error.\n        report(t, n, ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      // Check for assignments to non-aliases and report them as errors.\n      report(t, n, ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName() \n          && n.getFirstChild().getQualifiedName().startsWith(\"goog.\")) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else if (n.hasChildren() && !n.getFirstChild().isQualifiedName()) {\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    } else if (!parent.isFunction() && !parent.isParamList()) {\n      // Report error for non-alias locals that are not function declarations or parameters\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        if (aliasVar != null && aliasVar.getInitialValue() != null) {\n          aliases.put(name, aliasVar);\n\n          String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        }\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      // Handle cases where n is assigned directly in an assignment expression\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n      } else {\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n      String name = n.getString();\n      Var aliasVar = scope.getVar(name);\n      aliases.put(name, aliasVar);\n\n      String qualifiedName =\n          aliasVar.getInitialValue().getQualifiedName();\n      transformation.addAlias(name, qualifiedName);\n      // Bleeding functions already get a BAD_PARAMETERS error, so just\n      // do nothing.\n      // Parameters of the scope function also get a BAD_PARAMETERS\n      // error.\n    } else {\n      // TODO(robbyw): Support using locals for private variables.\n      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n    }\n    }\n  }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testNonAliasLocal() {\n\n    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog.dom + 10\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog['dom']\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"var x = goog.dom, y = 10\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n    testScopedFailure(\"function f() {}\",\n\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:932)  assertEquals(\"There should be one error. \" + errors,          1, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testScopedFailure(ScopedAliasesTest.java:359)  test(\"goog.scope(function() {\" + code + \"});\", null, expectedError);\n\tat com.google.javascript.jscomp.ScopedAliasesTest.testNonAliasLocal(ScopedAliasesTest.java:413)  testScopedFailure(\"function f() {}\",        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprivate void visitFunctionNode(Node n, Node parent) { Node name = null; JSDocInfo info = parent.getJSDocInfo(); if (info != null && info.isConstructor()) { name = parent.getFirstChild(); } else { info = n.getJSDocInfo(); if (info != null && info.isConstructor()) { name = n.getFirstChild(); } } if (name != null && name.isQualifiedName()) { String qualifiedName = name.getQualifiedName(); if (!this.convention.isPrivate(qualifiedName)) { Visibility visibility = info.getVisibility(); if (!visibility.equals(JSDocInfo.Visibility.PRIVATE)) { ctors.put(qualifiedName, name); } } } }\n```\n\n            \n```java\nprivate void flattenPrefixes(String alias, Name n, int depth) { String originalName = n.getFullName(); Ref decl = n.getDeclaration(); if (decl != null && decl.node != null && decl.node.isGetProp()) { flattenNameRefAtDepth(alias, decl.node, depth, originalName); } for (Ref r : n.getRefs()) { if (r == decl) { continue; } if (r.getTwin() == null || r.isSet()) { flattenNameRefAtDepth(alias, r.node, depth, originalName); } } if (n.props != null) { for (Name p : n.props) { flattenPrefixes(alias, p, depth + 1); } } }\n```\n\n            \n```java\nprivate void handleCandidateProvideDefinition(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { String name = null; if (n.isName() && parent.isVar()) { name = n.getString(); } else if (n.isAssign() && parent.isExprResult()) { name = n.getFirstChild().getQualifiedName(); } if (name != null) { if (parent.getBooleanProp(Node.IS_NAMESPACE)) { processProvideFromPreviousPass(t, name, parent); } else { ProvidedName pn = providedNames.get(name); if (pn != null) { pn.addDefinition(parent, t.getModule()); } } } } }\n```\n\n            \n```java\nprivate void normalizeBlocks(Node n) { if (NodeUtil.isControlStructure(n) && !n.isLabel() && !n.isSwitch()) { for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (NodeUtil.isControlStructureCodeBlock(n, c) && !c.isBlock()) { Node newBlock = IR.block().srcref(n); n.replaceChild(c, newBlock); if (!c.isEmpty()) { newBlock.addChildrenToFront(c); } else { newBlock.setWasEmptyNode(true); } c = newBlock; reportChange(); } } } }\n```\n\n            \n```java\nprivate void handleObjectLit(NodeTraversal t, Node n) { Node child = n.getFirstChild(); while (child != null) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make(t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? \\\"null\\\" : type.toString()), n.toString(), \\\"\\\")); } } child = child.getNext(); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n// Do not traverse into functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // Report non-alias locals that are not assigned a qualified name\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        if (aliasVar != null && aliasVar.getInitialValue() != null) {\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          if (qualifiedName != null) {\n            transformation.addAlias(name, qualifiedName);\n          }\n        }\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        Node initialValue = aliasVar.getInitialValue();\n        if (initialValue != null && initialValue.isQualifiedName()) {\n          String qualifiedName = initialValue.getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        }\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // Report non-alias variables with initial values that are not\n        // qualified names.\n        if (n.hasChildren()) {\n          Node child = n.getFirstChild();\n          if (!child.isQualifiedName()) {\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        } else {\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent != null && parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else if (!n.hasChildren() || !n.getFirstChild().isQualifiedName()) {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse into functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // If we're not handling a qualified name as expected, report error\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        // Only consider it an alias if it actually resolves to something with an initial value\n        if (aliasVar != null && aliasVar.getInitialValue() != null) {\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        }\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse in to functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName() && n.getFirstChild().isName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        if (aliasVar != null) {\n          aliases.put(name, aliasVar);\n\n          String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        }\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ],
                [
                    "\n// Do not traverse into functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        Node initialValue = aliasVar.getInitialValue();\n        if (initialValue != null && initialValue.isQualifiedName()) {\n          String qualifiedName = initialValue.getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n        } else {\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // TODO(robbyw): Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\n// Do not traverse into functions except for goog.scope functions.\nprivate void findAliases(NodeTraversal t) {\n  Scope scope = t.getScope();\n  for (Var v : scope.getVarIterable()) {\n    Node n = v.getNode();\n    int type = n.getType();\n    Node parent = n.getParent();\n    if (parent.isVar()) {\n      if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n        String name = n.getString();\n        Var aliasVar = scope.getVar(name);\n        aliases.put(name, aliasVar);\n\n        String qualifiedName =\n            aliasVar.getInitialValue().getQualifiedName();\n        transformation.addAlias(name, qualifiedName);\n        // Bleeding functions already get a BAD_PARAMETERS error, so just\n        // do nothing.\n        // Parameters of the scope function also get a BAD_PARAMETERS\n        // error.\n      } else {\n        // Report non-alias locals that are not assigned a qualified name\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n}\n"
                ]
            ]
        },
        "iteration_done": true
    }
}