{
    "Closure-86": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* @param locals A predicate to apply to unknown local values.\n* @return Whether the node is known to be a value that is not a reference\n*     outside the expression scope.\n*/\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      // There is no information about the locality of object properties.\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      // TODO(nicksantos): This needs to be changed so that it\n      // returns true iff we're sure the value was never aliased from inside\n      // the constructor (similar to callHasLocalResult)\n      return true;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testLocalValue1() throws Exception {\n\n    // Names are not known to be local.\n\n    assertFalse(testLocalValue(\"x\"));\n\n    assertFalse(testLocalValue(\"x()\"));\n\n    assertFalse(testLocalValue(\"this\"));\n\n    assertFalse(testLocalValue(\"arguments\"));\n\n\n\n    // We can't know if new objects are local unless we know\n\n    // that they don't alias themselves.\n\n    assertFalse(testLocalValue(\"new x()\"));\n\n\n\n    // property references are assume to be non-local\n\n    assertFalse(testLocalValue(\"(new x()).y\"));\n\n    assertFalse(testLocalValue(\"(new x())['y']\"));\n\n\n\n    // Primitive values are local\n\n    assertTrue(testLocalValue(\"null\"));\n\n    assertTrue(testLocalValue(\"undefined\"));\n\n    assertTrue(testLocalValue(\"Infinity\"));\n\n    assertTrue(testLocalValue(\"NaN\"));\n\n    assertTrue(testLocalValue(\"1\"));\n\n    assertTrue(testLocalValue(\"'a'\"));\n\n    assertTrue(testLocalValue(\"true\"));\n\n    assertTrue(testLocalValue(\"false\"));\n\n    assertTrue(testLocalValue(\"[]\"));\n\n    assertTrue(testLocalValue(\"{}\"));\n\n\n\n    // The contents of arrays and objects don't matter\n\n    assertTrue(testLocalValue(\"[x]\"));\n\n    assertTrue(testLocalValue(\"{'a':x}\"));\n\n\n\n    // Pre-increment results in primitive number\n\n    assertTrue(testLocalValue(\"++x\"));\n\n    assertTrue(testLocalValue(\"--x\"));\n\n\n\n    // Post-increment, the previous value matters.\n\n    assertFalse(testLocalValue(\"x++\"));\n\n    assertFalse(testLocalValue(\"x--\"));\n\n\n\n    // The left side of an only assign matters if it is an alias or mutable.\n\n    assertTrue(testLocalValue(\"x=1\"));\n\n    assertFalse(testLocalValue(\"x=[]\"));\n\n    assertFalse(testLocalValue(\"x=y\"));\n\n    // The right hand side of assignment opts don't matter, as they force\n\n    // a local result.\n\n    assertTrue(testLocalValue(\"x+=y\"));\n\n    assertTrue(testLocalValue(\"x*=y\"));\n\n    // Comparisons always result in locals, as they force a local boolean\n\n    // result.\n\n    assertTrue(testLocalValue(\"x==y\"));\n\n    assertTrue(testLocalValue(\"x!=y\"));\n\n    assertTrue(testLocalValue(\"x>y\"));\n\n    // Only the right side of a comma matters\n\n    assertTrue(testLocalValue(\"(1,2)\"));\n\n    assertTrue(testLocalValue(\"(x,1)\"));\n\n    assertFalse(testLocalValue(\"(x,y)\"));\n\n\n\n    // Both the operands of OR matter\n\n    assertTrue(testLocalValue(\"1||2\"));\n\n    assertFalse(testLocalValue(\"x||1\"));\n\n    assertFalse(testLocalValue(\"x||y\"));\n\n    assertFalse(testLocalValue(\"1||y\"));\n\n\n\n    // Both the operands of AND matter\n\n    assertTrue(testLocalValue(\"1&&2\"));\n\n    assertFalse(testLocalValue(\"x&&1\"));\n\n    assertFalse(testLocalValue(\"x&&y\"));\n\n    assertFalse(testLocalValue(\"1&&y\"));\n\n\n\n    // Only the results of HOOK matter\n\n    assertTrue(testLocalValue(\"x?1:2\"));\n\n    assertFalse(testLocalValue(\"x?x:2\"));\n\n    assertFalse(testLocalValue(\"x?1:x\"));\n\n    assertFalse(testLocalValue(\"x?x:y\"));\n\n\n\n    // Results of ops are local values\n\n    assertTrue(testLocalValue(\"!y\"));\n\n    assertTrue(testLocalValue(\"~y\"));\n\n    assertTrue(testLocalValue(\"y + 1\"));\n\n    assertTrue(testLocalValue(\"y + z\"));\n\n    assertTrue(testLocalValue(\"y * z\"));\n\n\n\n    assertTrue(testLocalValue(\"'a' in x\"));\n\n    assertTrue(testLocalValue(\"typeof x\"));\n\n    assertTrue(testLocalValue(\"x instanceof y\"));\n\n\n\n    assertTrue(testLocalValue(\"void x\"));\n\n    assertTrue(testLocalValue(\"void 0\"));\n\n\n\n    assertFalse(testLocalValue(\"{}.x\"));\n\n\n\n    assertTrue(testLocalValue(\"{}.toString()\"));\n\n    assertTrue(testLocalValue(\"o.toString()\"));\n\n\n\n    assertFalse(testLocalValue(\"o.valueOf()\"));\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat com.google.javascript.jscomp.NodeUtilTest.testLocalValue1(NodeUtilTest.java:1023)  assertFalse(testLocalValue(\"new x()\"));\n \n#Test method 2:\n```java\n  public void testLocalizedSideEffects8() throws Exception {\n\n    // Returning a local object that has been modified\n\n    // is not a global side-effect.\n\n    checkMarkedCalls(\"/** @constructor A */ function A() {};\" +\n\n                     \"function f() {\" +\n\n                     \"  var a = new A; a.foo = 1; return a;\" +\n\n                     \"}\" +\n\n                     \"f()\",\n\n                     BROKEN_NEW ?\n\n                         ImmutableList.<String>of(\"A\") :\n\n                         ImmutableList.<String>of(\"A\", \"f\"));\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<[A]> but was:<[A, f]>\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.checkMarkedCalls(PureFunctionIdentifierTest.java:1206)  assertEquals(expected, noSideEffectCalls);\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.testLocalizedSideEffects8(PureFunctionIdentifierTest.java:772)  checkMarkedCalls(\"/** @constructor A */ function A() {};\" +                     \"function f() {\" +                     \"  var a = new A; a.foo = 1; return a;\" +                     \"}\" +                     \"f()\",                     BROKEN_NEW ?                         ImmutableList.<String>of(\"A\") :                         ImmutableList.<String>of(\"A\", \"f\"));\n \n#Test method 3:\n```java\n  public void testLocalizedSideEffects9() throws Exception {\n\n    // Returning a local object that has been modified\n\n    // is not a global side-effect.\n\n    checkMarkedCalls(\"/** @constructor A */ function A() {this.x = 1};\" +\n\n                     \"function f() {\" +\n\n                     \"  var a = new A; a.foo = 1; return a;\" +\n\n                     \"}\" +\n\n                     \"f()\",\n\n                     BROKEN_NEW ?\n\n                         ImmutableList.<String>of(\"A\") :\n\n                         ImmutableList.<String>of(\"A\", \"f\"));\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<[A]> but was:<[A, f]>\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.checkMarkedCalls(PureFunctionIdentifierTest.java:1206)  assertEquals(expected, noSideEffectCalls);\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.testLocalizedSideEffects9(PureFunctionIdentifierTest.java:785)  checkMarkedCalls(\"/** @constructor A */ function A() {this.x = 1};\" +                     \"function f() {\" +                     \"  var a = new A; a.foo = 1; return a;\" +                     \"}\" +                     \"f()\",                     BROKEN_NEW ?                         ImmutableList.<String>of(\"A\") :                         ImmutableList.<String>of(\"A\", \"f\"));\n \n#Test method 4:\n```java\n  public void testAnnotationInExterns_new4() throws Exception {\n\n    // The entire expression containing \"externObjSEThisMethod\" is considered\n\n    // side-effect free in this context.\n\n\n\n    checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",\n\n        BROKEN_NEW ?\n\n            ImmutableList.<String>of(\n\n               \"externObjSEThis\") :\n\n            ImmutableList.<String>of(\n\n               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<[externObjSEThis]> but was:<[externObjSEThis, NEW STRING externObjSEThisMethod]>\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.checkMarkedCalls(PureFunctionIdentifierTest.java:1206)  assertEquals(expected, noSideEffectCalls);\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.testAnnotationInExterns_new4(PureFunctionIdentifierTest.java:241)  checkMarkedCalls(\"new externObjSEThis().externObjSEThisMethod('')\",        BROKEN_NEW ?            ImmutableList.<String>of(               \"externObjSEThis\") :            ImmutableList.<String>of(               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\"));\n \n#Test method 5:\n```java\n  public void testAnnotationInExterns_new6() throws Exception {\n\n    // While \"externObjSEThisMethod\" has modifies \"this\"\n\n    // it does not have global side-effects with \"this\" is\n\n    // a known local value.\n\n    checkMarkedCalls(\n\n        \"function f() {\" +\n\n        \"  new externObjSEThis().externObjSEThisMethod('') \" +\n\n        \"};\" +\n\n        \"f();\",\n\n        BROKEN_NEW ?\n\n            ImmutableList.<String>of(\n\n                \"externObjSEThis\") :\n\n           ImmutableList.<String>of(\n\n               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\", \"f\"));\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<[externObjSEThis]> but was:<[externObjSEThis, NEW STRING externObjSEThisMethod, f]>\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.checkMarkedCalls(PureFunctionIdentifierTest.java:1206)  assertEquals(expected, noSideEffectCalls);\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.testAnnotationInExterns_new6(PureFunctionIdentifierTest.java:260)  checkMarkedCalls(        \"function f() {\" +        \"  new externObjSEThis().externObjSEThisMethod('') \" +        \"};\" +        \"f();\",        BROKEN_NEW ?            ImmutableList.<String>of(                \"externObjSEThis\") :           ImmutableList.<String>of(               \"externObjSEThis\", \"NEW STRING externObjSEThisMethod\", \"f\"));\n \n#Test method 6:\n```java\n  public void testIssue303b() throws Exception {\n\n    checkMarkedCalls(\n\n        \"/** @constructor */ function F() {\" +\n\n        \"  var self = this;\" +\n\n        \"  window.setTimeout(function() {\" +\n\n        \"    window.location = self.location;\" +\n\n        \"  }, 0);\" +\n\n        \"}\" +\n\n        \"F.prototype.setLocation = function(x) {\" +\n\n        \"  this.location = x;\" +\n\n        \"};\" +\n\n        \"function x() {\" +\n\n        \"  (new F()).setLocation('http://www.google.com/');\" +\n\n        \"} window['x'] = x;\",\n\n        ImmutableList.<String>of());\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<[]> but was:<[NEW STRING setLocation]>\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.checkMarkedCalls(PureFunctionIdentifierTest.java:1206)  assertEquals(expected, noSideEffectCalls);\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.testIssue303b(PureFunctionIdentifierTest.java:206)  checkMarkedCalls(        \"/** @constructor */ function F() {\" +        \"  var self = this;\" +        \"  window.setTimeout(function() {\" +        \"    window.location = self.location;\" +        \"  }, 0);\" +        \"}\" +        \"F.prototype.setLocation = function(x) {\" +        \"  this.location = x;\" +        \"};\" +        \"function x() {\" +        \"  (new F()).setLocation('http://www.google.com/');\" +        \"} window['x'] = x;\",        ImmutableList.<String>of());\n \n#Test method 7:\n```java\n  public void testIssue303() throws Exception {\n\n    checkMarkedCalls(\n\n        \"/** @constructor */ function F() {\" +\n\n        \"  var self = this;\" +\n\n        \"  window.setTimeout(function() {\" +\n\n        \"    window.location = self.location;\" +\n\n        \"  }, 0);\" +\n\n        \"}\" +\n\n        \"F.prototype.setLocation = function(x) {\" +\n\n        \"  this.location = x;\" +\n\n        \"};\" +\n\n        \"(new F()).setLocation('http://www.google.com/');\",\n\n        ImmutableList.<String>of());\n\n  }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<[]> but was:<[NEW STRING setLocation]>\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.checkMarkedCalls(PureFunctionIdentifierTest.java:1206)  assertEquals(expected, noSideEffectCalls);\n\tat com.google.javascript.jscomp.PureFunctionIdentifierTest.testIssue303(PureFunctionIdentifierTest.java:191)  checkMarkedCalls(        \"/** @constructor */ function F() {\" +        \"  var self = this;\" +        \"  window.setTimeout(function() {\" +        \"    window.location = self.location;\" +        \"  }, 0);\" +        \"}\" +        \"F.prototype.setLocation = function(x) {\" +        \"  this.location = x;\" +        \"};\" +        \"(new F()).setLocation('http://www.google.com/');\",        ImmutableList.<String>of());\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return false;\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\n/**\n* @param locals A predicate to apply to unknown local values.\n* @return Whether the node is known to be a value that is not a reference\n*     outside the expression scope.\n*/\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return callHasLocalResult(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.test(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.test(value);\n    case Token.NAME:\n      return NodeUtil.isImmutableValue(value) || locals.test(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.test(value);\n    case Token.NEW:\n      return callHasLocalResult(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || NodeUtil.isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && evaluatesToLocalValue(value.getFirstChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return false;\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return callHasLocalResult(value) || locals.apply(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.apply(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.test(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.test(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.test(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.test(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\n/**\n* @param locals A predicate to apply to unknown local values.\n* @return Whether the node is known to be a value that is not a reference\n*     outside the expression scope.\n*/\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.test(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.test(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.test(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.test(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\n/**\n* @param locals A predicate to apply to unknown local values.\n* @return Whether the node is known to be a value that is not a reference\n*     outside the expression scope.\n*/\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.apply(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return callHasLocalResult(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.apply(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return false;\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.apply(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.apply(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ]
            ],
            "compiler_error_or_timeout": true,
            "plausible_patches": [
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return false;\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (evaluatesToLocalValue(value.getLastChild(), locals)\n              && locals.apply(value.getFirstChild()));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ],
                [
                    "\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value.getFirstChild())\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return false;\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.IN:\n      return true;\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n"
                ]
            ]
        }
    }
}