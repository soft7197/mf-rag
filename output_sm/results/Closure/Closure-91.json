{
    "Closure-91": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Since this pass reports errors only when a global {@code this} keyword\n* is encountered, there is no reason to traverse non global contexts.\n*/\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testLendsAnnotation3() {\n\n    testSame(\"/** @constructor */ function F() {}\" +\n\n        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +\n\n        \"    {foo: function() { return this.foo; }}));\");\n\n  }\n\n```\n#Error message: \tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:733)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CheckGlobalThisTest.testLendsAnnotation3(CheckGlobalThisTest.java:236)  testSame(\"/** @constructor */ function F() {}\" +        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +        \"    {foo: function() { return this.foo; }}));\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n          pType == Token.OBJECTLIT || // Added check for object literal context\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          \n          // Added object literal \n          pType == Token.OBJECTLIT)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          \n          // object literal value\n          pType == Token.OBJECTLIT)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          (pType == Token.CALL && parent.getFirstChild().matchesQualifiedName(\"dojo.declare\")))) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          pType == Token.OBJECTLIT)) { // Added OBJECTLIT to allow traversing object literals\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n          pType == Token.OBJECTLIT || // Allow object literals\n          pType == Token.EXPR_RESULT || // Allow expression results\n          pType == Token.CALL || // Allow calls\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n\n          // object literal or @lends expressions\n          pType == Token.OBJECTLIT)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          // Add the TYPEOF check for @lends\n          (pType == Token.OBJECTLIT && parent.getParent() != null && parent.getParent().getType() == Token.CALL))) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n          pType == Token.OBJECTLIT ||  // Added this line to handle object literals correctly.\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n\n          // Check if it's an object literal property in the context of @lends\n          (pType == Token.OBJECTLIT && parent.getParent() != null &&\n           parent.getParent().getType() == Token.CALL))) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Since this pass reports errors only when a global {@code this} keyword\n* is encountered, there is no reason to traverse non global contexts.\n*/\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n  public void testLendsAnnotation3() {\n\n    testSame(\"/** @constructor */ function F() {}\" +\n\n        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +\n\n        \"    {foo: function() { return this.foo; }}));\");\n\n  }\n\n```\n#Error message: \tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:733)  assertEquals(          \"Unexpected error(s): \" + Joiner.on(\"\\n\").join(compiler.getErrors()),          0, compiler.getErrorCount());\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)  test(compiler, new String[] { expected }, error, warning, description);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)  test(externsInputs, js, expected, error, warning, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)  test(js, expected, error, null);\n\tat com.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)  test(js, expected, (DiagnosticType) null);\n\tat com.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)  test(js, js);\n\tat com.google.javascript.jscomp.CheckGlobalThisTest.testLendsAnnotation3(CheckGlobalThisTest.java:236)  testSame(\"/** @constructor */ function F() {}\" +        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +        \"    {foo: function() { return this.foo; }}));\");\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprivate JSType createFromTypeNodesInternal(Node n, String sourceName, StaticScope<JSType> scope, boolean forgiving) { switch(n.getType()) { case Token.LC: return createRecordTypeFromNodes(n.getFirstChild(), sourceName, scope); case Token.BANG: return createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, forgiving).restrictByNotNullOrUndefined(); case Token.QMARK: Node firstChild = n.getFirstChild(); if (firstChild == null) { return getNativeType(UNKNOWN_TYPE); } return createDefaultObjectUnion(createFromTypeNodesInternal(firstChild, sourceName, scope, forgiving)); case Token.EQUALS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false)); case Token.ELLIPSIS: return createOptionalType(createFromTypeNodesInternal(n.getFirstChild(), sourceName, scope, false)); case Token.STAR: return getNativeType(ALL_TYPE); case Token.LB: return getNativeType(ARRAY_TYPE); case Token.PIPE: UnionTypeBuilder builder = new UnionTypeBuilder(this); for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { builder.addAlternate(createFromTypeNodesInternal(child, sourceName, scope, false)); } return builder.build(); case Token.EMPTY: return getNativeType(UNKNOWN_TYPE); case Token.VOID: return getNativeType(VOID_TYPE); case Token.STRING: JSType namedType = getType(scope, n.getString(), sourceName, n.getLineno(), n.getCharno()); if (forgiving) { namedType.forgiveUnknownNames(); } if (resolveMode != ResolveMode.LAZY_NAMES) { namedType = namedType.resolveInternal(reporter, scope); } if ((namedType instanceof ObjectType) && !(enumTypeNames.contains(n.getString()))) { Node typeList = n.getFirstChild(); if (typeList != null && (\\\"Array\\\".equals(n.getString()) || \\\"Object\\\".equals(n.getString()))) { JSType parameterType = createFromTypeNodesInternal(typeList.getLastChild(), sourceName, scope, false); namedType = new ParameterizedType(this, (ObjectType) namedType, parameterType); if (typeList.hasMoreThanOneChild()) { JSType indexType = createFromTypeNodesInternal(typeList.getFirstChild(), sourceName, scope, false); namedType = new IndexedType(this, (ObjectType) namedType, indexType); } } return createDefaultObjectUnion(namedType); } else { return namedType; } case Token.FUNCTION: ObjectType thisType = null; Node current = n.getFirstChild(); if (current.getType() == Token.THIS) { Node thisNode = current.getFirstChild(); thisType = ObjectType.cast(createFromTypeNodesInternal(thisNode, sourceName, scope, false).restrictByNotNullOrUndefined()); if (thisType == null) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.thisnotobject\\\"), sourceName, thisNode.getLineno(), \\\"\\\", thisNode.getCharno()); } current = current.getNext(); } FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this); if (current.getType() == Token.LP) { Node args = current.getFirstChild(); for (Node arg = current.getFirstChild(); arg != null; arg = arg.getNext()) { if (arg.getType() == Token.ELLIPSIS) { if (arg.getChildCount() == 0) { paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE)); } else { paramBuilder.addVarArgs(createFromTypeNodesInternal(arg.getFirstChild(), sourceName, scope, false)); } } else { JSType type = createFromTypeNodesInternal(arg, sourceName, scope, false); if (arg.getType() == Token.EQUALS) { boolean addSuccess = paramBuilder.addOptionalParams(type); if (!addSuccess) { reporter.warning(ScriptRuntime.getMessage0(\\\"msg.jsdoc.function.varargs\\\"), sourceName, arg.getLineno(), \\\"\\\", arg.getCharno()); } } else { paramBuilder.addRequiredParams(type); } } } current = current.getNext(); } JSType returnType = createFromTypeNodesInternal(current, sourceName, scope, false); return new FunctionBuilder(this).withParams(paramBuilder).withReturnType(returnType).withTypeOfThis(thisType).build(); } throw new IllegalStateException(\\\"Unexpected node in type expression: \\\" + n.toString()); }\n```\n\n            \n```java\nprivate UndiGraph<Var, Void> computeVariableNamesInterferenceGraph(NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) { UndiGraph<Var, Void> interferenceGraph = new LinkedUndirectedGraph<Var, Void>(); Scope scope = t.getScope(); for (Iterator<Var> i = scope.getVars(); i.hasNext(); ) { Var v = i.next(); if (!escaped.contains(v)) { if (!NodeUtil.isFunction(v.getParentNode())) { interferenceGraph.createNode(v); } } } for (Iterator<Var> i1 = scope.getVars(); i1.hasNext(); ) { Var v1 = i1.next(); NEXT_VAR_PAIR: for (Iterator<Var> i2 = scope.getVars(); i2.hasNext(); ) { Var v2 = i2.next(); if (v1.index >= v2.index) { continue; } if (!interferenceGraph.hasNode(v1) || !interferenceGraph.hasNode(v2)) { continue NEXT_VAR_PAIR; } if (v1.getParentNode().getType() == Token.LP && v2.getParentNode().getType() == Token.LP) { interferenceGraph.connectIfNotFound(v1, null, v2); continue NEXT_VAR_PAIR; } NEXT_CROSS_CFG_NODE: for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) { if (cfg.isImplicitReturn(cfgNode)) { continue NEXT_CROSS_CFG_NODE; } FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) || (state.getOut().isLive(v1) && state.getOut().isLive(v2))) { interferenceGraph.connectIfNotFound(v1, null, v2); continue NEXT_VAR_PAIR; } } NEXT_INTRA_CFG_NODE: for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) { if (cfg.isImplicitReturn(cfgNode)) { continue NEXT_INTRA_CFG_NODE; } FlowState<LiveVariableLattice> state = cfgNode.getAnnotation(); boolean v1OutLive = state.getOut().isLive(v1); boolean v2OutLive = state.getOut().isLive(v2); CombinedLiveRangeChecker checker = new CombinedLiveRangeChecker(new LiveRangeChecker(v1, v2OutLive ? null : v2), new LiveRangeChecker(v2, v1OutLive ? null : v1)); NodeTraversal.traverse(compiler, cfgNode.getValue(), checker); if (checker.connectIfCrossed(interferenceGraph)) { continue NEXT_VAR_PAIR; } } } } return interferenceGraph; }\n```\n\n            \n```java\n@Override public void visit(NodeTraversal t, Node n, Node parent) { switch(n.getType()) { case Token.CALL: boolean isExpr = parent.getType() == Token.EXPR_RESULT; Node left = n.getFirstChild(); if (left.getType() == Token.GETPROP) { Node name = left.getFirstChild(); if (name.getType() == Token.NAME && GOOG.equals(name.getString())) { String methodName = name.getNext().getString(); if (\\\"base\\\".equals(methodName)) { processBaseClassCall(t, n); } else if (!isExpr) { break; } else if (\\\"require\\\".equals(methodName)) { processRequireCall(t, n, parent); } else if (\\\"provide\\\".equals(methodName)) { processProvideCall(t, n, parent); } else if (\\\"exportSymbol\\\".equals(methodName)) { Node arg = left.getNext(); if (arg.getType() == Token.STRING) { int dot = arg.getString().indexOf('.'); if (dot == -1) { exportedVariables.add(arg.getString()); } else { exportedVariables.add(arg.getString().substring(0, dot)); } } } else if (\\\"addDependency\\\".equals(methodName)) { CodingConvention convention = compiler.getCodingConvention(); List<String> typeDecls = convention.identifyTypeDeclarationCall(n); if (typeDecls != null) { for (String typeDecl : typeDecls) { compiler.getTypeRegistry().forwardDeclareType(typeDecl); } } parent.replaceChild(n, Node.newNumber(0)); compiler.reportCodeChange(); } else if (\\\"setCssNameMapping\\\".equals(methodName)) { processSetCssNameMapping(t, n, parent); } } } break; case Token.ASSIGN: case Token.NAME: handleCandidateProvideDefinition(t, n, parent); break; case Token.FUNCTION: if (t.inGlobalScope() && !NodeUtil.isFunctionExpression(n)) { String name = n.getFirstChild().getString(); ProvidedName pn = providedNames.get(name); if (pn != null) { compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name)); } } break; case Token.NEW: trySimplifyNewDate(t, n, parent); break; case Token.GETPROP: if (n.getFirstChild().getType() == Token.NAME && parent.getType() != Token.CALL && parent.getType() != Token.ASSIGN && \\\"goog.base\\\".equals(n.getQualifiedName())) { reportBadBaseClassUse(t, n, \\\"May only be called directly.\\\"); } break; } }\n```\n\n            \n```java\npublic void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } } if (n.getType() == Token.ASSIGN) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.getType() == Token.CALL) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode(name, n, parent, parent.getParent())); } } } }\n```\n\n            \n```java\nprivate void addNonEmptyStatement(Node n, Context context, boolean allowNonBlockChild) { Node nodeToProcess = n; if (!allowNonBlockChild && n.getType() != Token.BLOCK) { throw new Error(\\\"Missing BLOCK child.\\\"); } if (n.getType() == Token.BLOCK) { int count = getNonEmptyChildCount(n, 2); if (count == 0) { if (cc.shouldPreserveExtraBlocks()) { cc.beginBlock(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } else { cc.endStatement(true); } return; } if (count == 1) { Node firstAndOnlyChild = getFirstNonEmptyChild(n); boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks(); if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) { cc.beginBlock(); add(firstAndOnlyChild, Context.STATEMENT); cc.maybeLineBreak(); cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); return; } else { nodeToProcess = firstAndOnlyChild; } } if (count > 1) { context = Context.PRESERVE_BLOCK; } } if (nodeToProcess.getType() == Token.EMPTY) { cc.endStatement(true); } else { add(nodeToProcess, context); if (nodeToProcess.getType() == Token.VAR) { cc.endStatement(); } } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          (pType == Token.STRING && NodeUtil.isObjectLitKey(parent)) ||\n          (pType == Token.NUMBER && NodeUtil.isObjectLitKey(parent)))) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs != null && llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          \n          // object lit references for @lends\n          (pType == Token.CALL && parent.getFirstChild().getType() == Token.GETPROP &&\n           \"lends\".equals(parent.getFirstChild().getLastChild().getString())))) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          pType == Token.EXPR_RESULT)) { // Added Token.EXPR_RESULT\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          (pType == Token.CALL && parent.getFirstChild().getType() == Token.GETPROP && \n           \"declare\".equals(parent.getFirstChild().getLastChild().getString())))) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER ||\n          pType == Token.OBJECTLIT)) {  // Added OBJECTLIT check\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          pType == Token.STRING ||\n          pType == Token.STRING_KEY ||  // Correct node type for object literal keys\n          pType == Token.NUMBER)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent != null ? parent.getType() : -1;\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs != null && llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||          \n          pType == Token.OBJECTLIT)) {\n      return false;\n    }\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.GETPROP ||\n          pType == Token.STRING ||\n          pType == Token.NUMBER)) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ],
                [
                    "\npublic boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n  if (n.getType() == Token.FUNCTION) {\n    // Don't traverse functions that are constructors or have the @this\n    // or @override annotation.\n    JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n    if (jsDoc != null &&\n        (jsDoc.isConstructor() ||\n         jsDoc.isInterface() ||\n         jsDoc.hasThisType() ||\n         jsDoc.isOverride())) {\n      return false;\n    }\n\n    // Don't traverse functions unless they would normally\n    // be able to have a @this annotation associated with them. e.g.,\n    // var a = function() { }; // or\n    // function a() {} // or\n    // a.x = function() {}; // or\n    // var a = {x: function() {}};\n    int pType = parent.getType();\n    if (!(pType == Token.BLOCK ||\n          pType == Token.SCRIPT ||\n          pType == Token.NAME ||\n          pType == Token.ASSIGN ||\n\n          // object literal keys\n          pType == Token.STRING ||\n          parent.isObjectLit())) {\n      return false;\n    }\n\n    // Don't traverse functions that are getting lent to a prototype.\n  }\n\n  if (parent != null && parent.getType() == Token.ASSIGN) {\n    Node lhs = parent.getFirstChild();\n    Node rhs = lhs.getNext();\n\n    if (n == lhs) {\n      // Always traverse the left side of the assignment. To handle\n      // nested assignments properly (e.g., (a = this).property = c;),\n      // assignLhsChild should not be overridden.\n      if (assignLhsChild == null) {\n        assignLhsChild = lhs;\n      }\n    } else {\n      // Only traverse the right side if it's not an assignment to a prototype\n      // property or subproperty.\n      if (NodeUtil.isGet(lhs)) {\n        if (lhs.getType() == Token.GETPROP &&\n            lhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n        Node llhs = lhs.getFirstChild();\n        if (llhs.getType() == Token.GETPROP &&\n            llhs.getLastChild().getString().equals(\"prototype\")) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}