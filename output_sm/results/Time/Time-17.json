{
    "Time-17": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Adjusts the offset to be the earlier or later one during an overlap.\n*\n* @param instant  the instant to adjust\n* @param earlierOrLater  false for earlier, true for later\n* @return the adjusted instant millis\n*/\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n    \n    // calculate result\n      // currently in later offset\n      // currently in earlier offset\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBug3476684_adjustOffset() {\n\n        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n\n        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n\n        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n\n        \n\n        assertSame(base, base.withEarlierOffsetAtOverlap());\n\n        assertSame(base, base.withLaterOffsetAtOverlap());\n\n        \n\n        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n\n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n\n        \n\n        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n\n        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2012-02-25T23:15:00.000-03:00> but was:<2012-02-25T23:15:00.000-02:00>\n\tat org.joda.time.TestDateTimeZoneCutover.testBug3476684_adjustOffset(TestDateTimeZoneCutover.java:1259)  assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, false, instantBefore);\n    long laterInstant = convertLocalToUTC(local, false, instantAfter);\n    \n    // calculate result\n    return earlierOrLater ? laterInstant : earlierInstant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    \n    long earlierInstant = convertLocalToUTC(local, false, instantBefore);\n    long laterInstant = convertLocalToUTC(local, false, instantAfter);\n    \n    if (earlierOrLater) {\n        return laterInstant > instant ? laterInstant : instant;\n    } else {\n        return earlierInstant < instant ? earlierInstant : instant;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    \n    long earlierOffset = convertLocalToUTC(local, false, instantBefore);\n    long laterOffset = convertLocalToUTC(local, false, instantAfter);\n    \n    if (earlierOrLater) {\n        return laterOffset;\n    } else {\n        return earlierOffset;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, false, instantBefore);\n    long laterInstant = convertLocalToUTC(local, false, instantAfter);\n\n    return earlierOrLater ? laterInstant : earlierInstant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n    \n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, false, instantBefore);\n    long laterInstant = convertLocalToUTC(local, false, instantAfter);\n    \n    if (earlierOrLater) {\n        return laterInstant > instant ? laterInstant : earlierInstant;\n    } else {\n        return earlierInstant > instant ? earlierInstant : laterInstant;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long earlierOffsetInstant = convertLocalToUTC(local, false, instantBefore);\n    long laterOffsetInstant = convertLocalToUTC(local, false, instantAfter);\n    \n    // return the correct instant based on earlierOrLater flag\n    return earlierOrLater ? laterOffsetInstant : earlierOffsetInstant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    \n    // find the offset from the instant\n    long offsetBefore = instant - instantBefore;\n    long offsetAfter = instant - instantAfter;\n    \n    // determine if the instant is in the overlap period\n    boolean inOverlap = offsetBefore > offsetAfter;\n    \n    // if in overlap, choose earlier or later offset\n    if (inOverlap) {\n        return convertLocalToUTC(local, false, earlierOrLater ? offsetAfter : offsetBefore);\n    }\n    \n    return instant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, false, instantBefore);\n    long laterInstant = convertLocalToUTC(local, false, instantAfter);\n    \n    // return earlier or later instant based on the flag\n    return earlierOrLater ? laterInstant : earlierInstant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap\n    }\n\n    long local = convertUTCToLocal(instant);\n    long adjustedInstantBefore = convertLocalToUTC(local, false, instantBefore);\n    long adjustedInstantAfter = convertLocalToUTC(local, false, instantAfter);\n\n    if (earlierOrLater) {\n        return adjustedInstantAfter;\n    } else {\n        return adjustedInstantBefore;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 1 hour before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long adjustedInstant = convertLocalToUTC(local, false, instantAfter);\n    \n    if (adjustedInstant == instant) {\n        return earlierOrLater ? convertLocalToUTC(local, false, instantBefore) : adjustedInstant;\n    }\n    \n    return earlierOrLater ? adjustedInstant : convertLocalToUTC(local, false, instantBefore);\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Adjusts the offset to be the earlier or later one during an overlap.\n*\n* @param instant  the instant to adjust\n* @param earlierOrLater  false for earlier, true for later\n* @return the adjusted instant millis\n*/\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n    \n    // calculate result\n      // currently in later offset\n      // currently in earlier offset\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testBug3476684_adjustOffset() {\n\n        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n\n        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n\n        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n\n        \n\n        assertSame(base, base.withEarlierOffsetAtOverlap());\n\n        assertSame(base, base.withLaterOffsetAtOverlap());\n\n        \n\n        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n\n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n\n        \n\n        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n\n        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2012-02-25T23:15:00.000-03:00> but was:<2012-02-25T23:15:00.000-02:00>\n\tat org.joda.time.TestDateTimeZoneCutover.testBug3476684_adjustOffset(TestDateTimeZoneCutover.java:1259)  assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nint getWeekOfWeekyear(long instant, int year) { long firstWeekMillis1 = getFirstWeekOfYearMillis(year); if (instant < firstWeekMillis1) { return getWeeksInYear(year - 1); } long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); if (instant >= firstWeekMillis2) { return 1; } return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; }\n```\n\n            \n```java\nprivate void printTo(Writer buf, long instant, Chronology chrono) throws IOException { DateTimePrinter printer = requirePrinter(); chrono = selectChronology(chrono); DateTimeZone zone = chrono.getZone(); int offset = zone.getOffset(instant); long adjustedInstant = instant + offset; if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) { zone = DateTimeZone.UTC; offset = 0; adjustedInstant = instant; } printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale); }\n```\n\n            \n```java\nprivate Info createInfo(long millis) { long periodStart = millis & (0xffffffffL << 32); Info info = new Info(iZone, periodStart); long end = periodStart | 0xffffffffL; Info chain = info; while (true) { long next = iZone.nextTransition(periodStart); if (next == periodStart || next > end) { break; } periodStart = next; chain = (chain.iNextInfo = new Info(iZone, periodStart)); } return info; }\n```\n\n            \n```java\npublic void testConstructor_RI_RP1() throws Throwable { DateTime dt = new DateTime(TEST_TIME_NOW); Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0); long result = TEST_TIME_NOW; result = ISOChronology.getInstance().months().add(result, 6); result = ISOChronology.getInstance().hours().add(result, 1); Interval test = new Interval(dt, dur); assertEquals(dt.getMillis(), test.getStartMillis()); assertEquals(result, test.getEndMillis()); }\n```\n\n            \n```java\npublic long getDateTimeMillis(long instant, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { Chronology base; if ((base = iBase) != null && (iBaseFlags & 1) == 1) { return base.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } return super.getDateTimeMillis(instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n    \n    long offsetBefore = instant - instantBefore;\n    long offsetAfter = instant - instantAfter;\n\n    // Determine if the current instant is in the overlap range\n    long local = convertUTCToLocal(instant);\n    long overlapStart = convertLocalToUTC(local, true, instantAfter);\n    long overlapEnd = convertLocalToUTC(local, false, instantBefore);\n    \n    if (earlierOrLater) {\n        // True for later\n        if (overlapEnd == instant + offsetAfter) {\n            return overlapEnd - offsetBefore;\n        } else {\n            return overlapEnd;\n        }\n    } else {\n        // False for earlier\n        if (overlapStart == instant + offsetBefore) {\n            return overlapStart - offsetAfter;\n        } else {\n            return overlapStart;\n        }\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n    \n    long offsetBefore = instant - instantBefore;\n    long offsetAfter = instant - instantAfter;\n    long local = convertUTCToLocal(instant);\n\n    if (earlierOrLater) {\n        return convertLocalToUTC(local, false, instantAfter + offsetAfter);\n    } else {\n        return convertLocalToUTC(local, false, instantBefore + offsetBefore);\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    return earlierOrLater ? convertLocalToUTC(local, false, instantAfter) : convertLocalToUTC(local, false, instantBefore);\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, true, instantBefore);\n    long laterInstant = convertLocalToUTC(local, false, instantAfter);\n\n    return earlierOrLater ? laterInstant : earlierInstant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n    \n    long local = convertUTCToLocal(instant);\n    long earlierOffset = instant - instantBefore;\n    long laterOffset = instant - instantAfter;\n    \n    if (earlierOrLater) {\n        return instant + (laterOffset - earlierOffset);\n    } else {\n        return instant;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n\n    long local = convertUTCToLocal(instant);\n    long earlierOffsetAdjustment = convertLocalToUTC(local, false, instantBefore);\n    long laterOffsetAdjustment = convertLocalToUTC(local, false, instantAfter);\n\n    if (earlierOrLater) {\n        return laterOffsetAdjustment > earlierOffsetAdjustment ? earlierOffsetAdjustment : laterOffsetAdjustment;\n    } else {\n        return earlierOffsetAdjustment < laterOffsetAdjustment ? earlierOffsetAdjustment : laterOffsetAdjustment;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n\n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, true, instantBefore);\n    long laterInstant = convertLocalToUTC(local, true, instantAfter);\n\n    return earlierOrLater ? laterInstant : earlierInstant;\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    // a bit messy, but will work in all non-pathological cases\n    \n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    // work out range of instants that have duplicate local times\n    long local = convertUTCToLocal(instant);\n    if (earlierOrLater) {\n        // return later instant if requested\n        return convertLocalToUTC(local, false, instantAfter);\n    } else {\n        // return earlier instant if requested\n        return convertLocalToUTC(local, false, instantBefore);\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;  // not an overlap (less than is a gap, equal is normal case)\n    }\n    \n    long local = convertUTCToLocal(instant);\n    long earlierInstant = convertLocalToUTC(local, true, instantBefore);\n    long laterInstant = convertLocalToUTC(local, true, instantAfter);\n    \n    if (earlierOrLater) {\n        return laterInstant;\n    } else {\n        return earlierInstant;\n    }\n}\n"
                ],
                [
                    "\npublic long adjustOffset(long instant, boolean earlierOrLater) {\n    long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n    if (instantBefore == instantAfter) {\n        return instant;\n    }\n    \n    long local = convertUTCToLocal(instant);\n    long earlierOffsetUTC = convertLocalToUTC(local, false, instantBefore);\n    long laterOffsetUTC = convertLocalToUTC(local, false, instantAfter);\n    \n    return earlierOrLater ? laterOffsetUTC : earlierOffsetUTC;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}