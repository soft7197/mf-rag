{
    "Time-24": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Computes the parsed datetime by setting the saved fields.\n* This method is idempotent, but it is not thread-safe.\n*\n* @param resetFields false by default, but when true, unsaved field values are cleared\n* @param text optional text being parsed, to be included in any error message\n* @return milliseconds since 1970-01-01T00:00:00Z\n* @throws IllegalArgumentException if any field is out of range\n* @since 1.3\n*/\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testParseLocalDate_weekyear_month_week_2010() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2010(TestDateTimeFormatter.java:428)  expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n \n#Test method 2:\n```java\n    public void testParseLocalDate_weekyear_month_week_2011() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2011-01-03> but was:<2010-01-04>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2011(TestDateTimeFormatter.java:434)  public void testParseDateTime_chrono() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withChronology(ISO_PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0,LONDON);        assertEquals(expect, g.withChronology(null).parseDateTime(\"2004-06-09T10:20:30Z\"));        expect = new DateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime(\"2547-06-09T10:20:30Z\"));        expect = new DateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));    }\n \n#Test method 3:\n```java\n    public void testParseLocalDate_weekyear_month_week_2012() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2012-01-02> but was:<2011-01-03>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2012(TestDateTimeFormatter.java:440)  assertEquals(expect, g.withChronology(null).parseDateTime(\"2004-06-09T10:20:30Z\"));\n \n#Test method 4:\n```java\n    public void testParseLocalDate_year_month_week_2010() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2010(TestDateTimeFormatter.java:454)\n \n#Test method 5:\n```java\n    public void testParseLocalDate_year_month_week_2011() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2011-01-03> but was:<2010-01-04>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2011(TestDateTimeFormatter.java:460)\n \n#Test method 6:\n```java\n    public void testParseLocalDate_year_month_week_2012() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2012-01-02> but was:<2011-01-03>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2012(TestDateTimeFormatter.java:466)  expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n \n#Test method 7:\n```java\n    public void testParseLocalDate_year_month_week_2016() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2016-01-04> but was:<2014-12-29>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2016(TestDateTimeFormatter.java:490)  .toFormatter();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day or week\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        } else if (compareReverse(first, weeks) == 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n\n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n\n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, weeks) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day or week\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, weeks) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, weeks) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear); // Changed from year() to weekyear()\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is weekyear\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, weekyears) == 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if ((compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0)\n            || compareReverse(first, weekyears) == 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // Alter base year for parsing if the first field is a month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField years = DurationFieldType.years().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        \n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        } else if (compareReverse(first, weekyears) >= 0 && compareReverse(first, years) <= 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Computes the parsed datetime by setting the saved fields.\n* This method is idempotent, but it is not thread-safe.\n*\n* @param resetFields false by default, but when true, unsaved field values are cleared\n* @param text optional text being parsed, to be included in any error message\n* @return milliseconds since 1970-01-01T00:00:00Z\n* @throws IllegalArgumentException if any field is out of range\n* @since 1.3\n*/\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testParseLocalDate_weekyear_month_week_2010() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2010(TestDateTimeFormatter.java:428)  expect = new DateTime(2004, 6, 9, 10, 20, 30, 0, UTC);\n \n#Test method 2:\n```java\n    public void testParseLocalDate_weekyear_month_week_2011() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2011-01-03> but was:<2010-01-04>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2011(TestDateTimeFormatter.java:434)  public void testParseDateTime_chrono() {        DateTime expect = null;        expect = new DateTime(2004, 6, 9, 12, 20, 30, 0, PARIS);        assertEquals(expect, g.withChronology(ISO_PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));        expect = new DateTime(2004, 6, 9, 11, 20, 30, 0,LONDON);        assertEquals(expect, g.withChronology(null).parseDateTime(\"2004-06-09T10:20:30Z\"));        expect = new DateTime(2547, 6, 9, 12, 20, 30, 0, BUDDHIST_PARIS);        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime(\"2547-06-09T10:20:30Z\"));        expect = new DateTime(2004, 6, 9, 10, 29, 51, 0, BUDDHIST_PARIS); // zone is +00:09:21 in 1451        assertEquals(expect, g.withChronology(BUDDHIST_PARIS).parseDateTime(\"2004-06-09T10:20:30Z\"));    }\n \n#Test method 3:\n```java\n    public void testParseLocalDate_weekyear_month_week_2012() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2012-01-02> but was:<2011-01-03>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2012(TestDateTimeFormatter.java:440)  assertEquals(expect, g.withChronology(null).parseDateTime(\"2004-06-09T10:20:30Z\"));\n \n#Test method 4:\n```java\n    public void testParseLocalDate_year_month_week_2010() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2010(TestDateTimeFormatter.java:454)\n \n#Test method 5:\n```java\n    public void testParseLocalDate_year_month_week_2011() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2011-01-03> but was:<2010-01-04>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2011(TestDateTimeFormatter.java:460)\n \n#Test method 6:\n```java\n    public void testParseLocalDate_year_month_week_2012() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2012-01-02> but was:<2011-01-03>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2012(TestDateTimeFormatter.java:466)  expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n \n#Test method 7:\n```java\n    public void testParseLocalDate_year_month_week_2016() {\n\n        Chronology chrono = GJChronology.getInstanceUTC();\n\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n\n        assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<2016-01-04> but was:<2014-12-29>\n\tat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2016(TestDateTimeFormatter.java:490)  .toFormatter();\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic DateTimeZone toDateTimeZone(String id, boolean outputID) { if (id == null) { throw new IllegalArgumentException(); } ArrayList<Transition> transitions = new ArrayList<Transition>(); DSTZone tailZone = null; long millis = Long.MIN_VALUE; int saveMillis = 0; int ruleSetCount = iRuleSets.size(); for (int i = 0; i < ruleSetCount; i++) { RuleSet rs = iRuleSets.get(i); Transition next = rs.firstTransition(millis); if (next == null) { continue; } addTransition(transitions, next); millis = next.getMillis(); saveMillis = next.getSaveMillis(); rs = new RuleSet(rs); while ((next = rs.nextTransition(millis, saveMillis)) != null) { if (addTransition(transitions, next)) { if (tailZone != null) { break; } } millis = next.getMillis(); saveMillis = next.getSaveMillis(); if (tailZone == null && i == ruleSetCount - 1) { tailZone = rs.buildTailZone(id); } } millis = rs.getUpperLimit(saveMillis); } if (transitions.size() == 0) { if (tailZone != null) { return tailZone; } return buildFixedZone(id, \\\"UTC\\\", 0, 0); } if (transitions.size() == 1 && tailZone == null) { Transition tr = transitions.get(0); return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); } PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); if (zone.isCachable()) { return CachedDateTimeZone.forZone(zone); } return zone; }\n```\n\n            \n```java\npublic DateTimeZone toDateTimeZone(String id, boolean outputID) { if (id == null) { throw new IllegalArgumentException(); } ArrayList transitions = new ArrayList(); DSTZone tailZone = null; long millis = Long.MIN_VALUE; int saveMillis = 0; int ruleSetCount = iRuleSets.size(); for (int i = 0; i < ruleSetCount; i++) { RuleSet rs = (RuleSet) iRuleSets.get(i); Transition next = rs.firstTransition(millis); if (next == null) { continue; } addTransition(transitions, next); millis = next.getMillis(); saveMillis = next.getSaveMillis(); rs = new RuleSet(rs); while ((next = rs.nextTransition(millis, saveMillis)) != null) { if (addTransition(transitions, next)) { if (tailZone != null) { break; } } millis = next.getMillis(); saveMillis = next.getSaveMillis(); if (tailZone == null && i == ruleSetCount - 1) { tailZone = rs.buildTailZone(id); } } millis = rs.getUpperLimit(saveMillis); } if (transitions.size() == 0) { if (tailZone != null) { return tailZone; } return buildFixedZone(id, \\\"UTC\\\", 0, 0); } if (transitions.size() == 1 && tailZone == null) { Transition tr = (Transition) transitions.get(0); return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset()); } PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone); if (zone.isCachable()) { return CachedDateTimeZone.forZone(zone); } return zone; }\n```\n\n            \n```java\nstatic PrecalculatedZone create(String id, boolean outputID, ArrayList transitions, DSTZone tailZone) { int size = transitions.size(); if (size == 0) { throw new IllegalArgumentException(); } long[] trans = new long[size]; int[] wallOffsets = new int[size]; int[] standardOffsets = new int[size]; String[] nameKeys = new String[size]; Transition last = null; for (int i = 0; i < size; i++) { Transition tr = (Transition) transitions.get(i); if (!tr.isTransitionFrom(last)) { throw new IllegalArgumentException(id); } trans[i] = tr.getMillis(); wallOffsets[i] = tr.getWallOffset(); standardOffsets[i] = tr.getStandardOffset(); nameKeys[i] = tr.getNameKey(); last = tr; } String[] zoneNameData = new String[5]; String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings(); for (int j = 0; j < zoneStrings.length; j++) { String[] set = zoneStrings[j]; if (set != null && set.length == 5 && id.equals(set[0])) { zoneNameData = set; } } for (int i = 0; i < nameKeys.length - 1; i++) { String curNameKey = nameKeys[i]; String nextNameKey = nameKeys[i + 1]; long curOffset = wallOffsets[i]; long nextOffset = wallOffsets[i + 1]; long curStdOffset = standardOffsets[i]; long nextStdOffset = standardOffsets[i + 1]; Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay()); if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) { System.out.println(\\\"Fixing duplicate name key - \\\" + nextNameKey); System.out.println(\\\" - \\\" + new DateTime(trans[i]) + \\\" - \\\" + new DateTime(trans[i + 1])); if (curOffset > nextOffset) { nameKeys[i] = (curNameKey + \\\"-Summer\\\").intern(); } else if (curOffset < nextOffset) { nameKeys[i + 1] = (nextNameKey + \\\"-Summer\\\").intern(); i++; } } } if (tailZone != null) { if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) { System.out.println(\\\"Fixing duplicate recurrent name key - \\\" + tailZone.iStartRecurrence.getNameKey()); if (tailZone.iStartRecurrence.getSaveMillis() > 0) { tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\\\"-Summer\\\"), tailZone.iEndRecurrence); } else { tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\\\"-Summer\\\")); } } } return new PrecalculatedZone((outputID ? id : \\\"\\\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone); }\n```\n\n            \n```java\npublic int doEndTag() throws JspException { if (value == null) { if (var != null) { pageContext.removeAttribute(var, scope); } return EVAL_PAGE; } DateTimeFormatter formatter; if (pattern != null) { formatter = DateTimeFormat.forPattern(pattern); } else if (style != null) { formatter = DateTimeFormat.forStyle(style); } else { formatter = DateTimeFormat.mediumDate(); } Locale locale = this.locale; if (locale == null) { locale = Util.getFormattingLocale(pageContext, this, true, DateFormat.getAvailableLocales()); } if (locale != null) { formatter = formatter.withLocale(locale); } DateTimeZone tz = this.dateTimeZone; if (tz == null) { tz = DateTimeZoneSupport.getDateTimeZone(pageContext, this); } if (tz != null) { formatter = formatter.withZone(tz); } String formatted; if (value instanceof ReadableInstant) { formatted = formatter.print((ReadableInstant) value); } else if (value instanceof ReadablePartial) { formatted = formatter.print((ReadablePartial) value); } else { throw new JspException(\\\"value attribute of format tag must be a ReadableInstant or ReadablePartial,\\\" + \\\" was: \\\" + value.getClass().getName()); } if (var != null) { pageContext.setAttribute(var, formatted, scope); } else { try { pageContext.getOut().print(formatted); } catch (IOException ioe) { throw new JspTagException(ioe.toString(), ioe); } } return EVAL_PAGE; }\n```\n\n            \n```java\npublic int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); if (position >= text.length()) { return mustParse ? ~position : position; } if (iPrefix != null) { position = iPrefix.parse(text, position); if (position >= 0) { mustParse = true; } else { if (!mustParse) { return ~position; } return position; } } int suffixPos = -1; if (iSuffix != null && !mustParse) { suffixPos = iSuffix.scan(text, position); if (suffixPos >= 0) { mustParse = true; } else { if (!mustParse) { return ~suffixPos; } return suffixPos; } } if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { return position; } int limit; if (suffixPos > 0) { limit = Math.min(iMaxParsedDigits, suffixPos - position); } else { limit = Math.min(iMaxParsedDigits, text.length() - position); } int length = 0; int fractPos = -1; boolean hasDigits = false; while (length < limit) { char c = text.charAt(position + length); if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { boolean negative = c == '-'; if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { break; } if (negative) { length++; } else { position++; } limit = Math.min(limit + 1, text.length() - position); continue; } if (c >= '0' && c <= '9') { hasDigits = true; } else { if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { if (fractPos >= 0) { break; } fractPos = position + length + 1; limit = Math.min(limit + 1, text.length() - position); } else { break; } } length++; } if (!hasDigits) { return ~position; } if (suffixPos >= 0 && position + length != suffixPos) { return position; } if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { setFieldValue(period, iFieldType, parseInt(text, position, length)); } else if (fractPos < 0) { setFieldValue(period, SECONDS, parseInt(text, position, length)); setFieldValue(period, MILLIS, 0); } else { int wholeValue = parseInt(text, position, fractPos - position - 1); setFieldValue(period, SECONDS, wholeValue); int fractLen = position + length - fractPos; int fractValue; if (fractLen <= 0) { fractValue = 0; } else { if (fractLen >= 3) { fractValue = parseInt(text, fractPos, 3); } else { fractValue = parseInt(text, fractPos, fractLen); if (fractLen == 1) { fractValue *= 100; } else { fractValue *= 10; } } if (wholeValue < 0) { fractValue = -fractValue; } } setFieldValue(period, MILLIS, fractValue); } position += length; if (position >= 0 && iSuffix != null) { position = iSuffix.parse(text, position); } return position; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // Check if the first field is weekyear, month, or week related to alter the base year\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField years = DurationFieldType.years().getField(iChrono);\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, weekyears) >= 0 && compareReverse(first, months) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n\n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n\n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // Alter base year for parsing if first field is week-based year, month or day\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n\n        if (compareReverse(first, weekyears) >= 0 && compareReverse(first, days) <= 0) {\n            if (savedFields[0].iField.getType() == DateTimeFieldType.weekyear()) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n            }\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n\n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n\n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0 && first != weeks) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        } else if (compareReverse(first, weekyears) >= 0 && compareReverse(first, weeks) <= 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day or week-related fields\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField weekYears = DurationFieldType.weekYears().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if ((compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) ||\n            (compareReverse(first, weekYears) >= 0 && compareReverse(first, weeks) <= 0)) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n\n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n\n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, weeks) <= 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    boolean dateTimeHasDayOfWeekSet = false;\n    for (int i = 0; i < count; i++) {\n        if (savedFields[i].iField.getType() == DateTimeFieldType.weekOfWeekyear()) {\n            dateTimeHasDayOfWeekSet = true;\n            break;\n        }\n    }\n    if (dateTimeHasDayOfWeekSet) {\n        for (int i = 0; i < count; i++) {\n            if (savedFields[i].iField.getType() == DateTimeFieldType.dayOfMonth() || savedFields[i].iField.getType() == DateTimeFieldType.monthOfYear()) {\n                resetFields = true;\n                break;\n            }\n        }\n    }\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weekyears = DurationFieldType.weekyears().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, weekyears) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // fix: alter base year for parsing if first field is month or week\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, weeks) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n    \n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weekyear = DurationFieldType.weekyears().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n        // check if the first field is weekyear\n        if (compareReverse(first, weekyear) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.weekyear(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ],
                [
                    "\npublic long computeMillis(boolean resetFields, String text) {\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month, day, or week\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField weeks = DurationFieldType.weeks().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0 ||\n            compareReverse(first, weeks) == 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    \n    if (iZone == null) {\n        millis -= iOffset;\n    } else {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message =\n                \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalArgumentException(message);\n        }\n    }\n    \n    return millis;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}