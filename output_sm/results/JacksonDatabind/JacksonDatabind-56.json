{
    "JacksonDatabind-56": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* \"Chameleon\" deserializer that works on simple types that are deserialized\n* from a simple String.\n*\n* @since 2.4\n*/\n@Override\n        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n        {\n            switch (_kind) {\n            case STD_FILE:\n                return new File(value);\n            case STD_URL:\n                return new URL(value);\n            case STD_URI:\n                return URI.create(value);\n            case STD_CLASS:\n                try {\n                    return ctxt.findClass(value);\n                } catch (Exception e) {\n                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n                }\n            case STD_JAVA_TYPE:\n                return ctxt.getTypeFactory().constructFromCanonical(value);\n            case STD_CURRENCY:\n                // will throw IAE if unknown:\n                return Currency.getInstance(value);\n            case STD_PATTERN:\n                // will throw IAE (or its subclass) if malformed\n                return Pattern.compile(value);\n            case STD_LOCALE:\n                {\n                    int ix = value.indexOf('_');\n                    if (ix < 0) { // single argument\n                        return new Locale(value);\n                    }\n                    String first = value.substring(0, ix);\n                    value = value.substring(ix+1);\n                    ix = value.indexOf('_');\n                    if (ix < 0) { // two pieces\n                        return new Locale(first, value);\n                    }\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix+1));\n                }\n            case STD_CHARSET:\n                return Charset.forName(value);\n            case STD_TIME_ZONE:\n                return TimeZone.getTimeZone(value);\n            case STD_INET_ADDRESS:\n                return InetAddress.getByName(value);\n            case STD_INET_SOCKET_ADDRESS:\n                if (value.startsWith(\"[\")) {\n                    // bracketed IPv6 (with port number)\n\n                    int i = value.lastIndexOf(']');\n                    if (i == -1) {\n                        throw new InvalidFormatException(ctxt.getParser(),\n                                \"Bracketed IPv6 address must contain closing bracket\",\n                                value, InetSocketAddress.class);\n                    }\n\n                    int j = value.indexOf(':', i);\n                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                    return new InetSocketAddress(value.substring(0, i + 1), port);\n                } else {\n                    int ix = value.indexOf(':');\n                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                        // host:port\n                        int port = Integer.parseInt(value.substring(ix+1));\n                        return new InetSocketAddress(value.substring(0, ix), port);\n                    }\n                    // host or unbracketed IPv6, without port number\n                    return new InetSocketAddress(value, 0);\n                }\n            }\n            throw new IllegalArgumentException();\n        }\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testLocale() throws IOException\n\n    {\n\n        assertEquals(new Locale(\"en\"), MAPPER.readValue(quote(\"en\"), Locale.class));\n\n        assertEquals(new Locale(\"es\", \"ES\"), MAPPER.readValue(quote(\"es_ES\"), Locale.class));\n\n        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"),\n\n                MAPPER.readValue(quote(\"fi_FI_savo\"), Locale.class));\n\n        assertEquals(new Locale(\"en\", \"US\"),\n\n                MAPPER.readValue(quote(\"en-US\"), Locale.class));\n\n\n\n        // [databind#1123]\n\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n\n        assertSame(Locale.ROOT, loc);\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<en_US> but was:<en-us>\n\tat com.fasterxml.jackson.databind.deser.TestJdkTypes.testLocale(TestJdkTypes.java:148)  assertEquals(new Locale(\"en\", \"US\"),                MAPPER.readValue(quote(\"en-US\"), Locale.class));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        return Pattern.compile(value);\n    case STD_LOCALE: {\n        if (value.isEmpty()) {\n            return Locale.ROOT;\n        }\n        int ix = value.indexOf('_');\n        if (ix < 0) {\n            return new Locale(value);\n        }\n        String first = value.substring(0, ix);\n        value = value.substring(ix + 1);\n        ix = value.indexOf('_');\n        if (ix < 0) {\n            return new Locale(first, value);\n        }\n        String second = value.substring(0, ix);\n        return new Locale(first, second, value.substring(ix + 1));\n    }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                int port = Integer.parseInt(value.substring(ix + 1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        // will throw IAE if unknown:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        // will throw IAE (or its subclass) if malformed\n        return Pattern.compile(value);\n    case STD_LOCALE: {\n        if (value.isEmpty()) {\n            return Locale.ROOT;\n        }\n        int ix = value.indexOf('_');\n        if (ix < 0) { // single argument\n            return new Locale(value);\n        }\n        String first = value.substring(0, ix);\n        value = value.substring(ix + 1);\n        ix = value.indexOf('_');\n        if (ix < 0) { // two pieces\n            return new Locale(first, value);\n        }\n        String second = value.substring(0, ix);\n        return new Locale(first, second, value.substring(ix + 1));\n    }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            // bracketed IPv6 (with port number)\n\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                // host:port\n                int port = Integer.parseInt(value.substring(ix + 1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            // host or unbracketed IPv6, without port number\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n{\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        // will throw IAE if unknown:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        // will throw IAE (or its subclass) if malformed\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            if (value.isEmpty()) {\n                return Locale.ROOT;\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) { // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix+1);\n            ix = value.indexOf('_');\n            if (ix < 0) { // two pieces\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix+1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            // bracketed IPv6 (with port number)\n\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                // host:port\n                int port = Integer.parseInt(value.substring(ix+1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            // host or unbracketed IPv6, without port number\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n{\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        // will throw IAE if unknown:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        // will throw IAE (or its subclass) if malformed\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            int ix = value.indexOf('_');\n            if (ix < 0) { // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix+1);\n            ix = value.indexOf('_');\n            if (ix < 0) { // two pieces\n                return new Locale(first, value.toUpperCase());\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second.toUpperCase(), value.substring(ix+1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            // bracketed IPv6 (with port number)\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                // host:port\n                int port = Integer.parseInt(value.substring(ix+1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            // host or unbracketed IPv6, without port number\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n{\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        // will throw IAE if unknown:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        // will throw IAE (or its subclass) if malformed\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            if (value.isEmpty()) {\n                return Locale.ROOT;\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) { // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix+1);\n            ix = value.indexOf('_');\n            if (ix < 0) { // two pieces\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix+1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            // bracketed IPv6 (with port number)\n\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                // host:port\n                int port = Integer.parseInt(value.substring(ix+1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            // host or unbracketed IPv6, without port number\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n{\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        // will throw IAE if unknown:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        // will throw IAE (or its subclass) if malformed\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            int ix = value.indexOf('_');\n            if (ix < 0) {\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix + 1);\n            ix = value.indexOf('_');\n            if (ix < 0) {\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix + 1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            // bracketed IPv6 (with port number)\n\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                // host:port\n                int port = Integer.parseInt(value.substring(ix + 1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            // host or unbracketed IPv6, without port number\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        return Pattern.compile(value);\n    case STD_LOCALE: {\n        if (value.isEmpty()) {\n            return Locale.ROOT;\n        }\n        String[] parts = value.split(\"[-_]\");\n        switch (parts.length) {\n            case 1:\n                return new Locale(parts[0]);\n            case 2:\n                return new Locale(parts[0], parts[1]);\n            case 3:\n                return new Locale(parts[0], parts[1], parts[2]);\n            default:\n                throw new IllegalArgumentException(\"Invalid locale format: \" + value);\n        }\n    }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n            }\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                int port = Integer.parseInt(value.substring(ix + 1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n{\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            if (value.isEmpty()) {\n                return Locale.ROOT;\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) { // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix+1);\n            ix = value.indexOf('_');\n            if (ix < 0) { // two pieces\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix+1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                int port = Integer.parseInt(value.substring(ix+1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        // will throw IAE if unknown:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        // will throw IAE (or its subclass) if malformed\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            if (value.isEmpty()) {\n                return Locale.ROOT;\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) { // single argument\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix+1);\n            ix = value.indexOf('_');\n            if (ix < 0) { // two pieces\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix+1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            // bracketed IPv6 (with port number)\n\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                // host:port\n                int port = Integer.parseInt(value.substring(ix+1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            // host or unbracketed IPv6, without port number\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ],
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n{\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        return Pattern.compile(value);\n    case STD_LOCALE:\n        {\n            if (value.isEmpty()) {\n                return Locale.ROOT;\n            }\n            int ix = value.indexOf('_');\n            if (ix < 0) {\n                return new Locale(value);\n            }\n            String first = value.substring(0, ix);\n            value = value.substring(ix+1);\n            ix = value.indexOf('_');\n            if (ix < 0) {\n                return new Locale(first, value);\n            }\n            String second = value.substring(0, ix);\n            return new Locale(first, second, value.substring(ix+1));\n        }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(),\n                        \"Bracketed IPv6 address must contain closing bracket\",\n                        value, InetSocketAddress.class);\n            }\n\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                int port = Integer.parseInt(value.substring(ix+1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        return Pattern.compile(value);\n    case STD_LOCALE: {\n        if (value.isEmpty()) {\n            return Locale.ROOT;\n        }\n        String[] parts = value.split(\"[-_]\");\n        switch (parts.length) {\n            case 1:\n                return new Locale(parts[0]);\n            case 2:\n                return new Locale(parts[0], parts[1]);\n            case 3:\n                return new Locale(parts[0], parts[1], parts[2]);\n            default:\n                throw new IllegalArgumentException(\"Invalid locale format: \" + value);\n        }\n    }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n            }\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                int port = Integer.parseInt(value.substring(ix + 1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ]
            ],
            "compiler_error_or_timeout": true,
            "plausible_patches": [
                [
                    "\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n    case STD_FILE:\n        return new File(value);\n    case STD_URL:\n        return new URL(value);\n    case STD_URI:\n        return URI.create(value);\n    case STD_CLASS:\n        try {\n            return ctxt.findClass(value);\n        } catch (Exception e) {\n            throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n        }\n    case STD_JAVA_TYPE:\n        return ctxt.getTypeFactory().constructFromCanonical(value);\n    case STD_CURRENCY:\n        return Currency.getInstance(value);\n    case STD_PATTERN:\n        return Pattern.compile(value);\n    case STD_LOCALE: {\n        if (value.isEmpty()) {\n            return Locale.ROOT;\n        }\n        String[] parts = value.split(\"[-_]\");\n        switch (parts.length) {\n            case 1:\n                return new Locale(parts[0]);\n            case 2:\n                return new Locale(parts[0], parts[1]);\n            case 3:\n                return new Locale(parts[0], parts[1], parts[2]);\n            default:\n                throw new IllegalArgumentException(\"Invalid locale format: \" + value);\n        }\n    }\n    case STD_CHARSET:\n        return Charset.forName(value);\n    case STD_TIME_ZONE:\n        return TimeZone.getTimeZone(value);\n    case STD_INET_ADDRESS:\n        return InetAddress.getByName(value);\n    case STD_INET_SOCKET_ADDRESS:\n        if (value.startsWith(\"[\")) {\n            int i = value.lastIndexOf(']');\n            if (i == -1) {\n                throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n            }\n            int j = value.indexOf(':', i);\n            int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n            return new InetSocketAddress(value.substring(0, i + 1), port);\n        } else {\n            int ix = value.indexOf(':');\n            if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                int port = Integer.parseInt(value.substring(ix + 1));\n                return new InetSocketAddress(value.substring(0, ix), port);\n            }\n            return new InetSocketAddress(value, 0);\n        }\n    }\n    throw new IllegalArgumentException();\n}\n"
                ]
            ]
        }
    }
}