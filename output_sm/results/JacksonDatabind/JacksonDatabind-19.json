{
    "JacksonDatabind-19": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* This method deals with parameterized types, that is,\n* first class generic classes.\n*/\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n/* First: what is the actual base type? One odd thing\n* is that 'getRawType' returns Type, not Class<?> as\n* one might expect. But let's assume it is always of\n* type Class: if not, need to add more code to resolve\n* it to Class.\n*/\nClass<?> rawType = (Class<?>) type.getRawType();\nType[] args = type.getActualTypeArguments();\nint paramCount = (args == null) ? 0 : args.length;\n\nJavaType[] pt;\n\nif (paramCount == 0) {\npt = NO_TYPES;\n} else {\npt = new JavaType[paramCount];\nfor (int i = 0; i < paramCount; ++i) {\npt[i] = _constructType(args[i], context);\n}\n}\n\n// Ok: Map or Collection?\nif (Map.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, rawType, pt);\nJavaType[] mapParams = findTypeParameters(subtype, Map.class);\nif (mapParams.length != 2) {\nthrow new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n}\nreturn MapType.construct(rawType, mapParams[0], mapParams[1]);\n}\nif (Collection.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, rawType, pt);\nJavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\nif (collectionParams.length != 1) {\nthrow new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n}\nreturn CollectionType.construct(rawType, collectionParams[0]);\n}\n// 28-Apr-2015, tatu: New class of types, referential...\nif (AtomicReference.class.isAssignableFrom(rawType)) {\nJavaType rt = null;\n\nif (rawType == AtomicReference.class) {\nif (paramCount == 1) {\nrt = pt[0];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\nif (pts != null && pts.length != 1) {\nrt = pts[0];\n}\n}\nreturn constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n}\nif (Map.Entry.class.isAssignableFrom(rawType)) {\nJavaType kt = null, vt = null;\n\nif (rawType == Map.Entry.class) {\nif (paramCount == 2) {\nkt = pt[0];\nvt = pt[1];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\nif (pts != null && pts.length != 2) {\nkt = pts[0];\nvt = pts[1];\n}\n}\nreturn constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n(kt == null) ? unknownType() : kt,\n(vt == null) ? unknownType() : vt });\n}\n\nif (paramCount == 0) { // no generics\nreturn new SimpleType(rawType);\n}\nreturn constructSimpleType(rawType, pt);\n}\n\nprotected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n{\nJavaType compType = _constructType(type.getGenericComponentType(), context);\nreturn ArrayType.construct(compType, null, null);\n}\n\nprotected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n{\nfinal String name = type.getName();\n// 19-Mar-2015: Without context, all we can check are bounds.\nif (context == null) {\n// And to prevent infinite loops, now need this:\ncontext = new TypeBindings(this, (Class<?>) null);\n} else {\n// Ok: here's where context might come in handy!\n/* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n*   unresolved type variables to handle some cases where bounds\n*   are enough. Let's hope it does not hide real fail cases.\n*/\nJavaType actualType = context.findType(name, false);\nif (actualType != null) {\nreturn actualType;\n}\n}\n\n/* 29-Jan-2010, tatu: We used to throw exception here, if type was\n*   bound: but the problem is that this can occur for generic \"base\"\n*   method, overridden by sub-class. If so, we will want to ignore\n*   current type (for method) since it will be masked.\n*/\nType[] bounds = type.getBounds();\n\n// With type variables we must use bound information.\n// Theoretically this gets tricky, as there may be multiple\n// bounds (\"... extends A & B\"); and optimally we might\n// want to choose the best match. Also, bounds are optional;\n// but here we are lucky in that implicit \"Object\" is\n// added as bounds if so.\n// Either way let's just use the first bound, for now, and\n// worry about better match later on if there is need.\n\n/* 29-Jan-2010, tatu: One more problem are recursive types\n*   (T extends Comparable<T>). Need to add \"placeholder\"\n*   for resolution to catch those.\n*/\ncontext._addPlaceholder(name);\nreturn _constructType(bounds[0], context);\n}\n\nprotected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n{\n/* Similar to challenges with TypeVariable, we may have\n* multiple upper bounds. But it is also possible that if\n* upper bound defaults to Object, we might want to consider\n* lower bounds instead.\n*\n* For now, we won't try anything more advanced; above is\n* just for future reference.\n*/\nprivate JavaType _mapType(Class<?> rawClass)\n{\n    // 28-May-2015, tatu: Properties are special, as per [databind#810]\n    JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n    // ok to have no types (\"raw\")\n    if (typeParams == null) {\n        return MapType.construct(rawClass, _unknownType(), _unknownType());\n    }\n    // but exactly 2 types if any found\n    if (typeParams.length != 2) {\n        throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n    }\n    return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testMapToProperties() throws Exception\n\n    {\n\n        Bean bean = new Bean();\n\n        bean.A = 129;\n\n        bean.B = \"13\";\n\n        Properties props = MAPPER.convertValue(bean, Properties.class);\n\n\n\n        assertEquals(2, props.size());\n\n\n\n        assertEquals(\"13\", props.getProperty(\"B\"));\n\n        // should coercce non-Strings to Strings\n\n        assertEquals(\"129\", props.getProperty(\"A\"));\n\n    }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<129> but was:<null>\n\tat com.fasterxml.jackson.databind.convert.TestMapConversions.testMapToProperties(TestMapConversions.java:113)  assertEquals(\"129\", props.getProperty(\"A\"));\n \n#Test method 2:\n```java\n    public void testReadProperties() throws Exception\n\n    {\n\n        Properties props = MAPPER.readValue(aposToQuotes(\"{'a':'foo', 'b':123, 'c':true}\"),\n\n                Properties.class);\n\n        assertEquals(3, props.size());\n\n        assertEquals(\"foo\", props.getProperty(\"a\"));\n\n        assertEquals(\"123\", props.getProperty(\"b\"));\n\n        assertEquals(\"true\", props.getProperty(\"c\"));\n\n    }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<123> but was:<null>\n\tat com.fasterxml.jackson.databind.deser.TestMapDeserialization.testReadProperties(TestMapDeserialization.java:574)  assertEquals(\"123\", props.getProperty(\"b\"));\n \n#Test method 3:\n```java\n    public void testProperties()\n\n    {\n\n        TypeFactory tf = TypeFactory.defaultInstance();\n\n        JavaType t = tf.constructType(Properties.class);\n\n        assertEquals(MapType.class, t.getClass());\n\n        assertSame(Properties.class, t.getRawClass());\n\n\n\n        // so far so good. But how about parameterization?\n\n        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n\n        assertSame(String.class, ((MapType) t).getContentType().getRawClass());\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected same:<class java.lang.String> was not:<class java.lang.Object>\n\tat com.fasterxml.jackson.databind.type.TestTypeFactory.testProperties(TestTypeFactory.java:185)  assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n\n        // Special handling for Properties: key and content types are forced to String\n        if (Properties.class.isAssignableFrom(rawType)) {\n            return MapType.construct(rawType, CORE_TYPE_STRING, CORE_TYPE_STRING);\n        }\n\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        if (Properties.class.isAssignableFrom(rawType)) {\n            return MapType.construct(rawType, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(String.class));\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        if (Properties.class.isAssignableFrom(rawType)) {\n            return MapType.construct(rawType, CORE_TYPE_STRING, CORE_TYPE_STRING);\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (Properties.class.isAssignableFrom(rawType)) {\n        return MapType.construct(rawType, constructType(String.class), constructType(String.class));\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context) {\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n    }\n\n    if (Properties.class.isAssignableFrom(rawType)) {\n        return MapType.construct(rawType, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(String.class));\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    // Ok: Map or Collection?\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (Properties.class.isAssignableFrom(rawType)) {\n        return MapType.construct(rawType, _unknownType(), _unknownType());\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Properties.class.isAssignableFrom(rawType)) {\n        return MapType.construct(rawType, CORE_TYPE_STRING, CORE_TYPE_STRING);\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[]{\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt\n        });\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    // Ok: Map or Collection?\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) { // no generics\n        if (Properties.class.isAssignableFrom(rawType)) {\n            return MapType.construct(rawType, _unknownType(String.class), _unknownType(String.class));\n        }\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n\nprivate JavaType _unknownType(Class<?> type) {\n    return new SimpleType(type);\n}\n"
                ]
            ],
            "compiler_error": true,
            "evaluation_done": true
        },
        "2": {
            "compiler_error": true,
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* This method deals with parameterized types, that is,\n* first class generic classes.\n*/\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n/* First: what is the actual base type? One odd thing\n* is that 'getRawType' returns Type, not Class<?> as\n* one might expect. But let's assume it is always of\n* type Class: if not, need to add more code to resolve\n* it to Class.\n*/\nClass<?> rawType = (Class<?>) type.getRawType();\nType[] args = type.getActualTypeArguments();\nint paramCount = (args == null) ? 0 : args.length;\n\nJavaType[] pt;\n\nif (paramCount == 0) {\npt = NO_TYPES;\n} else {\npt = new JavaType[paramCount];\nfor (int i = 0; i < paramCount; ++i) {\npt[i] = _constructType(args[i], context);\n}\n}\n\n// Ok: Map or Collection?\nif (Map.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, rawType, pt);\nJavaType[] mapParams = findTypeParameters(subtype, Map.class);\nif (mapParams.length != 2) {\nthrow new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n}\nreturn MapType.construct(rawType, mapParams[0], mapParams[1]);\n}\nif (Collection.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, rawType, pt);\nJavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\nif (collectionParams.length != 1) {\nthrow new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n}\nreturn CollectionType.construct(rawType, collectionParams[0]);\n}\n// 28-Apr-2015, tatu: New class of types, referential...\nif (AtomicReference.class.isAssignableFrom(rawType)) {\nJavaType rt = null;\n\nif (rawType == AtomicReference.class) {\nif (paramCount == 1) {\nrt = pt[0];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\nif (pts != null && pts.length != 1) {\nrt = pts[0];\n}\n}\nreturn constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n}\nif (Map.Entry.class.isAssignableFrom(rawType)) {\nJavaType kt = null, vt = null;\n\nif (rawType == Map.Entry.class) {\nif (paramCount == 2) {\nkt = pt[0];\nvt = pt[1];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\nif (pts != null && pts.length != 2) {\nkt = pts[0];\nvt = pts[1];\n}\n}\nreturn constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n(kt == null) ? unknownType() : kt,\n(vt == null) ? unknownType() : vt });\n}\n\nif (paramCount == 0) { // no generics\nreturn new SimpleType(rawType);\n}\nreturn constructSimpleType(rawType, pt);\n}\n\nprotected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n{\nJavaType compType = _constructType(type.getGenericComponentType(), context);\nreturn ArrayType.construct(compType, null, null);\n}\n\nprotected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n{\nfinal String name = type.getName();\n// 19-Mar-2015: Without context, all we can check are bounds.\nif (context == null) {\n// And to prevent infinite loops, now need this:\ncontext = new TypeBindings(this, (Class<?>) null);\n} else {\n// Ok: here's where context might come in handy!\n/* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n*   unresolved type variables to handle some cases where bounds\n*   are enough. Let's hope it does not hide real fail cases.\n*/\nJavaType actualType = context.findType(name, false);\nif (actualType != null) {\nreturn actualType;\n}\n}\n\n/* 29-Jan-2010, tatu: We used to throw exception here, if type was\n*   bound: but the problem is that this can occur for generic \"base\"\n*   method, overridden by sub-class. If so, we will want to ignore\n*   current type (for method) since it will be masked.\n*/\nType[] bounds = type.getBounds();\n\n// With type variables we must use bound information.\n// Theoretically this gets tricky, as there may be multiple\n// bounds (\"... extends A & B\"); and optimally we might\n// want to choose the best match. Also, bounds are optional;\n// but here we are lucky in that implicit \"Object\" is\n// added as bounds if so.\n// Either way let's just use the first bound, for now, and\n// worry about better match later on if there is need.\n\n/* 29-Jan-2010, tatu: One more problem are recursive types\n*   (T extends Comparable<T>). Need to add \"placeholder\"\n*   for resolution to catch those.\n*/\ncontext._addPlaceholder(name);\nreturn _constructType(bounds[0], context);\n}\n\nprotected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n{\n/* Similar to challenges with TypeVariable, we may have\n* multiple upper bounds. But it is also possible that if\n* upper bound defaults to Object, we might want to consider\n* lower bounds instead.\n*\n* For now, we won't try anything more advanced; above is\n* just for future reference.\n*/\nprivate JavaType _mapType(Class<?> rawClass)\n{\n    // 28-May-2015, tatu: Properties are special, as per [databind#810]\n    JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n    // ok to have no types (\"raw\")\n    if (typeParams == null) {\n        return MapType.construct(rawClass, _unknownType(), _unknownType());\n    }\n    // but exactly 2 types if any found\n    if (typeParams.length != 2) {\n        throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n    }\n    return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testMapToProperties() throws Exception\n\n    {\n\n        Bean bean = new Bean();\n\n        bean.A = 129;\n\n        bean.B = \"13\";\n\n        Properties props = MAPPER.convertValue(bean, Properties.class);\n\n\n\n        assertEquals(2, props.size());\n\n\n\n        assertEquals(\"13\", props.getProperty(\"B\"));\n\n        // should coercce non-Strings to Strings\n\n        assertEquals(\"129\", props.getProperty(\"A\"));\n\n    }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<129> but was:<null>\n\tat com.fasterxml.jackson.databind.convert.TestMapConversions.testMapToProperties(TestMapConversions.java:113)  assertEquals(\"129\", props.getProperty(\"A\"));\n \n#Test method 2:\n```java\n    public void testReadProperties() throws Exception\n\n    {\n\n        Properties props = MAPPER.readValue(aposToQuotes(\"{'a':'foo', 'b':123, 'c':true}\"),\n\n                Properties.class);\n\n        assertEquals(3, props.size());\n\n        assertEquals(\"foo\", props.getProperty(\"a\"));\n\n        assertEquals(\"123\", props.getProperty(\"b\"));\n\n        assertEquals(\"true\", props.getProperty(\"c\"));\n\n    }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<123> but was:<null>\n\tat com.fasterxml.jackson.databind.deser.TestMapDeserialization.testReadProperties(TestMapDeserialization.java:574)  assertEquals(\"123\", props.getProperty(\"b\"));\n \n#Test method 3:\n```java\n    public void testProperties()\n\n    {\n\n        TypeFactory tf = TypeFactory.defaultInstance();\n\n        JavaType t = tf.constructType(Properties.class);\n\n        assertEquals(MapType.class, t.getClass());\n\n        assertSame(Properties.class, t.getRawClass());\n\n\n\n        // so far so good. But how about parameterization?\n\n        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n\n        assertSame(String.class, ((MapType) t).getContentType().getRawClass());\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected same:<class java.lang.String> was not:<class java.lang.Object>\n\tat com.fasterxml.jackson.databind.type.TestTypeFactory.testProperties(TestTypeFactory.java:185)  assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nprotected Object getDefaultBean() { if (_defaultBean == null) { _defaultBean = _beanDesc.instantiateBean(_config.canOverrideAccessModifiers()); if (_defaultBean == null) { Class<?> cls = _beanDesc.getClassInfo().getAnnotated(); throw new IllegalArgumentException(\\\"Class \\\" + cls.getName() + \\\" has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation\\\"); } } return _defaultBean; }\n```\n\n            \n```java\npublic void testSimpleClassAsProperty() throws Exception { Map<String, Object> result = writeAndMap(MAPPER, new Cat(\\\"Beelzebub\\\", \\\"tabby\\\")); assertEquals(3, result.size()); assertEquals(\\\"Beelzebub\\\", result.get(\\\"name\\\")); assertEquals(\\\"tabby\\\", result.get(\\\"furColor\\\")); String classProp = Id.CLASS.getDefaultPropertyName(); assertEquals(Cat.class.getName(), result.get(classProp)); }\n```\n\n            \n```java\n@Override public Object findInjectableValue(Object valueId, DeserializationContext ctxt, BeanProperty forProperty, Object beanInstance) { if (!(valueId instanceof String)) { String type = (valueId == null) ? \\\"[null]\\\" : valueId.getClass().getName(); throw new IllegalArgumentException(\\\"Unrecognized inject value id type (\\\" + type + \\\"), expecting String\\\"); } String key = (String) valueId; Object ob = _values.get(key); if (ob == null && !_values.containsKey(key)) { throw new IllegalArgumentException(\\\"No injectable id with value '\\\" + key + \\\"' found (for property '\\\" + forProperty.getName() + \\\"')\\\"); } return ob; }\n```\n\n            \n```java\nprotected String getAndVerifyText(JsonParser jp) throws IOException, JsonParseException { int actLen = jp.getTextLength(); char[] ch = jp.getTextCharacters(); String str2 = new String(ch, jp.getTextOffset(), actLen); String str = jp.getText(); if (str.length() != actLen) { fail(\\\"Internal problem (jp.token == \\\" + jp.getCurrentToken() + \\\"): jp.getText().length() ['\\\" + str + \\\"'] == \\\" + str.length() + \\\"; jp.getTextLength() == \\\" + actLen); } assertEquals(\\\"String access via getText(), getTextXxx() must be the same\\\", str, str2); return str; }\n```\n\n            \n```java\npublic void testPrivateCtor() throws Exception { ObjectMapper m = new ObjectMapper(); PrivateBean bean = m.readValue(\\\"\\\\\"abc\\\\\"\\\", PrivateBean.class); assertEquals(\\\"abc\\\", bean.a); m = new ObjectMapper(); VisibilityChecker<?> vc = m.getVisibilityChecker(); vc = vc.withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY); m.setVisibility(vc); try { m.readValue(\\\"\\\\\"abc\\\\\"\\\", PrivateBean.class); fail(\\\"Expected exception for missing constructor\\\"); } catch (JsonProcessingException e) { verifyException(e, \\\"no single-String constructor/factory\\\"); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context) {\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    // Special handling for Properties class\n    if (Properties.class == rawType) {\n        return MapType.construct(rawType, CoreType.lookup(JavaType.class, String.class), CoreType.lookup(JavaType.class, String.class));\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, rawType, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, rawType, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[]{\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt\n        });\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (rawType == Properties.class) {\n        return MapType.construct(rawType, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(String.class));\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n    \n    JavaType[] pt;\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n    \n    if (Map.class.isAssignableFrom(rawType) || Properties.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, rawType, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) { \n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (Properties.class.isAssignableFrom(rawType)) {\n        return MapType.construct(rawType, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(String.class));\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n    \n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n        \n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n        \n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n    \n    if (paramCount == 0) {\n        if (Properties.class.isAssignableFrom(rawType)) {\n            return MapType.construct(rawType, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(String.class));\n        }\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[]{\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt});\n    }\n\n    if (Properties.class.isAssignableFrom(rawType)) {\n        return MapType.construct(rawType, SimpleType.constructUnsafe(String.class), SimpleType.constructUnsafe(String.class));\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    // Ok: Map or Collection?\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Map.class, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, Collection.class, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n\n    JavaType[] pt;\n\n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n\n    if (Map.class.isAssignableFrom(rawType) || Properties.class == rawType) {\n        JavaType subtype = constructSimpleType(rawType, rawType, pt);\n        JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n        if (mapParams == null || mapParams.length != 2) {\n            mapParams = new JavaType[]{_unknownType(), _unknownType()};\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, rawType, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams == null || collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName());\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length == 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length == 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[]{\n                (kt == null) ? unknownType() : kt,\n                (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) {\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n{\n    Class<?> rawType = (Class<?>) type.getRawType();\n    Type[] args = type.getActualTypeArguments();\n    int paramCount = (args == null) ? 0 : args.length;\n    \n    JavaType[] pt;\n    \n    if (paramCount == 0) {\n        pt = NO_TYPES;\n    } else {\n        pt = new JavaType[paramCount];\n        for (int i = 0; i < paramCount; ++i) {\n            pt[i] = _constructType(args[i], context);\n        }\n    }\n    \n    // Ok: Map or Collection?\n    if (Map.class.isAssignableFrom(rawType)) {\n        JavaType[] mapParams = pt;\n        if (Properties.class.isAssignableFrom(rawType)) {\n            mapParams = new JavaType[] {TypeFactory.defaultInstance().constructType(String.class), TypeFactory.defaultInstance().constructType(String.class)};\n        } else {\n            JavaType subtype = constructSimpleType(rawType, rawType, pt);\n            mapParams = findTypeParameters(subtype, Map.class);\n        }\n        if (mapParams.length != 2) {\n            throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \" + rawType.getName() + \" (found \" + mapParams.length + \")\");\n        }\n        return MapType.construct(rawType, mapParams[0], mapParams[1]);\n    }\n    if (Collection.class.isAssignableFrom(rawType)) {\n        JavaType subtype = constructSimpleType(rawType, rawType, pt);\n        JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n        if (collectionParams.length != 1) {\n            throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \" + rawType.getName() + \" (found \" + collectionParams.length + \")\");\n        }\n        return CollectionType.construct(rawType, collectionParams[0]);\n    }\n    if (AtomicReference.class.isAssignableFrom(rawType)) {\n        JavaType rt = null;\n\n        if (rawType == AtomicReference.class) {\n            if (paramCount == 1) {\n                rt = pt[0];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\n            if (pts != null && pts.length != 1) {\n                rt = pts[0];\n            }\n        }\n        return constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n    }\n    if (Map.Entry.class.isAssignableFrom(rawType)) {\n        JavaType kt = null, vt = null;\n\n        if (rawType == Map.Entry.class) {\n            if (paramCount == 2) {\n                kt = pt[0];\n                vt = pt[1];\n            }\n        } else {\n            JavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\n            if (pts != null && pts.length != 2) {\n                kt = pts[0];\n                vt = pts[1];\n            }\n        }\n        return constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n            (kt == null) ? unknownType() : kt,\n            (vt == null) ? unknownType() : vt });\n    }\n\n    if (paramCount == 0) { // no generics\n        return new SimpleType(rawType);\n    }\n    return constructSimpleType(rawType, pt);\n}\n"
                ],
                [
                    "\nprotected JavaType _fromParamType(ParameterizedType type, TypeBindings context) {\n/* First: what is the actual base type? One odd thing\n* is that 'getRawType' returns Type, not Class<?> as\n* one might expect. But let's assume it is always of\n* type Class: if not, need to add more code to resolve\n* it to Class.\n*/\nClass<?> rawType = (Class<?>) type.getRawType();\nType[] args = type.getActualTypeArguments();\nint paramCount = (args == null) ? 0 : args.length;\n\nJavaType[] pt;\n\nif (paramCount == 0) {\n    pt = NO_TYPES;\n} else {\n    pt = new JavaType[paramCount];\n    for (int i = 0; i < paramCount; ++i) {\n        pt[i] = _constructType(args[i], context);\n    }\n}\n\n// Ok: Map or Collection?\nif (Map.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Map.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, Map.class, pt);\nJavaType[] mapParams = findTypeParameters(subtype, Map.class);\nif (mapParams.length != 2) {\nthrow new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n}\nreturn MapType.construct(rawType, mapParams[0], mapParams[1]);\n}\nif (Collection.class.isAssignableFrom(rawType)) {\n// 19-Mar-2015, tatu: Looks like 2nd arg ought to be Collection.class, but that causes fails\nJavaType subtype = constructSimpleType(rawType, Collection.class, pt);\nJavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\nif (collectionParams.length != 1) {\nthrow new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n}\nreturn CollectionType.construct(rawType, collectionParams[0]);\n}\n// 28-Apr-2015, tatu: New class of types, referential...\nif (AtomicReference.class.isAssignableFrom(rawType)) {\nJavaType rt = null;\n\nif (rawType == AtomicReference.class) {\nif (paramCount == 1) {\nrt = pt[0];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, AtomicReference.class);\nif (pts != null && pts.length == 1) {\nrt = pts[0];\n}\n}\nreturn constructReferenceType(rawType, (rt == null) ? unknownType() : rt);\n}\nif (Map.Entry.class.isAssignableFrom(rawType)) {\nJavaType kt = null, vt = null;\n\nif (rawType == Map.Entry.class) {\nif (paramCount == 2) {\nkt = pt[0];\nvt = pt[1];\n}\n} else {\nJavaType[] pts = findTypeParameters(rawType, Map.Entry.class);\nif (pts != null && pts.length == 2) {\nkt = pts[0];\nvt = pts[1];\n}\n}\nreturn constructSimpleType(rawType, Map.Entry.class, new JavaType[] {\n(kt == null) ? unknownType() : kt,\n(vt == null) ? unknownType() : vt });\n}\n\nif (paramCount == 0) { // no generics\nreturn new SimpleType(rawType);\n}\nreturn constructSimpleType(rawType, pt);\n}\n"
                ]
            ],
            "regeneration": true,
            "compiler_error_or_timeout": true,
            "evaluation_done": true,
            "second_check": true
        },
        "iteration_done": true
    }
}