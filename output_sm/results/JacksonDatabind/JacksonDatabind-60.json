{
    "JacksonDatabind-60": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// let's try to indicate the path best we can...\n@Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer0) throws IOException\n    {\n        // Regardless of other parts, first need to find value to serialize:\n        Object value = null;\n        try {\n            value = _accessorMethod.getValue(bean);\n            // and if we got null, can also just write it directly\n            if (value == null) {\n                provider.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) { // no serializer yet? Need to fetch\n//                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n                ser = provider.findValueSerializer(value.getClass(), _property);\n            } else {\n                /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n                 *    this (note: type is for the wrapper type, not enclosed value!)\n                 */\n                if (_forceTypeInformation) {\n                    typeSer0.writeTypePrefixForScalar(bean, gen);\n                    ser.serialize(value, gen, provider);\n                    typeSer0.writeTypeSuffixForScalar(bean, gen);\n                    return;\n                }\n            }\n            // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n            //    to use different Object for type id (logical type) and actual serialization\n            //    (delegat type).\n            ser.serializeWithType(value, gen, provider, typeSer0);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            // Need to unwrap this specific type, to see infinite recursion...\n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            // Errors shouldn't be wrapped (and often can't, as well)\n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            // let's try to indicate the path best we can...\n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testWithCreatorAndJsonValue() throws Exception\n\n    {\n\n        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        mapper.enableDefaultTyping();\n\n        String json = mapper.writeValueAsString(new Bean1385Wrapper(\n\n                new Bean1385(BYTES)\n\n        ));\n\n        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);\n\n        assertNotNull(result);\n\n        assertNotNull(result.value);\n\n        assertEquals(Bean1385.class, result.value.getClass());\n\n        Bean1385 b = (Bean1385) result.value;\n\n        Assert.assertArrayEquals(BYTES, b.raw);\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators$Bean1385> but was:<class [B>\n\tat com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators.testWithCreatorAndJsonValue(TestDefaultWithCreators.java:94)  assertEquals(Bean1385.class, result.value.getClass());\n \n#Test method 2:\n```java\n    public void testWithAsValue() throws Exception\n\n    {\n\n        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));\n\n        String json = MAPPER.writeValueAsString(input);\n\n        assertNotNull(json);\n\n        assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);\n\n\n\n        // and get it back too:\n\n        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n\n        assertNotNull(result);\n\n        assertNotNull(result.value);\n\n        assertEquals(AsValueThingy.class, result.value.getClass());\n\n        assertEquals(12345L, ((AsValueThingy) result.value).rawDate);\n\n    }\n\n```\n#Error message: junit.framework.ComparisonFailure: expected:<...alue\":12345,\"type\":\"[thingy]\"}> but was:<...alue\":12345,\"type\":\"[date]\"}>\n\tat com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdTest.testWithAsValue(ExternalTypeIdTest.java:476)  assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegat type).\n        ser.serializeWithType(value, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\n    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n            TypeSerializer typeSer0) throws IOException\n    {\n        // Regardless of other parts, first need to find value to serialize:\n        Object value = null;\n        try {\n            value = _accessorMethod.getValue(bean);\n            // and if we got null, can also just write it directly\n            if (value == null) {\n                provider.defaultSerializeNull(gen);\n                return;\n            }\n            JsonSerializer<Object> ser = _valueSerializer;\n            if (ser == null) { // no serializer yet? Need to fetch\n                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n            } else {\n                if (_forceTypeInformation) {\n                    typeSer0.writeTypePrefixForScalar(bean, gen);\n                    ser.serialize(value, gen, provider);\n                    typeSer0.writeTypeSuffixForScalar(bean, gen);\n                    return;\n                }\n            }\n            ser.serializeWithType(value, gen, provider, typeSer0);\n        } catch (IOException ioe) {\n            throw ioe;\n        } catch (Exception e) {\n            Throwable t = e;\n            while (t instanceof InvocationTargetException && t.getCause() != null) {\n                t = t.getCause();\n            }\n            if (t instanceof Error) {\n                throw (Error) t;\n            }\n            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n        }\n    }\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegat type).\n        ser.serializeWithType(value, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegate type).\n        ser.serializeWithType(value, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        ser.serializeWithType(value, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegat type).\n        typeSer0.writeTypePrefixForScalar(bean, gen);\n        ser.serialize(value, gen, provider);\n        typeSer0.writeTypeSuffixForScalar(bean, gen);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegate type).\n        ser.serializeWithType(value, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        }\n        /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n         *    this (note: type is for the wrapper type, not enclosed value!)\n         */\n        if (_forceTypeInformation) {\n            typeSer0.writeTypePrefixForScalar(bean, gen);\n            ser.serialize(value, gen, provider);\n            typeSer0.writeTypeSuffixForScalar(bean, gen);\n            return;\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegate type).\n        ser.serializeWithType(value, gen, provider, typeSer0);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegate type).\n        if (_valueTypeSerializer != null) {\n            ser.serializeWithType(value, gen, provider, _valueTypeSerializer);\n        } else {\n            ser.serializeWithType(value, gen, provider, typeSer0);\n        }\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ],
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        ser.serialize(value, gen, provider);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegat type).\n        typeSer0.writeTypePrefixForScalar(bean, gen);\n        ser.serialize(value, gen, provider);\n        typeSer0.writeTypeSuffixForScalar(bean, gen);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ]
            ],
            "compiler_error_or_timeout": true,
            "plausible_patches": [
                [
                    "\n@Override\npublic void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n        TypeSerializer typeSer0) throws IOException\n{\n    // Regardless of other parts, first need to find value to serialize:\n    Object value = null;\n    try {\n        value = _accessorMethod.getValue(bean);\n        // and if we got null, can also just write it directly\n        if (value == null) {\n            provider.defaultSerializeNull(gen);\n            return;\n        }\n        JsonSerializer<Object> ser = _valueSerializer;\n        if (ser == null) { // no serializer yet? Need to fetch\n            ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n        } else {\n            /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n             *    this (note: type is for the wrapper type, not enclosed value!)\n             */\n            if (_forceTypeInformation) {\n                typeSer0.writeTypePrefixForScalar(bean, gen);\n                ser.serialize(value, gen, provider);\n                typeSer0.writeTypeSuffixForScalar(bean, gen);\n                return;\n            }\n        }\n        // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n        //    to use different Object for type id (logical type) and actual serialization\n        //    (delegat type).\n        typeSer0.writeTypePrefixForScalar(bean, gen);\n        ser.serialize(value, gen, provider);\n        typeSer0.writeTypeSuffixForScalar(bean, gen);\n    } catch (IOException ioe) {\n        throw ioe;\n    } catch (Exception e) {\n        Throwable t = e;\n        // Need to unwrap this specific type, to see infinite recursion...\n        while (t instanceof InvocationTargetException && t.getCause() != null) {\n            t = t.getCause();\n        }\n        // Errors shouldn't be wrapped (and often can't, as well)\n        if (t instanceof Error) {\n            throw (Error) t;\n        }\n        // let's try to indicate the path best we can...\n        throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n    }\n}\n"
                ]
            ]
        }
    }
}