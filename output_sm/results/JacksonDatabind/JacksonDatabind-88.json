{
    "JacksonDatabind-88": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = tf.constructFromCanonical(id);\n            // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testNestedTypeCheck1735() throws Exception\n\n    {\n\n        try {\n\n            MAPPER.readValue(aposToQuotes(\n\n\"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}\"),\n\n                    Wrapper1735.class);\n\n            fail(\"Should not pass\");\n\n        } catch (JsonMappingException e) {\n\n            verifyException(e, \"not subtype of\");\n\n        }\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: Expected an exception with one of substrings ([not subtype of]): got one (of type com.fasterxml.jackson.databind.JsonMappingException) with message \"Problem deserializing property 'w' (expected type: [simple type, class com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735]; actual type: java.util.HashMap), problem: Can not set com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735 field com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Wrapper1735.w to java.util.HashMap\n\tat com.fasterxml.jackson.databind.BaseTest.verifyException(BaseTest.java:367)  fail(\"Expected an exception with one of substrings (\"                +Arrays.asList(matches)+\"): got one (of type \"+e.getClass().getName()                +\") with message \\\"\"+msg+\"\\\"\");\n\tat com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test.testNestedTypeCheck1735(GenericTypeId1735Test.java:61)  verifyException(e, \"not subtype of\");\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \" + _baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    JavaType t;\n    if (id.indexOf('<') > 0) {\n        t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \"+_baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.hasRawClass(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \"+_baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.hasRawClass(_baseType.getRawClass())) {\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"not subtype of\");\n            }\n            return null;\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = tf.constructFromCanonical(id);\n        // Ensure that the constructed type is compatible with the base type\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"not subtype of\");\n            }\n            return null;\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Type id '\"+id+\"' is not subtype of base type\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    JavaType baseType = _baseType; // Store base type locally for use later\n\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        // Ensure assignment compatibility before returning\n        if (!baseType.isTypeOrSubTypeOf(t.getRawClass())) {\n            throw new IllegalArgumentException(\"Type id '\"+id+\"' not subtype of base type\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n\n    // Ensure assignment compatibility before returning\n    if (!baseType.isTypeOrSubTypeOf(cls)) {\n        throw new IllegalArgumentException(\"Type id '\"+id+\"' not subtype of base type\");\n    }\n    return tf.constructSpecializedType(baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (not subtype of \"+_baseType+\")\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!_baseType.isTypeOrSuperTypeOf(t.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"': not subtype of \"+_baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    JavaType baseType = _baseType; // Use _baseType for assignment compatibility check\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // Check for assignment compatibility\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \"+baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \" + _baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    JavaType t;\n    if (id.indexOf('<') > 0) {\n        t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \"+_baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = tf.constructFromCanonical(id);\n        // Ensure that the constructed type is compatible with the base type\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"not subtype of\");\n            }\n            return null;\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Type id '\"+id+\"' is not subtype of base type\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (not subtype of \"+_baseType+\")\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ]
            ],
            "compiler_error_or_timeout": true,
            "plausible_patches": [
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \" + _baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    JavaType t;\n    if (id.indexOf('<') > 0) {\n        t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): not subtype of \"+_baseType);\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls =  tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     *    check if any generics info is added; and only then ask factory\n     *    to do translation when necessary\n     */\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = tf.constructFromCanonical(id);\n        // Ensure that the constructed type is compatible with the base type\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"not subtype of\");\n            }\n            return null;\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n        //   DeserializationContext, just playing it safe\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            // First: we may have problem handlers that can deal with it?\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        // ... meaning that we really should never get here.\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Type id '\"+id+\"' is not subtype of base type\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ],
                [
                    "\n// not used with class name - based resolvers\nprotected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n{\n    TypeFactory tf = ctxt.getTypeFactory();\n    if (id.indexOf('<') > 0) {\n        JavaType t = tf.constructFromCanonical(id);\n        if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (not subtype of \"+_baseType+\")\");\n        }\n        return t;\n    }\n    Class<?> cls;\n    try {\n        cls = tf.findClass(id);\n    } catch (ClassNotFoundException e) {\n        if (ctxt instanceof DeserializationContext) {\n            DeserializationContext dctxt = (DeserializationContext) ctxt;\n            return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n        }\n        return null;\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n    }\n    return tf.constructSpecializedType(_baseType, cls);\n}\n"
                ]
            ]
        }
    }
}