{
    "Jsoup-34": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* Returns the number of characters between the current position and the next instance of the input sequence\n*\n* @param seq scan target\n* @return offset between current position and next instance of target. -1 if not found.\n*/\nint nextIndexOf(CharSequence seq) {\n    // doesn't handle scanning for surrogates\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n        if (offset < length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    @Test public void nextIndexOfUnmatched() {\n\n        CharacterReader r = new CharacterReader(\"<[[one]]\");\n\n        assertEquals(-1, r.nextIndexOf(\"]]>\"));\n\n    }\n\n```\n#Error message: java.lang.ArrayIndexOutOfBoundsException: 8\n\tat org.jsoup.parser.CharacterReader.nextIndexOf(CharacterReader.java:92)  for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n\tat org.jsoup.parser.CharacterReaderTest.nextIndexOfUnmatched(CharacterReaderTest.java:100)  assertEquals(-1, r.nextIndexOf(\"]]>\"));\n \n#Test method 2:\n```java\n    @Test public void handlesUnclosedCdataAtEOF() {\n\n        // https://github.com/jhy/jsoup/issues/349 would crash, as character reader would try to seek past EOF\n\n        String h = \"<![CDATA[]]\";\n\n        Document doc = Jsoup.parse(h);\n\n        assertEquals(1, doc.body().childNodeSize());\n\n    }\n\n```\n#Error message: java.lang.ArrayIndexOutOfBoundsException: 11\n\tat org.jsoup.parser.CharacterReader.nextIndexOf(CharacterReader.java:92)  for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n\tat org.jsoup.parser.CharacterReader.consumeTo(CharacterReader.java:112)  int offset = nextIndexOf(seq);\n\tat org.jsoup.parser.Tokeniser.read(Tokeniser.java:42)  state.read(this, reader);\n\tat org.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:47)  Token token = tokeniser.read();\n\tat org.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:41)  runParser();\n\tat org.jsoup.parser.HtmlTreeBuilder.parse(HtmlTreeBuilder.java:38)  return super.parse(input, baseUri, errors);\n\tat org.jsoup.parser.Parser.parse(Parser.java:90)  return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking());\n\tat org.jsoup.Jsoup.parse(Jsoup.java:58)  return Parser.parse(html, \"\");\n\tat org.jsoup.parser.HtmlParserTest.handlesUnclosedCdataAtEOF(HtmlParserTest.java:293)  Document doc = Jsoup.parse(h);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && j < seq.length() && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0) return -1; // handle empty sequence\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            int j = 1;\n            while (i < last && j < seq.length() && seq.charAt(j) == input[i]) {\n                i++;\n                j++;\n            }\n            if (j == seq.length()) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    int seqLength = seq.length();\n    for (int offset = pos; offset <= length - seqLength; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset <= length - seqLength && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int last = i + seqLength - 1;\n        if (offset <= length - seqLength) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0) {\n        return -1;\n    }\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int j = 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            while (i < last && seq.charAt(j) == input[i]) {\n                i++;\n                j++;\n            }\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) { // Ensure last is within bounds\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while (++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && j < seq.length() && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while (++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = offset + seq.length();\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length();\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && j < seq.length() && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0) return -1; // handle empty sequence\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            int j = 1;\n            while (i < last && j < seq.length() && seq.charAt(j) == input[i]) {\n                i++;\n                j++;\n            }\n            if (j == seq.length()) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    int seqLength = seq.length();\n    for (int offset = pos; offset <= length - seqLength; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset <= length - seqLength && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int last = i + seqLength - 1;\n        if (offset <= length - seqLength) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0) {\n        return -1;\n    }\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int j = 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            while (i < last && seq.charAt(j) == input[i]) {\n                i++;\n                j++;\n            }\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) { // Ensure last is within bounds\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while (++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && j < seq.length() && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while (++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = offset + seq.length();\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && j < seq.length() && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0) return -1; // handle empty sequence\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        // scan to first instance of startchar:\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            int j = 1;\n            while (i < last && j < seq.length() && seq.charAt(j) == input[i]) {\n                i++;\n                j++;\n            }\n            if (j == seq.length()) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    int seqLength = seq.length();\n    for (int offset = pos; offset <= length - seqLength; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset <= length - seqLength && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int last = i + seqLength - 1;\n        if (offset <= length - seqLength) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    if (seq.length() == 0) {\n        return -1;\n    }\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset]) {\n            while (++offset < length && startChar != input[offset]);\n        }\n        int i = offset + 1;\n        int j = 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            while (i < last && seq.charAt(j) == input[i]) {\n                i++;\n                j++;\n            }\n            if (i == last) {\n                return offset - pos;\n            }\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) { // Ensure last is within bounds\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length() - 1;\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && j < seq.length() && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ],
                [
                    "\nint nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while (++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = offset + seq.length();\n        if (offset < length && last <= length) {\n            for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n            if (i == last) // found full sequence\n                return offset - pos;\n        }\n    }\n    return -1;\n}\n"
                ]
            ]
        }
    }
}