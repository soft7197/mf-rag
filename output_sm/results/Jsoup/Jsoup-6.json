{
    "Jsoup-6": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* HMTL entities, and escape routines.\n* Source: <a href=\"http://www.w3.org/TR/html5/named-character-references.html#named-character-references\">W3C HTML\n* named character references</a>.\n*/\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 || charval > 0xFFFF) { // out of range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, c);\n        } else {\n            m.appendReplacement(accum, m.group(0));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void testYahooArticle() throws IOException {\n\n        File in = getFile(\"/htmltests/yahoo-article-1.html\");\n\n        Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");\n\n        Element p = doc.select(\"p:contains(Volt will be sold in the United States\").first();\n\n        assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n\n    }\n\n```\n#Error message: java.lang.IllegalArgumentException: Illegal group reference: group index is missing\n\tat org.jsoup.nodes.Entities.unescape(Entities.java:70)  m.appendReplacement(accum, c);\n\tat org.jsoup.nodes.TextNode.createFromEncoded(TextNode.java:95)  String text = Entities.unescape(encodedText);\n\tat org.jsoup.parser.Parser.parseTextNode(Parser.java:222)  textNode = TextNode.createFromEncoded(text, baseUri);\n\tat org.jsoup.parser.Parser.parse(Parser.java:94)  parseTextNode();\n\tat org.jsoup.parser.Parser.parse(Parser.java:54)  return parser.parse();\n\tat org.jsoup.Jsoup.parse(Jsoup.java:31)  return Parser.parse(html, baseUri);\n\tat org.jsoup.helper.DataUtil.parseByteData(DataUtil.java:80)  doc = Jsoup.parse(docData, baseUri);\n\tat org.jsoup.helper.DataUtil.load(DataUtil.java:53)  return parseByteData(byteData, charsetName, baseUri);\n\tat org.jsoup.helper.DataUtil.load(DataUtil.java:36)  return load(inStream, charsetName, baseUri);\n\tat org.jsoup.Jsoup.parse(Jsoup.java:74)  return DataUtil.load(in, charsetName, baseUri);\n\tat org.jsoup.integration.ParseTest.testYahooArticle(ParseTest.java:145)  Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\");\n \n#Test method 2:\n```java\n    @Test public void quoteReplacements() {\n\n        String escaped = \"&#92; &#36;\";\n\n        String unescaped = \"\\\\ $\";\n\n        \n\n        assertEquals(unescaped, Entities.unescape(escaped));\n\n    }\n\n```\n#Error message: java.lang.IllegalArgumentException: character to be escaped is missing\n\tat org.jsoup.nodes.Entities.unescape(Entities.java:70)  m.appendReplacement(accum, c);\n\tat org.jsoup.nodes.EntitiesTest.quoteReplacements(EntitiesTest.java:42)  assertEquals(unescaped, Entities.unescape(escaped));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval is within range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement to handle special characters\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use quoteReplacement here too\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval is within valid range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use quoteReplacement\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.parseInt(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval within range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // corrected range check\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use Matcher.quoteReplacement\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use Matcher.quoteReplacement\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.parseInt(num, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure within valid char range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // quote replacement to avoid IllegalArgumentException\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Matcher.quoteReplacement(Character.toString((char) charval));\n            m.appendReplacement(accum, c);\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval).replace(\"\\\\\", \"\\\\\\\\\").replace(\"$\", \"\\\\$\");\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval >= 0 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval is within range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement to handle special characters\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use quoteReplacement here too\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval is within valid range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use quoteReplacement\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.parseInt(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval within range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // corrected range check\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use Matcher.quoteReplacement\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use Matcher.quoteReplacement\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.parseInt(num, base);\n            } catch (NumberFormatException e) {\n                // skip\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure within valid char range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // quote replacement to avoid IllegalArgumentException\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Matcher.quoteReplacement(Character.toString((char) charval));\n            m.appendReplacement(accum, c);\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval >= 0 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n    // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            } // skip\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) { // ensure charval is within range\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c)); // use quoteReplacement to handle special characters\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // use quoteReplacement here too\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string);\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.parseInt(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval != -1 && charval <= 0xFFFF) {\n            String c = Matcher.quoteReplacement(Character.toString((char) charval));\n            m.appendReplacement(accum, c);\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ],
                [
                    "\nstatic String unescape(String string) {\n    if (!string.contains(\"&\"))\n        return string;\n\n    Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n    StringBuffer accum = new StringBuffer(string.length());\n\n    while (m.find()) {\n        int charval = -1;\n        String num = m.group(3);\n        if (num != null) {\n            try {\n                int base = m.group(2) != null ? 16 : 10;\n                charval = Integer.valueOf(num, base);\n            } catch (NumberFormatException e) {\n            }\n        } else {\n            String name = m.group(1);\n            if (full.containsKey(name))\n                charval = full.get(name);\n        }\n\n        if (charval >= 0 && charval <= 0xFFFF) {\n            String c = Character.toString((char) charval);\n            m.appendReplacement(accum, Matcher.quoteReplacement(c));\n        } else {\n            m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n        }\n    }\n    m.appendTail(accum);\n    return accum.toString();\n}\n"
                ]
            ]
        }
    }
}