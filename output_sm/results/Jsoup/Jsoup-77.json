{
    "Jsoup-77": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n/**\n* If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n* found, skips.\n*\n* @param endTag tag to close\n*/\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    @Test public void normalizesDiscordantTags() {\n\n        Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\n\n        Document document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);\n\n        assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html());\n\n        // was failing -> toString() = \"<div>\\n test\\n <p></p>\\n</div>\"\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<<div>\n test\n[</div>\n<p></p]>> but was:<<div>\n test\n[ <p></p>\n</div]>>\n\tat org.jsoup.parser.XmlTreeBuilderTest.normalizesDiscordantTags(XmlTreeBuilderTest.java:197)  assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html());\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() - 1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() - 1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound) {\n            stack.add(pos, next); // Re-add the last removed element\n            break;\n        }\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equalsIgnoreCase(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() - 1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ],
                [
                    "\n/**\n* If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n* found, skips.\n*\n* @param endTag tag to close\n*/\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() - 1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() - 1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n    \n    // Ensure to pop elements only up to the firstFound element\n    while (!stack.isEmpty() && stack.peek() != firstFound) {\n        stack.pop();\n    }\n    if (!stack.isEmpty() && stack.peek() == firstFound) {\n        stack.pop();\n    }\n}\n"
                ],
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equals(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() -1; pos >= firstFoundPos; pos--) {\n        Element next = stack.get(pos);\n        stack.remove(pos);\n        if (next == firstFound)\n            break;\n    }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equalsIgnoreCase(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\nprivate void popStackToClose(Token.EndTag endTag) {\n    String elName = endTag.name();\n    Element firstFound = null;\n    int firstFoundPos = -1;\n\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element next = stack.get(pos);\n        if (next.nodeName().equalsIgnoreCase(elName)) {\n            firstFound = next;\n            firstFoundPos = pos;\n            break;\n        }\n    }\n    if (firstFound == null)\n        return; // not found, skip\n\n    for (int pos = stack.size() - 1; pos >= firstFoundPos; pos--) {\n        stack.remove(pos);\n    }\n}\n"
                ]
            ]
        }
    }
}