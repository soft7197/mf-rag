{
    "Jsoup-61": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    @Test public void hasClassCaseInsensitive() {\n\n        Elements els = Jsoup.parse(\"<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE\").select(\"p\");\n\n        Element one = els.get(0);\n\n        Element two = els.get(1);\n\n        Element thr = els.get(2);\n\n\n\n        assertTrue(one.hasClass(\"One\"));\n\n        assertTrue(one.hasClass(\"ONE\"));\n\n\n\n        assertTrue(two.hasClass(\"TWO\"));\n\n        assertTrue(two.hasClass(\"Two\"));\n\n\n\n        assertTrue(thr.hasClass(\"ThreE\"));\n\n        assertTrue(thr.hasClass(\"three\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.jsoup.select.ElementsTest.hasClassCaseInsensitive(ElementsTest.java:104)  assertTrue(one.hasClass(\"One\"));\n \n#Test method 2:\n```java\n    @Test public void testByClassCaseInsensitive() {\n\n        String html = \"<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four\";\n\n        Elements elsFromClass = Jsoup.parse(html).select(\"P.Foo\");\n\n        Elements elsFromAttr = Jsoup.parse(html).select(\"p[class=foo]\");\n\n\n\n        assertEquals(elsFromAttr.size(), elsFromClass.size());\n\n        assertEquals(3, elsFromClass.size());\n\n        assertEquals(\"Two\", elsFromClass.get(1).text());\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<3> but was:<1>\n\tat org.jsoup.select.SelectorTest.testByClassCaseInsensitive(SelectorTest.java:56)  assertEquals(elsFromAttr.size(), elsFromClass.size());\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    \n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) return false;\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    \n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    @Test public void hasClassCaseInsensitive() {\n\n        Elements els = Jsoup.parse(\"<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE\").select(\"p\");\n\n        Element one = els.get(0);\n\n        Element two = els.get(1);\n\n        Element thr = els.get(2);\n\n\n\n        assertTrue(one.hasClass(\"One\"));\n\n        assertTrue(one.hasClass(\"ONE\"));\n\n\n\n        assertTrue(two.hasClass(\"TWO\"));\n\n        assertTrue(two.hasClass(\"Two\"));\n\n\n\n        assertTrue(thr.hasClass(\"ThreE\"));\n\n        assertTrue(thr.hasClass(\"three\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.jsoup.select.ElementsTest.hasClassCaseInsensitive(ElementsTest.java:104)  assertTrue(one.hasClass(\"One\"));\n \n#Test method 2:\n```java\n    @Test public void testByClassCaseInsensitive() {\n\n        String html = \"<p Class=foo>One <p Class=Foo>Two <p class=FOO>Three <p class=farp>Four\";\n\n        Elements elsFromClass = Jsoup.parse(html).select(\"P.Foo\");\n\n        Elements elsFromAttr = Jsoup.parse(html).select(\"p[class=foo]\");\n\n\n\n        assertEquals(elsFromAttr.size(), elsFromClass.size());\n\n        assertEquals(3, elsFromClass.size());\n\n        assertEquals(\"Two\", elsFromClass.get(1).text());\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError: expected:<3> but was:<1>\n\tat org.jsoup.select.SelectorTest.testByClassCaseInsensitive(SelectorTest.java:56)  assertEquals(elsFromAttr.size(), elsFromClass.size());\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nvoid reconstructFormattingElements() { Element last = lastFormattingElement(); if (last == null || onStack(last)) return; Element entry = last; int size = formattingElements.size(); int pos = size - 1; boolean skip = false; while (true) { if (pos == 0) { skip = true; break; } entry = formattingElements.get(--pos); if (entry == null || onStack(entry)) break; } while (true) { if (!skip) entry = formattingElements.get(++pos); Validate.notNull(entry); skip = false; Element newEl = insertStartTag(entry.nodeName()); newEl.attributes().addAll(entry.attributes()); formattingElements.set(pos, newEl); if (pos == size - 1) break; } }\n```\n\n            \n```java\nprivate static boolean looksLikeUtf8(byte[] input) { int i = 0; if (input.length >= 3 && (input[0] & 0xFF) == 0xEF && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) { i = 3; } int end; for (int j = input.length; i < j; ++i) { int o = input[i]; if ((o & 0x80) == 0) { continue; } if ((o & 0xE0) == 0xC0) { end = i + 1; } else if ((o & 0xF0) == 0xE0) { end = i + 2; } else if ((o & 0xF8) == 0xF0) { end = i + 3; } else { return false; } while (i < end) { i++; o = input[i]; if ((o & 0xC0) != 0x80) { return false; } } } return true; }\n```\n\n            \n```java\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) { String docData; Document doc = null; charsetName = detectCharsetFromBom(byteData, charsetName); if (charsetName == null) { docData = Charset.forName(defaultCharset).decode(byteData).toString(); doc = parser.parseInput(docData, baseUri); Element meta = doc.select(\\\"meta[http-equiv=content-type], meta[charset]\\\").first(); String foundCharset = null; if (meta != null) { if (meta.hasAttr(\\\"http-equiv\\\")) { foundCharset = getCharsetFromContentType(meta.attr(\\\"content\\\")); } if (foundCharset == null && meta.hasAttr(\\\"charset\\\")) { foundCharset = meta.attr(\\\"charset\\\"); } } if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) { XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0); if (prolog.name().equals(\\\"xml\\\")) { foundCharset = prolog.attr(\\\"encoding\\\"); } } foundCharset = validateCharset(foundCharset); if (foundCharset != null && !foundCharset.equals(defaultCharset)) { foundCharset = foundCharset.trim().replaceAll(\\\"[\\\\\"']\\\", \\\"\\\"); charsetName = foundCharset; byteData.rewind(); docData = Charset.forName(foundCharset).decode(byteData).toString(); doc = null; } } else { Validate.notEmpty(charsetName, \\\"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\\\"); docData = Charset.forName(charsetName).decode(byteData).toString(); } if (doc == null) { doc = parser.parseInput(docData, baseUri); doc.outputSettings().charset(charsetName); } return doc; }\n```\n\n            \n```java\nprivate ElementMeta createSafeElement(Element sourceEl) { String sourceTag = sourceEl.tagName(); Attributes destAttrs = new Attributes(); Element dest = new Element(Tag.valueOf(sourceTag), sourceEl.baseUri(), destAttrs); int numDiscarded = 0; Attributes sourceAttrs = sourceEl.attributes(); for (Attribute sourceAttr : sourceAttrs) { if (whitelist.isSafeAttribute(sourceTag, sourceEl, sourceAttr)) destAttrs.put(sourceAttr); else numDiscarded++; } Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag); destAttrs.addAll(enforcedAttrs); return new ElementMeta(dest, numDiscarded); }\n```\n\n            \n```java\nprivate static LinkedHashMap<String, List<String>> createHeaderMap(HttpURLConnection conn) { final LinkedHashMap<String, List<String>> headers = new LinkedHashMap<String, List<String>>(); int i = 0; while (true) { final String key = conn.getHeaderFieldKey(i); final String val = conn.getHeaderField(i); if (key == null && val == null) break; i++; if (key == null || val == null) continue; if (headers.containsKey(key)) headers.get(key).add(val); else { final ArrayList<String> vals = new ArrayList<String>(); vals.add(val); headers.put(key, vals); } } return headers; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n    \n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) return false; // Added to handle null class attribute\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    // check if className is at the end of the string without trailing space\n    if (len - start >= wantLen && classAttr.regionMatches(true, len - wantLen, className, 0, wantLen)) {\n        return true;\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null || className == null) return false;\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // whitespace ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n    \n    return false;\n}\n"
                ],
                [
                    "\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\n// performance sensitive\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    // handle case when className might be at the end and followed by whitespace or another class\n    if (inClass && len - start > wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n        return Character.isWhitespace(classAttr.charAt(start + wantLen));\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    if (classAttr == null) {\n        return false;\n    }\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ],
                [
                    "\npublic boolean hasClass(String className) {\n    final String classAttr = attributes.get(\"class\");\n    final int len = classAttr.length();\n    final int wantLen = className.length();\n\n    if (len == 0 || len < wantLen) {\n        return false;\n    }\n\n    // if both lengths are equal, only need compare the className with the attribute\n    if (len == wantLen) {\n        return className.equalsIgnoreCase(classAttr);\n    }\n\n    // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n    boolean inClass = false;\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        if (Character.isWhitespace(classAttr.charAt(i))) {\n            if (inClass) {\n                // white space ends a class name, compare it with the requested one, ignore case\n                if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                    return true;\n                }\n                inClass = false;\n            }\n        } else {\n            if (!inClass) {\n                // we're in a class name : keep the start of the substring\n                inClass = true;\n                start = i;\n            }\n        }\n    }\n\n    // check the last entry\n    if (inClass && len - start == wantLen) {\n        return classAttr.regionMatches(true, start, className, 0, wantLen);\n    }\n\n    return false;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "iteration_done": true
    }
}