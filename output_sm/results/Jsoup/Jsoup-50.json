{
    "Jsoup-50": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// todo - this is getting gnarly. needs a rewrite.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void supportsBOMinFiles() throws IOException {\n\n        // test files from http://www.i18nl10n.com/korean/utftest/\n\n        File in = getFile(\"/bomtests/bom_utf16be.html\");\n\n        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-16BE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf16le.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-16LE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf32be.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-32BE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf32le.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-32LE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.jsoup.helper.DataUtilTest.supportsBOMinFiles(DataUtilTest.java:109)  assertTrue(doc.title().contains(\"UTF-16BE\"));\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Check for BOM and determine the charset\n    byteData.mark();\n    Charset detectedCharset = null;\n    if (byteData.remaining() >= 2) {\n        byte b1 = byteData.get();\n        byte b2 = byteData.get();\n        if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) {\n            detectedCharset = Charset.forName(\"UTF-16BE\");\n        } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) {\n            detectedCharset = Charset.forName(\"UTF-16LE\");\n        } else if (byteData.remaining() >= 2) {\n            byte b3 = byteData.get();\n            byte b4 = byteData.get();\n            if (b1 == 0x00 && b2 == 0x00 && b3 == (byte) 0xFE && b4 == (byte) 0xFF) {\n                detectedCharset = Charset.forName(\"UTF-32BE\");\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE && b3 == 0x00 && b4 == 0x00) {\n                detectedCharset = Charset.forName(\"UTF-32LE\");\n            }\n            // Rewind buffer as it had read 4 bytes\n            byteData.reset();\n        } else {\n            // Rewind buffer as it had read 2 bytes\n            byteData.reset();\n        }\n    } else {\n        byteData.reset();\n    }\n\n    // Use detected charset if found, otherwise use provided charset or default\n    if (detectedCharset != null) {\n        charsetName = detectedCharset.name();\n    } else if (charsetName == null) {\n        charsetName = defaultCharset;\n    }\n\n    // Decode with the determined charset\n    docData = Charset.forName(charsetName).decode(byteData).toString();\n\n    // Parse document\n    doc = parser.parseInput(docData, baseUri);\n    doc.outputSettings().charset(charsetName);\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    if (charsetName == null) {\n        // Detect BOM for UTF-16 and UTF-32\n        if (byteData.remaining() >= 4) {\n            byte b1 = byteData.get(0);\n            byte b2 = byteData.get(1);\n            byte b3 = byteData.get(2);\n            byte b4 = byteData.get(3);\n\n            if (b1 == (byte)0xFE && b2 == (byte)0xFF) {\n                charsetName = \"UTF-16BE\";\n                byteData.position(2);\n            } else if (b1 == (byte)0xFF && b2 == (byte)0xFE) {\n                charsetName = \"UTF-16LE\";\n                byteData.position(2);\n            } else if (b1 == (byte)0x00 && b2 == (byte)0x00 && b3 == (byte)0xFE && b4 == (byte)0xFF) {\n                charsetName = \"UTF-32BE\";\n                byteData.position(4);\n            } else if (b1 == (byte)0xFF && b2 == (byte)0xFE && b3 == (byte)0x00 && b4 == (byte)0x00) {\n                charsetName = \"UTF-32LE\";\n                byteData.position(4);\n            }\n        }\n\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n    }\n\n    docData = Charset.forName(charsetName).decode(byteData).toString();\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n\n    doc = parser.parseInput(docData, baseUri);\n    doc.outputSettings().charset(charsetName);\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Check for BOM and determine charset\n    if (charsetName == null) {\n        byteData.mark();\n        char firstChar = (char) byteData.get();\n\n        if (firstChar == 0xFEFF) {\n            charsetName = \"UTF-32BE\";\n        } else if (firstChar == 0xFFFE) {\n            byte secondChar = byteData.get();\n            if (secondChar == 0x00) {\n                charsetName = \"UTF-32LE\";\n            } else {\n                charsetName = \"UTF-16LE\";\n            }\n        } else if (firstChar == 0xEF) {\n            byte secondChar = byteData.get();\n            byte thirdChar = byteData.get();\n            if (secondChar == 0xBB && thirdChar == 0xBF) {\n                charsetName = \"UTF-8\";\n            }\n        } else {\n            byteData.reset();\n        }\n\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n            Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n            if (meta != null) {\n                String foundCharset = null;\n                if (meta.hasAttr(\"http-equiv\")) {\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                }\n                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                    try {\n                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n                            foundCharset = meta.attr(\"charset\");\n                        }\n                    } catch (IllegalCharsetNameException e) {\n                        foundCharset = null;\n                    }\n                }\n\n                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else {\n            byteData.rewind();\n        }\n    }\n\n    if (charsetName != null) {\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n    \n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Check for BOM and determine charset from BOM\n    String bomCharset = detectCharsetFromBOM(byteData);\n    if (bomCharset != null) {\n        charsetName = bomCharset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { \n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { \n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (doc == null) {\n        docData = removeBOM(docData);\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\nprivate static String detectCharsetFromBOM(ByteBuffer byteData) {\n    byte[] bom = new byte[4];\n    byteData.get(bom, 0, Math.min(byteData.remaining(), 4)); \n    byteData.rewind();\n\n    if ((bom[0] == (byte)0xFE && bom[1] == (byte)0xFF)) {\n        return \"UTF-16BE\";\n    } else if ((bom[0] == (byte)0xFF && bom[1] == (byte)0xFE)) {\n        return \"UTF-16LE\";\n    } else if ((bom[0] == (byte)0x00 && bom[1] == (byte)0x00 && bom[2] == (byte)0xFE && bom[3] == (byte)0xFF)) {\n        return \"UTF-32BE\";\n    } else if ((bom[0] == (byte)0xFF && bom[1] == (byte)0xFE && bom[2] == (byte)0x00 && bom[3] == (byte)0x00)) {\n        return \"UTF-32LE\";\n    }\n    return null;\n}\n\nprivate static String removeBOM(String input) {\n    if (input.startsWith(\"\\uFEFF\")) {\n        return input.substring(1);\n    }\n    return input;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    if (byteData.remaining() >= 2) {\n        byteData.mark();\n        byte b1 = byteData.get();\n        byte b2 = byteData.get();\n        byteData.reset();\n\n        if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) {\n            charsetName = \"UTF-16BE\";\n        } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) {\n            charsetName = \"UTF-16LE\";\n        } else if (byteData.remaining() >= 4) {\n            byte b3 = byteData.get();\n            byte b4 = byteData.get();\n            byteData.reset();\n\n            if (b1 == (byte) 0x00 && b2 == (byte) 0x00 && b3 == (byte) 0xFE && b4 == (byte) 0xFF) {\n                charsetName = \"UTF-32BE\";\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE && b3 == (byte) 0x00 && b4 == (byte) 0x00) {\n                charsetName = \"UTF-32LE\";\n            }\n        }\n    }\n\n    if (charsetName == null) {\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Detect BOM\n    Charset detectedCharset = detectCharsetFromBOM(byteData);\n    if (detectedCharset != null) {\n        charsetName = detectedCharset.name();\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (doc == null) {\n        byteData.rewind();\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n            docData = docData.substring(1);\n        }\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\nprivate static Charset detectCharsetFromBOM(ByteBuffer byteData) {\n    byteData.mark();\n    if (byteData.remaining() >= 2) {\n        byte first = byteData.get();\n        byte second = byteData.get();\n        if (first == (byte) 0xFE && second == (byte) 0xFF) {\n            return Charset.forName(\"UTF-16BE\");\n        } else if (first == (byte) 0xFF && second == (byte) 0xFE) {\n            if (byteData.remaining() >= 2) {\n                byte third = byteData.get();\n                byte fourth = byteData.get();\n                if (third == (byte) 0x00 && fourth == (byte) 0x00) {\n                    return Charset.forName(\"UTF-32LE\");\n                }\n            }\n            return Charset.forName(\"UTF-16LE\");\n        } else if (first == (byte) 0x00 && second == (byte) 0x00 && byteData.remaining() >= 2) {\n            byte third = byteData.get();\n            byte fourth = byteData.get();\n            if (third == (byte) 0xFE && fourth == (byte) 0xFF) {\n                return Charset.forName(\"UTF-32BE\");\n            }\n        }\n    }\n    byteData.reset();\n    return null;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    String foundCharset = null;\n\n    // Handle BOM\n    if (byteData.remaining() >= 2) {\n        byte[] bom = new byte[4];\n        byteData.mark();\n        byteData.get(bom, 0, Math.min(byteData.remaining(), 4));\n        byteData.reset();\n\n        if ((bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF)) {\n            foundCharset = \"UTF-16BE\";\n        } else if ((bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE)) {\n            foundCharset = \"UTF-16LE\";\n        } else if (byteData.remaining() >= 4) {\n            if ((bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF)) {\n                foundCharset = \"UTF-32BE\";\n            } else if ((bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00)) {\n                foundCharset = \"UTF-32LE\";\n            }\n        }\n    }\n\n    if (foundCharset != null) {\n        charsetName = foundCharset;\n    }\n\n    if (charsetName == null) {\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n    Charset detectedCharset = null;\n\n    if (byteData.remaining() >= 4) {\n        byte[] bom = new byte[4];\n        byteData.mark();\n        byteData.get(bom);\n        byteData.rewind();\n\n        if ((bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF)) {\n            detectedCharset = Charset.forName(\"UTF-32BE\");\n        } else if ((bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00)) {\n            detectedCharset = Charset.forName(\"UTF-32LE\");\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) {\n            detectedCharset = Charset.forName(\"UTF-16BE\");\n        } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            detectedCharset = Charset.forName(\"UTF-16LE\");\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            detectedCharset = Charset.forName(\"UTF-8\");\n            byteData.position(3); // skip BOM\n        }\n    }\n\n    if (detectedCharset != null) {\n        charsetName = detectedCharset.name();\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n    Charset detectedCharset = null;\n\n    if (byteData.remaining() >= 2) {\n        byte b1 = byteData.get();\n        byte b2 = byteData.get();\n        byteData.rewind();\n\n        if ((b1 == (byte) 0xFE && b2 == (byte) 0xFF)) {\n            detectedCharset = Charset.forName(\"UTF-16BE\");\n        } else if ((b1 == (byte) 0xFF && b2 == (byte) 0xFE)) {\n            detectedCharset = Charset.forName(\"UTF-16LE\");\n        } else if (byteData.remaining() >= 4) {\n            byte b3 = byteData.get();\n            byte b4 = byteData.get();\n            byteData.rewind();\n\n            if (b1 == (byte) 0x00 && b2 == (byte) 0x00 && b3 == (byte) 0xFE && b4 == (byte) 0xFF) {\n                detectedCharset = Charset.forName(\"UTF-32BE\");\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE && b3 == (byte) 0x00 && b4 == (byte) 0x00) {\n                detectedCharset = Charset.forName(\"UTF-32LE\");\n            }\n        }\n    }\n\n    if (detectedCharset != null) {\n        charsetName = detectedCharset.name();\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { \n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { \n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { \n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Look for BOM - overrides any other header or input\n    byteData.mark();\n    Charset detectedCharset = null;\n    if (byteData.remaining() >= 2) {\n        byte b1 = byteData.get();\n        byte b2 = byteData.get();\n        if (b1 == (byte) 0xFE && b2 == (byte) 0xFF) {\n            detectedCharset = Charset.forName(\"UTF-16BE\");\n        } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE) {\n            detectedCharset = Charset.forName(\"UTF-16LE\");\n        } else if (byteData.remaining() >= 2) {\n            byte b3 = byteData.get();\n            byte b4 = byteData.get();\n            if (b1 == 0 && b2 == 0 && b3 == (byte) 0xFE && b4 == (byte) 0xFF) {\n                detectedCharset = Charset.forName(\"UTF-32BE\");\n            } else if (b1 == (byte) 0xFF && b2 == (byte) 0xFE && b3 == 0 && b4 == 0) {\n                detectedCharset = Charset.forName(\"UTF-32LE\");\n            }\n        }\n    }\n    byteData.reset();\n\n    if (detectedCharset != null) {\n        charsetName = detectedCharset.name();\n    }\n\n    if (charsetName == null) {\n        // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "compiler_error": true,
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// todo - this is getting gnarly. needs a rewrite.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void supportsBOMinFiles() throws IOException {\n\n        // test files from http://www.i18nl10n.com/korean/utftest/\n\n        File in = getFile(\"/bomtests/bom_utf16be.html\");\n\n        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-16BE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf16le.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-16LE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf32be.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-32BE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n\n\n        in = getFile(\"/bomtests/bom_utf32le.html\");\n\n        doc = Jsoup.parse(in, null, \"http://example.com\");\n\n        assertTrue(doc.title().contains(\"UTF-32LE\"));\n\n        assertTrue(doc.text().contains(\"\uac00\uac01\uac02\uac03\uac04\uac05\"));\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.jsoup.helper.DataUtilTest.supportsBOMinFiles(DataUtilTest.java:109)  assertTrue(doc.title().contains(\"UTF-16BE\"));\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\nchar[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) { if (reader.isEmpty()) return null; if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current()) return null; if (reader.matchesAnySorted(notCharRefCharsSorted)) return null; final char[] charRef = charRefHolder; reader.mark(); if (reader.matchConsume(\\\"#\\\")) { boolean isHexMode = reader.matchConsumeIgnoreCase(\\\"X\\\"); String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence(); if (numRef.length() == 0) { characterReferenceError(\\\"numeric reference with no numerals\\\"); reader.rewindToMark(); return null; } if (!reader.matchConsume(\\\";\\\")) characterReferenceError(\\\"missing semicolon\\\"); int charval = -1; try { int base = isHexMode ? 16 : 10; charval = Integer.valueOf(numRef, base); } catch (NumberFormatException e) { } if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) { characterReferenceError(\\\"character outside of valid range\\\"); charRef[0] = replacementChar; return charRef; } else { if (charval < Character.MIN_SUPPLEMENTARY_CODE_POINT) { charRef[0] = (char) charval; return charRef; } else return Character.toChars(charval); } } else { String nameRef = reader.consumeLetterThenDigitSequence(); boolean looksLegit = reader.matches(';'); boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit)); if (!found) { reader.rewindToMark(); if (looksLegit) characterReferenceError(String.format(\\\"invalid named referenece '%s'\\\", nameRef)); return null; } if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) { reader.rewindToMark(); return null; } if (!reader.matchConsume(\\\";\\\")) characterReferenceError(\\\"missing semicolon\\\"); charRef[0] = Entities.getCharacterByName(nameRef); return charRef; } }\n```\n\n            \n```java\npublic List<Connection.KeyVal> formData() { ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>(); for (Element el : elements) { if (!el.tag().isFormSubmittable()) continue; if (el.hasAttr(\\\"disabled\\\")) continue; String name = el.attr(\\\"name\\\"); if (name.length() == 0) continue; String type = el.attr(\\\"type\\\"); if (\\\"select\\\".equals(el.tagName())) { Elements options = el.select(\\\"option[selected]\\\"); boolean set = false; for (Element option : options) { data.add(HttpConnection.KeyVal.create(name, option.val())); set = true; } if (!set) { Element option = el.select(\\\"option\\\").first(); if (option != null) data.add(HttpConnection.KeyVal.create(name, option.val())); } } else if (\\\"checkbox\\\".equalsIgnoreCase(type) || \\\"radio\\\".equalsIgnoreCase(type)) { if (el.hasAttr(\\\"checked\\\")) { final String val = el.val().length() > 0 ? el.val() : \\\"on\\\"; data.add(HttpConnection.KeyVal.create(name, val)); } } else { data.add(HttpConnection.KeyVal.create(name, el.val())); } } return data; }\n```\n\n            \n```java\n@Test public void testClone() { Document doc = Jsoup.parse(\\\"<div><p>One<p><span>Two</div>\\\"); Element p = doc.select(\\\"p\\\").get(1); Element clone = p.clone(); assertNull(clone.parent()); assertEquals(0, clone.siblingIndex); assertEquals(1, p.siblingIndex); assertNotNull(p.parent()); clone.append(\\\"<span>Three\\\"); assertEquals(\\\"<p><span>Two</span><span>Three</span></p>\\\", TextUtil.stripNewlines(clone.outerHtml())); assertEquals(\\\"<div><p>One</p><p><span>Two</span></p></div>\\\", TextUtil.stripNewlines(doc.body().html())); doc.body().appendChild(clone); assertNotNull(clone.parent()); assertEquals(\\\"<div><p>One</p><p><span>Two</span></p></div><p><span>Two</span><span>Three</span></p>\\\", TextUtil.stripNewlines(doc.body().html())); }\n```\n\n            \n```java\nstatic Response execute(Connection.Request req, Response previousResponse) throws IOException { Validate.notNull(req, \\\"Request must not be null\\\"); String protocol = req.url().getProtocol(); if (!protocol.equals(\\\"http\\\") && !protocol.equals(\\\"https\\\")) throw new MalformedURLException(\\\"Only http & https protocols supported\\\"); String mimeBoundary = null; if (!req.method().hasBody() && req.data().size() > 0) { serialiseRequestUrl(req); } else if (req.method().hasBody()) { mimeBoundary = setOutputContentType(req); } HttpURLConnection conn = createConnection(req); Response res; try { conn.connect(); if (conn.getDoOutput()) writePost(req, conn.getOutputStream(), mimeBoundary); int status = conn.getResponseCode(); res = new Response(previousResponse); res.setupFromConnection(conn, previousResponse); res.req = req; if (res.hasHeader(LOCATION) && req.followRedirects()) { if (status != HTTP_TEMP_REDIR) { req.method(Method.GET); req.data().clear(); } String location = res.header(LOCATION); if (location != null && location.startsWith(\\\"http:/\\\") && location.charAt(6) != '/') location = location.substring(6); req.url(StringUtil.resolve(req.url(), encodeUrl(location))); for (Map.Entry<String, String> cookie : res.cookies.entrySet()) { req.cookie(cookie.getKey(), cookie.getValue()); } return execute(req, res); } if ((status < 200 || status >= 400) && !req.ignoreHttpErrors()) throw new HttpStatusException(\\\"HTTP error fetching URL\\\", status, req.url().toString()); String contentType = res.contentType(); if (contentType != null && !req.ignoreContentType() && !contentType.startsWith(\\\"text/\\\") && !xmlContentTypeRxp.matcher(contentType).matches()) throw new UnsupportedMimeTypeException(\\\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\\\", contentType, req.url().toString()); if (contentType != null && xmlContentTypeRxp.matcher(contentType).matches()) { if (req instanceof HttpConnection.Request && !((Request) req).parserDefined) { req.parser(Parser.xmlParser()); } } res.charset = DataUtil.getCharsetFromContentType(res.contentType); if (conn.getContentLength() != 0) { InputStream bodyStream = null; try { bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream(); if (res.hasHeaderWithValue(CONTENT_ENCODING, \\\"gzip\\\")) bodyStream = new GZIPInputStream(bodyStream); res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize()); } finally { if (bodyStream != null) bodyStream.close(); } } else { res.byteData = DataUtil.emptyByteBuffer(); } } finally { conn.disconnect(); } res.executed = true; return res; }\n```\n\n            \n```java\nprivate static HttpURLConnection createConnection(Connection.Request req) throws IOException { final HttpURLConnection conn = (HttpURLConnection) (req.proxy() == null ? req.url().openConnection() : req.url().openConnection(req.proxy())); conn.setRequestMethod(req.method().name()); conn.setInstanceFollowRedirects(false); conn.setConnectTimeout(req.timeout()); conn.setReadTimeout(req.timeout()); if (conn instanceof HttpsURLConnection) { if (!req.validateTLSCertificates()) { initUnSecureTSL(); ((HttpsURLConnection) conn).setSSLSocketFactory(sslSocketFactory); ((HttpsURLConnection) conn).setHostnameVerifier(getInsecureVerifier()); } } if (req.method().hasBody()) conn.setDoOutput(true); if (req.cookies().size() > 0) conn.addRequestProperty(\\\"Cookie\\\", getRequestCookieString(req)); for (Map.Entry<String, String> header : req.headers().entrySet()) { conn.addRequestProperty(header.getKey(), header.getValue()); } return conn; }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    if (charsetName == null) {\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && !foundCharset.isEmpty() && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && (docData.charAt(0) == UNICODE_BOM || isBOM(docData))) {\n        byteData.rewind();\n        charsetName = detectCharsetFromBOM(byteData);\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        if (docData.charAt(0) == UNICODE_BOM) {\n            docData = docData.substring(1);\n        }\n        doc = null;\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\nprivate static String detectCharsetFromBOM(ByteBuffer byteData) {\n    byteData.mark();\n    int first = byteData.get() & 0xFF;\n    int second = byteData.get() & 0xFF;\n\n    byteData.rewind();\n\n    if (first == 0xFE && second == 0xFF)\n        return \"UTF-16BE\";\n    else if (first == 0xFF && second == 0xFE)\n        return \"UTF-16LE\";\n    else {\n        int third = byteData.get() & 0xFF;\n        int fourth = byteData.get() & 0xFF;\n        byteData.rewind();\n        if (first == 0x00 && second == 0x00 && third == 0xFE && fourth == 0xFF)\n            return \"UTF-32BE\";\n        if (first == 0xFF && second == 0xFE && third == 0x00 && fourth == 0x00)\n            return \"UTF-32LE\";\n    }\n    return defaultCharset;\n}\n\nprivate static boolean isBOM(String docData) {\n    return docData.length() > 1 && ((docData.charAt(0) == '\\uFFFE' && docData.charAt(1) == '\\uFEFF') || \n           (docData.charAt(0) == '\\uFEFF' && docData.charAt(1) == '\\uFFFE'));\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData = null;\n    Document doc = null;\n\n    // Check for BOM and determine charset if not provided\n    byteData.mark();\n    byte[] bom = new byte[4];\n    int bomLength = 0;\n    if (byteData.remaining() >= 4) {\n        byteData.get(bom);\n        bomLength = 4;\n    } else if (byteData.remaining() >= 2) {\n        byteData.get(bom, 0, 2);\n        bomLength = 2;\n    }\n    byteData.rewind();\n\n    Charset detectedCharset = null;\n    if (bomLength >= 2) {\n        // UTF-8 BOM\n        if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            detectedCharset = Charset.forName(\"UTF-8\");\n            byteData.position(3);\n        }\n        // UTF-16 BE BOM\n        else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) {\n            detectedCharset = Charset.forName(\"UTF-16BE\");\n            byteData.position(2);\n        }\n        // UTF-16 LE BOM\n        else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            detectedCharset = Charset.forName(\"UTF-16LE\");\n            byteData.position(2);\n        }\n        // UTF-32 BE BOM\n        else if (bomLength == 4 && bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) {\n            detectedCharset = Charset.forName(\"UTF-32BE\");\n            byteData.position(4);\n        }\n        // UTF-32 LE BOM\n        else if (bomLength == 4 && bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) {\n            detectedCharset = Charset.forName(\"UTF-32LE\");\n            byteData.position(4);\n        }\n    }\n\n    if (charsetName == null) {\n        if (detectedCharset != null) {\n            charsetName = detectedCharset.name();\n        } else {\n            // Default to UTF-8 if no BOM and charset is not provided\n            charsetName = \"UTF-8\";\n        }\n    }\n\n    // Decode the byte buffer using the determined or given charset\n    byteData.rewind();\n    docData = Charset.forName(charsetName).decode(byteData).toString();\n    \n    // Parse the document \n    doc = parser.parseInput(docData, baseUri);\n\n    // Set the document's output settings charset for consistency\n    doc.outputSettings().charset(charsetName);\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData = null;\n    Document doc = null;\n\n    // look for BOM - overrides any other header or input\n    ByteOrderMark bom = detectBOM(byteData);\n    Charset bomCharset = bom != null ? bom.getCharset() : null;\n\n    if (bomCharset != null) {\n        charsetName = bomCharset.name();\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (byteData.hasArray() && bomCharset == null && docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n\nprivate static ByteOrderMark detectBOM(ByteBuffer byteData) {\n    // Check the first few bytes for known BOMs\n    if (byteData.remaining() >= 4) {\n        byte[] start = new byte[4];\n        byteData.mark();\n        byteData.get(start);\n        byteData.rewind();\n\n        if (start[0] == (byte) 0x00 && start[1] == (byte) 0x00 && start[2] == (byte) 0xFE && start[3] == (byte) 0xFF) {\n            return new ByteOrderMark(\"UTF-32BE\", new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0xFE, (byte) 0xFF});\n        } else if (start[0] == (byte) 0xFF && start[1] == (byte) 0xFE && start[2] == (byte) 0x00 && start[3] == (byte) 0x00) {\n            return new ByteOrderMark(\"UTF-32LE\", new byte[]{(byte) 0xFF, (byte) 0xFE, (byte) 0x00, (byte) 0x00});\n        }\n    }\n\n    if (byteData.remaining() >= 2) {\n        byte[] start = new byte[2];\n        byteData.mark();\n        byteData.get(start);\n        byteData.rewind();\n\n        if (start[0] == (byte) 0xFE && start[1] == (byte) 0xFF) {\n            return new ByteOrderMark(\"UTF-16BE\", new byte[]{(byte) 0xFE, (byte) 0xFF});\n        } else if (start[0] == (byte) 0xFF && start[1] == (byte) 0xFE) {\n            return new ByteOrderMark(\"UTF-16LE\", new byte[]{(byte) 0xFF, (byte) 0xFE});\n        } else if (start[0] == (byte) 0xEF && start[1] == (byte) 0xBB && start[2] == (byte) 0xBF) {\n            return new ByteOrderMark(\"UTF-8\", new byte[]{(byte) 0xEF, (byte) 0xBB, (byte) 0xBF});\n        }\n    }\n\n    return null;\n}\n\nprivate static class ByteOrderMark {\n    private final String charset;\n    private final byte[] bytes;\n\n    ByteOrderMark(String charset, byte[] bytes) {\n        this.charset = charset;\n        this.bytes = bytes;\n    }\n\n    public String getCharset() {\n        return charset;\n    }\n\n    public byte[] getBytes() {\n        return bytes;\n    }\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    if (byteData.hasRemaining()) {\n        byteData.mark();\n        byte[] bom = new byte[4];\n        for (int i = 0; i < 4 && byteData.hasRemaining(); i++) {\n            bom[i] = byteData.get();\n        }\n        byteData.reset();\n\n        String detectedCharset = null;\n        if (bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) {\n            detectedCharset = \"UTF-32BE\";\n        } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) {\n            detectedCharset = \"UTF-32LE\";\n        } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) {\n            detectedCharset = \"UTF-16BE\";\n        } else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            detectedCharset = \"UTF-16LE\";\n        } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n            detectedCharset = \"UTF-8\";\n        }\n\n        if (detectedCharset != null) {\n            charsetName = detectedCharset;\n        }\n    }\n\n    if (charsetName == null) {\n        docData = Charset.forName(\"UTF-8\").decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && !foundCharset.equals(\"UTF-8\")) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    \n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        if (charsetName != null) {\n            doc.outputSettings().charset(charsetName);\n        }\n    }\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    if (charsetName == null) {\n        byteData.mark();\n        Charset detectedCharset = detectCharsetFromBOM(byteData);\n        if (detectedCharset != null) {\n            charsetName = detectedCharset.name();\n        } else {\n            charsetName = defaultCharset;\n        }\n        byteData.rewind();\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(charsetName)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        docData = docData.substring(1);\n        charsetName = defaultCharset;\n        doc = null;\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n\nprivate static Charset detectCharsetFromBOM(ByteBuffer byteData) {\n    if (byteData.remaining() >= 4) {\n        int mark = byteData.position();\n        byte[] bom = new byte[4];\n        byteData.get(bom);\n        byteData.position(mark);\n        \n        // UTF-32BE\n        if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) {\n            return Charset.forName(\"UTF-32BE\");\n        }\n        // UTF-32LE\n        if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) {\n            return Charset.forName(\"UTF-32LE\");\n        }\n    }\n    if (byteData.remaining() >= 2) {\n        int mark = byteData.position();\n        byte[] bom = new byte[2];\n        byteData.get(bom);\n        byteData.position(mark);\n\n        // UTF-16BE\n        if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) {\n            return Charset.forName(\"UTF-16BE\");\n        }\n        // UTF-16LE\n        if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            return Charset.forName(\"UTF-16LE\");\n        }\n    }\n    return null; // or default charset if preferred\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    Charset detectedCharset = Charset.forName(defaultCharset);\n    \n    if (charsetName == null) {\n        byteData.mark();\n        detectedCharset = detectCharsetFromBOM(byteData);\n        byteData.reset();\n        charsetName = detectedCharset.name();\n    }\n\n    docData = detectedCharset.decode(byteData).toString();\n\n    if (charsetName == null) {\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n\nprivate static Charset detectCharsetFromBOM(ByteBuffer byteData) {\n    if (byteData.remaining() >= 4) {\n        byte first = byteData.get(0);\n        byte second = byteData.get(1);\n        byte third = byteData.get(2);\n        byte fourth = byteData.get(3);\n\n        if (first == (byte) 0x00 && second == (byte) 0x00 && third == (byte) 0xFE && fourth == (byte) 0xFF) {\n            return Charset.forName(\"UTF-32BE\");\n        } else if (first == (byte) 0xFF && second == (byte) 0xFE && third == (byte) 0x00 && fourth == (byte) 0x00) {\n            return Charset.forName(\"UTF-32LE\");\n        }\n    }\n\n    if (byteData.remaining() >= 2) {\n        byte first = byteData.get(0);\n        byte second = byteData.get(1);\n\n        if (first == (byte) 0xFE && second == (byte) 0xFF) {\n            return Charset.forName(\"UTF-16BE\");\n        } else if (first == (byte) 0xFF && second == (byte) 0xFE) {\n            return Charset.forName(\"UTF-16LE\");\n        }\n    }\n\n    return Charset.forName(defaultCharset);\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    String defaultCharset = \"UTF-8\";\n\n    // detect BOM\n    byteData.mark();\n    byte[] bom = new byte[4];\n    int bomSize = 0;\n    for (int i = 0; i < bom.length; i++) {\n        if (byteData.hasRemaining()) {\n            bom[i] = byteData.get();\n            bomSize++;\n        } else {\n            break;\n        }\n    }\n    byteData.rewind();\n\n    String bomCharset = null;\n    if (bomSize >= 2) {\n        // BOM checks\n        if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF) // UTF-16BE BOM\n            bomCharset = \"UTF-16BE\";\n        else if (bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n            if (bomSize >= 4 && bom[2] == (byte) 0x00 && bom[3] == (byte) 0x00) // UTF-32LE BOM\n                bomCharset = \"UTF-32LE\";\n            else // UTF-16LE BOM\n                bomCharset = \"UTF-16LE\";\n        } else if (bomSize >= 4 && bom[0] == (byte) 0x00 && bom[1] == (byte) 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) // UTF-32BE BOM\n            bomCharset = \"UTF-32BE\";\n    }\n\n    if (bomCharset != null) {\n        charsetName = bomCharset;\n    }\n\n    // decode\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Check for BOM and determine charset\n    byte[] bomBytes = new byte[Math.min(4, byteData.remaining())];\n    byteData.get(bomBytes);\n    byteData.rewind();\n\n    String detectedCharset = null;\n\n    if (bomBytes.length >= 2) {\n        if (bomBytes[0] == (byte) 0xFE && bomBytes[1] == (byte) 0xFF) {\n            detectedCharset = \"UTF-16BE\";\n        } else if (bomBytes[0] == (byte) 0xFF && bomBytes[1] == (byte) 0xFE) {\n            detectedCharset = \"UTF-16LE\";\n        } else if (bomBytes.length >= 3 && bomBytes[0] == (byte) 0xEF && bomBytes[1] == (byte) 0xBB && bomBytes[2] == (byte) 0xBF) {\n            detectedCharset = \"UTF-8\";\n        } else if (bomBytes.length == 4 && bomBytes[0] == (byte) 0x00 && bomBytes[1] == (byte) 0x00 && bomBytes[2] == (byte) 0xFE && bomBytes[3] == (byte) 0xFF) {\n            detectedCharset = \"UTF-32BE\";\n        } else if (bomBytes.length == 4 && bomBytes[0] == (byte) 0xFF && bomBytes[1] == (byte) 0xFE && bomBytes[2] == (byte) 0x00 && bomBytes[3] == (byte) 0x00) {\n            detectedCharset = \"UTF-32LE\";\n        }\n    }\n\n    if (detectedCharset != null) {\n        charsetName = detectedCharset;\n        byteData.rewind();\n    }\n\n    if (charsetName == null) { // Determine from meta. Safe parse as UTF-8\n        docData = Charset.forName(\"UTF-8\").decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n            if (foundCharset != null && foundCharset.length() != 0) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.startsWith(\"\\uFEFF\") || docData.startsWith(\"\\uFFFE\")) {\n        docData = docData.substring(1);\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // BOM Support handling\n    // UTF-8, UTF-16BE/LE, UTF-32BE/LE\n    String detectedCharset = detectCharsetFromBOM(byteData);\n    if (detectedCharset != null) {\n        charsetName = detectedCharset;\n    }\n\n    if (charsetName == null) { // Determine from meta. Default parse as UTF-8\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) {\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) {\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header or user\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n\n    return doc;\n}\n\nprivate static String detectCharsetFromBOM(ByteBuffer byteData) {\n    if (byteData.remaining() < 2) {\n        return null;\n    }\n    byteData.mark();\n    byte[] bom = new byte[4];\n    byteData.get(bom);\n    byteData.rewind();\n    \n    // UTF-8 BOM  EF BB BF\n    if ((bom[0] & 0xFF) == 0xEF && (bom[1] & 0xFF) == 0xBB && (bom[2] & 0xFF) == 0xBF) {\n        byteData.position(3);\n        return \"UTF-8\";\n    }\n    // UTF-16BE BOM FE FF\n    if ((bom[0] & 0xFF) == 0xFE && (bom[1] & 0xFF) == 0xFF) {\n        byteData.position(2);\n        return \"UTF-16BE\";\n    }\n    // UTF-16LE BOM FF FE\n    if ((bom[0] & 0xFF) == 0xFF && (bom[1] & 0xFF) == 0xFE) {\n        byteData.position(2);\n        return \"UTF-16LE\";\n    }\n    // UTF-32BE BOM 00 00 FE FF\n    if ((bom[0] & 0xFF) == 0x00 && (bom[1] & 0xFF) == 0x00 && (bom[2] & 0xFF) == 0xFE && (bom[3] & 0xFF) == 0xFF) {\n        byteData.position(4);\n        return \"UTF-32BE\";\n    }\n    // UTF-32LE BOM FF FE 00 00\n    if ((bom[0] & 0xFF) == 0xFF && (bom[1] & 0xFF) == 0xFE && (bom[2] & 0xFF) == 0x00 && (bom[3] & 0xFF) == 0x00) {\n        byteData.position(4);\n        return \"UTF-32LE\";\n    }\n    return null;\n}\n"
                ],
                [
                    "\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n\n    // Check for BOM and set charset accordingly\n    if (byteData.remaining() >= 2) {\n        byte[] bom = new byte[4];\n        byteData.get(bom, 0, Math.min(bom.length, byteData.remaining()));\n\n        if ((bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF)) {\n            charsetName = \"UTF-16BE\";\n            byteData.position(2);\n        } else if ((bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE)) {\n            charsetName = \"UTF-16LE\";\n            byteData.position(2);\n        } else if (byteData.remaining() >= 4 && bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF) {\n            charsetName = \"UTF-32BE\";\n            byteData.position(4);\n        } else if (byteData.remaining() >= 4 && bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) {\n            charsetName = \"UTF-32LE\";\n            byteData.position(4);\n        } else {\n            byteData.rewind();\n        }\n    }\n\n    if (charsetName == null) { // determine from meta. safe parse as UTF-8\n        charsetName = \"UTF-8\";\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        if (meta != null) { // if not found, will keep utf-8 as best attempt\n            String foundCharset = null;\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n\n            if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(charsetName)) { // need to re-decode\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                byteData.rewind();\n                docData = Charset.forName(foundCharset).decode(byteData).toString();\n                doc = null;\n            }\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n\n    if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n        docData = docData.substring(1);\n    }\n\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}\n"
                ]
            ],
            "regeneration": true,
            "evaluation_done": true,
            "second_check": true
        },
        "iteration_done": true
    }
}