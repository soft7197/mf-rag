{
    "Mockito-1": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n//sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        throw new UnsupportedOperationException();\n\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n\n      for (int position = 0; position < matchers.size(); position++) {\n          Matcher m = matchers.get(position);\n          if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n              //TODO SF - this whole lot can be moved captureFrom implementation\n              if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                  Object array = invocation.getRawArguments()[position];\n                  for (int i = 0; i < Array.getLength(array); i++) {\n                      ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                  }\n                  //since we've captured all varargs already, it does not make sense to process other matchers.\n                  return;\n              } else {\n                  ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n              }\n          }\n      }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {\n\n        //given\n\n        mock.varargs();\n\n        Invocation invocation = getLastInvocation();\n\n\n\n        //when\n\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n\n\n        //then\n\n        invocationMatcher.captureArgumentsFrom(invocation);\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMatcherTest.should_capture_arguments_when_args_count_does_NOT_match(InvocationMatcherTest.java:170)  invocationMatcher.captureArgumentsFrom(invocation);\n \n#Test method 2:\n```java\n    public void can_instantiate_class_with_parameterized_constructor() throws Exception {\n\n        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))\n\n                        .willReturn(new Object[]{null}).getMock();\n\n\n\n        new FieldInitializer(this, field(\"noDefaultConstructor\"), resolver).initialize();\n\n\n\n        assertNotNull(noDefaultConstructor);\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockito.internal.util.reflection.FieldInitializer.acquireFieldInstance(FieldInitializer.java:124)  return instantiator.instantiate();\n\tat org.mockito.internal.util.reflection.FieldInitializer.initialize(FieldInitializer.java:86)  return acquireFieldInstance();\n\tat org.mockito.internal.util.reflection.FieldInitializerTest.can_instantiate_class_with_parameterized_constructor(FieldInitializerTest.java:162)  new FieldInitializer(this, field(\"noDefaultConstructor\"), resolver).initialize();\n \n#Test method 3:\n```java\n    public void should_report_failure_if_constructor_throws_exception() throws Exception {\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ null });\n\n\n\n        try {\n\n            new ParameterizedConstructorInstantiator(this, field(\"withThrowingConstructor\"), resolver).instantiate();\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertThat(e.getMessage()).contains(\"constructor\").contains(\"raised an exception\");\n\n        }\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest.should_report_failure_if_constructor_throws_exception(ParameterizedConstructorInstantiatorTest.java:101)  new ParameterizedConstructorInstantiator(this, field(\"withThrowingConstructor\"), resolver).instantiate();\n\tat org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)  runner.run(notifier);\n\tat org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)  runner.run(notifier);\n \n#Test method 4:\n```java\n    public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type() throws Exception {\n\n        Observer observer = mock(Observer.class);\n\n        Set wrongArg = mock(Set.class);\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, wrongArg });\n\n\n\n        try {\n\n            new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n\n            fail();\n\n        } catch (MockitoException e) {\n\n            assertThat(e.getMessage()).contains(\"argResolver\").contains(\"incorrect types\");\n\n        }\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest.should_fail_if_an_argument_instance_type_do_not_match_wanted_type(ParameterizedConstructorInstantiatorTest.java:89)  new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n\tat org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)  runner.run(notifier);\n\tat org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)  runner.run(notifier);\n \n#Test method 5:\n```java\n    public void should_instantiate_type_with_vararg_constructor() throws Exception {\n\n        Observer[] vararg = new Observer[] {  };\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ \"\", vararg});\n\n\n\n        new ParameterizedConstructorInstantiator(this, field(\"withVarargConstructor\"), resolver).instantiate();\n\n\n\n        assertNotNull(withVarargConstructor);\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest.should_instantiate_type_with_vararg_constructor(ParameterizedConstructorInstantiatorTest.java:113)  new ParameterizedConstructorInstantiator(this, field(\"withVarargConstructor\"), resolver).instantiate();\n\tat org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)  runner.run(notifier);\n\tat org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)  runner.run(notifier);\n \n#Test method 6:\n```java\n    public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {\n\n        Observer observer = mock(Observer.class);\n\n        Map map = mock(Map.class);\n\n        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, map });\n\n\n\n        new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n\n\n\n        assertNotNull(withMultipleConstructor);\n\n        assertNotNull(withMultipleConstructor.observer);\n\n        assertNotNull(withMultipleConstructor.map);\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockito.internal.util.reflection.ParameterizedConstructorInstantiatorTest.should_instantiate_type_if_resolver_provide_matching_types(ParameterizedConstructorInstantiatorTest.java:75)  new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n\tat org.mockito.internal.runners.JUnit45AndHigherRunnerImpl.run(JUnit45AndHigherRunnerImpl.java:37)  runner.run(notifier);\n\tat org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:62)  runner.run(notifier);\n \n#Test method 7:\n```java\n    public void shouldRemoveAllStubbing() throws Exception {\n\n        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n\n        when(mock.objectReturningMethod(200)).thenReturn(200);\n\n        reset(mock);\n\n        assertNull(mock.objectReturningMethod(200));\n\n        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.ResetTest.shouldRemoveAllStubbing(ResetTest.java:48)  when(mock.objectReturningMethod(200)).thenReturn(200);\n \n#Test method 8:\n```java\n    public void shouldVerifyWithNullVarArgArray() {\n\n        Foo foo = Mockito.mock(Foo.class);\n\n        foo.varArgs((String[]) null);    \n\n        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n\n        Mockito.verify(foo).varArgs((String[]) null);\n\n    }  \n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptSuperCallable(MockMethodInterceptor.java:44)  return doIntercept(                mock,                invokedMethod,                arguments,                new InterceptedInvocation.SuperMethod.FromCallable(superCall)        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldVerifyWithNullVarArgArray(UsingVarargsTest.java:129)  Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n \n#Test method 9:\n```java\n    public void shouldVerifyWithAnyObject() {\n\n        Foo foo = Mockito.mock(Foo.class);\n\n        foo.varArgs(\"\");        \n\n        Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n\n        Mockito.verify(foo).varArgs((String) Mockito.anyObject());\n\n    }   \n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptSuperCallable(MockMethodInterceptor.java:44)  return doIntercept(                mock,                invokedMethod,                arguments,                new InterceptedInvocation.SuperMethod.FromCallable(superCall)        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldVerifyWithAnyObject(UsingVarargsTest.java:121)  Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());\n \n#Test method 10:\n```java\n    public void shouldStubBooleanVarargs() {\n\n        when(mock.withBooleanVarargs(1)).thenReturn(true);\n\n        when(mock.withBooleanVarargs(1, true, false)).thenReturn(true);\n\n        \n\n        assertEquals(true, mock.withBooleanVarargs(1));\n\n        assertEquals(false, mock.withBooleanVarargs(9999));\n\n        \n\n        assertEquals(true, mock.withBooleanVarargs(1, true, false));\n\n        assertEquals(false, mock.withBooleanVarargs(1, true, false, true));\n\n        assertEquals(false, mock.withBooleanVarargs(2, true, false));\n\n        assertEquals(false, mock.withBooleanVarargs(1, true));\n\n        assertEquals(false, mock.withBooleanVarargs(1, false, false));\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldStubBooleanVarargs(UsingVarargsTest.java:65)  assertEquals(true, mock.withBooleanVarargs(1));\n \n#Test method 11:\n```java\n    public void shouldMatchEasilyEmptyVararg() throws Exception {\n\n        //when\n\n        when(mock.foo(anyVararg())).thenReturn(-1);\n\n\n\n        //then\n\n        assertEquals(-1, mock.foo());\n\n    } \n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldMatchEasilyEmptyVararg(UsingVarargsTest.java:174)  assertEquals(-1, mock.foo());\n \n#Test method 12:\n```java\n    public void shouldVerifyBooleanVarargs() {\n\n        mock.withBooleanVarargs(1);\n\n        mock.withBooleanVarargs(2, true, false, true);\n\n        mock.withBooleanVarargs(3, true, true, true);\n\n\n\n        verify(mock).withBooleanVarargs(1);\n\n        verify(mock).withBooleanVarargs(2, true, false, true);\n\n        try {\n\n            verify(mock).withBooleanVarargs(3, true, true, true, true);\n\n            fail();\n\n        } catch (ArgumentsAreDifferent e) {}\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldVerifyBooleanVarargs(UsingVarargsTest.java:109)  verify(mock).withBooleanVarargs(1);\n \n#Test method 13:\n```java\n    public void shouldStubCorrectlyWhenMixedVarargsUsed() {\n\n        MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n\n        when(mixedVarargs.doSomething(\"hello\", (String[])null)).thenReturn(\"hello\");\n\n        when(mixedVarargs.doSomething(\"goodbye\", (String[])null)).thenReturn(\"goodbye\");\n\n\n\n        String result = mixedVarargs.doSomething(\"hello\",(String[]) null);\n\n        assertEquals(\"hello\", result);\n\n        \n\n        verify(mixedVarargs).doSomething(\"hello\", (String[])null);\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldStubCorrectlyWhenMixedVarargsUsed(UsingVarargsTest.java:150)  String result = mixedVarargs.doSomething(\"hello\",(String[]) null);\n \n#Test method 14:\n```java\n    public void shouldStubStringVarargs() {\n\n        when(mock.withStringVarargsReturningString(1)).thenReturn(\"1\");\n\n        when(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).thenReturn(\"2\");\n\n        \n\n        RuntimeException expected = new RuntimeException();\n\n        stubVoid(mock).toThrow(expected).on().withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n\n\n\n        assertEquals(\"1\", mock.withStringVarargsReturningString(1));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2));\n\n        \n\n        assertEquals(\"2\", mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\"));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\"));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\", \"4\"));\n\n        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"9999\"));\n\n        \n\n        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"9999\");\n\n        mock.withStringVarargs(9999, \"1\", \"2\", \"3\", \"4\");\n\n        \n\n        try {\n\n            mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n\n            fail();\n\n        } catch (Exception e) {\n\n            assertEquals(expected, e);\n\n        }\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldStubStringVarargs(UsingVarargsTest.java:41)  assertEquals(\"1\", mock.withStringVarargsReturningString(1));\n \n#Test method 15:\n```java\n    public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed() {\n\n        MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n\n        when(mixedVarargs.doSomething(\"one\", \"two\", (String[])null)).thenReturn(\"hello\");\n\n        when(mixedVarargs.doSomething(\"1\", \"2\", (String[])null)).thenReturn(\"goodbye\");\n\n\n\n        String result = mixedVarargs.doSomething(\"one\", \"two\", (String[])null);\n\n        assertEquals(\"hello\", result);\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed(UsingVarargsTest.java:163)  String result = mixedVarargs.doSomething(\"one\", \"two\", (String[])null);\n \n#Test method 16:\n```java\n    public void shouldVerifyStringVarargs() {\n\n        mock.withStringVarargs(1);\n\n        mock.withStringVarargs(2, \"1\", \"2\", \"3\");\n\n        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n\n\n\n        verify(mock).withStringVarargs(1);\n\n        verify(mock).withStringVarargs(2, \"1\", \"2\", \"3\");\n\n        try {\n\n            verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n\n            fail();\n\n        } catch (ArgumentsAreDifferent e) {}\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldVerifyStringVarargs(UsingVarargsTest.java:81)  verify(mock).withStringVarargs(1);\n \n#Test method 17:\n```java\n    public void shouldVerifyObjectVarargs() {\n\n        mock.withObjectVarargs(1);\n\n        mock.withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n\n        mock.withObjectVarargs(3, new Integer(1));\n\n\n\n        verify(mock).withObjectVarargs(1);\n\n        verify(mock).withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n\n        try {\n\n            verifyNoMoreInteractions(mock);\n\n            fail();\n\n        } catch (NoInteractionsWanted e) {}\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.basicapi.UsingVarargsTest.shouldVerifyObjectVarargs(UsingVarargsTest.java:95)  verify(mock).withObjectVarargs(1);\n \n#Test method 18:\n```java\n    public void shouldNotThrowAnyException() throws Exception {\n\n        Foo foo = mock(Foo.class);\n\n\n\n        when(foo.blah(anyString(), anyString())).thenCallRealMethod();\n\n\n\n        assertEquals(1, foo.blah(\"foo\", \"bar\"));\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptSuperCallable(MockMethodInterceptor.java:44)  return doIntercept(                mock,                invokedMethod,                arguments,                new InterceptedInvocation.SuperMethod.FromCallable(superCall)        );\n\tat org.mockitousage.bugs.VarargsErrorWhenCallingRealMethodTest.shouldNotThrowAnyException(VarargsErrorWhenCallingRealMethodTest.java:26)  assertEquals(1, foo.blah(\"foo\", \"bar\"));\n \n#Test method 19:\n```java\n    public void shouldVerifyCorrectlyWithAnyVarargs() {\n\n        //when\n\n        table.newRow(\"qux\", \"foo\", \"bar\", \"baz\");\n\n        table.newRow(\"abc\", \"def\");\n\n        \n\n        //then\n\n        verify(table, times(2)).newRow(anyString(), (String[]) anyVararg());\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.bugs.varargs.VarargsAndAnyObjectPicksUpExtraInvocationsTest.shouldVerifyCorrectlyWithAnyVarargs(VarargsAndAnyObjectPicksUpExtraInvocationsTest.java:30)  verify(table, times(2)).newRow(anyString(), (String[]) anyVararg());\n \n#Test method 20:\n```java\n    public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument() {\n\n        //when\n\n        table.newRow(\"x\", \"foo\", \"bar\", \"baz\");\n\n        table.newRow(\"x\", \"def\");\n\n\n\n        //then\n\n        verify(table, times(2)).newRow(eq(\"x\"), (String[]) anyVararg());\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.bugs.varargs.VarargsAndAnyObjectPicksUpExtraInvocationsTest.shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument(VarargsAndAnyObjectPicksUpExtraInvocationsTest.java:40)  verify(table, times(2)).newRow(eq(\"x\"), (String[]) anyVararg());\n \n#Test method 21:\n```java\n    public void shouldStubUsingAnyVarargs() {\n\n        when(mock.run((String[]) anyVararg())).thenReturn(\"foo\");\n\n        \n\n        assertEquals(\"foo\", mock.run(\"a\", \"b\"));\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.bugs.varargs.VarargsNotPlayingWithAnyObjectTest.shouldStubUsingAnyVarargs(VarargsNotPlayingWithAnyObjectTest.java:56)  assertEquals(\"foo\", mock.run(\"a\", \"b\"));\n \n#Test method 22:\n```java\n    public void shouldVerifyUsingMatchers() {\n\n        stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);\n\n        when(three.varargsObject(5, \"first arg\", \"second arg\")).thenReturn(\"stubbed\");\n\n\n\n        try {\n\n            one.oneArg(true);\n\n            fail();\n\n        } catch (RuntimeException e) {}\n\n\n\n        one.simpleMethod(100);\n\n        two.simpleMethod(\"test Mockito\");\n\n        three.varargsObject(10, \"first arg\", \"second arg\");\n\n        \n\n        assertEquals(\"stubbed\", three.varargsObject(5, \"first arg\", \"second arg\"));\n\n\n\n        verify(one).oneArg(eq(true));\n\n        verify(one).simpleMethod(anyInt());\n\n        verify(two).simpleMethod(startsWith(\"test\"));\n\n        verify(three).varargsObject(5, \"first arg\", \"second arg\");\n\n        verify(three).varargsObject(eq(10), eq(\"first arg\"), startsWith(\"second\"));\n\n        \n\n        verifyNoMoreInteractions(one, two, three);\n\n        \n\n        try {\n\n            verify(three).varargsObject(eq(10), eq(\"first arg\"), startsWith(\"third\"));\n\n            fail();\n\n        } catch (WantedButNotInvoked e) {}\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest.shouldVerifyUsingMatchers(VerificationAndStubbingUsingMatchersTest.java:65)  assertEquals(\"stubbed\", three.varargsObject(5, \"first arg\", \"second arg\"));\n \n#Test method 23:\n```java\n    public void test_stub_only_not_verifiable() throws Exception {\n\n        IMethods localMock = mock(IMethods.class, withSettings().stubOnly());\n\n\n\n        when(localMock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n\n        when(localMock.objectReturningMethod(200)).thenReturn(200);\n\n\n\n        assertEquals(200, localMock.objectReturningMethod(200));\n\n        assertEquals(100, localMock.objectReturningMethod(666));\n\n        assertEquals(\"default behavior should return null\", null, localMock.objectReturningMethod(\"blah\"));\n\n\n\n        try {\n\n            verify(localMock, atLeastOnce()).objectReturningMethod(eq(200));\n\n            fail();\n\n        } catch (CannotVerifyStubOnlyMock e) {}\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.stubbing.BasicStubbingTest.test_stub_only_not_verifiable(BasicStubbingTest.java:104)  when(localMock.objectReturningMethod(200)).thenReturn(200);\n \n#Test method 24:\n```java\n    public void should_evaluate_latest_stubbing_first() throws Exception {\n\n        when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);\n\n        when(mock.objectReturningMethod(200)).thenReturn(200);\n\n        \n\n        assertEquals(200, mock.objectReturningMethod(200));\n\n        assertEquals(100, mock.objectReturningMethod(666));\n\n        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.stubbing.BasicStubbingTest.should_evaluate_latest_stubbing_first(BasicStubbingTest.java:31)  when(mock.objectReturningMethod(200)).thenReturn(200);\n \n#Test method 25:\n```java\n    public void shouldEvaluateLatestStubbingFirst() throws Exception {\n\n        stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);\n\n        stub(mock.objectReturningMethod(200)).toReturn(200);\n\n        \n\n        assertEquals(200, mock.objectReturningMethod(200));\n\n        assertEquals(100, mock.objectReturningMethod(666));\n\n        assertEquals(\"default behavior should return null\", null, mock.objectReturningMethod(\"blah\"));\n\n    }\n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:94)  stubbedInvocation.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.stubbing.DeprecatedStubbingTest.shouldEvaluateLatestStubbingFirst(DeprecatedStubbingTest.java:31)  stub(mock.objectReturningMethod(200)).toReturn(200);\n \n#Test method 26:\n```java\n    public void shouldUseEqualsToVerifyMethodVarargs() {\n\n        mockOne = mock(IMethods.class);\n\n        \n\n        String textOne = \"test\";\n\n        String textTwo = new String(textOne);\n\n        \n\n        assertEquals(textOne, textTwo);\n\n        assertNotSame(textOne, textTwo);\n\n        \n\n        mockOne.varargsObject(1, textOne, textOne);\n\n        mockOne.varargsObject(1, textTwo, textTwo);\n\n        \n\n        verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n\n        \n\n        inOrder = inOrder(mockOne);\n\n        inOrder.verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n\n    } \n\n```\n#Error message: java.lang.UnsupportedOperationException\n\tat org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)  throw new UnsupportedOperationException();\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:22)  wanted.captureArgumentsFrom(invocation);\n\tat org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:16)  markVerified(invocation, wanted);\n\tat org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:48)  invocationMarker.markVerified(actualInvocations, wanted);\n\tat org.mockito.internal.verification.Times.verify(Times.java:39)  numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n\tat org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)  mode.verify(data);\n\tat org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:76)  verificationMode.verify(data);\n\tat org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)  Object result = delegate.handle(invocation);\n\tat org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)  Object returnedValue = mockHandler.handle(invocation);\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:82)  return handler.handle(new InterceptedInvocation(                mock,                createMockitoMethod(invokedMethod),                arguments,                superMethod,                SequenceNumber.next()        ));\n\tat org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.interceptAbstract(MockMethodInterceptor.java:70)  return doIntercept(                mock,                invokedMethod,                arguments,                InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE        );\n\tat org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest.shouldUseEqualsToVerifyMethodVarargs(VerificationInOrderMixedWithOrdiraryVerificationTest.java:158)  verify(mockOne, times(2)).varargsObject(1, textOne, textOne);\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        // Handle varargs by capturing each element individually\n        for (int i = 0; i < matchers.size(); i++) {\n            Matcher m = matchers.get(i);\n            if (m instanceof CapturesArguments) {\n                Object array = invocation.getRawArguments()[indexOfVararg];\n                for (int j = 0; j < Array.getLength(array); j++) {\n                    ((CapturesArguments) m).captureFrom(Array.get(array, j));\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n\n    for (int position = 0; position < matchers.size(); position++) {\n        Matcher m = matchers.get(position);\n        if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n            if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                Object array = invocation.getRawArguments()[position];\n                for (int i = 0; i < Array.getLength(array); i++) {\n                    ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                }\n                return;\n            } else {\n                ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    //since we've captured all varargs already, it does not make sense to process other matchers.\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[indexOfVararg];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\n//sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    //since we've captured all varargs already, it does not make sense to process other matchers.\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[indexOfVararg];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\n//sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ]
            ],
            "compiler_error_or_timeout": true,
            "plausible_patches": [
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[position];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ],
                [
                    "\npublic void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n                if (isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n                    Object array = invocation.getRawArguments()[indexOfVararg];\n                    for (int i = 0; i < Array.getLength(array); i++) {\n                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n                    }\n                    return;\n                } else {\n                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                }\n            }\n        }\n    } else {\n        for (int position = 0; position < matchers.size(); position++) {\n            Matcher m = matchers.get(position);\n            if (m instanceof CapturesArguments) {\n                ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n            }\n        }\n    }\n}\n"
                ]
            ]
        }
    }
}