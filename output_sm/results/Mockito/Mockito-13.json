{
    "Mockito-13": {
        "1": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// for tests\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n\n        //given\n\n        when(mock.otherMethod()).thenReturn(\"foo\");\n\n        \n\n        //when\n\n        mockTwo.simpleMethod(\"foo\");\n\n        \n\n        //then\n\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n\n        try {\n\n            verify(mockTwo, never()).simpleMethod(mock.otherMethod());\n\n            fail();\n\n        } catch (NeverWantedButInvoked e) {}\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest.shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine(VerifyingWithAnExtraCallToADifferentMockTest.java:33)  fail();\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            // Re-add verification mode if verification was started on a different mock\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() != invocation.getMock()) {\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        } else {\n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() != invocation.getMock()) {\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n        verificationMode.verify(data);\n        return null;\n    }\n\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            // Re-adding verification mode for different mock\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } else {\n            mockingProgress.resetVerificationMode();\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            // Re-adding verification mode when it's for a different mock\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            // Re-add verification mode since the invocation was on a different mock\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ]
            ],
            "evaluation_done": true
        },
        "2": {
            "prompt": "You are an expert Java developer. Below is a buggy method from a large Java project. This method causes one or more test failures.\nYour task is to fix the bug in this method. Use the provided test failure(s) and relevant context to guide your reasoning.\n\n---\n\n## Buggy Method\n\n```java\n// for tests\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n```\n---\n\n## Failing Test Case(s)\n\n \n#Test method 1:\n```java\n    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n\n        //given\n\n        when(mock.otherMethod()).thenReturn(\"foo\");\n\n        \n\n        //when\n\n        mockTwo.simpleMethod(\"foo\");\n\n        \n\n        //then\n\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n\n        try {\n\n            verify(mockTwo, never()).simpleMethod(mock.otherMethod());\n\n            fail();\n\n        } catch (NeverWantedButInvoked e) {}\n\n    }\n\n```\n#Error message: junit.framework.AssertionFailedError\n\tat org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest.shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine(VerifyingWithAnExtraCallToADifferentMockTest.java:33)  fail();\n\n\n## \ud83d\udca1 Context from Project\n\n            \n```java\npublic byte[] toByteArray() { int size = 24 + 2 * interfaceCount; int nbFields = 0; FieldWriter fb = firstField; while (fb != null) { ++nbFields; size += fb.getSize(); fb = fb.next; } int nbMethods = 0; MethodWriter mb = firstMethod; while (mb != null) { ++nbMethods; size += mb.getSize(); mb = mb.next; } int attributeCount = 0; if (ClassReader.SIGNATURES && signature != 0) { ++attributeCount; size += 8; newUTF8(\\\"Signature\\\"); } if (sourceFile != 0) { ++attributeCount; size += 8; newUTF8(\\\"SourceFile\\\"); } if (sourceDebug != null) { ++attributeCount; size += sourceDebug.length + 4; newUTF8(\\\"SourceDebugExtension\\\"); } if (enclosingMethodOwner != 0) { ++attributeCount; size += 10; newUTF8(\\\"EnclosingMethod\\\"); } if ((access & Opcodes.ACC_DEPRECATED) != 0) { ++attributeCount; size += 6; newUTF8(\\\"Deprecated\\\"); } if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) { ++attributeCount; size += 6; newUTF8(\\\"Synthetic\\\"); } if (innerClasses != null) { ++attributeCount; size += 8 + innerClasses.length; newUTF8(\\\"InnerClasses\\\"); } if (ClassReader.ANNOTATIONS && anns != null) { ++attributeCount; size += 8 + anns.getSize(); newUTF8(\\\"RuntimeVisibleAnnotations\\\"); } if (ClassReader.ANNOTATIONS && ianns != null) { ++attributeCount; size += 8 + ianns.getSize(); newUTF8(\\\"RuntimeInvisibleAnnotations\\\"); } if (attrs != null) { attributeCount += attrs.getCount(); size += attrs.getSize(this, null, 0, -1, -1); } size += pool.length; ByteVector out = new ByteVector(size); out.putInt(0xCAFEBABE).putInt(version); out.putShort(index).putByteArray(pool.data, 0, pool.length); out.putShort(access).putShort(name).putShort(superName); out.putShort(interfaceCount); for (int i = 0; i < interfaceCount; ++i) { out.putShort(interfaces[i]); } out.putShort(nbFields); fb = firstField; while (fb != null) { fb.put(out); fb = fb.next; } out.putShort(nbMethods); mb = firstMethod; while (mb != null) { mb.put(out); mb = mb.next; } out.putShort(attributeCount); if (ClassReader.SIGNATURES && signature != 0) { out.putShort(newUTF8(\\\"Signature\\\")).putInt(2).putShort(signature); } if (sourceFile != 0) { out.putShort(newUTF8(\\\"SourceFile\\\")).putInt(2).putShort(sourceFile); } if (sourceDebug != null) { int len = sourceDebug.length - 2; out.putShort(newUTF8(\\\"SourceDebugExtension\\\")).putInt(len); out.putByteArray(sourceDebug.data, 2, len); } if (enclosingMethodOwner != 0) { out.putShort(newUTF8(\\\"EnclosingMethod\\\")).putInt(4); out.putShort(enclosingMethodOwner).putShort(enclosingMethod); } if ((access & Opcodes.ACC_DEPRECATED) != 0) { out.putShort(newUTF8(\\\"Deprecated\\\")).putInt(0); } if ((access & Opcodes.ACC_SYNTHETIC) != 0 && (version & 0xffff) < Opcodes.V1_5) { out.putShort(newUTF8(\\\"Synthetic\\\")).putInt(0); } if (innerClasses != null) { out.putShort(newUTF8(\\\"InnerClasses\\\")); out.putInt(innerClasses.length + 2).putShort(innerClassesCount); out.putByteArray(innerClasses.data, 0, innerClasses.length); } if (ClassReader.ANNOTATIONS && anns != null) { out.putShort(newUTF8(\\\"RuntimeVisibleAnnotations\\\")); anns.put(out); } if (ClassReader.ANNOTATIONS && ianns != null) { out.putShort(newUTF8(\\\"RuntimeInvisibleAnnotations\\\")); ianns.put(out); } if (attrs != null) { attrs.put(this, null, 0, -1, -1, out); } if (invalidFrames) { ClassWriter cw = new ClassWriter(COMPUTE_FRAMES); new ClassReader(out.data).accept(cw, ClassReader.SKIP_FRAMES); return cw.toByteArray(); } return out.data; }\n```\n\n            \n```java\npublic void generate(ClassEmitter ce, Context context, List methods) { Set indexes = new HashSet(); for (Iterator it = methods.iterator(); it.hasNext(); ) { MethodInfo method = (MethodInfo) it.next(); if (TypeUtils.isProtected(method.getModifiers())) { } else { int index = context.getIndex(method); indexes.add(new Integer(index)); CodeEmitter e = context.beginMethod(ce, method); e.load_this(); e.dup(); e.invoke_virtual_this(loadMethod(index)); e.checkcast(method.getClassInfo().getType()); e.load_args(); e.invoke(method); e.return_value(); e.end_method(); } } for (Iterator it = indexes.iterator(); it.hasNext(); ) { int index = ((Integer) it.next()).intValue(); String delegate = \\\"CGLIB$LAZY_LOADER_\\\" + index; ce.declare_field(Constants.ACC_PRIVATE, delegate, Constants.TYPE_OBJECT, null); CodeEmitter e = ce.begin_method(Constants.ACC_PRIVATE | Constants.ACC_SYNCHRONIZED | Constants.ACC_FINAL, loadMethod(index), null); e.load_this(); e.getfield(delegate); e.dup(); Label end = e.make_label(); e.ifnonnull(end); e.pop(); e.load_this(); context.emitCallback(e, index); e.invoke_interface(LAZY_LOADER, LOAD_OBJECT); e.dup_x1(); e.putfield(delegate); e.mark(end); e.return_value(); e.end_method(); } }\n```\n\n            \n```java\nprivate void emitMethods(final ClassEmitter ce, List methods, List actualMethods) { CallbackGenerator[] generators = CallbackInfo.getGenerators(callbackTypes); Map groups = new HashMap(); final Map indexes = new HashMap(); final Map originalModifiers = new HashMap(); final Map positions = CollectionUtils.getIndexMap(methods); Iterator it1 = methods.iterator(); Iterator it2 = (actualMethods != null) ? actualMethods.iterator() : null; while (it1.hasNext()) { MethodInfo method = (MethodInfo) it1.next(); Method actualMethod = (it2 != null) ? (Method) it2.next() : null; int index = filter.accept(actualMethod); if (index >= callbackTypes.length) { throw new IllegalArgumentException(\\\"Callback filter returned an index that is too large: \\\" + index); } originalModifiers.put(method, new Integer((actualMethod != null) ? actualMethod.getModifiers() : method.getModifiers())); indexes.put(method, new Integer(index)); List group = (List) groups.get(generators[index]); if (group == null) { groups.put(generators[index], group = new ArrayList(methods.size())); } group.add(method); } Set seenGen = new HashSet(); CodeEmitter se = ce.getStaticHook(); se.new_instance(THREAD_LOCAL); se.dup(); se.invoke_constructor(THREAD_LOCAL, CSTRUCT_NULL); se.putfield(THREAD_CALLBACKS_FIELD); final Object[] state = new Object[1]; CallbackGenerator.Context context = new CallbackGenerator.Context() { public ClassLoader getClassLoader() { return Enhancer.this.getClassLoader(); } public int getOriginalModifiers(MethodInfo method) { return ((Integer) originalModifiers.get(method)).intValue(); } public int getIndex(MethodInfo method) { return ((Integer) indexes.get(method)).intValue(); } public void emitCallback(CodeEmitter e, int index) { emitCurrentCallback(e, index); } public Signature getImplSignature(MethodInfo method) { return rename(method.getSignature(), ((Integer) positions.get(method)).intValue()); } public CodeEmitter beginMethod(ClassEmitter ce, MethodInfo method) { CodeEmitter e = EmitUtils.begin_method(ce, method); if (!interceptDuringConstruction && !TypeUtils.isAbstract(method.getModifiers())) { Label constructed = e.make_label(); e.load_this(); e.getfield(CONSTRUCTED_FIELD); e.if_jump(e.NE, constructed); e.load_this(); e.load_args(); e.super_invoke(); e.return_value(); e.mark(constructed); } return e; } }; for (int i = 0; i < callbackTypes.length; i++) { CallbackGenerator gen = generators[i]; if (!seenGen.contains(gen)) { seenGen.add(gen); final List fmethods = (List) groups.get(gen); if (fmethods != null) { try { gen.generate(ce, context, fmethods); gen.generateStatic(se, context, fmethods); } catch (RuntimeException x) { throw x; } catch (Exception x) { throw new CodeGenerationException(x); } } } } se.return_value(); se.end_method(); }\n```\n\n            \n```java\nprivate void generateSet(final Class target, final Method[] setters) { CodeEmitter e = begin_method(Constants.ACC_PUBLIC, SET_PROPERTY_VALUES, null); if (setters.length > 0) { Local index = e.make_local(Type.INT_TYPE); e.push(0); e.store_local(index); e.load_arg(0); e.checkcast(Type.getType(target)); e.load_arg(1); Block handler = e.begin_block(); int lastIndex = 0; for (int i = 0; i < setters.length; i++) { if (setters[i] != null) { MethodInfo setter = ReflectUtils.getMethodInfo(setters[i]); int diff = i - lastIndex; if (diff > 0) { e.iinc(index, diff); lastIndex = i; } e.dup2(); e.aaload(i); e.unbox(setter.getSignature().getArgumentTypes()[0]); e.invoke(setter); } } handler.end(); e.return_value(); e.catch_exception(handler, Constants.TYPE_THROWABLE); e.new_instance(BULK_BEAN_EXCEPTION); e.dup_x1(); e.swap(); e.load_local(index); e.invoke_constructor(BULK_BEAN_EXCEPTION, CSTRUCT_EXCEPTION); e.athrow(); } else { e.return_value(); } e.end_method(); }\n```\n\n            \n```java\nprivate static void member_switch_helper(final CodeEmitter e, List members, final ObjectSwitchCallback callback, boolean useName) { try { final Map cache = new HashMap(); final ParameterTyper cached = new ParameterTyper() { public Type[] getParameterTypes(MethodInfo member) { Type[] types = (Type[]) cache.get(member); if (types == null) { cache.put(member, types = member.getSignature().getArgumentTypes()); } return types; } }; final Label def = e.make_label(); final Label end = e.make_label(); if (useName) { e.swap(); final Map buckets = CollectionUtils.bucket(members, new Transformer() { public Object transform(Object value) { return ((MethodInfo) value).getSignature().getName(); } }); String[] names = (String[]) buckets.keySet().toArray(new String[buckets.size()]); EmitUtils.string_switch(e, names, Constants.SWITCH_STYLE_HASH, new ObjectSwitchCallback() { public void processCase(Object key, Label dontUseEnd) throws Exception { member_helper_size(e, (List) buckets.get(key), callback, cached, def, end); } public void processDefault() throws Exception { e.goTo(def); } }); } else { member_helper_size(e, members, callback, cached, def, end); } e.mark(def); e.pop(); callback.processDefault(); e.mark(end); } catch (RuntimeException ex) { throw ex; } catch (Error ex) { throw ex; } catch (Exception ex) { throw new CodeGenerationException(ex); } }\n```\n\n---\n\n## Your Goal\n\nFix the buggy method. Return only the fixed Java method. Do not include explanations or other text.\n",
            "patches": [
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    if (verificationMode != null && verificationMode instanceof MockAwareVerificationMode) {\n        // We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (((MockAwareVerificationMode) verificationMode).getMock() != invocation.getMock()) {\n            mockingProgress.pushVerificationMode(verificationMode);\n            return null;\n        }\n    }\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n        verificationMode.verify(data);\n        return null;\n    }\n\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n            verificationMode.verify(data);\n            return null;\n        } else {\n            // Re-add verification mode if verification was started on a different mock\n            mockingProgress.resetVerificationMode(verificationMode);\n        }\n    }\n\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } else {\n            // re-add verification mode back because the mock does not match\n            mockingProgress.resetVerificationMode();\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            mockingProgress.setVerificationMode(verificationMode); // re-add verification mode\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\n// for tests\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n        } else {\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            mockingProgress.resetVerificationMode();  \n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n            verificationMode.verify(data);\n            return null;\n        } else {\n            // Re-push the verification mode if it was for a different mock\n            mockingProgress.pushVerificationMode(verificationMode);\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\n// for tests\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n            return null;\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode) {\n            MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n            if (mockAwareVerificationMode.getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode) {\n            MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n            if (mockAwareVerificationMode.getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                mockingProgress.pushVerificationMode(mockAwareVerificationMode);\n            }\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ]
            ],
            "evaluation_done": true,
            "old_plausible_patches": [
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode) {\n            MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n            if (mockAwareVerificationMode.getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ]
            ],
            "plausible_patches": [
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    if (verificationMode != null) {\n        if (verificationMode instanceof MockAwareVerificationMode) {\n            MockAwareVerificationMode mockAwareVerificationMode = (MockAwareVerificationMode) verificationMode;\n            if (mockAwareVerificationMode.getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ],
                [
                    "\npublic Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        //We need to check if verification was started on the correct mock \n        // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n            verificationMode.verify(data);\n            return null;\n            // this means there is an invocation on a different mock. Re-adding verification mode \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n        } else {\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n    \n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}\n"
                ]
            ]
        }
    }
}